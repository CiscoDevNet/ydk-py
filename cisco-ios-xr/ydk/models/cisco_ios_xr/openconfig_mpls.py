""" openconfig_mpls 

This module provides data definitions for configuration of
Multiprotocol Label Switching (MPLS) and associated protocols for
signaling and traffic engineering.

RFC 3031\: Multiprotocol Label Switching Architecture

The MPLS / TE data model consists of several modules and
submodules as shown below.  The top\-level MPLS module describes
the overall framework.  Three types of LSPs are supported\:

i) traffic\-engineered (or constrained\-path)

ii) IGP\-congruent (LSPs that follow the IGP path)

iii) static LSPs which are not signaled

The structure of each of these LSP configurations is defined in
corresponding submodules.  Companion modules define the relevant
configuration and operational data specific to key signaling
protocols used in operational practice.


                         +\-\-\-\-\-\-\-+
       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->\| MPLS  \|<\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
       \|                 +\-\-\-\-\-\-\-+               \|
       \|                     ^                   \|
       \|                     \|                   \|
  +\-\-\-\-+\-\-\-\-\-+      +\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+     +\-\-\-\-\-+\-\-\-\-\-+
  \| TE LSPs  \|      \| IGP\-based LSPs \|     \|static LSPs\|
  \|          \|      \|                \|     \|           \|
  +\-\-\-\-\-\-\-\-\-\-+      +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-+
      ^  ^                    ^  ^
      \|  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+   \|  +\-\-\-\-\-\-\-\-+
      \|                   \|   \|           \|
      \|   +\-\-\-\-\-\-+      +\-+\-\-\-+\-+      +\-\-+\-\-+
      +\-\-\-+ RSVP \|      \|SEGMENT\|      \| LDP \|
          +\-\-\-\-\-\-+      \|ROUTING\|      +\-\-\-\-\-+
                        +\-\-\-\-\-\-\-+


"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class CspfTieBreaking(Enum):
    """
    CspfTieBreaking

    type to indicate the CSPF selection policy when

    multiple equal cost paths are available

    .. data:: RANDOM = 0

    	CSPF calculation selects a random path among

    	multiple equal-cost paths to the destination

    .. data:: LEAST_FILL = 1

    	CSPF calculation selects the path with greatest

    	available bandwidth

    .. data:: MOST_FILL = 2

    	CSPF calculation selects the path with the least

    	available bandwidth

    """

    RANDOM = Enum.YLeaf(0, "RANDOM")

    LEAST_FILL = Enum.YLeaf(1, "LEAST_FILL")

    MOST_FILL = Enum.YLeaf(2, "MOST_FILL")


class MplsHopType(Enum):
    """
    MplsHopType

    enumerated type for specifying loose or strict

    paths

    .. data:: LOOSE = 0

    	loose hop in an explicit path

    .. data:: STRICT = 1

    	strict hop in an explicit path

    """

    LOOSE = Enum.YLeaf(0, "LOOSE")

    STRICT = Enum.YLeaf(1, "STRICT")


class MplsSrlgFloodingType(Enum):
    """
    MplsSrlgFloodingType

    Enumerated bype for specifying how the SRLG is flooded

    .. data:: FLOODED_SRLG = 0

    	SRLG is flooded in the IGP

    .. data:: STATIC_SRLG = 1

    	SRLG is not flooded, the members are

    	statically configured

    """

    FLOODED_SRLG = Enum.YLeaf(0, "FLOODED-SRLG")

    STATIC_SRLG = Enum.YLeaf(1, "STATIC-SRLG")


class TeBandwidthType(Enum):
    """
    TeBandwidthType

    enumerated type for specifying whether bandwidth is

    explicitly specified or automatically computed

    .. data:: SPECIFIED = 0

    	Bandwidth is explicitly specified

    .. data:: AUTO = 1

    	Bandwidth is automatically computed

    """

    SPECIFIED = Enum.YLeaf(0, "SPECIFIED")

    AUTO = Enum.YLeaf(1, "AUTO")


class TeMetricType(Enum):
    """
    TeMetricType

    union type for setting the LSP TE metric to a

    static value, or to track the IGP metric

    .. data:: IGP = 0

    	set the LSP metric to track the underlying

    	IGP metric

    """

    IGP = Enum.YLeaf(0, "IGP")



class PathComputationMethod(Identity):
    """
    base identity for supported path computation
    mechanisms
    
    

    """

    _prefix = 'mpls'
    _revision = '2015-11-05'

    def __init__(self):
        super(PathComputationMethod, self).__init__("http://openconfig.net/yang/mpls", "openconfig-mpls", "openconfig-mpls:path-computation-method")


class Mpls(Entity):
    """
    Anchor point for mpls configuration and operational
    data
    
    .. attribute:: global_
    
    	general mpls configuration applicable to any type of LSP and signaling protocol \- label ranges, entropy label supportmay be added here
    	**type**\:   :py:class:`Global_ <ydk.models.openconfig.openconfig_mpls.Mpls.Global_>`
    
    .. attribute:: lsps
    
    	LSP definitions and configuration
    	**type**\:   :py:class:`Lsps <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps>`
    
    .. attribute:: signaling_protocols
    
    	top\-level signaling protocol configuration
    	**type**\:   :py:class:`SignalingProtocols <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols>`
    
    .. attribute:: te_global_attributes
    
    	traffic\-engineering global attributes
    	**type**\:   :py:class:`TeGlobalAttributes <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes>`
    
    .. attribute:: te_interface_attributes
    
    	traffic engineering attributes specific for interfaces
    	**type**\:   :py:class:`TeInterfaceAttributes <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes>`
    
    

    This class is a :ref:`presence class<presence-class>`

    """

    _prefix = 'mpls'
    _revision = '2015-11-05'

    def __init__(self):
        super(Mpls, self).__init__()
        self._top_entity = None

        self.yang_name = "mpls"
        self.yang_parent_name = "openconfig-mpls"
        self.is_presence_container = True

        self.global_ = Mpls.Global_()
        self.global_.parent = self
        self._children_name_map["global_"] = "global"
        self._children_yang_names.add("global")

        self.lsps = Mpls.Lsps()
        self.lsps.parent = self
        self._children_name_map["lsps"] = "lsps"
        self._children_yang_names.add("lsps")

        self.signaling_protocols = Mpls.SignalingProtocols()
        self.signaling_protocols.parent = self
        self._children_name_map["signaling_protocols"] = "signaling-protocols"
        self._children_yang_names.add("signaling-protocols")

        self.te_global_attributes = Mpls.TeGlobalAttributes()
        self.te_global_attributes.parent = self
        self._children_name_map["te_global_attributes"] = "te-global-attributes"
        self._children_yang_names.add("te-global-attributes")

        self.te_interface_attributes = Mpls.TeInterfaceAttributes()
        self.te_interface_attributes.parent = self
        self._children_name_map["te_interface_attributes"] = "te-interface-attributes"
        self._children_yang_names.add("te-interface-attributes")


    class Global_(Entity):
        """
        general mpls configuration applicable to any
        type of LSP and signaling protocol \- label ranges,
        entropy label supportmay be added here
        
        .. attribute:: config
        
        	Top level global MPLS configuration
        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.Config>`
        
        .. attribute:: mpls_interface_attributes
        
        	Parameters related to MPLS interfaces
        	**type**\:   :py:class:`MplsInterfaceAttributes <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.MplsInterfaceAttributes>`
        
        .. attribute:: state
        
        	Top level global MPLS state
        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.State>`
        
        

        """

        _prefix = 'mpls'
        _revision = '2015-11-05'

        def __init__(self):
            super(Mpls.Global_, self).__init__()

            self.yang_name = "global"
            self.yang_parent_name = "mpls"

            self.config = Mpls.Global_.Config()
            self.config.parent = self
            self._children_name_map["config"] = "config"
            self._children_yang_names.add("config")

            self.mpls_interface_attributes = Mpls.Global_.MplsInterfaceAttributes()
            self.mpls_interface_attributes.parent = self
            self._children_name_map["mpls_interface_attributes"] = "mpls-interface-attributes"
            self._children_yang_names.add("mpls-interface-attributes")

            self.state = Mpls.Global_.State()
            self.state.parent = self
            self._children_name_map["state"] = "state"
            self._children_yang_names.add("state")


        class Config(Entity):
            """
            Top level global MPLS configuration
            
            .. attribute:: null_label
            
            	The null\-label type used, implicit or explicit
            	**type**\:   :py:class:`NullLabelType <ydk.models.openconfig.openconfig_mpls_types.NullLabelType>`
            
            	**default value**\: mplst:IMPLICIT
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.Global_.Config, self).__init__()

                self.yang_name = "config"
                self.yang_parent_name = "global"

                self.null_label = YLeaf(YType.identityref, "null-label")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("null_label") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.Global_.Config, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.Global_.Config, self).__setattr__(name, value)

            def has_data(self):
                return self.null_label.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.null_label.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "config" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.null_label.is_set or self.null_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.null_label.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "null-label"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "null-label"):
                    self.null_label = value
                    self.null_label.value_namespace = name_space
                    self.null_label.value_namespace_prefix = name_space_prefix


        class State(Entity):
            """
            Top level global MPLS state
            
            .. attribute:: null_label
            
            	The null\-label type used, implicit or explicit
            	**type**\:   :py:class:`NullLabelType <ydk.models.openconfig.openconfig_mpls_types.NullLabelType>`
            
            	**default value**\: mplst:IMPLICIT
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.Global_.State, self).__init__()

                self.yang_name = "state"
                self.yang_parent_name = "global"

                self.null_label = YLeaf(YType.identityref, "null-label")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("null_label") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.Global_.State, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.Global_.State, self).__setattr__(name, value)

            def has_data(self):
                return self.null_label.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.null_label.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.null_label.is_set or self.null_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.null_label.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "null-label"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "null-label"):
                    self.null_label = value
                    self.null_label.value_namespace = name_space
                    self.null_label.value_namespace_prefix = name_space_prefix


        class MplsInterfaceAttributes(Entity):
            """
            Parameters related to MPLS interfaces
            
            .. attribute:: interface
            
            	List of TE interfaces
            	**type**\: list of    :py:class:`Interface <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.MplsInterfaceAttributes.Interface>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.Global_.MplsInterfaceAttributes, self).__init__()

                self.yang_name = "mpls-interface-attributes"
                self.yang_parent_name = "global"

                self.interface = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.Global_.MplsInterfaceAttributes, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.Global_.MplsInterfaceAttributes, self).__setattr__(name, value)


            class Interface(Entity):
                """
                List of TE interfaces
                
                .. attribute:: name  <key>
                
                	The interface name
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.MplsInterfaceAttributes.Interface.Config>`
                
                .. attribute:: config
                
                	Configuration parameters related to MPLS interfaces\:
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.MplsInterfaceAttributes.Interface.Config>`
                
                .. attribute:: state
                
                	State parameters related to TE interfaces
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Global_.MplsInterfaceAttributes.Interface.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.Global_.MplsInterfaceAttributes.Interface, self).__init__()

                    self.yang_name = "interface"
                    self.yang_parent_name = "mpls-interface-attributes"

                    self.name = YLeaf(YType.str, "name")

                    self.config = Mpls.Global_.MplsInterfaceAttributes.Interface.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.Global_.MplsInterfaceAttributes.Interface.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.Global_.MplsInterfaceAttributes.Interface, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.Global_.MplsInterfaceAttributes.Interface, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configuration parameters related to MPLS interfaces\:
                    
                    .. attribute:: mpls_enabled
                    
                    	Enable MPLS forwarding on this interfacek
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: name
                    
                    	reference to interface name
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Global_.MplsInterfaceAttributes.Interface.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "interface"

                        self.mpls_enabled = YLeaf(YType.boolean, "mpls-enabled")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("mpls_enabled",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Global_.MplsInterfaceAttributes.Interface.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Global_.MplsInterfaceAttributes.Interface.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.mpls_enabled.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.mpls_enabled.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.mpls_enabled.is_set or self.mpls_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_enabled.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mpls-enabled" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "mpls-enabled"):
                            self.mpls_enabled = value
                            self.mpls_enabled.value_namespace = name_space
                            self.mpls_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters related to TE interfaces
                    
                    .. attribute:: mpls_enabled
                    
                    	Enable MPLS forwarding on this interfacek
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: name
                    
                    	reference to interface name
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Global_.MplsInterfaceAttributes.Interface.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "interface"

                        self.mpls_enabled = YLeaf(YType.boolean, "mpls-enabled")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("mpls_enabled",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Global_.MplsInterfaceAttributes.Interface.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Global_.MplsInterfaceAttributes.Interface.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.mpls_enabled.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.mpls_enabled.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.mpls_enabled.is_set or self.mpls_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mpls_enabled.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mpls-enabled" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "mpls-enabled"):
                            self.mpls_enabled = value
                            self.mpls_enabled.value_namespace = name_space
                            self.mpls_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/global/mpls-interface-attributes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.Global_.MplsInterfaceAttributes.Interface.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.Global_.MplsInterfaceAttributes.Interface.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.interface:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.interface:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "mpls-interface-attributes" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/global/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface"):
                    for c in self.interface:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.Global_.MplsInterfaceAttributes.Interface()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.interface.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.config is not None and self.config.has_data()) or
                (self.mpls_interface_attributes is not None and self.mpls_interface_attributes.has_data()) or
                (self.state is not None and self.state.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.config is not None and self.config.has_operation()) or
                (self.mpls_interface_attributes is not None and self.mpls_interface_attributes.has_operation()) or
                (self.state is not None and self.state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "global" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-mpls:mpls/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "config"):
                if (self.config is None):
                    self.config = Mpls.Global_.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                return self.config

            if (child_yang_name == "mpls-interface-attributes"):
                if (self.mpls_interface_attributes is None):
                    self.mpls_interface_attributes = Mpls.Global_.MplsInterfaceAttributes()
                    self.mpls_interface_attributes.parent = self
                    self._children_name_map["mpls_interface_attributes"] = "mpls-interface-attributes"
                return self.mpls_interface_attributes

            if (child_yang_name == "state"):
                if (self.state is None):
                    self.state = Mpls.Global_.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                return self.state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "config" or name == "mpls-interface-attributes" or name == "state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TeGlobalAttributes(Entity):
        """
        traffic\-engineering global attributes
        
        .. attribute:: igp_flooding_bandwidth
        
        	Interface bandwidth change percentages that trigger update events into the IGP traffic engineering database (TED)
        	**type**\:   :py:class:`IgpFloodingBandwidth <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth>`
        
        .. attribute:: mpls_admin_groups
        
        	Top\-level container for admin\-groups configuration and state
        	**type**\:   :py:class:`MplsAdminGroups <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups>`
        
        .. attribute:: srlg
        
        	Shared risk link groups attributes
        	**type**\:   :py:class:`Srlg <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg>`
        
        .. attribute:: te_lsp_timers
        
        	Definition for delays associated with setup and cleanup of TE LSPs
        	**type**\:   :py:class:`TeLspTimers <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.TeLspTimers>`
        
        

        """

        _prefix = 'mpls'
        _revision = '2015-11-05'

        def __init__(self):
            super(Mpls.TeGlobalAttributes, self).__init__()

            self.yang_name = "te-global-attributes"
            self.yang_parent_name = "mpls"

            self.igp_flooding_bandwidth = Mpls.TeGlobalAttributes.IgpFloodingBandwidth()
            self.igp_flooding_bandwidth.parent = self
            self._children_name_map["igp_flooding_bandwidth"] = "igp-flooding-bandwidth"
            self._children_yang_names.add("igp-flooding-bandwidth")

            self.mpls_admin_groups = Mpls.TeGlobalAttributes.MplsAdminGroups()
            self.mpls_admin_groups.parent = self
            self._children_name_map["mpls_admin_groups"] = "mpls-admin-groups"
            self._children_yang_names.add("mpls-admin-groups")

            self.srlg = Mpls.TeGlobalAttributes.Srlg()
            self.srlg.parent = self
            self._children_name_map["srlg"] = "srlg"
            self._children_yang_names.add("srlg")

            self.te_lsp_timers = Mpls.TeGlobalAttributes.TeLspTimers()
            self.te_lsp_timers.parent = self
            self._children_name_map["te_lsp_timers"] = "te-lsp-timers"
            self._children_yang_names.add("te-lsp-timers")


        class Srlg(Entity):
            """
            Shared risk link groups attributes
            
            .. attribute:: srlg
            
            	List of shared risk link groups
            	**type**\: list of    :py:class:`Srlg <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.TeGlobalAttributes.Srlg, self).__init__()

                self.yang_name = "srlg"
                self.yang_parent_name = "te-global-attributes"

                self.srlg = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.TeGlobalAttributes.Srlg, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.TeGlobalAttributes.Srlg, self).__setattr__(name, value)


            class Srlg(Entity):
                """
                List of shared risk link groups
                
                .. attribute:: name  <key>
                
                	The SRLG group identifier
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.Config>`
                
                .. attribute:: config
                
                	Configuration parameters related to the SRLG
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.Config>`
                
                .. attribute:: state
                
                	State parameters related to the SRLG
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.State>`
                
                .. attribute:: static_srlg_members
                
                	SRLG members for static (not flooded) SRLGs 
                	**type**\:   :py:class:`StaticSrlgMembers <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeGlobalAttributes.Srlg.Srlg, self).__init__()

                    self.yang_name = "srlg"
                    self.yang_parent_name = "srlg"

                    self.name = YLeaf(YType.str, "name")

                    self.config = Mpls.TeGlobalAttributes.Srlg.Srlg.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.TeGlobalAttributes.Srlg.Srlg.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                    self.static_srlg_members = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers()
                    self.static_srlg_members.parent = self
                    self._children_name_map["static_srlg_members"] = "static-srlg-members"
                    self._children_yang_names.add("static-srlg-members")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeGlobalAttributes.Srlg.Srlg, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeGlobalAttributes.Srlg.Srlg, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configuration parameters related to the SRLG
                    
                    .. attribute:: cost
                    
                    	The cost of the SRLG to the computation algorithm
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: flooding_type
                    
                    	The type of SRLG, either flooded in the IGP or statically configured
                    	**type**\:   :py:class:`MplsSrlgFloodingType <ydk.models.openconfig.openconfig_mpls.MplsSrlgFloodingType>`
                    
                    	**default value**\: FLOODED-SRLG
                    
                    .. attribute:: name
                    
                    	SRLG group identifier
                    	**type**\:  str
                    
                    .. attribute:: value
                    
                    	group ID for the SRLG
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeGlobalAttributes.Srlg.Srlg.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "srlg"

                        self.cost = YLeaf(YType.uint32, "cost")

                        self.flooding_type = YLeaf(YType.enumeration, "flooding-type")

                        self.name = YLeaf(YType.str, "name")

                        self.value = YLeaf(YType.uint32, "value")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("cost",
                                        "flooding_type",
                                        "name",
                                        "value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeGlobalAttributes.Srlg.Srlg.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeGlobalAttributes.Srlg.Srlg.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.cost.is_set or
                            self.flooding_type.is_set or
                            self.name.is_set or
                            self.value.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.cost.yfilter != YFilter.not_set or
                            self.flooding_type.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cost.get_name_leafdata())
                        if (self.flooding_type.is_set or self.flooding_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.flooding_type.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "cost" or name == "flooding-type" or name == "name" or name == "value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "cost"):
                            self.cost = value
                            self.cost.value_namespace = name_space
                            self.cost.value_namespace_prefix = name_space_prefix
                        if(value_path == "flooding-type"):
                            self.flooding_type = value
                            self.flooding_type.value_namespace = name_space
                            self.flooding_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "value"):
                            self.value = value
                            self.value.value_namespace = name_space
                            self.value.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters related to the SRLG
                    
                    .. attribute:: cost
                    
                    	The cost of the SRLG to the computation algorithm
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: flooding_type
                    
                    	The type of SRLG, either flooded in the IGP or statically configured
                    	**type**\:   :py:class:`MplsSrlgFloodingType <ydk.models.openconfig.openconfig_mpls.MplsSrlgFloodingType>`
                    
                    	**default value**\: FLOODED-SRLG
                    
                    .. attribute:: name
                    
                    	SRLG group identifier
                    	**type**\:  str
                    
                    .. attribute:: value
                    
                    	group ID for the SRLG
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeGlobalAttributes.Srlg.Srlg.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "srlg"

                        self.cost = YLeaf(YType.uint32, "cost")

                        self.flooding_type = YLeaf(YType.enumeration, "flooding-type")

                        self.name = YLeaf(YType.str, "name")

                        self.value = YLeaf(YType.uint32, "value")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("cost",
                                        "flooding_type",
                                        "name",
                                        "value") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeGlobalAttributes.Srlg.Srlg.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeGlobalAttributes.Srlg.Srlg.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.cost.is_set or
                            self.flooding_type.is_set or
                            self.name.is_set or
                            self.value.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.cost.yfilter != YFilter.not_set or
                            self.flooding_type.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.value.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.cost.get_name_leafdata())
                        if (self.flooding_type.is_set or self.flooding_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.flooding_type.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.value.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "cost" or name == "flooding-type" or name == "name" or name == "value"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "cost"):
                            self.cost = value
                            self.cost.value_namespace = name_space
                            self.cost.value_namespace_prefix = name_space_prefix
                        if(value_path == "flooding-type"):
                            self.flooding_type = value
                            self.flooding_type.value_namespace = name_space
                            self.flooding_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "value"):
                            self.value = value
                            self.value.value_namespace = name_space
                            self.value.value_namespace_prefix = name_space_prefix


                class StaticSrlgMembers(Entity):
                    """
                    SRLG members for static (not flooded) SRLGs 
                    
                    .. attribute:: members_list
                    
                    	List of SRLG members, which are expressed as IP address endpoints of links contained in the SRLG
                    	**type**\: list of    :py:class:`MembersList <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers, self).__init__()

                        self.yang_name = "static-srlg-members"
                        self.yang_parent_name = "srlg"

                        self.members_list = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers, self).__setattr__(name, value)


                    class MembersList(Entity):
                        """
                        List of SRLG members, which are expressed
                        as IP address endpoints of links contained in the
                        SRLG
                        
                        .. attribute:: from_address  <key>
                        
                        	The from address of the link in the SRLG
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: config
                        
                        	Configuration parameters relating to the SRLG members
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.Config>`
                        
                        .. attribute:: state
                        
                        	State parameters relating to the SRLG members
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList, self).__init__()

                            self.yang_name = "members-list"
                            self.yang_parent_name = "static-srlg-members"

                            self.from_address = YLeaf(YType.str, "from-address")

                            self.config = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("from_address") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration parameters relating to the
                            SRLG members
                            
                            .. attribute:: from_address
                            
                            	IP address of the a\-side of the SRLG link
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: to_address
                            
                            	IP address of the z\-side of the SRLG link
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "members-list"

                                self.from_address = YLeaf(YType.str, "from-address")

                                self.to_address = YLeaf(YType.str, "to-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("from_address",
                                                "to_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.from_address.is_set or
                                    self.to_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.from_address.yfilter != YFilter.not_set or
                                    self.to_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.from_address.is_set or self.from_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.from_address.get_name_leafdata())
                                if (self.to_address.is_set or self.to_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.to_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "from-address" or name == "to-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "from-address"):
                                    self.from_address = value
                                    self.from_address.value_namespace = name_space
                                    self.from_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "to-address"):
                                    self.to_address = value
                                    self.to_address.value_namespace = name_space
                                    self.to_address.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State parameters relating to the SRLG
                            members
                            
                            .. attribute:: from_address
                            
                            	IP address of the a\-side of the SRLG link
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: to_address
                            
                            	IP address of the z\-side of the SRLG link
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "members-list"

                                self.from_address = YLeaf(YType.str, "from-address")

                                self.to_address = YLeaf(YType.str, "to-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("from_address",
                                                "to_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.from_address.is_set or
                                    self.to_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.from_address.yfilter != YFilter.not_set or
                                    self.to_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.from_address.is_set or self.from_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.from_address.get_name_leafdata())
                                if (self.to_address.is_set or self.to_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.to_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "from-address" or name == "to-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "from-address"):
                                    self.from_address = value
                                    self.from_address.value_namespace = name_space
                                    self.from_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "to-address"):
                                    self.to_address = value
                                    self.to_address.value_namespace = name_space
                                    self.to_address.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.from_address.is_set or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.from_address.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "members-list" + "[from-address='" + self.from_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.from_address.is_set or self.from_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.from_address.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state" or name == "from-address"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "from-address"):
                                self.from_address = value
                                self.from_address.value_namespace = name_space
                                self.from_address.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.members_list:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.members_list:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "static-srlg-members" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "members-list"):
                            for c in self.members_list:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers.MembersList()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.members_list.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "members-list"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()) or
                        (self.static_srlg_members is not None and self.static_srlg_members.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()) or
                        (self.static_srlg_members is not None and self.static_srlg_members.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "srlg" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/te-global-attributes/srlg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.TeGlobalAttributes.Srlg.Srlg.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.TeGlobalAttributes.Srlg.Srlg.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    if (child_yang_name == "static-srlg-members"):
                        if (self.static_srlg_members is None):
                            self.static_srlg_members = Mpls.TeGlobalAttributes.Srlg.Srlg.StaticSrlgMembers()
                            self.static_srlg_members.parent = self
                            self._children_name_map["static_srlg_members"] = "static-srlg-members"
                        return self.static_srlg_members

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state" or name == "static-srlg-members" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.srlg:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.srlg:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "srlg" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/te-global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "srlg"):
                    for c in self.srlg:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.TeGlobalAttributes.Srlg.Srlg()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.srlg.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "srlg"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class IgpFloodingBandwidth(Entity):
            """
            Interface bandwidth change percentages
            that trigger update events into the IGP traffic
            engineering database (TED)
            
            .. attribute:: config
            
            	Configuration parameters for TED update threshold 
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config>`
            
            .. attribute:: state
            
            	State parameters for TED update threshold 
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth, self).__init__()

                self.yang_name = "igp-flooding-bandwidth"
                self.yang_parent_name = "te-global-attributes"

                self.config = Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration parameters for TED
                update threshold 
                
                .. attribute:: delta_percentage
                
                	The percentage of the maximum\-reservable\-bandwidth considered as the delta that results in an IGP update being flooded
                	**type**\:  int
                
                	**range:** 0..100
                
                .. attribute:: down_thresholds
                
                	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is decreasing
                	**type**\:  list of int
                
                	**range:** 0..100
                
                .. attribute:: threshold_specification
                
                	This value specifies whether a single set of threshold values should be used for both increasing and decreasing bandwidth when determining whether to trigger updated bandwidth values to be flooded in the IGP TE extensions. MIRRORED\-UP\-DOWN indicates that a single value (or set of values) should be used for both increasing and decreasing values, where SEPARATE\-UP\-DOWN specifies that the increasing and decreasing values will be separately specified
                	**type**\:   :py:class:`ThresholdSpecification <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config.ThresholdSpecification>`
                
                .. attribute:: threshold_type
                
                	The type of threshold that should be used to specify the values at which bandwidth is flooded. DELTA indicates that the local system should flood IGP updates when a change in reserved bandwidth >= the specified delta occurs on the interface. Where THRESHOLD\-CROSSED is specified, the local system should trigger an update (and hence flood) the reserved bandwidth when the reserved bandwidth changes such that it crosses, or becomes equal to one of the threshold values
                	**type**\:   :py:class:`ThresholdType <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config.ThresholdType>`
                
                .. attribute:: up_down_thresholds
                
                	The thresholds (expressed as a percentage of the maximum reservable bandwidth of the interface) at which bandwidth updates are flooded \- used both when the bandwidth is increasing and decreasing
                	**type**\:  list of int
                
                	**range:** 0..100
                
                .. attribute:: up_thresholds
                
                	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is increasing
                	**type**\:  list of int
                
                	**range:** 0..100
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "igp-flooding-bandwidth"

                    self.delta_percentage = YLeaf(YType.uint8, "delta-percentage")

                    self.down_thresholds = YLeafList(YType.uint8, "down-thresholds")

                    self.threshold_specification = YLeaf(YType.enumeration, "threshold-specification")

                    self.threshold_type = YLeaf(YType.enumeration, "threshold-type")

                    self.up_down_thresholds = YLeafList(YType.uint8, "up-down-thresholds")

                    self.up_thresholds = YLeafList(YType.uint8, "up-thresholds")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("delta_percentage",
                                    "down_thresholds",
                                    "threshold_specification",
                                    "threshold_type",
                                    "up_down_thresholds",
                                    "up_thresholds") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config, self).__setattr__(name, value)

                class ThresholdSpecification(Enum):
                    """
                    ThresholdSpecification

                    This value specifies whether a single set of threshold

                    values should be used for both increasing and decreasing

                    bandwidth when determining whether to trigger updated

                    bandwidth values to be flooded in the IGP TE extensions.

                    MIRRORED\-UP\-DOWN indicates that a single value (or set of

                    values) should be used for both increasing and decreasing

                    values, where SEPARATE\-UP\-DOWN specifies that the increasing

                    and decreasing values will be separately specified

                    .. data:: MIRRORED_UP_DOWN = 0

                    	MIRRORED-UP-DOWN indicates that a single set of

                    	threshold values should be used for both increasing

                    	and decreasing bandwidth when determining whether

                    	to trigger updated bandwidth values to be flooded

                    	in the IGP TE extensions.

                    .. data:: SEPARATE_UP_DOWN = 1

                    	SEPARATE-UP-DOWN indicates that a separate

                    	threshold values should be used for the increasing

                    	and decreasing bandwidth when determining whether

                    	to trigger updated bandwidth values to be flooded

                    	in the IGP TE extensions.

                    """

                    MIRRORED_UP_DOWN = Enum.YLeaf(0, "MIRRORED-UP-DOWN")

                    SEPARATE_UP_DOWN = Enum.YLeaf(1, "SEPARATE-UP-DOWN")


                class ThresholdType(Enum):
                    """
                    ThresholdType

                    The type of threshold that should be used to specify the

                    values at which bandwidth is flooded. DELTA indicates that

                    the local system should flood IGP updates when a change in

                    reserved bandwidth >= the specified delta occurs on the

                    interface. Where THRESHOLD\-CROSSED is specified, the local

                    system should trigger an update (and hence flood) the

                    reserved bandwidth when the reserved bandwidth changes such

                    that it crosses, or becomes equal to one of the threshold

                    values

                    .. data:: DELTA = 0

                    	DELTA indicates that the local

                    	system should flood IGP updates when a

                    	change in reserved bandwidth >= the specified

                    	delta occurs on the interface.

                    .. data:: THRESHOLD_CROSSED = 1

                    	THRESHOLD-CROSSED indicates that

                    	the local system should trigger an update (and

                    	hence flood) the reserved bandwidth when the

                    	reserved bandwidth changes such that it crosses,

                    	or becomes equal to one of the threshold values.

                    """

                    DELTA = Enum.YLeaf(0, "DELTA")

                    THRESHOLD_CROSSED = Enum.YLeaf(1, "THRESHOLD-CROSSED")


                def has_data(self):
                    for leaf in self.down_thresholds.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.up_down_thresholds.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.up_thresholds.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.delta_percentage.is_set or
                        self.threshold_specification.is_set or
                        self.threshold_type.is_set)

                def has_operation(self):
                    for leaf in self.down_thresholds.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.up_down_thresholds.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.up_thresholds.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.delta_percentage.yfilter != YFilter.not_set or
                        self.down_thresholds.yfilter != YFilter.not_set or
                        self.threshold_specification.yfilter != YFilter.not_set or
                        self.threshold_type.yfilter != YFilter.not_set or
                        self.up_down_thresholds.yfilter != YFilter.not_set or
                        self.up_thresholds.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/te-global-attributes/igp-flooding-bandwidth/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.delta_percentage.is_set or self.delta_percentage.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.delta_percentage.get_name_leafdata())
                    if (self.threshold_specification.is_set or self.threshold_specification.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.threshold_specification.get_name_leafdata())
                    if (self.threshold_type.is_set or self.threshold_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.threshold_type.get_name_leafdata())

                    leaf_name_data.extend(self.down_thresholds.get_name_leafdata())

                    leaf_name_data.extend(self.up_down_thresholds.get_name_leafdata())

                    leaf_name_data.extend(self.up_thresholds.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "delta-percentage" or name == "down-thresholds" or name == "threshold-specification" or name == "threshold-type" or name == "up-down-thresholds" or name == "up-thresholds"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "delta-percentage"):
                        self.delta_percentage = value
                        self.delta_percentage.value_namespace = name_space
                        self.delta_percentage.value_namespace_prefix = name_space_prefix
                    if(value_path == "down-thresholds"):
                        self.down_thresholds.append(value)
                    if(value_path == "threshold-specification"):
                        self.threshold_specification = value
                        self.threshold_specification.value_namespace = name_space
                        self.threshold_specification.value_namespace_prefix = name_space_prefix
                    if(value_path == "threshold-type"):
                        self.threshold_type = value
                        self.threshold_type.value_namespace = name_space
                        self.threshold_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-down-thresholds"):
                        self.up_down_thresholds.append(value)
                    if(value_path == "up-thresholds"):
                        self.up_thresholds.append(value)


            class State(Entity):
                """
                State parameters for TED update threshold 
                
                .. attribute:: delta_percentage
                
                	The percentage of the maximum\-reservable\-bandwidth considered as the delta that results in an IGP update being flooded
                	**type**\:  int
                
                	**range:** 0..100
                
                .. attribute:: down_thresholds
                
                	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is decreasing
                	**type**\:  list of int
                
                	**range:** 0..100
                
                .. attribute:: threshold_specification
                
                	This value specifies whether a single set of threshold values should be used for both increasing and decreasing bandwidth when determining whether to trigger updated bandwidth values to be flooded in the IGP TE extensions. MIRRORED\-UP\-DOWN indicates that a single value (or set of values) should be used for both increasing and decreasing values, where SEPARATE\-UP\-DOWN specifies that the increasing and decreasing values will be separately specified
                	**type**\:   :py:class:`ThresholdSpecification <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State.ThresholdSpecification>`
                
                .. attribute:: threshold_type
                
                	The type of threshold that should be used to specify the values at which bandwidth is flooded. DELTA indicates that the local system should flood IGP updates when a change in reserved bandwidth >= the specified delta occurs on the interface. Where THRESHOLD\-CROSSED is specified, the local system should trigger an update (and hence flood) the reserved bandwidth when the reserved bandwidth changes such that it crosses, or becomes equal to one of the threshold values
                	**type**\:   :py:class:`ThresholdType <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State.ThresholdType>`
                
                .. attribute:: up_down_thresholds
                
                	The thresholds (expressed as a percentage of the maximum reservable bandwidth of the interface) at which bandwidth updates are flooded \- used both when the bandwidth is increasing and decreasing
                	**type**\:  list of int
                
                	**range:** 0..100
                
                .. attribute:: up_thresholds
                
                	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is increasing
                	**type**\:  list of int
                
                	**range:** 0..100
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "igp-flooding-bandwidth"

                    self.delta_percentage = YLeaf(YType.uint8, "delta-percentage")

                    self.down_thresholds = YLeafList(YType.uint8, "down-thresholds")

                    self.threshold_specification = YLeaf(YType.enumeration, "threshold-specification")

                    self.threshold_type = YLeaf(YType.enumeration, "threshold-type")

                    self.up_down_thresholds = YLeafList(YType.uint8, "up-down-thresholds")

                    self.up_thresholds = YLeafList(YType.uint8, "up-thresholds")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("delta_percentage",
                                    "down_thresholds",
                                    "threshold_specification",
                                    "threshold_type",
                                    "up_down_thresholds",
                                    "up_thresholds") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State, self).__setattr__(name, value)

                class ThresholdSpecification(Enum):
                    """
                    ThresholdSpecification

                    This value specifies whether a single set of threshold

                    values should be used for both increasing and decreasing

                    bandwidth when determining whether to trigger updated

                    bandwidth values to be flooded in the IGP TE extensions.

                    MIRRORED\-UP\-DOWN indicates that a single value (or set of

                    values) should be used for both increasing and decreasing

                    values, where SEPARATE\-UP\-DOWN specifies that the increasing

                    and decreasing values will be separately specified

                    .. data:: MIRRORED_UP_DOWN = 0

                    	MIRRORED-UP-DOWN indicates that a single set of

                    	threshold values should be used for both increasing

                    	and decreasing bandwidth when determining whether

                    	to trigger updated bandwidth values to be flooded

                    	in the IGP TE extensions.

                    .. data:: SEPARATE_UP_DOWN = 1

                    	SEPARATE-UP-DOWN indicates that a separate

                    	threshold values should be used for the increasing

                    	and decreasing bandwidth when determining whether

                    	to trigger updated bandwidth values to be flooded

                    	in the IGP TE extensions.

                    """

                    MIRRORED_UP_DOWN = Enum.YLeaf(0, "MIRRORED-UP-DOWN")

                    SEPARATE_UP_DOWN = Enum.YLeaf(1, "SEPARATE-UP-DOWN")


                class ThresholdType(Enum):
                    """
                    ThresholdType

                    The type of threshold that should be used to specify the

                    values at which bandwidth is flooded. DELTA indicates that

                    the local system should flood IGP updates when a change in

                    reserved bandwidth >= the specified delta occurs on the

                    interface. Where THRESHOLD\-CROSSED is specified, the local

                    system should trigger an update (and hence flood) the

                    reserved bandwidth when the reserved bandwidth changes such

                    that it crosses, or becomes equal to one of the threshold

                    values

                    .. data:: DELTA = 0

                    	DELTA indicates that the local

                    	system should flood IGP updates when a

                    	change in reserved bandwidth >= the specified

                    	delta occurs on the interface.

                    .. data:: THRESHOLD_CROSSED = 1

                    	THRESHOLD-CROSSED indicates that

                    	the local system should trigger an update (and

                    	hence flood) the reserved bandwidth when the

                    	reserved bandwidth changes such that it crosses,

                    	or becomes equal to one of the threshold values.

                    """

                    DELTA = Enum.YLeaf(0, "DELTA")

                    THRESHOLD_CROSSED = Enum.YLeaf(1, "THRESHOLD-CROSSED")


                def has_data(self):
                    for leaf in self.down_thresholds.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.up_down_thresholds.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.up_thresholds.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.delta_percentage.is_set or
                        self.threshold_specification.is_set or
                        self.threshold_type.is_set)

                def has_operation(self):
                    for leaf in self.down_thresholds.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.up_down_thresholds.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.up_thresholds.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.delta_percentage.yfilter != YFilter.not_set or
                        self.down_thresholds.yfilter != YFilter.not_set or
                        self.threshold_specification.yfilter != YFilter.not_set or
                        self.threshold_type.yfilter != YFilter.not_set or
                        self.up_down_thresholds.yfilter != YFilter.not_set or
                        self.up_thresholds.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/te-global-attributes/igp-flooding-bandwidth/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.delta_percentage.is_set or self.delta_percentage.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.delta_percentage.get_name_leafdata())
                    if (self.threshold_specification.is_set or self.threshold_specification.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.threshold_specification.get_name_leafdata())
                    if (self.threshold_type.is_set or self.threshold_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.threshold_type.get_name_leafdata())

                    leaf_name_data.extend(self.down_thresholds.get_name_leafdata())

                    leaf_name_data.extend(self.up_down_thresholds.get_name_leafdata())

                    leaf_name_data.extend(self.up_thresholds.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "delta-percentage" or name == "down-thresholds" or name == "threshold-specification" or name == "threshold-type" or name == "up-down-thresholds" or name == "up-thresholds"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "delta-percentage"):
                        self.delta_percentage = value
                        self.delta_percentage.value_namespace = name_space
                        self.delta_percentage.value_namespace_prefix = name_space_prefix
                    if(value_path == "down-thresholds"):
                        self.down_thresholds.append(value)
                    if(value_path == "threshold-specification"):
                        self.threshold_specification = value
                        self.threshold_specification.value_namespace = name_space
                        self.threshold_specification.value_namespace_prefix = name_space_prefix
                    if(value_path == "threshold-type"):
                        self.threshold_type = value
                        self.threshold_type.value_namespace = name_space
                        self.threshold_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-down-thresholds"):
                        self.up_down_thresholds.append(value)
                    if(value_path == "up-thresholds"):
                        self.up_thresholds.append(value)

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "igp-flooding-bandwidth" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/te-global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Mpls.TeGlobalAttributes.IgpFloodingBandwidth.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Mpls.TeGlobalAttributes.IgpFloodingBandwidth.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class MplsAdminGroups(Entity):
            """
            Top\-level container for admin\-groups configuration
            and state
            
            .. attribute:: admin_group
            
            	configuration of value to name mapping for mpls affinities/admin\-groups
            	**type**\: list of    :py:class:`AdminGroup <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.TeGlobalAttributes.MplsAdminGroups, self).__init__()

                self.yang_name = "mpls-admin-groups"
                self.yang_parent_name = "te-global-attributes"

                self.admin_group = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.TeGlobalAttributes.MplsAdminGroups, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.TeGlobalAttributes.MplsAdminGroups, self).__setattr__(name, value)


            class AdminGroup(Entity):
                """
                configuration of value to name mapping
                for mpls affinities/admin\-groups
                
                .. attribute:: admin_group_name  <key>
                
                	name for mpls admin\-group
                	**type**\:  str
                
                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config>`
                
                .. attribute:: config
                
                	Configurable items for admin\-groups
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config>`
                
                .. attribute:: state
                
                	Operational state for admin\-groups
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup, self).__init__()

                    self.yang_name = "admin-group"
                    self.yang_parent_name = "mpls-admin-groups"

                    self.admin_group_name = YLeaf(YType.str, "admin-group-name")

                    self.config = Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_group_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configurable items for admin\-groups
                    
                    .. attribute:: admin_group_name
                    
                    	name for mpls admin\-group
                    	**type**\:  str
                    
                    .. attribute:: bit_position
                    
                    	bit\-position value for mpls admin\-group. The value for the admin group is an integer that represents one of the bit positions in the admin\-group bitmask. Values between 0 and 31 are interpreted as the original limit of 32 admin groups. Values >=32 are interpreted as extended admin group values as per RFC7308
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "admin-group"

                        self.admin_group_name = YLeaf(YType.str, "admin-group-name")

                        self.bit_position = YLeaf(YType.uint32, "bit-position")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("admin_group_name",
                                        "bit_position") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.admin_group_name.is_set or
                            self.bit_position.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.admin_group_name.yfilter != YFilter.not_set or
                            self.bit_position.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.admin_group_name.is_set or self.admin_group_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_group_name.get_name_leafdata())
                        if (self.bit_position.is_set or self.bit_position.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bit_position.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "admin-group-name" or name == "bit-position"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "admin-group-name"):
                            self.admin_group_name = value
                            self.admin_group_name.value_namespace = name_space
                            self.admin_group_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "bit-position"):
                            self.bit_position = value
                            self.bit_position.value_namespace = name_space
                            self.bit_position.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    Operational state for admin\-groups
                    
                    .. attribute:: admin_group_name
                    
                    	name for mpls admin\-group
                    	**type**\:  str
                    
                    .. attribute:: bit_position
                    
                    	bit\-position value for mpls admin\-group. The value for the admin group is an integer that represents one of the bit positions in the admin\-group bitmask. Values between 0 and 31 are interpreted as the original limit of 32 admin groups. Values >=32 are interpreted as extended admin group values as per RFC7308
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "admin-group"

                        self.admin_group_name = YLeaf(YType.str, "admin-group-name")

                        self.bit_position = YLeaf(YType.uint32, "bit-position")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("admin_group_name",
                                        "bit_position") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.admin_group_name.is_set or
                            self.bit_position.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.admin_group_name.yfilter != YFilter.not_set or
                            self.bit_position.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.admin_group_name.is_set or self.admin_group_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_group_name.get_name_leafdata())
                        if (self.bit_position.is_set or self.bit_position.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bit_position.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "admin-group-name" or name == "bit-position"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "admin-group-name"):
                            self.admin_group_name = value
                            self.admin_group_name.value_namespace = name_space
                            self.admin_group_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "bit-position"):
                            self.bit_position = value
                            self.bit_position.value_namespace = name_space
                            self.bit_position.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.admin_group_name.is_set or
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_group_name.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "admin-group" + "[admin-group-name='" + self.admin_group_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/te-global-attributes/mpls-admin-groups/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.admin_group_name.is_set or self.admin_group_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_group_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state" or name == "admin-group-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-group-name"):
                        self.admin_group_name = value
                        self.admin_group_name.value_namespace = name_space
                        self.admin_group_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.admin_group:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.admin_group:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "mpls-admin-groups" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/te-global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "admin-group"):
                    for c in self.admin_group:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.admin_group.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "admin-group"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class TeLspTimers(Entity):
            """
            Definition for delays associated with setup
            and cleanup of TE LSPs
            
            .. attribute:: config
            
            	Configuration parameters related to timers for TE LSPs
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.TeLspTimers.Config>`
            
            .. attribute:: state
            
            	State related to timers for TE LSPs
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.TeLspTimers.State>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.TeGlobalAttributes.TeLspTimers, self).__init__()

                self.yang_name = "te-lsp-timers"
                self.yang_parent_name = "te-global-attributes"

                self.config = Mpls.TeGlobalAttributes.TeLspTimers.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.state = Mpls.TeGlobalAttributes.TeLspTimers.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")


            class Config(Entity):
                """
                Configuration parameters related
                to timers for TE LSPs
                
                .. attribute:: cleanup_delay
                
                	delay the removal of old te lsp for a specified amount of time
                	**type**\:  int
                
                	**range:** 0..65535
                
                	**units**\: seconds
                
                .. attribute:: install_delay
                
                	delay the use of newly installed te lsp for a specified amount of time
                	**type**\:  int
                
                	**range:** 0..3600
                
                	**units**\: seconds
                
                .. attribute:: reoptimize_timer
                
                	frequency of reoptimization of a traffic engineered LSP
                	**type**\:  int
                
                	**range:** 0..65535
                
                	**units**\: seconds
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeGlobalAttributes.TeLspTimers.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "te-lsp-timers"

                    self.cleanup_delay = YLeaf(YType.uint16, "cleanup-delay")

                    self.install_delay = YLeaf(YType.uint16, "install-delay")

                    self.reoptimize_timer = YLeaf(YType.uint16, "reoptimize-timer")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("cleanup_delay",
                                    "install_delay",
                                    "reoptimize_timer") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeGlobalAttributes.TeLspTimers.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeGlobalAttributes.TeLspTimers.Config, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.cleanup_delay.is_set or
                        self.install_delay.is_set or
                        self.reoptimize_timer.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.cleanup_delay.yfilter != YFilter.not_set or
                        self.install_delay.yfilter != YFilter.not_set or
                        self.reoptimize_timer.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/te-global-attributes/te-lsp-timers/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.cleanup_delay.is_set or self.cleanup_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cleanup_delay.get_name_leafdata())
                    if (self.install_delay.is_set or self.install_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.install_delay.get_name_leafdata())
                    if (self.reoptimize_timer.is_set or self.reoptimize_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reoptimize_timer.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "cleanup-delay" or name == "install-delay" or name == "reoptimize-timer"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "cleanup-delay"):
                        self.cleanup_delay = value
                        self.cleanup_delay.value_namespace = name_space
                        self.cleanup_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "install-delay"):
                        self.install_delay = value
                        self.install_delay.value_namespace = name_space
                        self.install_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "reoptimize-timer"):
                        self.reoptimize_timer = value
                        self.reoptimize_timer.value_namespace = name_space
                        self.reoptimize_timer.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                State related to timers for TE LSPs
                
                .. attribute:: cleanup_delay
                
                	delay the removal of old te lsp for a specified amount of time
                	**type**\:  int
                
                	**range:** 0..65535
                
                	**units**\: seconds
                
                .. attribute:: install_delay
                
                	delay the use of newly installed te lsp for a specified amount of time
                	**type**\:  int
                
                	**range:** 0..3600
                
                	**units**\: seconds
                
                .. attribute:: reoptimize_timer
                
                	frequency of reoptimization of a traffic engineered LSP
                	**type**\:  int
                
                	**range:** 0..65535
                
                	**units**\: seconds
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeGlobalAttributes.TeLspTimers.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "te-lsp-timers"

                    self.cleanup_delay = YLeaf(YType.uint16, "cleanup-delay")

                    self.install_delay = YLeaf(YType.uint16, "install-delay")

                    self.reoptimize_timer = YLeaf(YType.uint16, "reoptimize-timer")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("cleanup_delay",
                                    "install_delay",
                                    "reoptimize_timer") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeGlobalAttributes.TeLspTimers.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeGlobalAttributes.TeLspTimers.State, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.cleanup_delay.is_set or
                        self.install_delay.is_set or
                        self.reoptimize_timer.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.cleanup_delay.yfilter != YFilter.not_set or
                        self.install_delay.yfilter != YFilter.not_set or
                        self.reoptimize_timer.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/te-global-attributes/te-lsp-timers/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.cleanup_delay.is_set or self.cleanup_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cleanup_delay.get_name_leafdata())
                    if (self.install_delay.is_set or self.install_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.install_delay.get_name_leafdata())
                    if (self.reoptimize_timer.is_set or self.reoptimize_timer.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reoptimize_timer.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "cleanup-delay" or name == "install-delay" or name == "reoptimize-timer"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "cleanup-delay"):
                        self.cleanup_delay = value
                        self.cleanup_delay.value_namespace = name_space
                        self.cleanup_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "install-delay"):
                        self.install_delay = value
                        self.install_delay.value_namespace = name_space
                        self.install_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "reoptimize-timer"):
                        self.reoptimize_timer = value
                        self.reoptimize_timer.value_namespace = name_space
                        self.reoptimize_timer.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.config is not None and self.config.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "te-lsp-timers" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/te-global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Mpls.TeGlobalAttributes.TeLspTimers.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Mpls.TeGlobalAttributes.TeLspTimers.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.igp_flooding_bandwidth is not None and self.igp_flooding_bandwidth.has_data()) or
                (self.mpls_admin_groups is not None and self.mpls_admin_groups.has_data()) or
                (self.srlg is not None and self.srlg.has_data()) or
                (self.te_lsp_timers is not None and self.te_lsp_timers.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.igp_flooding_bandwidth is not None and self.igp_flooding_bandwidth.has_operation()) or
                (self.mpls_admin_groups is not None and self.mpls_admin_groups.has_operation()) or
                (self.srlg is not None and self.srlg.has_operation()) or
                (self.te_lsp_timers is not None and self.te_lsp_timers.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "te-global-attributes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-mpls:mpls/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "igp-flooding-bandwidth"):
                if (self.igp_flooding_bandwidth is None):
                    self.igp_flooding_bandwidth = Mpls.TeGlobalAttributes.IgpFloodingBandwidth()
                    self.igp_flooding_bandwidth.parent = self
                    self._children_name_map["igp_flooding_bandwidth"] = "igp-flooding-bandwidth"
                return self.igp_flooding_bandwidth

            if (child_yang_name == "mpls-admin-groups"):
                if (self.mpls_admin_groups is None):
                    self.mpls_admin_groups = Mpls.TeGlobalAttributes.MplsAdminGroups()
                    self.mpls_admin_groups.parent = self
                    self._children_name_map["mpls_admin_groups"] = "mpls-admin-groups"
                return self.mpls_admin_groups

            if (child_yang_name == "srlg"):
                if (self.srlg is None):
                    self.srlg = Mpls.TeGlobalAttributes.Srlg()
                    self.srlg.parent = self
                    self._children_name_map["srlg"] = "srlg"
                return self.srlg

            if (child_yang_name == "te-lsp-timers"):
                if (self.te_lsp_timers is None):
                    self.te_lsp_timers = Mpls.TeGlobalAttributes.TeLspTimers()
                    self.te_lsp_timers.parent = self
                    self._children_name_map["te_lsp_timers"] = "te-lsp-timers"
                return self.te_lsp_timers

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "igp-flooding-bandwidth" or name == "mpls-admin-groups" or name == "srlg" or name == "te-lsp-timers"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class TeInterfaceAttributes(Entity):
        """
        traffic engineering attributes specific
        for interfaces
        
        .. attribute:: interface
        
        	List of TE interfaces
        	**type**\: list of    :py:class:`Interface <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface>`
        
        

        """

        _prefix = 'mpls'
        _revision = '2015-11-05'

        def __init__(self):
            super(Mpls.TeInterfaceAttributes, self).__init__()

            self.yang_name = "te-interface-attributes"
            self.yang_parent_name = "mpls"

            self.interface = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Mpls.TeInterfaceAttributes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Mpls.TeInterfaceAttributes, self).__setattr__(name, value)


        class Interface(Entity):
            """
            List of TE interfaces
            
            .. attribute:: name  <key>
            
            	The interface name
            	**type**\:  str
            
            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.Config>`
            
            .. attribute:: config
            
            	Configuration parameters related to TE interfaces\:
            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.Config>`
            
            .. attribute:: igp_flooding_bandwidth
            
            	Interface bandwidth change percentages that trigger update events into the IGP traffic engineering database (TED)
            	**type**\:   :py:class:`IgpFloodingBandwidth <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth>`
            
            .. attribute:: state
            
            	State parameters related to TE interfaces
            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.State>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.TeInterfaceAttributes.Interface, self).__init__()

                self.yang_name = "interface"
                self.yang_parent_name = "te-interface-attributes"

                self.name = YLeaf(YType.str, "name")

                self.config = Mpls.TeInterfaceAttributes.Interface.Config()
                self.config.parent = self
                self._children_name_map["config"] = "config"
                self._children_yang_names.add("config")

                self.igp_flooding_bandwidth = Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth()
                self.igp_flooding_bandwidth.parent = self
                self._children_name_map["igp_flooding_bandwidth"] = "igp-flooding-bandwidth"
                self._children_yang_names.add("igp-flooding-bandwidth")

                self.state = Mpls.TeInterfaceAttributes.Interface.State()
                self.state.parent = self
                self._children_name_map["state"] = "state"
                self._children_yang_names.add("state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.TeInterfaceAttributes.Interface, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.TeInterfaceAttributes.Interface, self).__setattr__(name, value)


            class Config(Entity):
                """
                Configuration parameters related to TE interfaces\:
                
                .. attribute:: admin_group
                
                	list of admin groups (by name) on the interface
                	**type**\:  list of str
                
                .. attribute:: name
                
                	reference to interface name
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                
                .. attribute:: srlg_membership
                
                	list of references to named shared risk link groups that the interface belongs to
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg>`
                
                .. attribute:: te_metric
                
                	TE specific metric for the link
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeInterfaceAttributes.Interface.Config, self).__init__()

                    self.yang_name = "config"
                    self.yang_parent_name = "interface"

                    self.admin_group = YLeafList(YType.str, "admin-group")

                    self.name = YLeaf(YType.str, "name")

                    self.srlg_membership = YLeafList(YType.str, "srlg-membership")

                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_group",
                                    "name",
                                    "srlg_membership",
                                    "te_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeInterfaceAttributes.Interface.Config, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeInterfaceAttributes.Interface.Config, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.admin_group.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.srlg_membership.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.name.is_set or
                        self.te_metric.is_set)

                def has_operation(self):
                    for leaf in self.admin_group.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.srlg_membership.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_group.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.srlg_membership.yfilter != YFilter.not_set or
                        self.te_metric.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_metric.get_name_leafdata())

                    leaf_name_data.extend(self.admin_group.get_name_leafdata())

                    leaf_name_data.extend(self.srlg_membership.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "admin-group" or name == "name" or name == "srlg-membership" or name == "te-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-group"):
                        self.admin_group.append(value)
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "srlg-membership"):
                        self.srlg_membership.append(value)
                    if(value_path == "te-metric"):
                        self.te_metric = value
                        self.te_metric.value_namespace = name_space
                        self.te_metric.value_namespace_prefix = name_space_prefix


            class State(Entity):
                """
                State parameters related to TE interfaces
                
                .. attribute:: admin_group
                
                	list of admin groups (by name) on the interface
                	**type**\:  list of str
                
                .. attribute:: name
                
                	reference to interface name
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                
                .. attribute:: srlg_membership
                
                	list of references to named shared risk link groups that the interface belongs to
                	**type**\:  list of str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.Srlg.Srlg>`
                
                .. attribute:: te_metric
                
                	TE specific metric for the link
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeInterfaceAttributes.Interface.State, self).__init__()

                    self.yang_name = "state"
                    self.yang_parent_name = "interface"

                    self.admin_group = YLeafList(YType.str, "admin-group")

                    self.name = YLeaf(YType.str, "name")

                    self.srlg_membership = YLeafList(YType.str, "srlg-membership")

                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_group",
                                    "name",
                                    "srlg_membership",
                                    "te_metric") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.TeInterfaceAttributes.Interface.State, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.TeInterfaceAttributes.Interface.State, self).__setattr__(name, value)

                def has_data(self):
                    for leaf in self.admin_group.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.srlg_membership.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.name.is_set or
                        self.te_metric.is_set)

                def has_operation(self):
                    for leaf in self.admin_group.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.srlg_membership.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_group.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.srlg_membership.yfilter != YFilter.not_set or
                        self.te_metric.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_metric.get_name_leafdata())

                    leaf_name_data.extend(self.admin_group.get_name_leafdata())

                    leaf_name_data.extend(self.srlg_membership.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "admin-group" or name == "name" or name == "srlg-membership" or name == "te-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-group"):
                        self.admin_group.append(value)
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "srlg-membership"):
                        self.srlg_membership.append(value)
                    if(value_path == "te-metric"):
                        self.te_metric = value
                        self.te_metric.value_namespace = name_space
                        self.te_metric.value_namespace_prefix = name_space_prefix


            class IgpFloodingBandwidth(Entity):
                """
                Interface bandwidth change percentages
                that trigger update events into the IGP traffic
                engineering database (TED)
                
                .. attribute:: config
                
                	Configuration parameters for TED update threshold 
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config>`
                
                .. attribute:: state
                
                	State parameters for TED update threshold 
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth, self).__init__()

                    self.yang_name = "igp-flooding-bandwidth"
                    self.yang_parent_name = "interface"

                    self.config = Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration parameters for TED
                    update threshold 
                    
                    .. attribute:: delta_percentage
                    
                    	The percentage of the maximum\-reservable\-bandwidth considered as the delta that results in an IGP update being flooded
                    	**type**\:  int
                    
                    	**range:** 0..100
                    
                    .. attribute:: down_thresholds
                    
                    	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is decreasing
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    .. attribute:: threshold_specification
                    
                    	This value specifies whether a single set of threshold values should be used for both increasing and decreasing bandwidth when determining whether to trigger updated bandwidth values to be flooded in the IGP TE extensions. MIRRORED\-UP\-DOWN indicates that a single value (or set of values) should be used for both increasing and decreasing values, where SEPARATE\-UP\-DOWN specifies that the increasing and decreasing values will be separately specified
                    	**type**\:   :py:class:`ThresholdSpecification <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config.ThresholdSpecification>`
                    
                    .. attribute:: threshold_type
                    
                    	The type of threshold that should be used to specify the values at which bandwidth is flooded. DELTA indicates that the local system should flood IGP updates when a change in reserved bandwidth >= the specified delta occurs on the interface. Where THRESHOLD\-CROSSED is specified, the local system should trigger an update (and hence flood) the reserved bandwidth when the reserved bandwidth changes such that it crosses, or becomes equal to one of the threshold values
                    	**type**\:   :py:class:`ThresholdType <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config.ThresholdType>`
                    
                    .. attribute:: up_down_thresholds
                    
                    	The thresholds (expressed as a percentage of the maximum reservable bandwidth of the interface) at which bandwidth updates are flooded \- used both when the bandwidth is increasing and decreasing
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    .. attribute:: up_thresholds
                    
                    	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is increasing
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "igp-flooding-bandwidth"

                        self.delta_percentage = YLeaf(YType.uint8, "delta-percentage")

                        self.down_thresholds = YLeafList(YType.uint8, "down-thresholds")

                        self.threshold_specification = YLeaf(YType.enumeration, "threshold-specification")

                        self.threshold_type = YLeaf(YType.enumeration, "threshold-type")

                        self.up_down_thresholds = YLeafList(YType.uint8, "up-down-thresholds")

                        self.up_thresholds = YLeafList(YType.uint8, "up-thresholds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("delta_percentage",
                                        "down_thresholds",
                                        "threshold_specification",
                                        "threshold_type",
                                        "up_down_thresholds",
                                        "up_thresholds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config, self).__setattr__(name, value)

                    class ThresholdSpecification(Enum):
                        """
                        ThresholdSpecification

                        This value specifies whether a single set of threshold

                        values should be used for both increasing and decreasing

                        bandwidth when determining whether to trigger updated

                        bandwidth values to be flooded in the IGP TE extensions.

                        MIRRORED\-UP\-DOWN indicates that a single value (or set of

                        values) should be used for both increasing and decreasing

                        values, where SEPARATE\-UP\-DOWN specifies that the increasing

                        and decreasing values will be separately specified

                        .. data:: MIRRORED_UP_DOWN = 0

                        	MIRRORED-UP-DOWN indicates that a single set of

                        	threshold values should be used for both increasing

                        	and decreasing bandwidth when determining whether

                        	to trigger updated bandwidth values to be flooded

                        	in the IGP TE extensions.

                        .. data:: SEPARATE_UP_DOWN = 1

                        	SEPARATE-UP-DOWN indicates that a separate

                        	threshold values should be used for the increasing

                        	and decreasing bandwidth when determining whether

                        	to trigger updated bandwidth values to be flooded

                        	in the IGP TE extensions.

                        """

                        MIRRORED_UP_DOWN = Enum.YLeaf(0, "MIRRORED-UP-DOWN")

                        SEPARATE_UP_DOWN = Enum.YLeaf(1, "SEPARATE-UP-DOWN")


                    class ThresholdType(Enum):
                        """
                        ThresholdType

                        The type of threshold that should be used to specify the

                        values at which bandwidth is flooded. DELTA indicates that

                        the local system should flood IGP updates when a change in

                        reserved bandwidth >= the specified delta occurs on the

                        interface. Where THRESHOLD\-CROSSED is specified, the local

                        system should trigger an update (and hence flood) the

                        reserved bandwidth when the reserved bandwidth changes such

                        that it crosses, or becomes equal to one of the threshold

                        values

                        .. data:: DELTA = 0

                        	DELTA indicates that the local

                        	system should flood IGP updates when a

                        	change in reserved bandwidth >= the specified

                        	delta occurs on the interface.

                        .. data:: THRESHOLD_CROSSED = 1

                        	THRESHOLD-CROSSED indicates that

                        	the local system should trigger an update (and

                        	hence flood) the reserved bandwidth when the

                        	reserved bandwidth changes such that it crosses,

                        	or becomes equal to one of the threshold values.

                        """

                        DELTA = Enum.YLeaf(0, "DELTA")

                        THRESHOLD_CROSSED = Enum.YLeaf(1, "THRESHOLD-CROSSED")


                    def has_data(self):
                        for leaf in self.down_thresholds.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.up_down_thresholds.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.up_thresholds.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.delta_percentage.is_set or
                            self.threshold_specification.is_set or
                            self.threshold_type.is_set)

                    def has_operation(self):
                        for leaf in self.down_thresholds.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.up_down_thresholds.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.up_thresholds.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.delta_percentage.yfilter != YFilter.not_set or
                            self.down_thresholds.yfilter != YFilter.not_set or
                            self.threshold_specification.yfilter != YFilter.not_set or
                            self.threshold_type.yfilter != YFilter.not_set or
                            self.up_down_thresholds.yfilter != YFilter.not_set or
                            self.up_thresholds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.delta_percentage.is_set or self.delta_percentage.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.delta_percentage.get_name_leafdata())
                        if (self.threshold_specification.is_set or self.threshold_specification.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_specification.get_name_leafdata())
                        if (self.threshold_type.is_set or self.threshold_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_type.get_name_leafdata())

                        leaf_name_data.extend(self.down_thresholds.get_name_leafdata())

                        leaf_name_data.extend(self.up_down_thresholds.get_name_leafdata())

                        leaf_name_data.extend(self.up_thresholds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "delta-percentage" or name == "down-thresholds" or name == "threshold-specification" or name == "threshold-type" or name == "up-down-thresholds" or name == "up-thresholds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "delta-percentage"):
                            self.delta_percentage = value
                            self.delta_percentage.value_namespace = name_space
                            self.delta_percentage.value_namespace_prefix = name_space_prefix
                        if(value_path == "down-thresholds"):
                            self.down_thresholds.append(value)
                        if(value_path == "threshold-specification"):
                            self.threshold_specification = value
                            self.threshold_specification.value_namespace = name_space
                            self.threshold_specification.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-type"):
                            self.threshold_type = value
                            self.threshold_type.value_namespace = name_space
                            self.threshold_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "up-down-thresholds"):
                            self.up_down_thresholds.append(value)
                        if(value_path == "up-thresholds"):
                            self.up_thresholds.append(value)


                class State(Entity):
                    """
                    State parameters for TED update threshold 
                    
                    .. attribute:: delta_percentage
                    
                    	The percentage of the maximum\-reservable\-bandwidth considered as the delta that results in an IGP update being flooded
                    	**type**\:  int
                    
                    	**range:** 0..100
                    
                    .. attribute:: down_thresholds
                    
                    	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is decreasing
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    .. attribute:: threshold_specification
                    
                    	This value specifies whether a single set of threshold values should be used for both increasing and decreasing bandwidth when determining whether to trigger updated bandwidth values to be flooded in the IGP TE extensions. MIRRORED\-UP\-DOWN indicates that a single value (or set of values) should be used for both increasing and decreasing values, where SEPARATE\-UP\-DOWN specifies that the increasing and decreasing values will be separately specified
                    	**type**\:   :py:class:`ThresholdSpecification <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State.ThresholdSpecification>`
                    
                    .. attribute:: threshold_type
                    
                    	The type of threshold that should be used to specify the values at which bandwidth is flooded. DELTA indicates that the local system should flood IGP updates when a change in reserved bandwidth >= the specified delta occurs on the interface. Where THRESHOLD\-CROSSED is specified, the local system should trigger an update (and hence flood) the reserved bandwidth when the reserved bandwidth changes such that it crosses, or becomes equal to one of the threshold values
                    	**type**\:   :py:class:`ThresholdType <ydk.models.openconfig.openconfig_mpls.Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State.ThresholdType>`
                    
                    .. attribute:: up_down_thresholds
                    
                    	The thresholds (expressed as a percentage of the maximum reservable bandwidth of the interface) at which bandwidth updates are flooded \- used both when the bandwidth is increasing and decreasing
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    .. attribute:: up_thresholds
                    
                    	The thresholds (expressed as a percentage of the maximum reservable bandwidth) at which bandwidth updates are to be triggered when the bandwidth is increasing
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "igp-flooding-bandwidth"

                        self.delta_percentage = YLeaf(YType.uint8, "delta-percentage")

                        self.down_thresholds = YLeafList(YType.uint8, "down-thresholds")

                        self.threshold_specification = YLeaf(YType.enumeration, "threshold-specification")

                        self.threshold_type = YLeaf(YType.enumeration, "threshold-type")

                        self.up_down_thresholds = YLeafList(YType.uint8, "up-down-thresholds")

                        self.up_thresholds = YLeafList(YType.uint8, "up-thresholds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("delta_percentage",
                                        "down_thresholds",
                                        "threshold_specification",
                                        "threshold_type",
                                        "up_down_thresholds",
                                        "up_thresholds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State, self).__setattr__(name, value)

                    class ThresholdSpecification(Enum):
                        """
                        ThresholdSpecification

                        This value specifies whether a single set of threshold

                        values should be used for both increasing and decreasing

                        bandwidth when determining whether to trigger updated

                        bandwidth values to be flooded in the IGP TE extensions.

                        MIRRORED\-UP\-DOWN indicates that a single value (or set of

                        values) should be used for both increasing and decreasing

                        values, where SEPARATE\-UP\-DOWN specifies that the increasing

                        and decreasing values will be separately specified

                        .. data:: MIRRORED_UP_DOWN = 0

                        	MIRRORED-UP-DOWN indicates that a single set of

                        	threshold values should be used for both increasing

                        	and decreasing bandwidth when determining whether

                        	to trigger updated bandwidth values to be flooded

                        	in the IGP TE extensions.

                        .. data:: SEPARATE_UP_DOWN = 1

                        	SEPARATE-UP-DOWN indicates that a separate

                        	threshold values should be used for the increasing

                        	and decreasing bandwidth when determining whether

                        	to trigger updated bandwidth values to be flooded

                        	in the IGP TE extensions.

                        """

                        MIRRORED_UP_DOWN = Enum.YLeaf(0, "MIRRORED-UP-DOWN")

                        SEPARATE_UP_DOWN = Enum.YLeaf(1, "SEPARATE-UP-DOWN")


                    class ThresholdType(Enum):
                        """
                        ThresholdType

                        The type of threshold that should be used to specify the

                        values at which bandwidth is flooded. DELTA indicates that

                        the local system should flood IGP updates when a change in

                        reserved bandwidth >= the specified delta occurs on the

                        interface. Where THRESHOLD\-CROSSED is specified, the local

                        system should trigger an update (and hence flood) the

                        reserved bandwidth when the reserved bandwidth changes such

                        that it crosses, or becomes equal to one of the threshold

                        values

                        .. data:: DELTA = 0

                        	DELTA indicates that the local

                        	system should flood IGP updates when a

                        	change in reserved bandwidth >= the specified

                        	delta occurs on the interface.

                        .. data:: THRESHOLD_CROSSED = 1

                        	THRESHOLD-CROSSED indicates that

                        	the local system should trigger an update (and

                        	hence flood) the reserved bandwidth when the

                        	reserved bandwidth changes such that it crosses,

                        	or becomes equal to one of the threshold values.

                        """

                        DELTA = Enum.YLeaf(0, "DELTA")

                        THRESHOLD_CROSSED = Enum.YLeaf(1, "THRESHOLD-CROSSED")


                    def has_data(self):
                        for leaf in self.down_thresholds.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.up_down_thresholds.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        for leaf in self.up_thresholds.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return (
                            self.delta_percentage.is_set or
                            self.threshold_specification.is_set or
                            self.threshold_type.is_set)

                    def has_operation(self):
                        for leaf in self.down_thresholds.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.up_down_thresholds.getYLeafs():
                            if (leaf.is_set):
                                return True
                        for leaf in self.up_thresholds.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.delta_percentage.yfilter != YFilter.not_set or
                            self.down_thresholds.yfilter != YFilter.not_set or
                            self.threshold_specification.yfilter != YFilter.not_set or
                            self.threshold_type.yfilter != YFilter.not_set or
                            self.up_down_thresholds.yfilter != YFilter.not_set or
                            self.up_thresholds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.delta_percentage.is_set or self.delta_percentage.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.delta_percentage.get_name_leafdata())
                        if (self.threshold_specification.is_set or self.threshold_specification.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_specification.get_name_leafdata())
                        if (self.threshold_type.is_set or self.threshold_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold_type.get_name_leafdata())

                        leaf_name_data.extend(self.down_thresholds.get_name_leafdata())

                        leaf_name_data.extend(self.up_down_thresholds.get_name_leafdata())

                        leaf_name_data.extend(self.up_thresholds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "delta-percentage" or name == "down-thresholds" or name == "threshold-specification" or name == "threshold-type" or name == "up-down-thresholds" or name == "up-thresholds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "delta-percentage"):
                            self.delta_percentage = value
                            self.delta_percentage.value_namespace = name_space
                            self.delta_percentage.value_namespace_prefix = name_space_prefix
                        if(value_path == "down-thresholds"):
                            self.down_thresholds.append(value)
                        if(value_path == "threshold-specification"):
                            self.threshold_specification = value
                            self.threshold_specification.value_namespace = name_space
                            self.threshold_specification.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold-type"):
                            self.threshold_type = value
                            self.threshold_type.value_namespace = name_space
                            self.threshold_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "up-down-thresholds"):
                            self.up_down_thresholds.append(value)
                        if(value_path == "up-thresholds"):
                            self.up_thresholds.append(value)

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "igp-flooding-bandwidth" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.name.is_set or
                    (self.config is not None and self.config.has_data()) or
                    (self.igp_flooding_bandwidth is not None and self.igp_flooding_bandwidth.has_data()) or
                    (self.state is not None and self.state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.name.yfilter != YFilter.not_set or
                    (self.config is not None and self.config.has_operation()) or
                    (self.igp_flooding_bandwidth is not None and self.igp_flooding_bandwidth.has_operation()) or
                    (self.state is not None and self.state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface" + "[name='" + self.name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/te-interface-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "config"):
                    if (self.config is None):
                        self.config = Mpls.TeInterfaceAttributes.Interface.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                    return self.config

                if (child_yang_name == "igp-flooding-bandwidth"):
                    if (self.igp_flooding_bandwidth is None):
                        self.igp_flooding_bandwidth = Mpls.TeInterfaceAttributes.Interface.IgpFloodingBandwidth()
                        self.igp_flooding_bandwidth.parent = self
                        self._children_name_map["igp_flooding_bandwidth"] = "igp-flooding-bandwidth"
                    return self.igp_flooding_bandwidth

                if (child_yang_name == "state"):
                    if (self.state is None):
                        self.state = Mpls.TeInterfaceAttributes.Interface.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                    return self.state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "config" or name == "igp-flooding-bandwidth" or name == "state" or name == "name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "name"):
                    self.name = value
                    self.name.value_namespace = name_space
                    self.name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.interface:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "te-interface-attributes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-mpls:mpls/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface"):
                for c in self.interface:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Mpls.TeInterfaceAttributes.Interface()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class SignalingProtocols(Entity):
        """
        top\-level signaling protocol configuration
        
        .. attribute:: ldp
        
        	LDP global signaling configuration
        	**type**\:   :py:class:`Ldp <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.Ldp>`
        
        .. attribute:: rsvp_te
        
        	RSVP\-TE global signaling protocol configuration
        	**type**\:   :py:class:`RsvpTe <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe>`
        
        .. attribute:: segment_routing
        
        	SR global signaling config
        	**type**\:   :py:class:`SegmentRouting <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting>`
        
        

        """

        _prefix = 'mpls'
        _revision = '2015-11-05'

        def __init__(self):
            super(Mpls.SignalingProtocols, self).__init__()

            self.yang_name = "signaling-protocols"
            self.yang_parent_name = "mpls"

            self.ldp = Mpls.SignalingProtocols.Ldp()
            self.ldp.parent = self
            self._children_name_map["ldp"] = "ldp"
            self._children_yang_names.add("ldp")

            self.rsvp_te = Mpls.SignalingProtocols.RsvpTe()
            self.rsvp_te.parent = self
            self._children_name_map["rsvp_te"] = "rsvp-te"
            self._children_yang_names.add("rsvp-te")

            self.segment_routing = Mpls.SignalingProtocols.SegmentRouting()
            self.segment_routing.parent = self
            self._children_name_map["segment_routing"] = "segment-routing"
            self._children_yang_names.add("segment-routing")


        class RsvpTe(Entity):
            """
            RSVP\-TE global signaling protocol configuration
            
            .. attribute:: global_
            
            	Platform wide RSVP configuration and state
            	**type**\:   :py:class:`Global_ <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_>`
            
            .. attribute:: interface_attributes
            
            	Attributes relating to RSVP\-TE enabled interfaces
            	**type**\:   :py:class:`InterfaceAttributes <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes>`
            
            .. attribute:: neighbors
            
            	Configuration and state for RSVP neighbors connecting to the device
            	**type**\:   :py:class:`Neighbors <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Neighbors>`
            
            .. attribute:: sessions
            
            	Configuration and state of RSVP sessions
            	**type**\:   :py:class:`Sessions <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Sessions>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.SignalingProtocols.RsvpTe, self).__init__()

                self.yang_name = "rsvp-te"
                self.yang_parent_name = "signaling-protocols"

                self.global_ = Mpls.SignalingProtocols.RsvpTe.Global_()
                self.global_.parent = self
                self._children_name_map["global_"] = "global"
                self._children_yang_names.add("global")

                self.interface_attributes = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes()
                self.interface_attributes.parent = self
                self._children_name_map["interface_attributes"] = "interface-attributes"
                self._children_yang_names.add("interface-attributes")

                self.neighbors = Mpls.SignalingProtocols.RsvpTe.Neighbors()
                self.neighbors.parent = self
                self._children_name_map["neighbors"] = "neighbors"
                self._children_yang_names.add("neighbors")

                self.sessions = Mpls.SignalingProtocols.RsvpTe.Sessions()
                self.sessions.parent = self
                self._children_name_map["sessions"] = "sessions"
                self._children_yang_names.add("sessions")


            class Sessions(Entity):
                """
                Configuration and state of RSVP sessions
                
                .. attribute:: config
                
                	Configuration of RSVP sessions on the device
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Sessions.Config>`
                
                .. attribute:: state
                
                	State information relating to RSVP sessions on the device
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Sessions.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.RsvpTe.Sessions, self).__init__()

                    self.yang_name = "sessions"
                    self.yang_parent_name = "rsvp-te"

                    self.config = Mpls.SignalingProtocols.RsvpTe.Sessions.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.SignalingProtocols.RsvpTe.Sessions.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration of RSVP sessions on the device
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Sessions.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "sessions"

                    def has_data(self):
                        return False

                    def has_operation(self):
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/sessions/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class State(Entity):
                    """
                    State information relating to RSVP sessions
                    on the device
                    
                    .. attribute:: session
                    
                    	List of RSVP sessions
                    	**type**\: list of    :py:class:`Session <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Sessions.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "sessions"

                        self.session = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.RsvpTe.Sessions.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.RsvpTe.Sessions.State, self).__setattr__(name, value)


                    class Session(Entity):
                        """
                        List of RSVP sessions
                        
                        .. attribute:: source_port  <key>
                        
                        	RSVP source port
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: destination_port  <key>
                        
                        	RSVP source port
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: source_address  <key>
                        
                        	Origin address of RSVP session
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: destination_address  <key>
                        
                        	Destination address of RSVP session
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: associated_lsps
                        
                        	List of label switched paths associated with this RSVP session
                        	**type**\:  list of str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Config>`
                        
                        .. attribute:: label_in
                        
                        	Incoming MPLS label associated with this RSVP session
                        	**type**\: one of the below types:
                        
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        
                        ----
                        	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                        
                        
                        ----
                        .. attribute:: label_out
                        
                        	Outgoing MPLS label associated with this RSVP session
                        	**type**\: one of the below types:
                        
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        
                        ----
                        	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                        
                        
                        ----
                        .. attribute:: status
                        
                        	Enumeration of RSVP session states
                        	**type**\:   :py:class:`Status <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session.Status>`
                        
                        .. attribute:: tunnel_id
                        
                        	Unique identifier of RSVP session
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: type
                        
                        	Enumeration of possible RSVP session types
                        	**type**\:   :py:class:`Type <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session.Type>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session, self).__init__()

                            self.yang_name = "session"
                            self.yang_parent_name = "state"

                            self.source_port = YLeaf(YType.uint16, "source-port")

                            self.destination_port = YLeaf(YType.uint16, "destination-port")

                            self.source_address = YLeaf(YType.str, "source-address")

                            self.destination_address = YLeaf(YType.str, "destination-address")

                            self.associated_lsps = YLeafList(YType.str, "associated-lsps")

                            self.label_in = YLeaf(YType.str, "label-in")

                            self.label_out = YLeaf(YType.str, "label-out")

                            self.status = YLeaf(YType.enumeration, "status")

                            self.tunnel_id = YLeaf(YType.uint16, "tunnel-id")

                            self.type = YLeaf(YType.enumeration, "type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("source_port",
                                            "destination_port",
                                            "source_address",
                                            "destination_address",
                                            "associated_lsps",
                                            "label_in",
                                            "label_out",
                                            "status",
                                            "tunnel_id",
                                            "type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session, self).__setattr__(name, value)

                        class Status(Enum):
                            """
                            Status

                            Enumeration of RSVP session states

                            .. data:: UP = 0

                            	RSVP session is up

                            .. data:: DOWN = 1

                            	RSVP session is down

                            """

                            UP = Enum.YLeaf(0, "UP")

                            DOWN = Enum.YLeaf(1, "DOWN")


                        class Type(Enum):
                            """
                            Type

                            Enumeration of possible RSVP session types

                            .. data:: SOURCE = 0

                            	RSVP session originates on this device

                            .. data:: TRANSIT = 1

                            	RSVP session transits this device only

                            .. data:: DESTINATION = 2

                            	RSVP session terminates on this device

                            """

                            SOURCE = Enum.YLeaf(0, "SOURCE")

                            TRANSIT = Enum.YLeaf(1, "TRANSIT")

                            DESTINATION = Enum.YLeaf(2, "DESTINATION")


                        def has_data(self):
                            for leaf in self.associated_lsps.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return (
                                self.source_port.is_set or
                                self.destination_port.is_set or
                                self.source_address.is_set or
                                self.destination_address.is_set or
                                self.label_in.is_set or
                                self.label_out.is_set or
                                self.status.is_set or
                                self.tunnel_id.is_set or
                                self.type.is_set)

                        def has_operation(self):
                            for leaf in self.associated_lsps.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.source_port.yfilter != YFilter.not_set or
                                self.destination_port.yfilter != YFilter.not_set or
                                self.source_address.yfilter != YFilter.not_set or
                                self.destination_address.yfilter != YFilter.not_set or
                                self.associated_lsps.yfilter != YFilter.not_set or
                                self.label_in.yfilter != YFilter.not_set or
                                self.label_out.yfilter != YFilter.not_set or
                                self.status.yfilter != YFilter.not_set or
                                self.tunnel_id.yfilter != YFilter.not_set or
                                self.type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "session" + "[source-port='" + self.source_port.get() + "']" + "[destination-port='" + self.destination_port.get() + "']" + "[source-address='" + self.source_address.get() + "']" + "[destination-address='" + self.destination_address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/sessions/state/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.source_port.is_set or self.source_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source_port.get_name_leafdata())
                            if (self.destination_port.is_set or self.destination_port.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination_port.get_name_leafdata())
                            if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source_address.get_name_leafdata())
                            if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination_address.get_name_leafdata())
                            if (self.label_in.is_set or self.label_in.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.label_in.get_name_leafdata())
                            if (self.label_out.is_set or self.label_out.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.label_out.get_name_leafdata())
                            if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.status.get_name_leafdata())
                            if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tunnel_id.get_name_leafdata())
                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.type.get_name_leafdata())

                            leaf_name_data.extend(self.associated_lsps.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "source-port" or name == "destination-port" or name == "source-address" or name == "destination-address" or name == "associated-lsps" or name == "label-in" or name == "label-out" or name == "status" or name == "tunnel-id" or name == "type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "source-port"):
                                self.source_port = value
                                self.source_port.value_namespace = name_space
                                self.source_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "destination-port"):
                                self.destination_port = value
                                self.destination_port.value_namespace = name_space
                                self.destination_port.value_namespace_prefix = name_space_prefix
                            if(value_path == "source-address"):
                                self.source_address = value
                                self.source_address.value_namespace = name_space
                                self.source_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "destination-address"):
                                self.destination_address = value
                                self.destination_address.value_namespace = name_space
                                self.destination_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "associated-lsps"):
                                self.associated_lsps.append(value)
                            if(value_path == "label-in"):
                                self.label_in = value
                                self.label_in.value_namespace = name_space
                                self.label_in.value_namespace_prefix = name_space_prefix
                            if(value_path == "label-out"):
                                self.label_out = value
                                self.label_out.value_namespace = name_space
                                self.label_out.value_namespace_prefix = name_space_prefix
                            if(value_path == "status"):
                                self.status = value
                                self.status.value_namespace = name_space
                                self.status.value_namespace_prefix = name_space_prefix
                            if(value_path == "tunnel-id"):
                                self.tunnel_id = value
                                self.tunnel_id.value_namespace = name_space
                                self.tunnel_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "type"):
                                self.type = value
                                self.type.value_namespace = name_space
                                self.type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.session:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.session:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/sessions/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "session"):
                            for c in self.session:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Mpls.SignalingProtocols.RsvpTe.Sessions.State.Session()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.session.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "session"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "sessions" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.SignalingProtocols.RsvpTe.Sessions.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.SignalingProtocols.RsvpTe.Sessions.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Neighbors(Entity):
                """
                Configuration and state for RSVP neighbors connecting
                to the device
                
                .. attribute:: config
                
                	Configuration of RSVP neighbor information
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Neighbors.Config>`
                
                .. attribute:: state
                
                	State information relating to RSVP neighbors
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Neighbors.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.RsvpTe.Neighbors, self).__init__()

                    self.yang_name = "neighbors"
                    self.yang_parent_name = "rsvp-te"

                    self.config = Mpls.SignalingProtocols.RsvpTe.Neighbors.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.SignalingProtocols.RsvpTe.Neighbors.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class Config(Entity):
                    """
                    Configuration of RSVP neighbor information
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Neighbors.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "neighbors"

                    def has_data(self):
                        return False

                    def has_operation(self):
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/neighbors/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class State(Entity):
                    """
                    State information relating to RSVP neighbors
                    
                    .. attribute:: neighbor
                    
                    	List of RSVP neighbors connecting to the device, keyed by neighbor address
                    	**type**\: list of    :py:class:`Neighbor <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Neighbors.State.Neighbor>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Neighbors.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "neighbors"

                        self.neighbor = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.RsvpTe.Neighbors.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.RsvpTe.Neighbors.State, self).__setattr__(name, value)


                    class Neighbor(Entity):
                        """
                        List of RSVP neighbors connecting to the device,
                        keyed by neighbor address
                        
                        .. attribute:: address  <key>
                        
                        	Address of RSVP neighbor
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: detected_interface
                        
                        	Interface where RSVP neighbor was detected
                        	**type**\:  str
                        
                        .. attribute:: neighbor_status
                        
                        	Enumuration of possible RSVP neighbor states
                        	**type**\:   :py:class:`NeighborStatus <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Neighbors.State.Neighbor.NeighborStatus>`
                        
                        .. attribute:: refresh_reduction
                        
                        	Suppport of neighbor for RSVP refresh reduction
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Neighbors.State.Neighbor, self).__init__()

                            self.yang_name = "neighbor"
                            self.yang_parent_name = "state"

                            self.address = YLeaf(YType.str, "address")

                            self.detected_interface = YLeaf(YType.str, "detected-interface")

                            self.neighbor_status = YLeaf(YType.enumeration, "neighbor-status")

                            self.refresh_reduction = YLeaf(YType.boolean, "refresh-reduction")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "detected_interface",
                                            "neighbor_status",
                                            "refresh_reduction") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Neighbors.State.Neighbor, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Neighbors.State.Neighbor, self).__setattr__(name, value)

                        class NeighborStatus(Enum):
                            """
                            NeighborStatus

                            Enumuration of possible RSVP neighbor states

                            .. data:: UP = 0

                            	RSVP hello messages are detected from the neighbor

                            .. data:: DOWN = 1

                            	RSVP neighbor not detected as up, due to a

                            	communication failure or IGP notification

                            	the neighbor is unavailable

                            """

                            UP = Enum.YLeaf(0, "UP")

                            DOWN = Enum.YLeaf(1, "DOWN")


                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.detected_interface.is_set or
                                self.neighbor_status.is_set or
                                self.refresh_reduction.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.detected_interface.yfilter != YFilter.not_set or
                                self.neighbor_status.yfilter != YFilter.not_set or
                                self.refresh_reduction.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "neighbor" + "[address='" + self.address.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/neighbors/state/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.detected_interface.is_set or self.detected_interface.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detected_interface.get_name_leafdata())
                            if (self.neighbor_status.is_set or self.neighbor_status.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.neighbor_status.get_name_leafdata())
                            if (self.refresh_reduction.is_set or self.refresh_reduction.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.refresh_reduction.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "detected-interface" or name == "neighbor-status" or name == "refresh-reduction"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "detected-interface"):
                                self.detected_interface = value
                                self.detected_interface.value_namespace = name_space
                                self.detected_interface.value_namespace_prefix = name_space_prefix
                            if(value_path == "neighbor-status"):
                                self.neighbor_status = value
                                self.neighbor_status.value_namespace = name_space
                                self.neighbor_status.value_namespace_prefix = name_space_prefix
                            if(value_path == "refresh-reduction"):
                                self.refresh_reduction = value
                                self.refresh_reduction.value_namespace = name_space
                                self.refresh_reduction.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.neighbor:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.neighbor:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/neighbors/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "neighbor"):
                            for c in self.neighbor:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Mpls.SignalingProtocols.RsvpTe.Neighbors.State.Neighbor()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.neighbor.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "neighbor"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "neighbors" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.SignalingProtocols.RsvpTe.Neighbors.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.SignalingProtocols.RsvpTe.Neighbors.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Global_(Entity):
                """
                Platform wide RSVP configuration and state
                
                .. attribute:: graceful_restart
                
                	Operational state and configuration parameters relating to graceful\-restart for RSVP
                	**type**\:   :py:class:`GracefulRestart <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart>`
                
                .. attribute:: hellos
                
                	Top level container for RSVP hello parameters
                	**type**\:   :py:class:`Hellos <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.Hellos>`
                
                .. attribute:: soft_preemption
                
                	Protocol options relating to RSVP soft preemption
                	**type**\:   :py:class:`SoftPreemption <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption>`
                
                .. attribute:: state
                
                	Platform wide RSVP state, including counters
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.RsvpTe.Global_, self).__init__()

                    self.yang_name = "global"
                    self.yang_parent_name = "rsvp-te"

                    self.graceful_restart = Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart()
                    self.graceful_restart.parent = self
                    self._children_name_map["graceful_restart"] = "graceful-restart"
                    self._children_yang_names.add("graceful-restart")

                    self.hellos = Mpls.SignalingProtocols.RsvpTe.Global_.Hellos()
                    self.hellos.parent = self
                    self._children_name_map["hellos"] = "hellos"
                    self._children_yang_names.add("hellos")

                    self.soft_preemption = Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption()
                    self.soft_preemption.parent = self
                    self._children_name_map["soft_preemption"] = "soft-preemption"
                    self._children_yang_names.add("soft-preemption")

                    self.state = Mpls.SignalingProtocols.RsvpTe.Global_.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")


                class GracefulRestart(Entity):
                    """
                    Operational state and configuration parameters relating to
                    graceful\-restart for RSVP
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to graceful\-restart
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.Config>`
                    
                    .. attribute:: state
                    
                    	State information associated with RSVP graceful\-restart
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart, self).__init__()

                        self.yang_name = "graceful-restart"
                        self.yang_parent_name = "global"

                        self.config = Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to
                        graceful\-restart
                        
                        .. attribute:: enable
                        
                        	Enables graceful restart on the node
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: recovery_time
                        
                        	RSVP state recovery time
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: restart_time
                        
                        	Graceful restart time (seconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "graceful-restart"

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.recovery_time = YLeaf(YType.uint32, "recovery-time")

                            self.restart_time = YLeaf(YType.uint32, "restart-time")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "recovery_time",
                                            "restart_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.recovery_time.is_set or
                                self.restart_time.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.recovery_time.yfilter != YFilter.not_set or
                                self.restart_time.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/graceful-restart/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.recovery_time.is_set or self.recovery_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.recovery_time.get_name_leafdata())
                            if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.restart_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable" or name == "recovery-time" or name == "restart-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "recovery-time"):
                                self.recovery_time = value
                                self.recovery_time.value_namespace = name_space
                                self.recovery_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "restart-time"):
                                self.restart_time = value
                                self.restart_time.value_namespace = name_space
                                self.restart_time.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information associated with
                        RSVP graceful\-restart
                        
                        .. attribute:: enable
                        
                        	Enables graceful restart on the node
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: recovery_time
                        
                        	RSVP state recovery time
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: restart_time
                        
                        	Graceful restart time (seconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "graceful-restart"

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.recovery_time = YLeaf(YType.uint32, "recovery-time")

                            self.restart_time = YLeaf(YType.uint32, "restart-time")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "recovery_time",
                                            "restart_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.recovery_time.is_set or
                                self.restart_time.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.recovery_time.yfilter != YFilter.not_set or
                                self.restart_time.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/graceful-restart/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.recovery_time.is_set or self.recovery_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.recovery_time.get_name_leafdata())
                            if (self.restart_time.is_set or self.restart_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.restart_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable" or name == "recovery-time" or name == "restart-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "recovery-time"):
                                self.recovery_time = value
                                self.recovery_time.value_namespace = name_space
                                self.recovery_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "restart-time"):
                                self.restart_time = value
                                self.restart_time.value_namespace = name_space
                                self.restart_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "graceful-restart" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SoftPreemption(Entity):
                    """
                    Protocol options relating to RSVP
                    soft preemption
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to RSVP soft preemption support
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.Config>`
                    
                    .. attribute:: state
                    
                    	State parameters relating to RSVP soft preemption support
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption, self).__init__()

                        self.yang_name = "soft-preemption"
                        self.yang_parent_name = "global"

                        self.config = Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to RSVP
                        soft preemption support
                        
                        .. attribute:: enable
                        
                        	Enables soft preemption on a node
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: soft_preemption_timeout
                        
                        	Timeout value for soft preemption to revert to hard preemption
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        	**default value**\: 0
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "soft-preemption"

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.soft_preemption_timeout = YLeaf(YType.uint16, "soft-preemption-timeout")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "soft_preemption_timeout") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.soft_preemption_timeout.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.soft_preemption_timeout.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/soft-preemption/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.soft_preemption_timeout.is_set or self.soft_preemption_timeout.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.soft_preemption_timeout.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable" or name == "soft-preemption-timeout"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "soft-preemption-timeout"):
                                self.soft_preemption_timeout = value
                                self.soft_preemption_timeout.value_namespace = name_space
                                self.soft_preemption_timeout.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State parameters relating to RSVP
                        soft preemption support
                        
                        .. attribute:: enable
                        
                        	Enables soft preemption on a node
                        	**type**\:  bool
                        
                        	**default value**\: false
                        
                        .. attribute:: soft_preemption_timeout
                        
                        	Timeout value for soft preemption to revert to hard preemption
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        	**default value**\: 0
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "soft-preemption"

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.soft_preemption_timeout = YLeaf(YType.uint16, "soft-preemption-timeout")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "soft_preemption_timeout") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.soft_preemption_timeout.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.soft_preemption_timeout.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/soft-preemption/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.soft_preemption_timeout.is_set or self.soft_preemption_timeout.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.soft_preemption_timeout.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable" or name == "soft-preemption-timeout"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "soft-preemption-timeout"):
                                self.soft_preemption_timeout = value
                                self.soft_preemption_timeout.value_namespace = name_space
                                self.soft_preemption_timeout.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "soft-preemption" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Hellos(Entity):
                    """
                    Top level container for RSVP hello parameters
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to RSVP hellos
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.Config>`
                    
                    .. attribute:: state
                    
                    	State information associated with RSVP hellos
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos, self).__init__()

                        self.yang_name = "hellos"
                        self.yang_parent_name = "global"

                        self.config = Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters relating to RSVP
                        hellos
                        
                        .. attribute:: hello_interval
                        
                        	set the interval in ms between RSVP hello messages
                        	**type**\:  int
                        
                        	**range:** 1000..60000
                        
                        	**units**\: milliseconds
                        
                        	**default value**\: 9000
                        
                        .. attribute:: refresh_reduction
                        
                        	enables all RSVP refresh reduction message bundling, RSVP message ID, reliable message delivery and summary refresh
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "hellos"

                            self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                            self.refresh_reduction = YLeaf(YType.boolean, "refresh-reduction")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hello_interval",
                                            "refresh_reduction") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hello_interval.is_set or
                                self.refresh_reduction.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hello_interval.yfilter != YFilter.not_set or
                                self.refresh_reduction.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/hellos/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_interval.get_name_leafdata())
                            if (self.refresh_reduction.is_set or self.refresh_reduction.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.refresh_reduction.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-interval" or name == "refresh-reduction"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hello-interval"):
                                self.hello_interval = value
                                self.hello_interval.value_namespace = name_space
                                self.hello_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "refresh-reduction"):
                                self.refresh_reduction = value
                                self.refresh_reduction.value_namespace = name_space
                                self.refresh_reduction.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State information associated with RSVP hellos
                        
                        .. attribute:: hello_interval
                        
                        	set the interval in ms between RSVP hello messages
                        	**type**\:  int
                        
                        	**range:** 1000..60000
                        
                        	**units**\: milliseconds
                        
                        	**default value**\: 9000
                        
                        .. attribute:: refresh_reduction
                        
                        	enables all RSVP refresh reduction message bundling, RSVP message ID, reliable message delivery and summary refresh
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "hellos"

                            self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                            self.refresh_reduction = YLeaf(YType.boolean, "refresh-reduction")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hello_interval",
                                            "refresh_reduction") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hello_interval.is_set or
                                self.refresh_reduction.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hello_interval.yfilter != YFilter.not_set or
                                self.refresh_reduction.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/hellos/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hello_interval.get_name_leafdata())
                            if (self.refresh_reduction.is_set or self.refresh_reduction.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.refresh_reduction.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hello-interval" or name == "refresh-reduction"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hello-interval"):
                                self.hello_interval = value
                                self.hello_interval.value_namespace = name_space
                                self.hello_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "refresh-reduction"):
                                self.refresh_reduction = value
                                self.refresh_reduction.value_namespace = name_space
                                self.refresh_reduction.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "hellos" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.SignalingProtocols.RsvpTe.Global_.Hellos.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class State(Entity):
                    """
                    Platform wide RSVP state, including counters
                    
                    .. attribute:: counters
                    
                    	Platform wide RSVP statistics and counters
                    	**type**\:   :py:class:`Counters <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.Global_.State.Counters>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.Global_.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "global"

                        self.counters = Mpls.SignalingProtocols.RsvpTe.Global_.State.Counters()
                        self.counters.parent = self
                        self._children_name_map["counters"] = "counters"
                        self._children_yang_names.add("counters")


                    class Counters(Entity):
                        """
                        Platform wide RSVP statistics and counters
                        
                        .. attribute:: in_ack_messages
                        
                        	Number of received RSVP refresh reduction ack messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_hello_messages
                        
                        	Number of received RSVP hello messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_path_error_messages
                        
                        	Number of received RSVP Path Error messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_path_messages
                        
                        	Number of received RSVP Path messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_path_tear_messages
                        
                        	Number of received RSVP Path Tear messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_reservation_error_messages
                        
                        	Number of received RSVP Resv Error messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_reservation_messages
                        
                        	Number of received RSVP Resv messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_reservation_tear_messages
                        
                        	Number of received RSVP Resv Tear messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: in_srefresh_messages
                        
                        	Number of received RSVP summary refresh messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_ack_messages
                        
                        	Number of sent RSVP refresh reduction ack messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_hello_messages
                        
                        	Number of sent RSVP hello messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_path_error_messages
                        
                        	Number of sent RSVP Path Error messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_path_messages
                        
                        	Number of sent RSVP PATH messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_path_tear_messages
                        
                        	Number of sent RSVP Path Tear messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_reservation_error_messages
                        
                        	Number of sent RSVP Resv Error messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_reservation_messages
                        
                        	Number of sent RSVP Resv messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_reservation_tear_messages
                        
                        	Number of sent RSVP Resv Tear messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: out_srefresh_messages
                        
                        	Number of sent RSVP summary refresh messages
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: path_timeouts
                        
                        	TODO
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: rate_limited_messages
                        
                        	RSVP messages dropped due to rate limiting
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: reservation_timeouts
                        
                        	TODO
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.Global_.State.Counters, self).__init__()

                            self.yang_name = "counters"
                            self.yang_parent_name = "state"

                            self.in_ack_messages = YLeaf(YType.uint64, "in-ack-messages")

                            self.in_hello_messages = YLeaf(YType.uint64, "in-hello-messages")

                            self.in_path_error_messages = YLeaf(YType.uint64, "in-path-error-messages")

                            self.in_path_messages = YLeaf(YType.uint64, "in-path-messages")

                            self.in_path_tear_messages = YLeaf(YType.uint64, "in-path-tear-messages")

                            self.in_reservation_error_messages = YLeaf(YType.uint64, "in-reservation-error-messages")

                            self.in_reservation_messages = YLeaf(YType.uint64, "in-reservation-messages")

                            self.in_reservation_tear_messages = YLeaf(YType.uint64, "in-reservation-tear-messages")

                            self.in_srefresh_messages = YLeaf(YType.uint64, "in-srefresh-messages")

                            self.out_ack_messages = YLeaf(YType.uint64, "out-ack-messages")

                            self.out_hello_messages = YLeaf(YType.uint64, "out-hello-messages")

                            self.out_path_error_messages = YLeaf(YType.uint64, "out-path-error-messages")

                            self.out_path_messages = YLeaf(YType.uint64, "out-path-messages")

                            self.out_path_tear_messages = YLeaf(YType.uint64, "out-path-tear-messages")

                            self.out_reservation_error_messages = YLeaf(YType.uint64, "out-reservation-error-messages")

                            self.out_reservation_messages = YLeaf(YType.uint64, "out-reservation-messages")

                            self.out_reservation_tear_messages = YLeaf(YType.uint64, "out-reservation-tear-messages")

                            self.out_srefresh_messages = YLeaf(YType.uint64, "out-srefresh-messages")

                            self.path_timeouts = YLeaf(YType.uint64, "path-timeouts")

                            self.rate_limited_messages = YLeaf(YType.uint64, "rate-limited-messages")

                            self.reservation_timeouts = YLeaf(YType.uint64, "reservation-timeouts")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("in_ack_messages",
                                            "in_hello_messages",
                                            "in_path_error_messages",
                                            "in_path_messages",
                                            "in_path_tear_messages",
                                            "in_reservation_error_messages",
                                            "in_reservation_messages",
                                            "in_reservation_tear_messages",
                                            "in_srefresh_messages",
                                            "out_ack_messages",
                                            "out_hello_messages",
                                            "out_path_error_messages",
                                            "out_path_messages",
                                            "out_path_tear_messages",
                                            "out_reservation_error_messages",
                                            "out_reservation_messages",
                                            "out_reservation_tear_messages",
                                            "out_srefresh_messages",
                                            "path_timeouts",
                                            "rate_limited_messages",
                                            "reservation_timeouts") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.Global_.State.Counters, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.Global_.State.Counters, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.in_ack_messages.is_set or
                                self.in_hello_messages.is_set or
                                self.in_path_error_messages.is_set or
                                self.in_path_messages.is_set or
                                self.in_path_tear_messages.is_set or
                                self.in_reservation_error_messages.is_set or
                                self.in_reservation_messages.is_set or
                                self.in_reservation_tear_messages.is_set or
                                self.in_srefresh_messages.is_set or
                                self.out_ack_messages.is_set or
                                self.out_hello_messages.is_set or
                                self.out_path_error_messages.is_set or
                                self.out_path_messages.is_set or
                                self.out_path_tear_messages.is_set or
                                self.out_reservation_error_messages.is_set or
                                self.out_reservation_messages.is_set or
                                self.out_reservation_tear_messages.is_set or
                                self.out_srefresh_messages.is_set or
                                self.path_timeouts.is_set or
                                self.rate_limited_messages.is_set or
                                self.reservation_timeouts.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.in_ack_messages.yfilter != YFilter.not_set or
                                self.in_hello_messages.yfilter != YFilter.not_set or
                                self.in_path_error_messages.yfilter != YFilter.not_set or
                                self.in_path_messages.yfilter != YFilter.not_set or
                                self.in_path_tear_messages.yfilter != YFilter.not_set or
                                self.in_reservation_error_messages.yfilter != YFilter.not_set or
                                self.in_reservation_messages.yfilter != YFilter.not_set or
                                self.in_reservation_tear_messages.yfilter != YFilter.not_set or
                                self.in_srefresh_messages.yfilter != YFilter.not_set or
                                self.out_ack_messages.yfilter != YFilter.not_set or
                                self.out_hello_messages.yfilter != YFilter.not_set or
                                self.out_path_error_messages.yfilter != YFilter.not_set or
                                self.out_path_messages.yfilter != YFilter.not_set or
                                self.out_path_tear_messages.yfilter != YFilter.not_set or
                                self.out_reservation_error_messages.yfilter != YFilter.not_set or
                                self.out_reservation_messages.yfilter != YFilter.not_set or
                                self.out_reservation_tear_messages.yfilter != YFilter.not_set or
                                self.out_srefresh_messages.yfilter != YFilter.not_set or
                                self.path_timeouts.yfilter != YFilter.not_set or
                                self.rate_limited_messages.yfilter != YFilter.not_set or
                                self.reservation_timeouts.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "counters" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/state/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.in_ack_messages.is_set or self.in_ack_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_ack_messages.get_name_leafdata())
                            if (self.in_hello_messages.is_set or self.in_hello_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_hello_messages.get_name_leafdata())
                            if (self.in_path_error_messages.is_set or self.in_path_error_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_path_error_messages.get_name_leafdata())
                            if (self.in_path_messages.is_set or self.in_path_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_path_messages.get_name_leafdata())
                            if (self.in_path_tear_messages.is_set or self.in_path_tear_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_path_tear_messages.get_name_leafdata())
                            if (self.in_reservation_error_messages.is_set or self.in_reservation_error_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_reservation_error_messages.get_name_leafdata())
                            if (self.in_reservation_messages.is_set or self.in_reservation_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_reservation_messages.get_name_leafdata())
                            if (self.in_reservation_tear_messages.is_set or self.in_reservation_tear_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_reservation_tear_messages.get_name_leafdata())
                            if (self.in_srefresh_messages.is_set or self.in_srefresh_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_srefresh_messages.get_name_leafdata())
                            if (self.out_ack_messages.is_set or self.out_ack_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_ack_messages.get_name_leafdata())
                            if (self.out_hello_messages.is_set or self.out_hello_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_hello_messages.get_name_leafdata())
                            if (self.out_path_error_messages.is_set or self.out_path_error_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_path_error_messages.get_name_leafdata())
                            if (self.out_path_messages.is_set or self.out_path_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_path_messages.get_name_leafdata())
                            if (self.out_path_tear_messages.is_set or self.out_path_tear_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_path_tear_messages.get_name_leafdata())
                            if (self.out_reservation_error_messages.is_set or self.out_reservation_error_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_reservation_error_messages.get_name_leafdata())
                            if (self.out_reservation_messages.is_set or self.out_reservation_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_reservation_messages.get_name_leafdata())
                            if (self.out_reservation_tear_messages.is_set or self.out_reservation_tear_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_reservation_tear_messages.get_name_leafdata())
                            if (self.out_srefresh_messages.is_set or self.out_srefresh_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_srefresh_messages.get_name_leafdata())
                            if (self.path_timeouts.is_set or self.path_timeouts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_timeouts.get_name_leafdata())
                            if (self.rate_limited_messages.is_set or self.rate_limited_messages.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rate_limited_messages.get_name_leafdata())
                            if (self.reservation_timeouts.is_set or self.reservation_timeouts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reservation_timeouts.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "in-ack-messages" or name == "in-hello-messages" or name == "in-path-error-messages" or name == "in-path-messages" or name == "in-path-tear-messages" or name == "in-reservation-error-messages" or name == "in-reservation-messages" or name == "in-reservation-tear-messages" or name == "in-srefresh-messages" or name == "out-ack-messages" or name == "out-hello-messages" or name == "out-path-error-messages" or name == "out-path-messages" or name == "out-path-tear-messages" or name == "out-reservation-error-messages" or name == "out-reservation-messages" or name == "out-reservation-tear-messages" or name == "out-srefresh-messages" or name == "path-timeouts" or name == "rate-limited-messages" or name == "reservation-timeouts"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "in-ack-messages"):
                                self.in_ack_messages = value
                                self.in_ack_messages.value_namespace = name_space
                                self.in_ack_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-hello-messages"):
                                self.in_hello_messages = value
                                self.in_hello_messages.value_namespace = name_space
                                self.in_hello_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-path-error-messages"):
                                self.in_path_error_messages = value
                                self.in_path_error_messages.value_namespace = name_space
                                self.in_path_error_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-path-messages"):
                                self.in_path_messages = value
                                self.in_path_messages.value_namespace = name_space
                                self.in_path_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-path-tear-messages"):
                                self.in_path_tear_messages = value
                                self.in_path_tear_messages.value_namespace = name_space
                                self.in_path_tear_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-reservation-error-messages"):
                                self.in_reservation_error_messages = value
                                self.in_reservation_error_messages.value_namespace = name_space
                                self.in_reservation_error_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-reservation-messages"):
                                self.in_reservation_messages = value
                                self.in_reservation_messages.value_namespace = name_space
                                self.in_reservation_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-reservation-tear-messages"):
                                self.in_reservation_tear_messages = value
                                self.in_reservation_tear_messages.value_namespace = name_space
                                self.in_reservation_tear_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "in-srefresh-messages"):
                                self.in_srefresh_messages = value
                                self.in_srefresh_messages.value_namespace = name_space
                                self.in_srefresh_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-ack-messages"):
                                self.out_ack_messages = value
                                self.out_ack_messages.value_namespace = name_space
                                self.out_ack_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-hello-messages"):
                                self.out_hello_messages = value
                                self.out_hello_messages.value_namespace = name_space
                                self.out_hello_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-path-error-messages"):
                                self.out_path_error_messages = value
                                self.out_path_error_messages.value_namespace = name_space
                                self.out_path_error_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-path-messages"):
                                self.out_path_messages = value
                                self.out_path_messages.value_namespace = name_space
                                self.out_path_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-path-tear-messages"):
                                self.out_path_tear_messages = value
                                self.out_path_tear_messages.value_namespace = name_space
                                self.out_path_tear_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-reservation-error-messages"):
                                self.out_reservation_error_messages = value
                                self.out_reservation_error_messages.value_namespace = name_space
                                self.out_reservation_error_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-reservation-messages"):
                                self.out_reservation_messages = value
                                self.out_reservation_messages.value_namespace = name_space
                                self.out_reservation_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-reservation-tear-messages"):
                                self.out_reservation_tear_messages = value
                                self.out_reservation_tear_messages.value_namespace = name_space
                                self.out_reservation_tear_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-srefresh-messages"):
                                self.out_srefresh_messages = value
                                self.out_srefresh_messages.value_namespace = name_space
                                self.out_srefresh_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-timeouts"):
                                self.path_timeouts = value
                                self.path_timeouts.value_namespace = name_space
                                self.path_timeouts.value_namespace_prefix = name_space_prefix
                            if(value_path == "rate-limited-messages"):
                                self.rate_limited_messages = value
                                self.rate_limited_messages.value_namespace = name_space
                                self.rate_limited_messages.value_namespace_prefix = name_space_prefix
                            if(value_path == "reservation-timeouts"):
                                self.reservation_timeouts = value
                                self.reservation_timeouts.value_namespace = name_space
                                self.reservation_timeouts.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.counters is not None and self.counters.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.counters is not None and self.counters.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/global/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "counters"):
                            if (self.counters is None):
                                self.counters = Mpls.SignalingProtocols.RsvpTe.Global_.State.Counters()
                                self.counters.parent = self
                                self._children_name_map["counters"] = "counters"
                            return self.counters

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "counters"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                        (self.hellos is not None and self.hellos.has_data()) or
                        (self.soft_preemption is not None and self.soft_preemption.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                        (self.hellos is not None and self.hellos.has_operation()) or
                        (self.soft_preemption is not None and self.soft_preemption.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "global" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "graceful-restart"):
                        if (self.graceful_restart is None):
                            self.graceful_restart = Mpls.SignalingProtocols.RsvpTe.Global_.GracefulRestart()
                            self.graceful_restart.parent = self
                            self._children_name_map["graceful_restart"] = "graceful-restart"
                        return self.graceful_restart

                    if (child_yang_name == "hellos"):
                        if (self.hellos is None):
                            self.hellos = Mpls.SignalingProtocols.RsvpTe.Global_.Hellos()
                            self.hellos.parent = self
                            self._children_name_map["hellos"] = "hellos"
                        return self.hellos

                    if (child_yang_name == "soft-preemption"):
                        if (self.soft_preemption is None):
                            self.soft_preemption = Mpls.SignalingProtocols.RsvpTe.Global_.SoftPreemption()
                            self.soft_preemption.parent = self
                            self._children_name_map["soft_preemption"] = "soft-preemption"
                        return self.soft_preemption

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.SignalingProtocols.RsvpTe.Global_.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "graceful-restart" or name == "hellos" or name == "soft-preemption" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class InterfaceAttributes(Entity):
                """
                Attributes relating to RSVP\-TE enabled interfaces
                
                .. attribute:: interface
                
                	list of per\-interface RSVP configurations
                	**type**\: list of    :py:class:`Interface <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes, self).__init__()

                    self.yang_name = "interface-attributes"
                    self.yang_parent_name = "rsvp-te"

                    self.interface = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes, self).__setattr__(name, value)


                class Interface(Entity):
                    """
                    list of per\-interface RSVP configurations
                    
                    .. attribute:: interface_name  <key>
                    
                    	references a configured IP interface
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`interface_name <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config>`
                    
                    .. attribute:: authentication
                    
                    	Configuration and state parameters relating to RSVP authentication as per RFC2747
                    	**type**\:   :py:class:`Authentication <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication>`
                    
                    .. attribute:: config
                    
                    	Configuration of per\-interface RSVP parameters
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config>`
                    
                    .. attribute:: hellos
                    
                    	Top level container for RSVP hello parameters
                    	**type**\:   :py:class:`Hellos <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos>`
                    
                    .. attribute:: protection
                    
                    	link\-protection (NHOP) related configuration
                    	**type**\:   :py:class:`Protection <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection>`
                    
                    .. attribute:: state
                    
                    	Per\-interface RSVP protocol and state information
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State>`
                    
                    .. attribute:: subscription
                    
                    	Bandwidth percentage reservable by RSVP on an interface
                    	**type**\:   :py:class:`Subscription <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface, self).__init__()

                        self.yang_name = "interface"
                        self.yang_parent_name = "interface-attributes"

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.authentication = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication()
                        self.authentication.parent = self
                        self._children_name_map["authentication"] = "authentication"
                        self._children_yang_names.add("authentication")

                        self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.hellos = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos()
                        self.hellos.parent = self
                        self._children_name_map["hellos"] = "hellos"
                        self._children_yang_names.add("hellos")

                        self.protection = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection()
                        self.protection.parent = self
                        self._children_name_map["protection"] = "protection"
                        self._children_yang_names.add("protection")

                        self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                        self.subscription = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription()
                        self.subscription.parent = self
                        self._children_name_map["subscription"] = "subscription"
                        self._children_yang_names.add("subscription")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface, self).__setattr__(name, value)


                    class Config(Entity):
                        """
                        Configuration of per\-interface RSVP parameters
                        
                        .. attribute:: interface_name
                        
                        	Name of configured IP interface
                        	**type**\:  str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "interface"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.interface_name.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        Per\-interface RSVP protocol and state information
                        
                        .. attribute:: active_reservation_count
                        
                        	Number of active RSVP reservations
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: bandwidth
                        
                        	Available and reserved bandwidth by priority on the interface
                        	**type**\: list of    :py:class:`Bandwidth <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Bandwidth>`
                        
                        .. attribute:: counters
                        
                        	Interface specific RSVP statistics and counters
                        	**type**\:   :py:class:`Counters <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Counters>`
                        
                        .. attribute:: highwater_mark
                        
                        	Maximum bandwidth ever reserved
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "interface"

                            self.active_reservation_count = YLeaf(YType.uint64, "active-reservation-count")

                            self.highwater_mark = YLeaf(YType.uint64, "highwater-mark")

                            self.counters = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Counters()
                            self.counters.parent = self
                            self._children_name_map["counters"] = "counters"
                            self._children_yang_names.add("counters")

                            self.bandwidth = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("active_reservation_count",
                                            "highwater_mark") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State, self).__setattr__(name, value)


                        class Bandwidth(Entity):
                            """
                            Available and reserved bandwidth by priority on
                            the interface.
                            
                            .. attribute:: priority  <key>
                            
                            	RSVP priority level for LSPs traversing the interface
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            .. attribute:: available_bandwidth
                            
                            	Bandwidth currently available
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: reserved_bandwidth
                            
                            	Bandwidth currently reserved
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Bandwidth, self).__init__()

                                self.yang_name = "bandwidth"
                                self.yang_parent_name = "state"

                                self.priority = YLeaf(YType.uint8, "priority")

                                self.available_bandwidth = YLeaf(YType.uint64, "available-bandwidth")

                                self.reserved_bandwidth = YLeaf(YType.uint64, "reserved-bandwidth")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("priority",
                                                "available_bandwidth",
                                                "reserved_bandwidth") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Bandwidth, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Bandwidth, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.priority.is_set or
                                    self.available_bandwidth.is_set or
                                    self.reserved_bandwidth.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.available_bandwidth.yfilter != YFilter.not_set or
                                    self.reserved_bandwidth.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bandwidth" + "[priority='" + self.priority.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.available_bandwidth.is_set or self.available_bandwidth.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.available_bandwidth.get_name_leafdata())
                                if (self.reserved_bandwidth.is_set or self.reserved_bandwidth.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reserved_bandwidth.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority" or name == "available-bandwidth" or name == "reserved-bandwidth"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "available-bandwidth"):
                                    self.available_bandwidth = value
                                    self.available_bandwidth.value_namespace = name_space
                                    self.available_bandwidth.value_namespace_prefix = name_space_prefix
                                if(value_path == "reserved-bandwidth"):
                                    self.reserved_bandwidth = value
                                    self.reserved_bandwidth.value_namespace = name_space
                                    self.reserved_bandwidth.value_namespace_prefix = name_space_prefix


                        class Counters(Entity):
                            """
                            Interface specific RSVP statistics and counters
                            
                            .. attribute:: in_ack_messages
                            
                            	Number of received RSVP refresh reduction ack messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_hello_messages
                            
                            	Number of received RSVP hello messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_path_error_messages
                            
                            	Number of received RSVP Path Error messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_path_messages
                            
                            	Number of received RSVP Path messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_path_tear_messages
                            
                            	Number of received RSVP Path Tear messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_reservation_error_messages
                            
                            	Number of received RSVP Resv Error messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_reservation_messages
                            
                            	Number of received RSVP Resv messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_reservation_tear_messages
                            
                            	Number of received RSVP Resv Tear messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: in_srefresh_messages
                            
                            	Number of received RSVP summary refresh messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_ack_messages
                            
                            	Number of sent RSVP refresh reduction ack messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_hello_messages
                            
                            	Number of sent RSVP hello messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_path_error_messages
                            
                            	Number of sent RSVP Path Error messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_path_messages
                            
                            	Number of sent RSVP PATH messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_path_tear_messages
                            
                            	Number of sent RSVP Path Tear messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_reservation_error_messages
                            
                            	Number of sent RSVP Resv Error messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_reservation_messages
                            
                            	Number of sent RSVP Resv messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_reservation_tear_messages
                            
                            	Number of sent RSVP Resv Tear messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: out_srefresh_messages
                            
                            	Number of sent RSVP summary refresh messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Counters, self).__init__()

                                self.yang_name = "counters"
                                self.yang_parent_name = "state"

                                self.in_ack_messages = YLeaf(YType.uint64, "in-ack-messages")

                                self.in_hello_messages = YLeaf(YType.uint64, "in-hello-messages")

                                self.in_path_error_messages = YLeaf(YType.uint64, "in-path-error-messages")

                                self.in_path_messages = YLeaf(YType.uint64, "in-path-messages")

                                self.in_path_tear_messages = YLeaf(YType.uint64, "in-path-tear-messages")

                                self.in_reservation_error_messages = YLeaf(YType.uint64, "in-reservation-error-messages")

                                self.in_reservation_messages = YLeaf(YType.uint64, "in-reservation-messages")

                                self.in_reservation_tear_messages = YLeaf(YType.uint64, "in-reservation-tear-messages")

                                self.in_srefresh_messages = YLeaf(YType.uint64, "in-srefresh-messages")

                                self.out_ack_messages = YLeaf(YType.uint64, "out-ack-messages")

                                self.out_hello_messages = YLeaf(YType.uint64, "out-hello-messages")

                                self.out_path_error_messages = YLeaf(YType.uint64, "out-path-error-messages")

                                self.out_path_messages = YLeaf(YType.uint64, "out-path-messages")

                                self.out_path_tear_messages = YLeaf(YType.uint64, "out-path-tear-messages")

                                self.out_reservation_error_messages = YLeaf(YType.uint64, "out-reservation-error-messages")

                                self.out_reservation_messages = YLeaf(YType.uint64, "out-reservation-messages")

                                self.out_reservation_tear_messages = YLeaf(YType.uint64, "out-reservation-tear-messages")

                                self.out_srefresh_messages = YLeaf(YType.uint64, "out-srefresh-messages")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("in_ack_messages",
                                                "in_hello_messages",
                                                "in_path_error_messages",
                                                "in_path_messages",
                                                "in_path_tear_messages",
                                                "in_reservation_error_messages",
                                                "in_reservation_messages",
                                                "in_reservation_tear_messages",
                                                "in_srefresh_messages",
                                                "out_ack_messages",
                                                "out_hello_messages",
                                                "out_path_error_messages",
                                                "out_path_messages",
                                                "out_path_tear_messages",
                                                "out_reservation_error_messages",
                                                "out_reservation_messages",
                                                "out_reservation_tear_messages",
                                                "out_srefresh_messages") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Counters, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Counters, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.in_ack_messages.is_set or
                                    self.in_hello_messages.is_set or
                                    self.in_path_error_messages.is_set or
                                    self.in_path_messages.is_set or
                                    self.in_path_tear_messages.is_set or
                                    self.in_reservation_error_messages.is_set or
                                    self.in_reservation_messages.is_set or
                                    self.in_reservation_tear_messages.is_set or
                                    self.in_srefresh_messages.is_set or
                                    self.out_ack_messages.is_set or
                                    self.out_hello_messages.is_set or
                                    self.out_path_error_messages.is_set or
                                    self.out_path_messages.is_set or
                                    self.out_path_tear_messages.is_set or
                                    self.out_reservation_error_messages.is_set or
                                    self.out_reservation_messages.is_set or
                                    self.out_reservation_tear_messages.is_set or
                                    self.out_srefresh_messages.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.in_ack_messages.yfilter != YFilter.not_set or
                                    self.in_hello_messages.yfilter != YFilter.not_set or
                                    self.in_path_error_messages.yfilter != YFilter.not_set or
                                    self.in_path_messages.yfilter != YFilter.not_set or
                                    self.in_path_tear_messages.yfilter != YFilter.not_set or
                                    self.in_reservation_error_messages.yfilter != YFilter.not_set or
                                    self.in_reservation_messages.yfilter != YFilter.not_set or
                                    self.in_reservation_tear_messages.yfilter != YFilter.not_set or
                                    self.in_srefresh_messages.yfilter != YFilter.not_set or
                                    self.out_ack_messages.yfilter != YFilter.not_set or
                                    self.out_hello_messages.yfilter != YFilter.not_set or
                                    self.out_path_error_messages.yfilter != YFilter.not_set or
                                    self.out_path_messages.yfilter != YFilter.not_set or
                                    self.out_path_tear_messages.yfilter != YFilter.not_set or
                                    self.out_reservation_error_messages.yfilter != YFilter.not_set or
                                    self.out_reservation_messages.yfilter != YFilter.not_set or
                                    self.out_reservation_tear_messages.yfilter != YFilter.not_set or
                                    self.out_srefresh_messages.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "counters" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.in_ack_messages.is_set or self.in_ack_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_ack_messages.get_name_leafdata())
                                if (self.in_hello_messages.is_set or self.in_hello_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_hello_messages.get_name_leafdata())
                                if (self.in_path_error_messages.is_set or self.in_path_error_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_path_error_messages.get_name_leafdata())
                                if (self.in_path_messages.is_set or self.in_path_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_path_messages.get_name_leafdata())
                                if (self.in_path_tear_messages.is_set or self.in_path_tear_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_path_tear_messages.get_name_leafdata())
                                if (self.in_reservation_error_messages.is_set or self.in_reservation_error_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_reservation_error_messages.get_name_leafdata())
                                if (self.in_reservation_messages.is_set or self.in_reservation_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_reservation_messages.get_name_leafdata())
                                if (self.in_reservation_tear_messages.is_set or self.in_reservation_tear_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_reservation_tear_messages.get_name_leafdata())
                                if (self.in_srefresh_messages.is_set or self.in_srefresh_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_srefresh_messages.get_name_leafdata())
                                if (self.out_ack_messages.is_set or self.out_ack_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_ack_messages.get_name_leafdata())
                                if (self.out_hello_messages.is_set or self.out_hello_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_hello_messages.get_name_leafdata())
                                if (self.out_path_error_messages.is_set or self.out_path_error_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_path_error_messages.get_name_leafdata())
                                if (self.out_path_messages.is_set or self.out_path_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_path_messages.get_name_leafdata())
                                if (self.out_path_tear_messages.is_set or self.out_path_tear_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_path_tear_messages.get_name_leafdata())
                                if (self.out_reservation_error_messages.is_set or self.out_reservation_error_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_reservation_error_messages.get_name_leafdata())
                                if (self.out_reservation_messages.is_set or self.out_reservation_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_reservation_messages.get_name_leafdata())
                                if (self.out_reservation_tear_messages.is_set or self.out_reservation_tear_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_reservation_tear_messages.get_name_leafdata())
                                if (self.out_srefresh_messages.is_set or self.out_srefresh_messages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_srefresh_messages.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "in-ack-messages" or name == "in-hello-messages" or name == "in-path-error-messages" or name == "in-path-messages" or name == "in-path-tear-messages" or name == "in-reservation-error-messages" or name == "in-reservation-messages" or name == "in-reservation-tear-messages" or name == "in-srefresh-messages" or name == "out-ack-messages" or name == "out-hello-messages" or name == "out-path-error-messages" or name == "out-path-messages" or name == "out-path-tear-messages" or name == "out-reservation-error-messages" or name == "out-reservation-messages" or name == "out-reservation-tear-messages" or name == "out-srefresh-messages"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "in-ack-messages"):
                                    self.in_ack_messages = value
                                    self.in_ack_messages.value_namespace = name_space
                                    self.in_ack_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-hello-messages"):
                                    self.in_hello_messages = value
                                    self.in_hello_messages.value_namespace = name_space
                                    self.in_hello_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-path-error-messages"):
                                    self.in_path_error_messages = value
                                    self.in_path_error_messages.value_namespace = name_space
                                    self.in_path_error_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-path-messages"):
                                    self.in_path_messages = value
                                    self.in_path_messages.value_namespace = name_space
                                    self.in_path_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-path-tear-messages"):
                                    self.in_path_tear_messages = value
                                    self.in_path_tear_messages.value_namespace = name_space
                                    self.in_path_tear_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-reservation-error-messages"):
                                    self.in_reservation_error_messages = value
                                    self.in_reservation_error_messages.value_namespace = name_space
                                    self.in_reservation_error_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-reservation-messages"):
                                    self.in_reservation_messages = value
                                    self.in_reservation_messages.value_namespace = name_space
                                    self.in_reservation_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-reservation-tear-messages"):
                                    self.in_reservation_tear_messages = value
                                    self.in_reservation_tear_messages.value_namespace = name_space
                                    self.in_reservation_tear_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "in-srefresh-messages"):
                                    self.in_srefresh_messages = value
                                    self.in_srefresh_messages.value_namespace = name_space
                                    self.in_srefresh_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-ack-messages"):
                                    self.out_ack_messages = value
                                    self.out_ack_messages.value_namespace = name_space
                                    self.out_ack_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-hello-messages"):
                                    self.out_hello_messages = value
                                    self.out_hello_messages.value_namespace = name_space
                                    self.out_hello_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-path-error-messages"):
                                    self.out_path_error_messages = value
                                    self.out_path_error_messages.value_namespace = name_space
                                    self.out_path_error_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-path-messages"):
                                    self.out_path_messages = value
                                    self.out_path_messages.value_namespace = name_space
                                    self.out_path_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-path-tear-messages"):
                                    self.out_path_tear_messages = value
                                    self.out_path_tear_messages.value_namespace = name_space
                                    self.out_path_tear_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-reservation-error-messages"):
                                    self.out_reservation_error_messages = value
                                    self.out_reservation_error_messages.value_namespace = name_space
                                    self.out_reservation_error_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-reservation-messages"):
                                    self.out_reservation_messages = value
                                    self.out_reservation_messages.value_namespace = name_space
                                    self.out_reservation_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-reservation-tear-messages"):
                                    self.out_reservation_tear_messages = value
                                    self.out_reservation_tear_messages.value_namespace = name_space
                                    self.out_reservation_tear_messages.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-srefresh-messages"):
                                    self.out_srefresh_messages = value
                                    self.out_srefresh_messages.value_namespace = name_space
                                    self.out_srefresh_messages.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.bandwidth:
                                if (c.has_data()):
                                    return True
                            return (
                                self.active_reservation_count.is_set or
                                self.highwater_mark.is_set or
                                (self.counters is not None and self.counters.has_data()))

                        def has_operation(self):
                            for c in self.bandwidth:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.active_reservation_count.yfilter != YFilter.not_set or
                                self.highwater_mark.yfilter != YFilter.not_set or
                                (self.counters is not None and self.counters.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.active_reservation_count.is_set or self.active_reservation_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.active_reservation_count.get_name_leafdata())
                            if (self.highwater_mark.is_set or self.highwater_mark.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.highwater_mark.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bandwidth"):
                                for c in self.bandwidth:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Bandwidth()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.bandwidth.append(c)
                                return c

                            if (child_yang_name == "counters"):
                                if (self.counters is None):
                                    self.counters = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State.Counters()
                                    self.counters.parent = self
                                    self._children_name_map["counters"] = "counters"
                                return self.counters

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth" or name == "counters" or name == "active-reservation-count" or name == "highwater-mark"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "active-reservation-count"):
                                self.active_reservation_count = value
                                self.active_reservation_count.value_namespace = name_space
                                self.active_reservation_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "highwater-mark"):
                                self.highwater_mark = value
                                self.highwater_mark.value_namespace = name_space
                                self.highwater_mark.value_namespace_prefix = name_space_prefix


                    class Hellos(Entity):
                        """
                        Top level container for RSVP hello parameters
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to RSVP hellos
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.Config>`
                        
                        .. attribute:: state
                        
                        	State information associated with RSVP hellos
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos, self).__init__()

                            self.yang_name = "hellos"
                            self.yang_parent_name = "interface"

                            self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to RSVP
                            hellos
                            
                            .. attribute:: hello_interval
                            
                            	set the interval in ms between RSVP hello messages
                            	**type**\:  int
                            
                            	**range:** 1000..60000
                            
                            	**units**\: milliseconds
                            
                            	**default value**\: 9000
                            
                            .. attribute:: refresh_reduction
                            
                            	enables all RSVP refresh reduction message bundling, RSVP message ID, reliable message delivery and summary refresh
                            	**type**\:  bool
                            
                            	**default value**\: true
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "hellos"

                                self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                                self.refresh_reduction = YLeaf(YType.boolean, "refresh-reduction")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("hello_interval",
                                                "refresh_reduction") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.hello_interval.is_set or
                                    self.refresh_reduction.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.hello_interval.yfilter != YFilter.not_set or
                                    self.refresh_reduction.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                if (self.refresh_reduction.is_set or self.refresh_reduction.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.refresh_reduction.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "hello-interval" or name == "refresh-reduction"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "hello-interval"):
                                    self.hello_interval = value
                                    self.hello_interval.value_namespace = name_space
                                    self.hello_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "refresh-reduction"):
                                    self.refresh_reduction = value
                                    self.refresh_reduction.value_namespace = name_space
                                    self.refresh_reduction.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information associated with RSVP hellos
                            
                            .. attribute:: hello_interval
                            
                            	set the interval in ms between RSVP hello messages
                            	**type**\:  int
                            
                            	**range:** 1000..60000
                            
                            	**units**\: milliseconds
                            
                            	**default value**\: 9000
                            
                            .. attribute:: refresh_reduction
                            
                            	enables all RSVP refresh reduction message bundling, RSVP message ID, reliable message delivery and summary refresh
                            	**type**\:  bool
                            
                            	**default value**\: true
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "hellos"

                                self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                                self.refresh_reduction = YLeaf(YType.boolean, "refresh-reduction")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("hello_interval",
                                                "refresh_reduction") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.hello_interval.is_set or
                                    self.refresh_reduction.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.hello_interval.yfilter != YFilter.not_set or
                                    self.refresh_reduction.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                if (self.refresh_reduction.is_set or self.refresh_reduction.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.refresh_reduction.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "hello-interval" or name == "refresh-reduction"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "hello-interval"):
                                    self.hello_interval = value
                                    self.hello_interval.value_namespace = name_space
                                    self.hello_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "refresh-reduction"):
                                    self.refresh_reduction = value
                                    self.refresh_reduction.value_namespace = name_space
                                    self.refresh_reduction.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "hellos" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Authentication(Entity):
                        """
                        Configuration and state parameters relating to RSVP
                        authentication as per RFC2747
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to authentication
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.Config>`
                        
                        .. attribute:: state
                        
                        	State information associated with authentication
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication, self).__init__()

                            self.yang_name = "authentication"
                            self.yang_parent_name = "interface"

                            self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating
                            to authentication
                            
                            .. attribute:: authentication_key
                            
                            	authenticate RSVP signaling messages
                            	**type**\:  str
                            
                            	**length:** 1..32
                            
                            .. attribute:: enable
                            
                            	Enables RSVP authentication on the node
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "authentication"

                                self.authentication_key = YLeaf(YType.str, "authentication-key")

                                self.enable = YLeaf(YType.boolean, "enable")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("authentication_key",
                                                "enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.authentication_key.is_set or
                                    self.enable.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.authentication_key.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.authentication_key.is_set or self.authentication_key.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.authentication_key.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "authentication-key" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "authentication-key"):
                                    self.authentication_key = value
                                    self.authentication_key.value_namespace = name_space
                                    self.authentication_key.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State information associated
                            with authentication
                            
                            .. attribute:: authentication_key
                            
                            	authenticate RSVP signaling messages
                            	**type**\:  str
                            
                            	**length:** 1..32
                            
                            .. attribute:: enable
                            
                            	Enables RSVP authentication on the node
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "authentication"

                                self.authentication_key = YLeaf(YType.str, "authentication-key")

                                self.enable = YLeaf(YType.boolean, "enable")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("authentication_key",
                                                "enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.authentication_key.is_set or
                                    self.enable.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.authentication_key.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.authentication_key.is_set or self.authentication_key.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.authentication_key.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "authentication-key" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "authentication-key"):
                                    self.authentication_key = value
                                    self.authentication_key.value_namespace = name_space
                                    self.authentication_key.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "authentication" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Subscription(Entity):
                        """
                        Bandwidth percentage reservable by RSVP
                        on an interface
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to RSVP subscription options
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.Config>`
                        
                        .. attribute:: state
                        
                        	State parameters relating to RSVP subscription options
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription, self).__init__()

                            self.yang_name = "subscription"
                            self.yang_parent_name = "interface"

                            self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration parameters relating to RSVP
                            subscription options
                            
                            .. attribute:: subscription
                            
                            	percentage of the interface bandwidth that RSVP can reserve
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "subscription"

                                self.subscription = YLeaf(YType.uint8, "subscription")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("subscription") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return self.subscription.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.subscription.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.subscription.is_set or self.subscription.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subscription.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "subscription"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "subscription"):
                                    self.subscription = value
                                    self.subscription.value_namespace = name_space
                                    self.subscription.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State parameters relating to RSVP
                            subscription options
                            
                            .. attribute:: subscription
                            
                            	percentage of the interface bandwidth that RSVP can reserve
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "subscription"

                                self.subscription = YLeaf(YType.uint8, "subscription")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("subscription") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.State, self).__setattr__(name, value)

                            def has_data(self):
                                return self.subscription.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.subscription.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.subscription.is_set or self.subscription.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.subscription.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "subscription"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "subscription"):
                                    self.subscription = value
                                    self.subscription.value_namespace = name_space
                                    self.subscription.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "subscription" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Protection(Entity):
                        """
                        link\-protection (NHOP) related configuration
                        
                        .. attribute:: config
                        
                        	Configuration for link\-protection
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.Config>`
                        
                        .. attribute:: state
                        
                        	State for link\-protection
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection, self).__init__()

                            self.yang_name = "protection"
                            self.yang_parent_name = "interface"

                            self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")


                        class Config(Entity):
                            """
                            Configuration for link\-protection
                            
                            .. attribute:: bypass_optimize_interval
                            
                            	interval between periodic optimization of the bypass LSPs
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            	**units**\: seconds
                            
                            .. attribute:: link_protection_style_requested
                            
                            	Style of mpls frr protection desired\: link, link\-node, or unprotected
                            	**type**\:   :py:class:`ProtectionType <ydk.models.openconfig.openconfig_mpls_types.ProtectionType>`
                            
                            	**default value**\: mplst:link-node-protection-requested
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "protection"

                                self.bypass_optimize_interval = YLeaf(YType.uint16, "bypass-optimize-interval")

                                self.link_protection_style_requested = YLeaf(YType.identityref, "link-protection-style-requested")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bypass_optimize_interval",
                                                "link_protection_style_requested") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bypass_optimize_interval.is_set or
                                    self.link_protection_style_requested.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bypass_optimize_interval.yfilter != YFilter.not_set or
                                    self.link_protection_style_requested.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bypass_optimize_interval.is_set or self.bypass_optimize_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bypass_optimize_interval.get_name_leafdata())
                                if (self.link_protection_style_requested.is_set or self.link_protection_style_requested.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.link_protection_style_requested.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bypass-optimize-interval" or name == "link-protection-style-requested"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bypass-optimize-interval"):
                                    self.bypass_optimize_interval = value
                                    self.bypass_optimize_interval.value_namespace = name_space
                                    self.bypass_optimize_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "link-protection-style-requested"):
                                    self.link_protection_style_requested = value
                                    self.link_protection_style_requested.value_namespace = name_space
                                    self.link_protection_style_requested.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State for link\-protection
                            
                            .. attribute:: bypass_optimize_interval
                            
                            	interval between periodic optimization of the bypass LSPs
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            	**units**\: seconds
                            
                            .. attribute:: link_protection_style_requested
                            
                            	Style of mpls frr protection desired\: link, link\-node, or unprotected
                            	**type**\:   :py:class:`ProtectionType <ydk.models.openconfig.openconfig_mpls_types.ProtectionType>`
                            
                            	**default value**\: mplst:link-node-protection-requested
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "protection"

                                self.bypass_optimize_interval = YLeaf(YType.uint16, "bypass-optimize-interval")

                                self.link_protection_style_requested = YLeaf(YType.identityref, "link-protection-style-requested")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bypass_optimize_interval",
                                                "link_protection_style_requested") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bypass_optimize_interval.is_set or
                                    self.link_protection_style_requested.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bypass_optimize_interval.yfilter != YFilter.not_set or
                                    self.link_protection_style_requested.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bypass_optimize_interval.is_set or self.bypass_optimize_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bypass_optimize_interval.get_name_leafdata())
                                if (self.link_protection_style_requested.is_set or self.link_protection_style_requested.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.link_protection_style_requested.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bypass-optimize-interval" or name == "link-protection-style-requested"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bypass-optimize-interval"):
                                    self.bypass_optimize_interval = value
                                    self.bypass_optimize_interval.value_namespace = name_space
                                    self.bypass_optimize_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "link-protection-style-requested"):
                                    self.link_protection_style_requested = value
                                    self.link_protection_style_requested.value_namespace = name_space
                                    self.link_protection_style_requested.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "protection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "state"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.interface_name.is_set or
                            (self.authentication is not None and self.authentication.has_data()) or
                            (self.config is not None and self.config.has_data()) or
                            (self.hellos is not None and self.hellos.has_data()) or
                            (self.protection is not None and self.protection.has_data()) or
                            (self.state is not None and self.state.has_data()) or
                            (self.subscription is not None and self.subscription.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            (self.authentication is not None and self.authentication.has_operation()) or
                            (self.config is not None and self.config.has_operation()) or
                            (self.hellos is not None and self.hellos.has_operation()) or
                            (self.protection is not None and self.protection.has_operation()) or
                            (self.state is not None and self.state.has_operation()) or
                            (self.subscription is not None and self.subscription.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/interface-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "authentication"):
                            if (self.authentication is None):
                                self.authentication = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Authentication()
                                self.authentication.parent = self
                                self._children_name_map["authentication"] = "authentication"
                            return self.authentication

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "hellos"):
                            if (self.hellos is None):
                                self.hellos = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Hellos()
                                self.hellos.parent = self
                                self._children_name_map["hellos"] = "hellos"
                            return self.hellos

                        if (child_yang_name == "protection"):
                            if (self.protection is None):
                                self.protection = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Protection()
                                self.protection.parent = self
                                self._children_name_map["protection"] = "protection"
                            return self.protection

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        if (child_yang_name == "subscription"):
                            if (self.subscription is None):
                                self.subscription = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface.Subscription()
                                self.subscription.parent = self
                                self._children_name_map["subscription"] = "subscription"
                            return self.subscription

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication" or name == "config" or name == "hellos" or name == "protection" or name == "state" or name == "subscription" or name == "interface-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.interface:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.interface:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/rsvp-te/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "interface"):
                        for c in self.interface:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes.Interface()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.interface.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.global_ is not None and self.global_.has_data()) or
                    (self.interface_attributes is not None and self.interface_attributes.has_data()) or
                    (self.neighbors is not None and self.neighbors.has_data()) or
                    (self.sessions is not None and self.sessions.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.global_ is not None and self.global_.has_operation()) or
                    (self.interface_attributes is not None and self.interface_attributes.has_operation()) or
                    (self.neighbors is not None and self.neighbors.has_operation()) or
                    (self.sessions is not None and self.sessions.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "rsvp-te" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/signaling-protocols/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "global"):
                    if (self.global_ is None):
                        self.global_ = Mpls.SignalingProtocols.RsvpTe.Global_()
                        self.global_.parent = self
                        self._children_name_map["global_"] = "global"
                    return self.global_

                if (child_yang_name == "interface-attributes"):
                    if (self.interface_attributes is None):
                        self.interface_attributes = Mpls.SignalingProtocols.RsvpTe.InterfaceAttributes()
                        self.interface_attributes.parent = self
                        self._children_name_map["interface_attributes"] = "interface-attributes"
                    return self.interface_attributes

                if (child_yang_name == "neighbors"):
                    if (self.neighbors is None):
                        self.neighbors = Mpls.SignalingProtocols.RsvpTe.Neighbors()
                        self.neighbors.parent = self
                        self._children_name_map["neighbors"] = "neighbors"
                    return self.neighbors

                if (child_yang_name == "sessions"):
                    if (self.sessions is None):
                        self.sessions = Mpls.SignalingProtocols.RsvpTe.Sessions()
                        self.sessions.parent = self
                        self._children_name_map["sessions"] = "sessions"
                    return self.sessions

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "global" or name == "interface-attributes" or name == "neighbors" or name == "sessions"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class SegmentRouting(Entity):
            """
            SR global signaling config
            
            .. attribute:: interfaces
            
            	List of interfaces with associated segment routing configuration
            	**type**\: list of    :py:class:`Interfaces <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces>`
            
            .. attribute:: srgb
            
            	List of Segment Routing Global Block (SRGB) entries. These label blocks are reserved to be allocated as domain\-wide entries
            	**type**\: list of    :py:class:`Srgb <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Srgb>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.SignalingProtocols.SegmentRouting, self).__init__()

                self.yang_name = "segment-routing"
                self.yang_parent_name = "signaling-protocols"

                self.interfaces = YList(self)
                self.srgb = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.SignalingProtocols.SegmentRouting, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.SignalingProtocols.SegmentRouting, self).__setattr__(name, value)


            class Srgb(Entity):
                """
                List of Segment Routing Global Block (SRGB) entries. These
                label blocks are reserved to be allocated as domain\-wide
                entries.
                
                .. attribute:: lower_bound  <key>
                
                	Lower value in the block
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: upper_bound  <key>
                
                	Upper value in the block
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: config
                
                	Configuration parameters relating to the Segment Routing Global Block (SRGB)
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Srgb.Config>`
                
                .. attribute:: state
                
                	State parameters relating to the Segment Routing Global Block (SRGB)
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Srgb.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.SegmentRouting.Srgb, self).__init__()

                    self.yang_name = "srgb"
                    self.yang_parent_name = "segment-routing"

                    self.lower_bound = YLeaf(YType.uint32, "lower-bound")

                    self.upper_bound = YLeaf(YType.uint32, "upper-bound")

                    self.config = Mpls.SignalingProtocols.SegmentRouting.Srgb.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.SignalingProtocols.SegmentRouting.Srgb.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lower_bound",
                                    "upper_bound") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.SignalingProtocols.SegmentRouting.Srgb, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.SignalingProtocols.SegmentRouting.Srgb, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configuration parameters relating to the Segment Routing
                    Global Block (SRGB)
                    
                    .. attribute:: lower_bound
                    
                    	Lower value in the block
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: upper_bound
                    
                    	Upper value in the block
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.SegmentRouting.Srgb.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "srgb"

                        self.lower_bound = YLeaf(YType.uint32, "lower-bound")

                        self.upper_bound = YLeaf(YType.uint32, "upper-bound")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("lower_bound",
                                        "upper_bound") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.SegmentRouting.Srgb.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.SegmentRouting.Srgb.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.lower_bound.is_set or
                            self.upper_bound.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.lower_bound.yfilter != YFilter.not_set or
                            self.upper_bound.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.lower_bound.is_set or self.lower_bound.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lower_bound.get_name_leafdata())
                        if (self.upper_bound.is_set or self.upper_bound.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.upper_bound.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "lower-bound" or name == "upper-bound"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "lower-bound"):
                            self.lower_bound = value
                            self.lower_bound.value_namespace = name_space
                            self.lower_bound.value_namespace_prefix = name_space_prefix
                        if(value_path == "upper-bound"):
                            self.upper_bound = value
                            self.upper_bound.value_namespace = name_space
                            self.upper_bound.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters relating to the Segment Routing Global
                    Block (SRGB)
                    
                    .. attribute:: free
                    
                    	Number of SRGB indexes that have not yet been allocated
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: lower_bound
                    
                    	Lower value in the block
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: size
                    
                    	Number of indexes in the SRGB block
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: upper_bound
                    
                    	Upper value in the block
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: used
                    
                    	Number of SRGB indexes that are currently allocated
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.SegmentRouting.Srgb.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "srgb"

                        self.free = YLeaf(YType.uint32, "free")

                        self.lower_bound = YLeaf(YType.uint32, "lower-bound")

                        self.size = YLeaf(YType.uint32, "size")

                        self.upper_bound = YLeaf(YType.uint32, "upper-bound")

                        self.used = YLeaf(YType.uint32, "used")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("free",
                                        "lower_bound",
                                        "size",
                                        "upper_bound",
                                        "used") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.SegmentRouting.Srgb.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.SegmentRouting.Srgb.State, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.free.is_set or
                            self.lower_bound.is_set or
                            self.size.is_set or
                            self.upper_bound.is_set or
                            self.used.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.free.yfilter != YFilter.not_set or
                            self.lower_bound.yfilter != YFilter.not_set or
                            self.size.yfilter != YFilter.not_set or
                            self.upper_bound.yfilter != YFilter.not_set or
                            self.used.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.free.is_set or self.free.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.free.get_name_leafdata())
                        if (self.lower_bound.is_set or self.lower_bound.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lower_bound.get_name_leafdata())
                        if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.size.get_name_leafdata())
                        if (self.upper_bound.is_set or self.upper_bound.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.upper_bound.get_name_leafdata())
                        if (self.used.is_set or self.used.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.used.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "free" or name == "lower-bound" or name == "size" or name == "upper-bound" or name == "used"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "free"):
                            self.free = value
                            self.free.value_namespace = name_space
                            self.free.value_namespace_prefix = name_space_prefix
                        if(value_path == "lower-bound"):
                            self.lower_bound = value
                            self.lower_bound.value_namespace = name_space
                            self.lower_bound.value_namespace_prefix = name_space_prefix
                        if(value_path == "size"):
                            self.size = value
                            self.size.value_namespace = name_space
                            self.size.value_namespace_prefix = name_space_prefix
                        if(value_path == "upper-bound"):
                            self.upper_bound = value
                            self.upper_bound.value_namespace = name_space
                            self.upper_bound.value_namespace_prefix = name_space_prefix
                        if(value_path == "used"):
                            self.used = value
                            self.used.value_namespace = name_space
                            self.used.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lower_bound.is_set or
                        self.upper_bound.is_set or
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lower_bound.yfilter != YFilter.not_set or
                        self.upper_bound.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "srgb" + "[lower-bound='" + self.lower_bound.get() + "']" + "[upper-bound='" + self.upper_bound.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/segment-routing/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lower_bound.is_set or self.lower_bound.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lower_bound.get_name_leafdata())
                    if (self.upper_bound.is_set or self.upper_bound.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.upper_bound.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.SignalingProtocols.SegmentRouting.Srgb.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.SignalingProtocols.SegmentRouting.Srgb.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "state" or name == "lower-bound" or name == "upper-bound"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lower-bound"):
                        self.lower_bound = value
                        self.lower_bound.value_namespace = name_space
                        self.lower_bound.value_namespace_prefix = name_space_prefix
                    if(value_path == "upper-bound"):
                        self.upper_bound = value
                        self.upper_bound.value_namespace = name_space
                        self.upper_bound.value_namespace_prefix = name_space_prefix


            class Interfaces(Entity):
                """
                List of interfaces with associated segment routing
                configuration
                
                .. attribute:: interface  <key>
                
                	Reference to the interface for which segment routing configuration is to be applied
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                
                .. attribute:: adjacency_sid
                
                	Configuration for Adjacency SIDs that are related to the specified interface
                	**type**\:   :py:class:`AdjacencySid <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid>`
                
                .. attribute:: config
                
                	Interface configuration parameters for Segment Routing relating to the specified interface
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.Config>`
                
                .. attribute:: state
                
                	State parameters for Segment Routing features relating to the specified interface
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.SegmentRouting.Interfaces, self).__init__()

                    self.yang_name = "interfaces"
                    self.yang_parent_name = "segment-routing"

                    self.interface = YLeaf(YType.str, "interface")

                    self.adjacency_sid = Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid()
                    self.adjacency_sid.parent = self
                    self._children_name_map["adjacency_sid"] = "adjacency-sid"
                    self._children_yang_names.add("adjacency-sid")

                    self.config = Mpls.SignalingProtocols.SegmentRouting.Interfaces.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.SignalingProtocols.SegmentRouting.Interfaces.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.SignalingProtocols.SegmentRouting.Interfaces, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.SignalingProtocols.SegmentRouting.Interfaces, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Interface configuration parameters for Segment Routing
                    relating to the specified interface
                    
                    .. attribute:: interface
                    
                    	Reference to the interface for which segment routing configuration is to be applied
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "interfaces"

                        self.interface = YLeaf(YType.str, "interface")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.interface.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters for Segment Routing features relating
                    to the specified interface
                    
                    .. attribute:: interface
                    
                    	Reference to the interface for which segment routing configuration is to be applied
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_interfaces.Interfaces.Interface>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "interfaces"

                        self.interface = YLeaf(YType.str, "interface")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.interface.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix


                class AdjacencySid(Entity):
                    """
                    Configuration for Adjacency SIDs that are related to
                    the specified interface
                    
                    .. attribute:: config
                    
                    	Configuration parameters for the Adjacency\-SIDs that are related to this interface
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config>`
                    
                    .. attribute:: state
                    
                    	State parameters for the Adjacency\-SIDs that are related to this interface
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid, self).__init__()

                        self.yang_name = "adjacency-sid"
                        self.yang_parent_name = "interfaces"

                        self.config = Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters for the Adjacency\-SIDs
                        that are related to this interface
                        
                        .. attribute:: advertise
                        
                        	Specifies the type of adjacency SID which should be advertised for the specified entity
                        	**type**\:  list of   :py:class:`Advertise <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config.Advertise>`
                        
                        .. attribute:: groups
                        
                        	Specifies the groups to which this interface belongs. Setting a value in this list results in an additional AdjSID being advertised, with the S\-bit set to 1. The AdjSID is assumed to be protected
                        	**type**\:  list of int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "adjacency-sid"

                            self.advertise = YLeafList(YType.enumeration, "advertise")

                            self.groups = YLeafList(YType.uint32, "groups")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("advertise",
                                            "groups") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config, self).__setattr__(name, value)

                        class Advertise(Enum):
                            """
                            Advertise

                            Specifies the type of adjacency SID which should be

                            advertised for the specified entity.

                            .. data:: PROTECTED = 0

                            	Advertise an Adjacency-SID for this interface, which is

                            	eligible to be protected using a local protection

                            	mechanism on the local LSR. The local protection

                            	mechanism selected is dependent upon the configuration

                            	of RSVP-TE FRR or LFA elsewhere on the system

                            .. data:: UNPROTECTED = 1

                            	Advertise an Adajcency-SID for this interface, which is

                            	explicitly excluded from being protected by any local

                            	protection mechanism

                            """

                            PROTECTED = Enum.YLeaf(0, "PROTECTED")

                            UNPROTECTED = Enum.YLeaf(1, "UNPROTECTED")


                        def has_data(self):
                            for leaf in self.advertise.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.groups.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return False

                        def has_operation(self):
                            for leaf in self.advertise.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.groups.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.advertise.yfilter != YFilter.not_set or
                                self.groups.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            leaf_name_data.extend(self.advertise.get_name_leafdata())

                            leaf_name_data.extend(self.groups.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "advertise" or name == "groups"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "advertise"):
                                self.advertise.append(value)
                            if(value_path == "groups"):
                                self.groups.append(value)


                    class State(Entity):
                        """
                        State parameters for the Adjacency\-SIDs that are
                        related to this interface
                        
                        .. attribute:: advertise
                        
                        	Specifies the type of adjacency SID which should be advertised for the specified entity
                        	**type**\:  list of   :py:class:`Advertise <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State.Advertise>`
                        
                        .. attribute:: groups
                        
                        	Specifies the groups to which this interface belongs. Setting a value in this list results in an additional AdjSID being advertised, with the S\-bit set to 1. The AdjSID is assumed to be protected
                        	**type**\:  list of int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "adjacency-sid"

                            self.advertise = YLeafList(YType.enumeration, "advertise")

                            self.groups = YLeafList(YType.uint32, "groups")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("advertise",
                                            "groups") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State, self).__setattr__(name, value)

                        class Advertise(Enum):
                            """
                            Advertise

                            Specifies the type of adjacency SID which should be

                            advertised for the specified entity.

                            .. data:: PROTECTED = 0

                            	Advertise an Adjacency-SID for this interface, which is

                            	eligible to be protected using a local protection

                            	mechanism on the local LSR. The local protection

                            	mechanism selected is dependent upon the configuration

                            	of RSVP-TE FRR or LFA elsewhere on the system

                            .. data:: UNPROTECTED = 1

                            	Advertise an Adajcency-SID for this interface, which is

                            	explicitly excluded from being protected by any local

                            	protection mechanism

                            """

                            PROTECTED = Enum.YLeaf(0, "PROTECTED")

                            UNPROTECTED = Enum.YLeaf(1, "UNPROTECTED")


                        def has_data(self):
                            for leaf in self.advertise.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            for leaf in self.groups.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return False

                        def has_operation(self):
                            for leaf in self.advertise.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            for leaf in self.groups.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.advertise.yfilter != YFilter.not_set or
                                self.groups.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            leaf_name_data.extend(self.advertise.get_name_leafdata())

                            leaf_name_data.extend(self.groups.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "advertise" or name == "groups"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "advertise"):
                                self.advertise.append(value)
                            if(value_path == "groups"):
                                self.groups.append(value)

                    def has_data(self):
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "adjacency-sid" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.interface.is_set or
                        (self.adjacency_sid is not None and self.adjacency_sid.has_data()) or
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        (self.adjacency_sid is not None and self.adjacency_sid.has_operation()) or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interfaces" + "[interface='" + self.interface.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/segment-routing/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "adjacency-sid"):
                        if (self.adjacency_sid is None):
                            self.adjacency_sid = Mpls.SignalingProtocols.SegmentRouting.Interfaces.AdjacencySid()
                            self.adjacency_sid.parent = self
                            self._children_name_map["adjacency_sid"] = "adjacency-sid"
                        return self.adjacency_sid

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.SignalingProtocols.SegmentRouting.Interfaces.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.SignalingProtocols.SegmentRouting.Interfaces.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjacency-sid" or name == "config" or name == "state" or name == "interface"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.interfaces:
                    if (c.has_data()):
                        return True
                for c in self.srgb:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.interfaces:
                    if (c.has_operation()):
                        return True
                for c in self.srgb:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "segment-routing" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/signaling-protocols/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interfaces"):
                    for c in self.interfaces:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.SignalingProtocols.SegmentRouting.Interfaces()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.interfaces.append(c)
                    return c

                if (child_yang_name == "srgb"):
                    for c in self.srgb:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.SignalingProtocols.SegmentRouting.Srgb()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.srgb.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interfaces" or name == "srgb"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Ldp(Entity):
            """
            LDP global signaling configuration
            
            .. attribute:: timers
            
            	LDP timers
            	**type**\:   :py:class:`Timers <ydk.models.openconfig.openconfig_mpls.Mpls.SignalingProtocols.Ldp.Timers>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.SignalingProtocols.Ldp, self).__init__()

                self.yang_name = "ldp"
                self.yang_parent_name = "signaling-protocols"

                self.timers = Mpls.SignalingProtocols.Ldp.Timers()
                self.timers.parent = self
                self._children_name_map["timers"] = "timers"
                self._children_yang_names.add("timers")


            class Timers(Entity):
                """
                LDP timers
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.SignalingProtocols.Ldp.Timers, self).__init__()

                    self.yang_name = "timers"
                    self.yang_parent_name = "ldp"

                def has_data(self):
                    return False

                def has_operation(self):
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "timers" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/signaling-protocols/ldp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (self.timers is not None and self.timers.has_data())

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.timers is not None and self.timers.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ldp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/signaling-protocols/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "timers"):
                    if (self.timers is None):
                        self.timers = Mpls.SignalingProtocols.Ldp.Timers()
                        self.timers.parent = self
                        self._children_name_map["timers"] = "timers"
                    return self.timers

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "timers"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.ldp is not None and self.ldp.has_data()) or
                (self.rsvp_te is not None and self.rsvp_te.has_data()) or
                (self.segment_routing is not None and self.segment_routing.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ldp is not None and self.ldp.has_operation()) or
                (self.rsvp_te is not None and self.rsvp_te.has_operation()) or
                (self.segment_routing is not None and self.segment_routing.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "signaling-protocols" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-mpls:mpls/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ldp"):
                if (self.ldp is None):
                    self.ldp = Mpls.SignalingProtocols.Ldp()
                    self.ldp.parent = self
                    self._children_name_map["ldp"] = "ldp"
                return self.ldp

            if (child_yang_name == "rsvp-te"):
                if (self.rsvp_te is None):
                    self.rsvp_te = Mpls.SignalingProtocols.RsvpTe()
                    self.rsvp_te.parent = self
                    self._children_name_map["rsvp_te"] = "rsvp-te"
                return self.rsvp_te

            if (child_yang_name == "segment-routing"):
                if (self.segment_routing is None):
                    self.segment_routing = Mpls.SignalingProtocols.SegmentRouting()
                    self.segment_routing.parent = self
                    self._children_name_map["segment_routing"] = "segment-routing"
                return self.segment_routing

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ldp" or name == "rsvp-te" or name == "segment-routing"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Lsps(Entity):
        """
        LSP definitions and configuration
        
        .. attribute:: constrained_path
        
        	traffic\-engineered LSPs supporting different path computation and signaling methods
        	**type**\:   :py:class:`ConstrainedPath <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath>`
        
        .. attribute:: static_lsps
        
        	statically configured LSPs, without dynamic signaling
        	**type**\:   :py:class:`StaticLsps <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.StaticLsps>`
        
        .. attribute:: unconstrained_path
        
        	LSPs that use the IGP\-determined path, i.e., non traffic\-engineered, or non constrained\-path
        	**type**\:   :py:class:`UnconstrainedPath <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath>`
        
        

        """

        _prefix = 'mpls'
        _revision = '2015-11-05'

        def __init__(self):
            super(Mpls.Lsps, self).__init__()

            self.yang_name = "lsps"
            self.yang_parent_name = "mpls"

            self.constrained_path = Mpls.Lsps.ConstrainedPath()
            self.constrained_path.parent = self
            self._children_name_map["constrained_path"] = "constrained-path"
            self._children_yang_names.add("constrained-path")

            self.static_lsps = Mpls.Lsps.StaticLsps()
            self.static_lsps.parent = self
            self._children_name_map["static_lsps"] = "static-lsps"
            self._children_yang_names.add("static-lsps")

            self.unconstrained_path = Mpls.Lsps.UnconstrainedPath()
            self.unconstrained_path.parent = self
            self._children_name_map["unconstrained_path"] = "unconstrained-path"
            self._children_yang_names.add("unconstrained-path")


        class ConstrainedPath(Entity):
            """
            traffic\-engineered LSPs supporting different
            path computation and signaling methods
            
            .. attribute:: named_explicit_paths
            
            	A list of explicit paths
            	**type**\: list of    :py:class:`NamedExplicitPaths <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths>`
            
            .. attribute:: tunnel
            
            	List of TE tunnels
            	**type**\: list of    :py:class:`Tunnel <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.Lsps.ConstrainedPath, self).__init__()

                self.yang_name = "constrained-path"
                self.yang_parent_name = "lsps"

                self.named_explicit_paths = YList(self)
                self.tunnel = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.Lsps.ConstrainedPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.Lsps.ConstrainedPath, self).__setattr__(name, value)


            class NamedExplicitPaths(Entity):
                """
                A list of explicit paths
                
                .. attribute:: name  <key>
                
                	A string name that uniquely identifies an explicit path
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config>`
                
                .. attribute:: config
                
                	Configuration parameters relating to named explicit paths
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config>`
                
                .. attribute:: explicit_route_objects
                
                	List of explicit route objects
                	**type**\: list of    :py:class:`ExplicitRouteObjects <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects>`
                
                .. attribute:: state
                
                	Operational state parameters relating to the named explicit paths
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths, self).__init__()

                    self.yang_name = "named-explicit-paths"
                    self.yang_parent_name = "constrained-path"

                    self.name = YLeaf(YType.str, "name")

                    self.config = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.state = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                    self.explicit_route_objects = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configuration parameters relating to named explicit
                    paths
                    
                    .. attribute:: name
                    
                    	A string name that uniquely identifies an explicit path
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "named-explicit-paths"

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return self.name.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    Operational state parameters relating to the named
                    explicit paths
                    
                    .. attribute:: name
                    
                    	A string name that uniquely identifies an explicit path
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "named-explicit-paths"

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.State, self).__setattr__(name, value)

                    def has_data(self):
                        return self.name.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix


                class ExplicitRouteObjects(Entity):
                    """
                    List of explicit route objects
                    
                    .. attribute:: index  <key>
                    
                    	Index of this explicit route object, to express the order of hops in path
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**refers to**\:  :py:class:`index <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config>`
                    
                    .. attribute:: config
                    
                    	Configuration parameters relating to an explicit route
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config>`
                    
                    .. attribute:: state
                    
                    	State parameters relating to an explicit route
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects, self).__init__()

                        self.yang_name = "explicit-route-objects"
                        self.yang_parent_name = "named-explicit-paths"

                        self.index = YLeaf(YType.str, "index")

                        self.config = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("index") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects, self).__setattr__(name, value)


                    class Config(Entity):
                        """
                        Configuration parameters relating to an explicit
                        route
                        
                        .. attribute:: address
                        
                        	router hop for the LSP path
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: hop_type
                        
                        	strict or loose hop
                        	**type**\:   :py:class:`MplsHopType <ydk.models.openconfig.openconfig_mpls.MplsHopType>`
                        
                        .. attribute:: index
                        
                        	Index of this explicit route object to express the order of hops in the path
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "explicit-route-objects"

                            self.address = YLeaf(YType.str, "address")

                            self.hop_type = YLeaf(YType.enumeration, "hop-type")

                            self.index = YLeaf(YType.uint8, "index")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "hop_type",
                                            "index") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.hop_type.is_set or
                                self.index.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.hop_type.yfilter != YFilter.not_set or
                                self.index.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.hop_type.is_set or self.hop_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hop_type.get_name_leafdata())
                            if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.index.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "hop-type" or name == "index"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "hop-type"):
                                self.hop_type = value
                                self.hop_type.value_namespace = name_space
                                self.hop_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "index"):
                                self.index = value
                                self.index.value_namespace = name_space
                                self.index.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State parameters relating to an explicit route
                        
                        .. attribute:: address
                        
                        	router hop for the LSP path
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: hop_type
                        
                        	strict or loose hop
                        	**type**\:   :py:class:`MplsHopType <ydk.models.openconfig.openconfig_mpls.MplsHopType>`
                        
                        .. attribute:: index
                        
                        	Index of this explicit route object to express the order of hops in the path
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "explicit-route-objects"

                            self.address = YLeaf(YType.str, "address")

                            self.hop_type = YLeaf(YType.enumeration, "hop-type")

                            self.index = YLeaf(YType.uint8, "index")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("address",
                                            "hop_type",
                                            "index") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.address.is_set or
                                self.hop_type.is_set or
                                self.index.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.address.yfilter != YFilter.not_set or
                                self.hop_type.yfilter != YFilter.not_set or
                                self.index.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.address.get_name_leafdata())
                            if (self.hop_type.is_set or self.hop_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hop_type.get_name_leafdata())
                            if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.index.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "address" or name == "hop-type" or name == "index"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "address"):
                                self.address = value
                                self.address.value_namespace = name_space
                                self.address.value_namespace_prefix = name_space_prefix
                            if(value_path == "hop-type"):
                                self.hop_type = value
                                self.hop_type.value_namespace = name_space
                                self.hop_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "index"):
                                self.index = value
                                self.index.value_namespace = name_space
                                self.index.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.index.is_set or
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.index.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "explicit-route-objects" + "[index='" + self.index.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.index.is_set or self.index.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.index.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "state" or name == "index"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "index"):
                            self.index = value
                            self.index.value_namespace = name_space
                            self.index.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.explicit_route_objects:
                        if (c.has_data()):
                            return True
                    return (
                        self.name.is_set or
                        (self.config is not None and self.config.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    for c in self.explicit_route_objects:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.config is not None and self.config.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "named-explicit-paths" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/lsps/constrained-path/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "explicit-route-objects"):
                        for c in self.explicit_route_objects:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.ExplicitRouteObjects()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.explicit_route_objects.append(c)
                        return c

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config" or name == "explicit-route-objects" or name == "state" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class Tunnel(Entity):
                """
                List of TE tunnels
                
                .. attribute:: name  <key>
                
                	The tunnel name
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Config>`
                
                .. attribute:: type  <key>
                
                	The tunnel type, p2p or p2mp
                	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                
                .. attribute:: bandwidth
                
                	Bandwidth configuration for TE LSPs
                	**type**\:   :py:class:`Bandwidth <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth>`
                
                .. attribute:: config
                
                	Configuration parameters related to TE tunnels\:
                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Config>`
                
                .. attribute:: p2p_tunnel_attributes
                
                	Parameters related to LSPs of type P2P
                	**type**\:   :py:class:`P2PTunnelAttributes <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes>`
                
                .. attribute:: state
                
                	State parameters related to TE tunnels
                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.State>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.Lsps.ConstrainedPath.Tunnel, self).__init__()

                    self.yang_name = "tunnel"
                    self.yang_parent_name = "constrained-path"

                    self.name = YLeaf(YType.str, "name")

                    self.type = YLeaf(YType.identityref, "type")

                    self.bandwidth = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth()
                    self.bandwidth.parent = self
                    self._children_name_map["bandwidth"] = "bandwidth"
                    self._children_yang_names.add("bandwidth")

                    self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Config()
                    self.config.parent = self
                    self._children_name_map["config"] = "config"
                    self._children_yang_names.add("config")

                    self.p2p_tunnel_attributes = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes()
                    self.p2p_tunnel_attributes.parent = self
                    self._children_name_map["p2p_tunnel_attributes"] = "p2p-tunnel-attributes"
                    self._children_yang_names.add("p2p-tunnel-attributes")

                    self.state = Mpls.Lsps.ConstrainedPath.Tunnel.State()
                    self.state.parent = self
                    self._children_name_map["state"] = "state"
                    self._children_yang_names.add("state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name",
                                    "type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.Lsps.ConstrainedPath.Tunnel, self).__setattr__(name, value)


                class Config(Entity):
                    """
                    Configuration parameters related to TE tunnels\:
                    
                    .. attribute:: admin_status
                    
                    	TE tunnel administrative state
                    	**type**\:   :py:class:`TunnelAdminStatus <ydk.models.openconfig.openconfig_mpls_types.TunnelAdminStatus>`
                    
                    	**default value**\: mplst:ADMIN_UP
                    
                    .. attribute:: description
                    
                    	optional text description for the tunnel
                    	**type**\:  str
                    
                    .. attribute:: hold_priority
                    
                    	preemption priority once the LSP is established, lower is higher priority; default 0 indicates other LSPs will not preempt the LSPs once established
                    	**type**\:  int
                    
                    	**range:** 0..7
                    
                    	**default value**\: 0
                    
                    .. attribute:: local_id
                    
                    	locally signficant optional identifier for the tunnel; may be a numerical or string value
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    	**type**\:  str
                    
                    
                    ----
                    .. attribute:: metric
                    
                    	LSP metric, either explicit or IGP
                    	**type**\: one of the below types:
                    
                    	**type**\:   :py:class:`TeMetricType <ydk.models.openconfig.openconfig_mpls.TeMetricType>`
                    
                    
                    ----
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    .. attribute:: name
                    
                    	The tunnel name
                    	**type**\:  str
                    
                    .. attribute:: preference
                    
                    	Specifies a preference for this tunnel. A lower number signifies a better preference
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    .. attribute:: protection_style_requested
                    
                    	style of mpls frr protection desired\: can be link, link\-node or unprotected
                    	**type**\:   :py:class:`ProtectionType <ydk.models.openconfig.openconfig_mpls_types.ProtectionType>`
                    
                    	**default value**\: mplst:unprotected
                    
                    .. attribute:: reoptimize_timer
                    
                    	frequency of reoptimization of a traffic engineered LSP
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: seconds
                    
                    .. attribute:: setup_priority
                    
                    	RSVP\-TE preemption priority during LSP setup, lower is higher priority; default 7 indicates that LSP will not preempt established LSPs during setup
                    	**type**\:  int
                    
                    	**range:** 0..7
                    
                    	**default value**\: 7
                    
                    .. attribute:: signaling_protocol
                    
                    	Signaling protocol used to set up this tunnel
                    	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                    
                    .. attribute:: soft_preemption
                    
                    	Enables RSVP soft\-preemption on this LSP
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: source
                    
                    	RSVP\-TE tunnel source address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: type
                    
                    	Tunnel type, p2p or p2mp
                    	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.Tunnel.Config, self).__init__()

                        self.yang_name = "config"
                        self.yang_parent_name = "tunnel"

                        self.admin_status = YLeaf(YType.identityref, "admin-status")

                        self.description = YLeaf(YType.str, "description")

                        self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                        self.local_id = YLeaf(YType.str, "local-id")

                        self.metric = YLeaf(YType.str, "metric")

                        self.name = YLeaf(YType.str, "name")

                        self.preference = YLeaf(YType.uint8, "preference")

                        self.protection_style_requested = YLeaf(YType.identityref, "protection-style-requested")

                        self.reoptimize_timer = YLeaf(YType.uint16, "reoptimize-timer")

                        self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                        self.signaling_protocol = YLeaf(YType.identityref, "signaling-protocol")

                        self.soft_preemption = YLeaf(YType.boolean, "soft-preemption")

                        self.source = YLeaf(YType.str, "source")

                        self.type = YLeaf(YType.identityref, "type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("admin_status",
                                        "description",
                                        "hold_priority",
                                        "local_id",
                                        "metric",
                                        "name",
                                        "preference",
                                        "protection_style_requested",
                                        "reoptimize_timer",
                                        "setup_priority",
                                        "signaling_protocol",
                                        "soft_preemption",
                                        "source",
                                        "type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Config, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Config, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.admin_status.is_set or
                            self.description.is_set or
                            self.hold_priority.is_set or
                            self.local_id.is_set or
                            self.metric.is_set or
                            self.name.is_set or
                            self.preference.is_set or
                            self.protection_style_requested.is_set or
                            self.reoptimize_timer.is_set or
                            self.setup_priority.is_set or
                            self.signaling_protocol.is_set or
                            self.soft_preemption.is_set or
                            self.source.is_set or
                            self.type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.admin_status.yfilter != YFilter.not_set or
                            self.description.yfilter != YFilter.not_set or
                            self.hold_priority.yfilter != YFilter.not_set or
                            self.local_id.yfilter != YFilter.not_set or
                            self.metric.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.preference.yfilter != YFilter.not_set or
                            self.protection_style_requested.yfilter != YFilter.not_set or
                            self.reoptimize_timer.yfilter != YFilter.not_set or
                            self.setup_priority.yfilter != YFilter.not_set or
                            self.signaling_protocol.yfilter != YFilter.not_set or
                            self.soft_preemption.yfilter != YFilter.not_set or
                            self.source.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.admin_status.is_set or self.admin_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_status.get_name_leafdata())
                        if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.description.get_name_leafdata())
                        if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_priority.get_name_leafdata())
                        if (self.local_id.is_set or self.local_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_id.get_name_leafdata())
                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.metric.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.preference.get_name_leafdata())
                        if (self.protection_style_requested.is_set or self.protection_style_requested.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protection_style_requested.get_name_leafdata())
                        if (self.reoptimize_timer.is_set or self.reoptimize_timer.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reoptimize_timer.get_name_leafdata())
                        if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.setup_priority.get_name_leafdata())
                        if (self.signaling_protocol.is_set or self.signaling_protocol.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.signaling_protocol.get_name_leafdata())
                        if (self.soft_preemption.is_set or self.soft_preemption.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.soft_preemption.get_name_leafdata())
                        if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "admin-status" or name == "description" or name == "hold-priority" or name == "local-id" or name == "metric" or name == "name" or name == "preference" or name == "protection-style-requested" or name == "reoptimize-timer" or name == "setup-priority" or name == "signaling-protocol" or name == "soft-preemption" or name == "source" or name == "type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "admin-status"):
                            self.admin_status = value
                            self.admin_status.value_namespace = name_space
                            self.admin_status.value_namespace_prefix = name_space_prefix
                        if(value_path == "description"):
                            self.description = value
                            self.description.value_namespace = name_space
                            self.description.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-priority"):
                            self.hold_priority = value
                            self.hold_priority.value_namespace = name_space
                            self.hold_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-id"):
                            self.local_id = value
                            self.local_id.value_namespace = name_space
                            self.local_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "metric"):
                            self.metric = value
                            self.metric.value_namespace = name_space
                            self.metric.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "preference"):
                            self.preference = value
                            self.preference.value_namespace = name_space
                            self.preference.value_namespace_prefix = name_space_prefix
                        if(value_path == "protection-style-requested"):
                            self.protection_style_requested = value
                            self.protection_style_requested.value_namespace = name_space
                            self.protection_style_requested.value_namespace_prefix = name_space_prefix
                        if(value_path == "reoptimize-timer"):
                            self.reoptimize_timer = value
                            self.reoptimize_timer.value_namespace = name_space
                            self.reoptimize_timer.value_namespace_prefix = name_space_prefix
                        if(value_path == "setup-priority"):
                            self.setup_priority = value
                            self.setup_priority.value_namespace = name_space
                            self.setup_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "signaling-protocol"):
                            self.signaling_protocol = value
                            self.signaling_protocol.value_namespace = name_space
                            self.signaling_protocol.value_namespace_prefix = name_space_prefix
                        if(value_path == "soft-preemption"):
                            self.soft_preemption = value
                            self.soft_preemption.value_namespace = name_space
                            self.soft_preemption.value_namespace_prefix = name_space_prefix
                        if(value_path == "source"):
                            self.source = value
                            self.source.value_namespace = name_space
                            self.source.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix


                class State(Entity):
                    """
                    State parameters related to TE tunnels
                    
                    .. attribute:: admin_status
                    
                    	TE tunnel administrative state
                    	**type**\:   :py:class:`TunnelAdminStatus <ydk.models.openconfig.openconfig_mpls_types.TunnelAdminStatus>`
                    
                    	**default value**\: mplst:ADMIN_UP
                    
                    .. attribute:: counters
                    
                    	State data for MPLS label switched paths. This state data is specific to a single label switched path
                    	**type**\:   :py:class:`Counters <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.State.Counters>`
                    
                    .. attribute:: description
                    
                    	optional text description for the tunnel
                    	**type**\:  str
                    
                    .. attribute:: hold_priority
                    
                    	preemption priority once the LSP is established, lower is higher priority; default 0 indicates other LSPs will not preempt the LSPs once established
                    	**type**\:  int
                    
                    	**range:** 0..7
                    
                    	**default value**\: 0
                    
                    .. attribute:: local_id
                    
                    	locally signficant optional identifier for the tunnel; may be a numerical or string value
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    	**type**\:  str
                    
                    
                    ----
                    .. attribute:: metric
                    
                    	LSP metric, either explicit or IGP
                    	**type**\: one of the below types:
                    
                    	**type**\:   :py:class:`TeMetricType <ydk.models.openconfig.openconfig_mpls.TeMetricType>`
                    
                    
                    ----
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    
                    ----
                    .. attribute:: name
                    
                    	The tunnel name
                    	**type**\:  str
                    
                    .. attribute:: oper_status
                    
                    	The operational status of the TE tunnel
                    	**type**\:   :py:class:`LspOperStatus <ydk.models.openconfig.openconfig_mpls_types.LspOperStatus>`
                    
                    .. attribute:: preference
                    
                    	Specifies a preference for this tunnel. A lower number signifies a better preference
                    	**type**\:  int
                    
                    	**range:** 1..255
                    
                    .. attribute:: protection_style_requested
                    
                    	style of mpls frr protection desired\: can be link, link\-node or unprotected
                    	**type**\:   :py:class:`ProtectionType <ydk.models.openconfig.openconfig_mpls_types.ProtectionType>`
                    
                    	**default value**\: mplst:unprotected
                    
                    .. attribute:: reoptimize_timer
                    
                    	frequency of reoptimization of a traffic engineered LSP
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: seconds
                    
                    .. attribute:: role
                    
                    	The lsp role at the current node, whether it is headend, transit or tailend
                    	**type**\:   :py:class:`LspRole <ydk.models.openconfig.openconfig_mpls_types.LspRole>`
                    
                    .. attribute:: setup_priority
                    
                    	RSVP\-TE preemption priority during LSP setup, lower is higher priority; default 7 indicates that LSP will not preempt established LSPs during setup
                    	**type**\:  int
                    
                    	**range:** 0..7
                    
                    	**default value**\: 7
                    
                    .. attribute:: signaling_protocol
                    
                    	Signaling protocol used to set up this tunnel
                    	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                    
                    .. attribute:: soft_preemption
                    
                    	Enables RSVP soft\-preemption on this LSP
                    	**type**\:  bool
                    
                    	**default value**\: false
                    
                    .. attribute:: source
                    
                    	RSVP\-TE tunnel source address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: type
                    
                    	Tunnel type, p2p or p2mp
                    	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.Tunnel.State, self).__init__()

                        self.yang_name = "state"
                        self.yang_parent_name = "tunnel"

                        self.admin_status = YLeaf(YType.identityref, "admin-status")

                        self.description = YLeaf(YType.str, "description")

                        self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                        self.local_id = YLeaf(YType.str, "local-id")

                        self.metric = YLeaf(YType.str, "metric")

                        self.name = YLeaf(YType.str, "name")

                        self.oper_status = YLeaf(YType.identityref, "oper-status")

                        self.preference = YLeaf(YType.uint8, "preference")

                        self.protection_style_requested = YLeaf(YType.identityref, "protection-style-requested")

                        self.reoptimize_timer = YLeaf(YType.uint16, "reoptimize-timer")

                        self.role = YLeaf(YType.identityref, "role")

                        self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                        self.signaling_protocol = YLeaf(YType.identityref, "signaling-protocol")

                        self.soft_preemption = YLeaf(YType.boolean, "soft-preemption")

                        self.source = YLeaf(YType.str, "source")

                        self.type = YLeaf(YType.identityref, "type")

                        self.counters = Mpls.Lsps.ConstrainedPath.Tunnel.State.Counters()
                        self.counters.parent = self
                        self._children_name_map["counters"] = "counters"
                        self._children_yang_names.add("counters")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("admin_status",
                                        "description",
                                        "hold_priority",
                                        "local_id",
                                        "metric",
                                        "name",
                                        "oper_status",
                                        "preference",
                                        "protection_style_requested",
                                        "reoptimize_timer",
                                        "role",
                                        "setup_priority",
                                        "signaling_protocol",
                                        "soft_preemption",
                                        "source",
                                        "type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.State, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.State, self).__setattr__(name, value)


                    class Counters(Entity):
                        """
                        State data for MPLS label switched paths. This state
                        data is specific to a single label switched path.
                        
                        .. attribute:: bytes
                        
                        	Number of bytes that have been forwarded over the label switched path
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: current_path_time
                        
                        	Indicates the time the LSP switched onto its current path. This is reset upon a LSP path change
                        	**type**\:  str
                        
                        	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
                        
                        .. attribute:: next_reoptimization_time
                        
                        	Indicates the next scheduled time the LSP will be reoptimized
                        	**type**\:  str
                        
                        	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
                        
                        .. attribute:: online_time
                        
                        	Indication of the time the label switched path transitioned to an Oper Up or in\-service state
                        	**type**\:  str
                        
                        	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
                        
                        .. attribute:: packets
                        
                        	Number of pacets that have been forwarded over the label switched path
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: path_changes
                        
                        	Number of path changes for the label switched path
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: state_changes
                        
                        	Number of state changes for the label switched path
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.State.Counters, self).__init__()

                            self.yang_name = "counters"
                            self.yang_parent_name = "state"

                            self.bytes = YLeaf(YType.uint64, "bytes")

                            self.current_path_time = YLeaf(YType.str, "current-path-time")

                            self.next_reoptimization_time = YLeaf(YType.str, "next-reoptimization-time")

                            self.online_time = YLeaf(YType.str, "online-time")

                            self.packets = YLeaf(YType.uint64, "packets")

                            self.path_changes = YLeaf(YType.uint64, "path-changes")

                            self.state_changes = YLeaf(YType.uint64, "state-changes")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bytes",
                                            "current_path_time",
                                            "next_reoptimization_time",
                                            "online_time",
                                            "packets",
                                            "path_changes",
                                            "state_changes") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.State.Counters, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.State.Counters, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bytes.is_set or
                                self.current_path_time.is_set or
                                self.next_reoptimization_time.is_set or
                                self.online_time.is_set or
                                self.packets.is_set or
                                self.path_changes.is_set or
                                self.state_changes.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bytes.yfilter != YFilter.not_set or
                                self.current_path_time.yfilter != YFilter.not_set or
                                self.next_reoptimization_time.yfilter != YFilter.not_set or
                                self.online_time.yfilter != YFilter.not_set or
                                self.packets.yfilter != YFilter.not_set or
                                self.path_changes.yfilter != YFilter.not_set or
                                self.state_changes.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "counters" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bytes.is_set or self.bytes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bytes.get_name_leafdata())
                            if (self.current_path_time.is_set or self.current_path_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.current_path_time.get_name_leafdata())
                            if (self.next_reoptimization_time.is_set or self.next_reoptimization_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_reoptimization_time.get_name_leafdata())
                            if (self.online_time.is_set or self.online_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.online_time.get_name_leafdata())
                            if (self.packets.is_set or self.packets.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.packets.get_name_leafdata())
                            if (self.path_changes.is_set or self.path_changes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_changes.get_name_leafdata())
                            if (self.state_changes.is_set or self.state_changes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_changes.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bytes" or name == "current-path-time" or name == "next-reoptimization-time" or name == "online-time" or name == "packets" or name == "path-changes" or name == "state-changes"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bytes"):
                                self.bytes = value
                                self.bytes.value_namespace = name_space
                                self.bytes.value_namespace_prefix = name_space_prefix
                            if(value_path == "current-path-time"):
                                self.current_path_time = value
                                self.current_path_time.value_namespace = name_space
                                self.current_path_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-reoptimization-time"):
                                self.next_reoptimization_time = value
                                self.next_reoptimization_time.value_namespace = name_space
                                self.next_reoptimization_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "online-time"):
                                self.online_time = value
                                self.online_time.value_namespace = name_space
                                self.online_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "packets"):
                                self.packets = value
                                self.packets.value_namespace = name_space
                                self.packets.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-changes"):
                                self.path_changes = value
                                self.path_changes.value_namespace = name_space
                                self.path_changes.value_namespace_prefix = name_space_prefix
                            if(value_path == "state-changes"):
                                self.state_changes = value
                                self.state_changes.value_namespace = name_space
                                self.state_changes.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.admin_status.is_set or
                            self.description.is_set or
                            self.hold_priority.is_set or
                            self.local_id.is_set or
                            self.metric.is_set or
                            self.name.is_set or
                            self.oper_status.is_set or
                            self.preference.is_set or
                            self.protection_style_requested.is_set or
                            self.reoptimize_timer.is_set or
                            self.role.is_set or
                            self.setup_priority.is_set or
                            self.signaling_protocol.is_set or
                            self.soft_preemption.is_set or
                            self.source.is_set or
                            self.type.is_set or
                            (self.counters is not None and self.counters.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.admin_status.yfilter != YFilter.not_set or
                            self.description.yfilter != YFilter.not_set or
                            self.hold_priority.yfilter != YFilter.not_set or
                            self.local_id.yfilter != YFilter.not_set or
                            self.metric.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.oper_status.yfilter != YFilter.not_set or
                            self.preference.yfilter != YFilter.not_set or
                            self.protection_style_requested.yfilter != YFilter.not_set or
                            self.reoptimize_timer.yfilter != YFilter.not_set or
                            self.role.yfilter != YFilter.not_set or
                            self.setup_priority.yfilter != YFilter.not_set or
                            self.signaling_protocol.yfilter != YFilter.not_set or
                            self.soft_preemption.yfilter != YFilter.not_set or
                            self.source.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set or
                            (self.counters is not None and self.counters.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "state" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.admin_status.is_set or self.admin_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_status.get_name_leafdata())
                        if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.description.get_name_leafdata())
                        if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_priority.get_name_leafdata())
                        if (self.local_id.is_set or self.local_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_id.get_name_leafdata())
                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.metric.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.oper_status.is_set or self.oper_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.oper_status.get_name_leafdata())
                        if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.preference.get_name_leafdata())
                        if (self.protection_style_requested.is_set or self.protection_style_requested.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protection_style_requested.get_name_leafdata())
                        if (self.reoptimize_timer.is_set or self.reoptimize_timer.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reoptimize_timer.get_name_leafdata())
                        if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.role.get_name_leafdata())
                        if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.setup_priority.get_name_leafdata())
                        if (self.signaling_protocol.is_set or self.signaling_protocol.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.signaling_protocol.get_name_leafdata())
                        if (self.soft_preemption.is_set or self.soft_preemption.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.soft_preemption.get_name_leafdata())
                        if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "counters"):
                            if (self.counters is None):
                                self.counters = Mpls.Lsps.ConstrainedPath.Tunnel.State.Counters()
                                self.counters.parent = self
                                self._children_name_map["counters"] = "counters"
                            return self.counters

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "counters" or name == "admin-status" or name == "description" or name == "hold-priority" or name == "local-id" or name == "metric" or name == "name" or name == "oper-status" or name == "preference" or name == "protection-style-requested" or name == "reoptimize-timer" or name == "role" or name == "setup-priority" or name == "signaling-protocol" or name == "soft-preemption" or name == "source" or name == "type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "admin-status"):
                            self.admin_status = value
                            self.admin_status.value_namespace = name_space
                            self.admin_status.value_namespace_prefix = name_space_prefix
                        if(value_path == "description"):
                            self.description = value
                            self.description.value_namespace = name_space
                            self.description.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-priority"):
                            self.hold_priority = value
                            self.hold_priority.value_namespace = name_space
                            self.hold_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-id"):
                            self.local_id = value
                            self.local_id.value_namespace = name_space
                            self.local_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "metric"):
                            self.metric = value
                            self.metric.value_namespace = name_space
                            self.metric.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "oper-status"):
                            self.oper_status = value
                            self.oper_status.value_namespace = name_space
                            self.oper_status.value_namespace_prefix = name_space_prefix
                        if(value_path == "preference"):
                            self.preference = value
                            self.preference.value_namespace = name_space
                            self.preference.value_namespace_prefix = name_space_prefix
                        if(value_path == "protection-style-requested"):
                            self.protection_style_requested = value
                            self.protection_style_requested.value_namespace = name_space
                            self.protection_style_requested.value_namespace_prefix = name_space_prefix
                        if(value_path == "reoptimize-timer"):
                            self.reoptimize_timer = value
                            self.reoptimize_timer.value_namespace = name_space
                            self.reoptimize_timer.value_namespace_prefix = name_space_prefix
                        if(value_path == "role"):
                            self.role = value
                            self.role.value_namespace = name_space
                            self.role.value_namespace_prefix = name_space_prefix
                        if(value_path == "setup-priority"):
                            self.setup_priority = value
                            self.setup_priority.value_namespace = name_space
                            self.setup_priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "signaling-protocol"):
                            self.signaling_protocol = value
                            self.signaling_protocol.value_namespace = name_space
                            self.signaling_protocol.value_namespace_prefix = name_space_prefix
                        if(value_path == "soft-preemption"):
                            self.soft_preemption = value
                            self.soft_preemption.value_namespace = name_space
                            self.soft_preemption.value_namespace_prefix = name_space_prefix
                        if(value_path == "source"):
                            self.source = value
                            self.source.value_namespace = name_space
                            self.source.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix


                class Bandwidth(Entity):
                    """
                    Bandwidth configuration for TE LSPs
                    
                    .. attribute:: auto_bandwidth
                    
                    	Parameters related to auto\-bandwidth
                    	**type**\:   :py:class:`AutoBandwidth <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth>`
                    
                    .. attribute:: config
                    
                    	Configuration parameters related to bandwidth on TE tunnels\:
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.Config>`
                    
                    .. attribute:: state
                    
                    	State parameters related to bandwidth configuration of TE tunnels
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth, self).__init__()

                        self.yang_name = "bandwidth"
                        self.yang_parent_name = "tunnel"

                        self.auto_bandwidth = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth()
                        self.auto_bandwidth.parent = self
                        self._children_name_map["auto_bandwidth"] = "auto-bandwidth"
                        self._children_yang_names.add("auto-bandwidth")

                        self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")


                    class Config(Entity):
                        """
                        Configuration parameters related to bandwidth on TE
                        tunnels\:
                        
                        .. attribute:: set_bandwidth
                        
                        	set bandwidth explicitly, e.g., using offline calculation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: specification_type
                        
                        	The method used for settign the bandwidth, either explicitly specified or configured
                        	**type**\:   :py:class:`TeBandwidthType <ydk.models.openconfig.openconfig_mpls.TeBandwidthType>`
                        
                        	**default value**\: SPECIFIED
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "bandwidth"

                            self.set_bandwidth = YLeaf(YType.uint32, "set-bandwidth")

                            self.specification_type = YLeaf(YType.enumeration, "specification-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("set_bandwidth",
                                            "specification_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.set_bandwidth.is_set or
                                self.specification_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.set_bandwidth.yfilter != YFilter.not_set or
                                self.specification_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.set_bandwidth.is_set or self.set_bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_bandwidth.get_name_leafdata())
                            if (self.specification_type.is_set or self.specification_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.specification_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "set-bandwidth" or name == "specification-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "set-bandwidth"):
                                self.set_bandwidth = value
                                self.set_bandwidth.value_namespace = name_space
                                self.set_bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "specification-type"):
                                self.specification_type = value
                                self.specification_type.value_namespace = name_space
                                self.specification_type.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State parameters related to bandwidth
                        configuration of TE tunnels
                        
                        .. attribute:: set_bandwidth
                        
                        	set bandwidth explicitly, e.g., using offline calculation
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: specification_type
                        
                        	The method used for settign the bandwidth, either explicitly specified or configured
                        	**type**\:   :py:class:`TeBandwidthType <ydk.models.openconfig.openconfig_mpls.TeBandwidthType>`
                        
                        	**default value**\: SPECIFIED
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "bandwidth"

                            self.set_bandwidth = YLeaf(YType.uint32, "set-bandwidth")

                            self.specification_type = YLeaf(YType.enumeration, "specification-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("set_bandwidth",
                                            "specification_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.State, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.set_bandwidth.is_set or
                                self.specification_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.set_bandwidth.yfilter != YFilter.not_set or
                                self.specification_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.set_bandwidth.is_set or self.set_bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.set_bandwidth.get_name_leafdata())
                            if (self.specification_type.is_set or self.specification_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.specification_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "set-bandwidth" or name == "specification-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "set-bandwidth"):
                                self.set_bandwidth = value
                                self.set_bandwidth.value_namespace = name_space
                                self.set_bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "specification-type"):
                                self.specification_type = value
                                self.specification_type.value_namespace = name_space
                                self.specification_type.value_namespace_prefix = name_space_prefix


                    class AutoBandwidth(Entity):
                        """
                        Parameters related to auto\-bandwidth
                        
                        .. attribute:: config
                        
                        	Configuration parameters relating to MPLS auto\-bandwidth on the tunnel
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Config>`
                        
                        .. attribute:: overflow
                        
                        	configuration of MPLS overflow bandwidth adjustement for the LSP
                        	**type**\:   :py:class:`Overflow <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow>`
                        
                        .. attribute:: state
                        
                        	State parameters relating to MPLS auto\-bandwidth on the tunnel
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.State>`
                        
                        .. attribute:: underflow
                        
                        	configuration of MPLS underflow bandwidth           adjustement for the LSP
                        	**type**\:   :py:class:`Underflow <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth, self).__init__()

                            self.yang_name = "auto-bandwidth"
                            self.yang_parent_name = "bandwidth"

                            self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.overflow = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow()
                            self.overflow.parent = self
                            self._children_name_map["overflow"] = "overflow"
                            self._children_yang_names.add("overflow")

                            self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                            self.underflow = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow()
                            self.underflow.parent = self
                            self._children_name_map["underflow"] = "underflow"
                            self._children_yang_names.add("underflow")


                        class Config(Entity):
                            """
                            Configuration parameters relating to MPLS
                            auto\-bandwidth on the tunnel.
                            
                            .. attribute:: adjust_interval
                            
                            	time in seconds between adjustments to LSP bandwidth
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: adjust_threshold
                            
                            	percentage difference between the LSP's specified bandwidth and its current bandwidth allocation \-\- if the difference is greater than the specified percentage, auto\-bandwidth adjustment is triggered
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            .. attribute:: enabled
                            
                            	enables mpls auto\-bandwidth on the lsp
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: max_bw
                            
                            	set the maximum bandwidth in Mbps for an auto\-bandwidth LSP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: min_bw
                            
                            	set the minimum bandwidth in Mbps for an auto\-bandwidth LSP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "auto-bandwidth"

                                self.adjust_interval = YLeaf(YType.uint32, "adjust-interval")

                                self.adjust_threshold = YLeaf(YType.uint8, "adjust-threshold")

                                self.enabled = YLeaf(YType.boolean, "enabled")

                                self.max_bw = YLeaf(YType.uint32, "max-bw")

                                self.min_bw = YLeaf(YType.uint32, "min-bw")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("adjust_interval",
                                                "adjust_threshold",
                                                "enabled",
                                                "max_bw",
                                                "min_bw") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.adjust_interval.is_set or
                                    self.adjust_threshold.is_set or
                                    self.enabled.is_set or
                                    self.max_bw.is_set or
                                    self.min_bw.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.adjust_interval.yfilter != YFilter.not_set or
                                    self.adjust_threshold.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set or
                                    self.max_bw.yfilter != YFilter.not_set or
                                    self.min_bw.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.adjust_interval.is_set or self.adjust_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjust_interval.get_name_leafdata())
                                if (self.adjust_threshold.is_set or self.adjust_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjust_threshold.get_name_leafdata())
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())
                                if (self.max_bw.is_set or self.max_bw.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_bw.get_name_leafdata())
                                if (self.min_bw.is_set or self.min_bw.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.min_bw.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "adjust-interval" or name == "adjust-threshold" or name == "enabled" or name == "max-bw" or name == "min-bw"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "adjust-interval"):
                                    self.adjust_interval = value
                                    self.adjust_interval.value_namespace = name_space
                                    self.adjust_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "adjust-threshold"):
                                    self.adjust_threshold = value
                                    self.adjust_threshold.value_namespace = name_space
                                    self.adjust_threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix
                                if(value_path == "max-bw"):
                                    self.max_bw = value
                                    self.max_bw.value_namespace = name_space
                                    self.max_bw.value_namespace_prefix = name_space_prefix
                                if(value_path == "min-bw"):
                                    self.min_bw = value
                                    self.min_bw.value_namespace = name_space
                                    self.min_bw.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State parameters relating to MPLS
                            auto\-bandwidth on the tunnel.
                            
                            .. attribute:: adjust_interval
                            
                            	time in seconds between adjustments to LSP bandwidth
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: adjust_threshold
                            
                            	percentage difference between the LSP's specified bandwidth and its current bandwidth allocation \-\- if the difference is greater than the specified percentage, auto\-bandwidth adjustment is triggered
                            	**type**\:  int
                            
                            	**range:** 0..100
                            
                            .. attribute:: enabled
                            
                            	enables mpls auto\-bandwidth on the lsp
                            	**type**\:  bool
                            
                            	**default value**\: false
                            
                            .. attribute:: max_bw
                            
                            	set the maximum bandwidth in Mbps for an auto\-bandwidth LSP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: min_bw
                            
                            	set the minimum bandwidth in Mbps for an auto\-bandwidth LSP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "auto-bandwidth"

                                self.adjust_interval = YLeaf(YType.uint32, "adjust-interval")

                                self.adjust_threshold = YLeaf(YType.uint8, "adjust-threshold")

                                self.enabled = YLeaf(YType.boolean, "enabled")

                                self.max_bw = YLeaf(YType.uint32, "max-bw")

                                self.min_bw = YLeaf(YType.uint32, "min-bw")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("adjust_interval",
                                                "adjust_threshold",
                                                "enabled",
                                                "max_bw",
                                                "min_bw") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.adjust_interval.is_set or
                                    self.adjust_threshold.is_set or
                                    self.enabled.is_set or
                                    self.max_bw.is_set or
                                    self.min_bw.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.adjust_interval.yfilter != YFilter.not_set or
                                    self.adjust_threshold.yfilter != YFilter.not_set or
                                    self.enabled.yfilter != YFilter.not_set or
                                    self.max_bw.yfilter != YFilter.not_set or
                                    self.min_bw.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.adjust_interval.is_set or self.adjust_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjust_interval.get_name_leafdata())
                                if (self.adjust_threshold.is_set or self.adjust_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjust_threshold.get_name_leafdata())
                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enabled.get_name_leafdata())
                                if (self.max_bw.is_set or self.max_bw.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_bw.get_name_leafdata())
                                if (self.min_bw.is_set or self.min_bw.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.min_bw.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "adjust-interval" or name == "adjust-threshold" or name == "enabled" or name == "max-bw" or name == "min-bw"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "adjust-interval"):
                                    self.adjust_interval = value
                                    self.adjust_interval.value_namespace = name_space
                                    self.adjust_interval.value_namespace_prefix = name_space_prefix
                                if(value_path == "adjust-threshold"):
                                    self.adjust_threshold = value
                                    self.adjust_threshold.value_namespace = name_space
                                    self.adjust_threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "enabled"):
                                    self.enabled = value
                                    self.enabled.value_namespace = name_space
                                    self.enabled.value_namespace_prefix = name_space_prefix
                                if(value_path == "max-bw"):
                                    self.max_bw = value
                                    self.max_bw.value_namespace = name_space
                                    self.max_bw.value_namespace_prefix = name_space_prefix
                                if(value_path == "min-bw"):
                                    self.min_bw = value
                                    self.min_bw.value_namespace = name_space
                                    self.min_bw.value_namespace_prefix = name_space_prefix


                        class Overflow(Entity):
                            """
                            configuration of MPLS overflow bandwidth
                            adjustement for the LSP
                            
                            .. attribute:: config
                            
                            	Config information for MPLS overflow bandwidth adjustment
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.Config>`
                            
                            .. attribute:: state
                            
                            	Config information for MPLS overflow bandwidth adjustment
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.State>`
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow, self).__init__()

                                self.yang_name = "overflow"
                                self.yang_parent_name = "auto-bandwidth"

                                self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Config information for MPLS overflow bandwidth
                                adjustment
                                
                                .. attribute:: enabled
                                
                                	enables mpls lsp bandwidth overflow adjustment on the lsp
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: overflow_threshold
                                
                                	bandwidth percentage change to trigger an overflow event
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                .. attribute:: trigger_event_count
                                
                                	number of consecutive overflow sample events needed to trigger an overflow adjustment
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "overflow"

                                    self.enabled = YLeaf(YType.boolean, "enabled")

                                    self.overflow_threshold = YLeaf(YType.uint8, "overflow-threshold")

                                    self.trigger_event_count = YLeaf(YType.uint16, "trigger-event-count")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("enabled",
                                                    "overflow_threshold",
                                                    "trigger_event_count") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.enabled.is_set or
                                        self.overflow_threshold.is_set or
                                        self.trigger_event_count.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.enabled.yfilter != YFilter.not_set or
                                        self.overflow_threshold.yfilter != YFilter.not_set or
                                        self.trigger_event_count.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enabled.get_name_leafdata())
                                    if (self.overflow_threshold.is_set or self.overflow_threshold.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.overflow_threshold.get_name_leafdata())
                                    if (self.trigger_event_count.is_set or self.trigger_event_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.trigger_event_count.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "enabled" or name == "overflow-threshold" or name == "trigger-event-count"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "enabled"):
                                        self.enabled = value
                                        self.enabled.value_namespace = name_space
                                        self.enabled.value_namespace_prefix = name_space_prefix
                                    if(value_path == "overflow-threshold"):
                                        self.overflow_threshold = value
                                        self.overflow_threshold.value_namespace = name_space
                                        self.overflow_threshold.value_namespace_prefix = name_space_prefix
                                    if(value_path == "trigger-event-count"):
                                        self.trigger_event_count = value
                                        self.trigger_event_count.value_namespace = name_space
                                        self.trigger_event_count.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                Config information for MPLS overflow bandwidth
                                adjustment
                                
                                .. attribute:: enabled
                                
                                	enables mpls lsp bandwidth overflow adjustment on the lsp
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: overflow_threshold
                                
                                	bandwidth percentage change to trigger an overflow event
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                .. attribute:: trigger_event_count
                                
                                	number of consecutive overflow sample events needed to trigger an overflow adjustment
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "overflow"

                                    self.enabled = YLeaf(YType.boolean, "enabled")

                                    self.overflow_threshold = YLeaf(YType.uint8, "overflow-threshold")

                                    self.trigger_event_count = YLeaf(YType.uint16, "trigger-event-count")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("enabled",
                                                    "overflow_threshold",
                                                    "trigger_event_count") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.enabled.is_set or
                                        self.overflow_threshold.is_set or
                                        self.trigger_event_count.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.enabled.yfilter != YFilter.not_set or
                                        self.overflow_threshold.yfilter != YFilter.not_set or
                                        self.trigger_event_count.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enabled.get_name_leafdata())
                                    if (self.overflow_threshold.is_set or self.overflow_threshold.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.overflow_threshold.get_name_leafdata())
                                    if (self.trigger_event_count.is_set or self.trigger_event_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.trigger_event_count.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "enabled" or name == "overflow-threshold" or name == "trigger-event-count"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "enabled"):
                                        self.enabled = value
                                        self.enabled.value_namespace = name_space
                                        self.enabled.value_namespace_prefix = name_space_prefix
                                    if(value_path == "overflow-threshold"):
                                        self.overflow_threshold = value
                                        self.overflow_threshold.value_namespace = name_space
                                        self.overflow_threshold.value_namespace_prefix = name_space_prefix
                                    if(value_path == "trigger-event-count"):
                                        self.trigger_event_count = value
                                        self.trigger_event_count.value_namespace = name_space
                                        self.trigger_event_count.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "overflow" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Underflow(Entity):
                            """
                            configuration of MPLS underflow bandwidth
                                      adjustement for the LSP
                            
                            .. attribute:: config
                            
                            	Config information for MPLS underflow bandwidth           adjustment
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.Config>`
                            
                            .. attribute:: state
                            
                            	State information for MPLS underflow bandwidth           adjustment
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.State>`
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow, self).__init__()

                                self.yang_name = "underflow"
                                self.yang_parent_name = "auto-bandwidth"

                                self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Config information for MPLS underflow bandwidth
                                          adjustment
                                
                                .. attribute:: enabled
                                
                                	enables bandwidth underflow adjustment on the lsp
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: trigger_event_count
                                
                                	number of consecutive underflow sample events needed to trigger an underflow adjustment
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: underflow_threshold
                                
                                	bandwidth percentage change to trigger and underflow event
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "underflow"

                                    self.enabled = YLeaf(YType.boolean, "enabled")

                                    self.trigger_event_count = YLeaf(YType.uint16, "trigger-event-count")

                                    self.underflow_threshold = YLeaf(YType.uint8, "underflow-threshold")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("enabled",
                                                    "trigger_event_count",
                                                    "underflow_threshold") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.enabled.is_set or
                                        self.trigger_event_count.is_set or
                                        self.underflow_threshold.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.enabled.yfilter != YFilter.not_set or
                                        self.trigger_event_count.yfilter != YFilter.not_set or
                                        self.underflow_threshold.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enabled.get_name_leafdata())
                                    if (self.trigger_event_count.is_set or self.trigger_event_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.trigger_event_count.get_name_leafdata())
                                    if (self.underflow_threshold.is_set or self.underflow_threshold.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.underflow_threshold.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "enabled" or name == "trigger-event-count" or name == "underflow-threshold"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "enabled"):
                                        self.enabled = value
                                        self.enabled.value_namespace = name_space
                                        self.enabled.value_namespace_prefix = name_space_prefix
                                    if(value_path == "trigger-event-count"):
                                        self.trigger_event_count = value
                                        self.trigger_event_count.value_namespace = name_space
                                        self.trigger_event_count.value_namespace_prefix = name_space_prefix
                                    if(value_path == "underflow-threshold"):
                                        self.underflow_threshold = value
                                        self.underflow_threshold.value_namespace = name_space
                                        self.underflow_threshold.value_namespace_prefix = name_space_prefix


                            class State(Entity):
                                """
                                State information for MPLS underflow bandwidth
                                          adjustment
                                
                                .. attribute:: enabled
                                
                                	enables bandwidth underflow adjustment on the lsp
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: trigger_event_count
                                
                                	number of consecutive underflow sample events needed to trigger an underflow adjustment
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: underflow_threshold
                                
                                	bandwidth percentage change to trigger and underflow event
                                	**type**\:  int
                                
                                	**range:** 0..100
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "underflow"

                                    self.enabled = YLeaf(YType.boolean, "enabled")

                                    self.trigger_event_count = YLeaf(YType.uint16, "trigger-event-count")

                                    self.underflow_threshold = YLeaf(YType.uint8, "underflow-threshold")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("enabled",
                                                    "trigger_event_count",
                                                    "underflow_threshold") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.State, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.enabled.is_set or
                                        self.trigger_event_count.is_set or
                                        self.underflow_threshold.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.enabled.yfilter != YFilter.not_set or
                                        self.trigger_event_count.yfilter != YFilter.not_set or
                                        self.underflow_threshold.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enabled.get_name_leafdata())
                                    if (self.trigger_event_count.is_set or self.trigger_event_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.trigger_event_count.get_name_leafdata())
                                    if (self.underflow_threshold.is_set or self.underflow_threshold.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.underflow_threshold.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "enabled" or name == "trigger-event-count" or name == "underflow-threshold"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "enabled"):
                                        self.enabled = value
                                        self.enabled.value_namespace = name_space
                                        self.enabled.value_namespace_prefix = name_space_prefix
                                    if(value_path == "trigger-event-count"):
                                        self.trigger_event_count = value
                                        self.trigger_event_count.value_namespace = name_space
                                        self.trigger_event_count.value_namespace_prefix = name_space_prefix
                                    if(value_path == "underflow-threshold"):
                                        self.underflow_threshold = value
                                        self.underflow_threshold.value_namespace = name_space
                                        self.underflow_threshold.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "underflow" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.config is not None and self.config.has_data()) or
                                (self.overflow is not None and self.overflow.has_data()) or
                                (self.state is not None and self.state.has_data()) or
                                (self.underflow is not None and self.underflow.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.config is not None and self.config.has_operation()) or
                                (self.overflow is not None and self.overflow.has_operation()) or
                                (self.state is not None and self.state.has_operation()) or
                                (self.underflow is not None and self.underflow.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "auto-bandwidth" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "overflow"):
                                if (self.overflow is None):
                                    self.overflow = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Overflow()
                                    self.overflow.parent = self
                                    self._children_name_map["overflow"] = "overflow"
                                return self.overflow

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            if (child_yang_name == "underflow"):
                                if (self.underflow is None):
                                    self.underflow = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth.Underflow()
                                    self.underflow.parent = self
                                    self._children_name_map["underflow"] = "underflow"
                                return self.underflow

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "config" or name == "overflow" or name == "state" or name == "underflow"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.auto_bandwidth is not None and self.auto_bandwidth.has_data()) or
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.auto_bandwidth is not None and self.auto_bandwidth.has_operation()) or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "bandwidth" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "auto-bandwidth"):
                            if (self.auto_bandwidth is None):
                                self.auto_bandwidth = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.AutoBandwidth()
                                self.auto_bandwidth.parent = self
                                self._children_name_map["auto_bandwidth"] = "auto-bandwidth"
                            return self.auto_bandwidth

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "auto-bandwidth" or name == "config" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class P2PTunnelAttributes(Entity):
                    """
                    Parameters related to LSPs of type P2P
                    
                    .. attribute:: config
                    
                    	Configuration parameters for P2P LSPs
                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.Config>`
                    
                    .. attribute:: p2p_primary_paths
                    
                    	List of p2p primary paths for a tunnel
                    	**type**\: list of    :py:class:`P2PPrimaryPaths <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths>`
                    
                    .. attribute:: p2p_secondary_paths
                    
                    	List of p2p primary paths for a tunnel
                    	**type**\: list of    :py:class:`P2PSecondaryPaths <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths>`
                    
                    .. attribute:: state
                    
                    	State parameters for P2P LSPs
                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.State>`
                    
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes, self).__init__()

                        self.yang_name = "p2p-tunnel-attributes"
                        self.yang_parent_name = "tunnel"

                        self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.Config()
                        self.config.parent = self
                        self._children_name_map["config"] = "config"
                        self._children_yang_names.add("config")

                        self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.State()
                        self.state.parent = self
                        self._children_name_map["state"] = "state"
                        self._children_yang_names.add("state")

                        self.p2p_primary_paths = YList(self)
                        self.p2p_secondary_paths = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes, self).__setattr__(name, value)


                    class P2PSecondaryPaths(Entity):
                        """
                        List of p2p primary paths for a tunnel
                        
                        .. attribute:: name  <key>
                        
                        	Path name
                        	**type**\:  str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config>`
                        
                        .. attribute:: admin_groups
                        
                        	Top\-level container for include/exclude constraints for link affinities
                        	**type**\:   :py:class:`AdminGroups <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups>`
                        
                        .. attribute:: config
                        
                        	Configuration parameters related to paths
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config>`
                        
                        .. attribute:: state
                        
                        	State parameters related to paths
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths, self).__init__()

                            self.yang_name = "p2p-secondary-paths"
                            self.yang_parent_name = "p2p-tunnel-attributes"

                            self.name = YLeaf(YType.str, "name")

                            self.admin_groups = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups()
                            self.admin_groups.parent = self
                            self._children_name_map["admin_groups"] = "admin-groups"
                            self._children_yang_names.add("admin-groups")

                            self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration parameters related to paths
                            
                            .. attribute:: cspf_tiebreaker
                            
                            	Determine the tie\-breaking method to choose between equally desirable paths during CSFP computation
                            	**type**\:   :py:class:`CspfTieBreaking <ydk.models.openconfig.openconfig_mpls.CspfTieBreaking>`
                            
                            .. attribute:: explicit_path_name
                            
                            	reference to a defined path
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config>`
                            
                            .. attribute:: hold_priority
                            
                            	preemption priority once the LSP is established, lower is higher priority; default 0 indicates other LSPs will not preempt the LSPs once established
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 0
                            
                            .. attribute:: name
                            
                            	Path name
                            	**type**\:  str
                            
                            .. attribute:: path_computation_method
                            
                            	The method used for computing the path, either locally computed, queried from a server or not computed at all (explicitly configured)
                            	**type**\:   :py:class:`PathComputationMethod <ydk.models.openconfig.openconfig_mpls.PathComputationMethod>`
                            
                            	**default value**\: locally-computed
                            
                            .. attribute:: path_computation_server
                            
                            	Address of the external path computation server
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: preference
                            
                            	Specifies a preference for this path. The lower the number higher the preference
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            .. attribute:: retry_timer
                            
                            	sets the time between attempts to establish the LSP
                            	**type**\:  int
                            
                            	**range:** 1..600
                            
                            	**units**\: seconds
                            
                            .. attribute:: setup_priority
                            
                            	RSVP\-TE preemption priority during LSP setup, lower is higher priority; default 7 indicates that LSP will not preempt established LSPs during setup
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 7
                            
                            .. attribute:: use_cspf
                            
                            	Flag to enable CSPF for locally computed LSPs
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "p2p-secondary-paths"

                                self.cspf_tiebreaker = YLeaf(YType.enumeration, "cspf-tiebreaker")

                                self.explicit_path_name = YLeaf(YType.str, "explicit-path-name")

                                self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                                self.name = YLeaf(YType.str, "name")

                                self.path_computation_method = YLeaf(YType.identityref, "path-computation-method")

                                self.path_computation_server = YLeaf(YType.str, "path-computation-server")

                                self.preference = YLeaf(YType.uint8, "preference")

                                self.retry_timer = YLeaf(YType.uint16, "retry-timer")

                                self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                                self.use_cspf = YLeaf(YType.boolean, "use-cspf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cspf_tiebreaker",
                                                "explicit_path_name",
                                                "hold_priority",
                                                "name",
                                                "path_computation_method",
                                                "path_computation_server",
                                                "preference",
                                                "retry_timer",
                                                "setup_priority",
                                                "use_cspf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cspf_tiebreaker.is_set or
                                    self.explicit_path_name.is_set or
                                    self.hold_priority.is_set or
                                    self.name.is_set or
                                    self.path_computation_method.is_set or
                                    self.path_computation_server.is_set or
                                    self.preference.is_set or
                                    self.retry_timer.is_set or
                                    self.setup_priority.is_set or
                                    self.use_cspf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cspf_tiebreaker.yfilter != YFilter.not_set or
                                    self.explicit_path_name.yfilter != YFilter.not_set or
                                    self.hold_priority.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set or
                                    self.path_computation_method.yfilter != YFilter.not_set or
                                    self.path_computation_server.yfilter != YFilter.not_set or
                                    self.preference.yfilter != YFilter.not_set or
                                    self.retry_timer.yfilter != YFilter.not_set or
                                    self.setup_priority.yfilter != YFilter.not_set or
                                    self.use_cspf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cspf_tiebreaker.is_set or self.cspf_tiebreaker.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cspf_tiebreaker.get_name_leafdata())
                                if (self.explicit_path_name.is_set or self.explicit_path_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.explicit_path_name.get_name_leafdata())
                                if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hold_priority.get_name_leafdata())
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())
                                if (self.path_computation_method.is_set or self.path_computation_method.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_method.get_name_leafdata())
                                if (self.path_computation_server.is_set or self.path_computation_server.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_server.get_name_leafdata())
                                if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preference.get_name_leafdata())
                                if (self.retry_timer.is_set or self.retry_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retry_timer.get_name_leafdata())
                                if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.setup_priority.get_name_leafdata())
                                if (self.use_cspf.is_set or self.use_cspf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.use_cspf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cspf-tiebreaker" or name == "explicit-path-name" or name == "hold-priority" or name == "name" or name == "path-computation-method" or name == "path-computation-server" or name == "preference" or name == "retry-timer" or name == "setup-priority" or name == "use-cspf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cspf-tiebreaker"):
                                    self.cspf_tiebreaker = value
                                    self.cspf_tiebreaker.value_namespace = name_space
                                    self.cspf_tiebreaker.value_namespace_prefix = name_space_prefix
                                if(value_path == "explicit-path-name"):
                                    self.explicit_path_name = value
                                    self.explicit_path_name.value_namespace = name_space
                                    self.explicit_path_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "hold-priority"):
                                    self.hold_priority = value
                                    self.hold_priority.value_namespace = name_space
                                    self.hold_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-method"):
                                    self.path_computation_method = value
                                    self.path_computation_method.value_namespace = name_space
                                    self.path_computation_method.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-server"):
                                    self.path_computation_server = value
                                    self.path_computation_server.value_namespace = name_space
                                    self.path_computation_server.value_namespace_prefix = name_space_prefix
                                if(value_path == "preference"):
                                    self.preference = value
                                    self.preference.value_namespace = name_space
                                    self.preference.value_namespace_prefix = name_space_prefix
                                if(value_path == "retry-timer"):
                                    self.retry_timer = value
                                    self.retry_timer.value_namespace = name_space
                                    self.retry_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "setup-priority"):
                                    self.setup_priority = value
                                    self.setup_priority.value_namespace = name_space
                                    self.setup_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "use-cspf"):
                                    self.use_cspf = value
                                    self.use_cspf.value_namespace = name_space
                                    self.use_cspf.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State parameters related to paths
                            
                            .. attribute:: cspf_tiebreaker
                            
                            	Determine the tie\-breaking method to choose between equally desirable paths during CSFP computation
                            	**type**\:   :py:class:`CspfTieBreaking <ydk.models.openconfig.openconfig_mpls.CspfTieBreaking>`
                            
                            .. attribute:: explicit_path_name
                            
                            	reference to a defined path
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config>`
                            
                            .. attribute:: hold_priority
                            
                            	preemption priority once the LSP is established, lower is higher priority; default 0 indicates other LSPs will not preempt the LSPs once established
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 0
                            
                            .. attribute:: name
                            
                            	Path name
                            	**type**\:  str
                            
                            .. attribute:: path_computation_method
                            
                            	The method used for computing the path, either locally computed, queried from a server or not computed at all (explicitly configured)
                            	**type**\:   :py:class:`PathComputationMethod <ydk.models.openconfig.openconfig_mpls.PathComputationMethod>`
                            
                            	**default value**\: locally-computed
                            
                            .. attribute:: path_computation_server
                            
                            	Address of the external path computation server
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: preference
                            
                            	Specifies a preference for this path. The lower the number higher the preference
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            .. attribute:: retry_timer
                            
                            	sets the time between attempts to establish the LSP
                            	**type**\:  int
                            
                            	**range:** 1..600
                            
                            	**units**\: seconds
                            
                            .. attribute:: setup_priority
                            
                            	RSVP\-TE preemption priority during LSP setup, lower is higher priority; default 7 indicates that LSP will not preempt established LSPs during setup
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 7
                            
                            .. attribute:: use_cspf
                            
                            	Flag to enable CSPF for locally computed LSPs
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "p2p-secondary-paths"

                                self.cspf_tiebreaker = YLeaf(YType.enumeration, "cspf-tiebreaker")

                                self.explicit_path_name = YLeaf(YType.str, "explicit-path-name")

                                self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                                self.name = YLeaf(YType.str, "name")

                                self.path_computation_method = YLeaf(YType.identityref, "path-computation-method")

                                self.path_computation_server = YLeaf(YType.str, "path-computation-server")

                                self.preference = YLeaf(YType.uint8, "preference")

                                self.retry_timer = YLeaf(YType.uint16, "retry-timer")

                                self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                                self.use_cspf = YLeaf(YType.boolean, "use-cspf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cspf_tiebreaker",
                                                "explicit_path_name",
                                                "hold_priority",
                                                "name",
                                                "path_computation_method",
                                                "path_computation_server",
                                                "preference",
                                                "retry_timer",
                                                "setup_priority",
                                                "use_cspf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cspf_tiebreaker.is_set or
                                    self.explicit_path_name.is_set or
                                    self.hold_priority.is_set or
                                    self.name.is_set or
                                    self.path_computation_method.is_set or
                                    self.path_computation_server.is_set or
                                    self.preference.is_set or
                                    self.retry_timer.is_set or
                                    self.setup_priority.is_set or
                                    self.use_cspf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cspf_tiebreaker.yfilter != YFilter.not_set or
                                    self.explicit_path_name.yfilter != YFilter.not_set or
                                    self.hold_priority.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set or
                                    self.path_computation_method.yfilter != YFilter.not_set or
                                    self.path_computation_server.yfilter != YFilter.not_set or
                                    self.preference.yfilter != YFilter.not_set or
                                    self.retry_timer.yfilter != YFilter.not_set or
                                    self.setup_priority.yfilter != YFilter.not_set or
                                    self.use_cspf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cspf_tiebreaker.is_set or self.cspf_tiebreaker.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cspf_tiebreaker.get_name_leafdata())
                                if (self.explicit_path_name.is_set or self.explicit_path_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.explicit_path_name.get_name_leafdata())
                                if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hold_priority.get_name_leafdata())
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())
                                if (self.path_computation_method.is_set or self.path_computation_method.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_method.get_name_leafdata())
                                if (self.path_computation_server.is_set or self.path_computation_server.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_server.get_name_leafdata())
                                if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preference.get_name_leafdata())
                                if (self.retry_timer.is_set or self.retry_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retry_timer.get_name_leafdata())
                                if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.setup_priority.get_name_leafdata())
                                if (self.use_cspf.is_set or self.use_cspf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.use_cspf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cspf-tiebreaker" or name == "explicit-path-name" or name == "hold-priority" or name == "name" or name == "path-computation-method" or name == "path-computation-server" or name == "preference" or name == "retry-timer" or name == "setup-priority" or name == "use-cspf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cspf-tiebreaker"):
                                    self.cspf_tiebreaker = value
                                    self.cspf_tiebreaker.value_namespace = name_space
                                    self.cspf_tiebreaker.value_namespace_prefix = name_space_prefix
                                if(value_path == "explicit-path-name"):
                                    self.explicit_path_name = value
                                    self.explicit_path_name.value_namespace = name_space
                                    self.explicit_path_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "hold-priority"):
                                    self.hold_priority = value
                                    self.hold_priority.value_namespace = name_space
                                    self.hold_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-method"):
                                    self.path_computation_method = value
                                    self.path_computation_method.value_namespace = name_space
                                    self.path_computation_method.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-server"):
                                    self.path_computation_server = value
                                    self.path_computation_server.value_namespace = name_space
                                    self.path_computation_server.value_namespace_prefix = name_space_prefix
                                if(value_path == "preference"):
                                    self.preference = value
                                    self.preference.value_namespace = name_space
                                    self.preference.value_namespace_prefix = name_space_prefix
                                if(value_path == "retry-timer"):
                                    self.retry_timer = value
                                    self.retry_timer.value_namespace = name_space
                                    self.retry_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "setup-priority"):
                                    self.setup_priority = value
                                    self.setup_priority.value_namespace = name_space
                                    self.setup_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "use-cspf"):
                                    self.use_cspf = value
                                    self.use_cspf.value_namespace = name_space
                                    self.use_cspf.value_namespace_prefix = name_space_prefix


                        class AdminGroups(Entity):
                            """
                            Top\-level container for include/exclude constraints for
                            link affinities
                            
                            .. attribute:: config
                            
                            	Configuration data 
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.Config>`
                            
                            .. attribute:: state
                            
                            	Operational state data 
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.State>`
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups, self).__init__()

                                self.yang_name = "admin-groups"
                                self.yang_parent_name = "p2p-secondary-paths"

                                self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration data 
                                
                                .. attribute:: exclude_group
                                
                                	list of references to named admin\-groups to exclude in path calculation
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_all_group
                                
                                	list of references to named admin\-groups of which all must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_any_group
                                
                                	list of references to named admin\-groups of which one must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "admin-groups"

                                    self.exclude_group = YLeafList(YType.str, "exclude-group")

                                    self.include_all_group = YLeafList(YType.str, "include-all-group")

                                    self.include_any_group = YLeafList(YType.str, "include-any-group")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("exclude_group",
                                                    "include_all_group",
                                                    "include_any_group") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    return False

                                def has_operation(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.exclude_group.yfilter != YFilter.not_set or
                                        self.include_all_group.yfilter != YFilter.not_set or
                                        self.include_any_group.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    leaf_name_data.extend(self.exclude_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_all_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_any_group.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-group" or name == "include-all-group" or name == "include-any-group"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "exclude-group"):
                                        self.exclude_group.append(value)
                                    if(value_path == "include-all-group"):
                                        self.include_all_group.append(value)
                                    if(value_path == "include-any-group"):
                                        self.include_any_group.append(value)


                            class State(Entity):
                                """
                                Operational state data 
                                
                                .. attribute:: exclude_group
                                
                                	list of references to named admin\-groups to exclude in path calculation
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_all_group
                                
                                	list of references to named admin\-groups of which all must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_any_group
                                
                                	list of references to named admin\-groups of which one must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "admin-groups"

                                    self.exclude_group = YLeafList(YType.str, "exclude-group")

                                    self.include_all_group = YLeafList(YType.str, "include-all-group")

                                    self.include_any_group = YLeafList(YType.str, "include-any-group")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("exclude_group",
                                                    "include_all_group",
                                                    "include_any_group") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.State, self).__setattr__(name, value)

                                def has_data(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    return False

                                def has_operation(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.exclude_group.yfilter != YFilter.not_set or
                                        self.include_all_group.yfilter != YFilter.not_set or
                                        self.include_any_group.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    leaf_name_data.extend(self.exclude_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_all_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_any_group.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-group" or name == "include-all-group" or name == "include-any-group"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "exclude-group"):
                                        self.exclude_group.append(value)
                                    if(value_path == "include-all-group"):
                                        self.include_all_group.append(value)
                                    if(value_path == "include-any-group"):
                                        self.include_any_group.append(value)

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "admin-groups" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.name.is_set or
                                (self.admin_groups is not None and self.admin_groups.has_data()) or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set or
                                (self.admin_groups is not None and self.admin_groups.has_operation()) or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "p2p-secondary-paths" + "[name='" + self.name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "admin-groups"):
                                if (self.admin_groups is None):
                                    self.admin_groups = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.AdminGroups()
                                    self.admin_groups.parent = self
                                    self._children_name_map["admin_groups"] = "admin-groups"
                                return self.admin_groups

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "admin-groups" or name == "config" or name == "state" or name == "name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix


                    class State(Entity):
                        """
                        State parameters for P2P LSPs
                        
                        .. attribute:: destination
                        
                        	P2P tunnel destination address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.State, self).__init__()

                            self.yang_name = "state"
                            self.yang_parent_name = "p2p-tunnel-attributes"

                            self.destination = YLeaf(YType.str, "destination")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("destination") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.State, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.State, self).__setattr__(name, value)

                        def has_data(self):
                            return self.destination.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.destination.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "destination"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "destination"):
                                self.destination = value
                                self.destination.value_namespace = name_space
                                self.destination.value_namespace_prefix = name_space_prefix


                    class Config(Entity):
                        """
                        Configuration parameters for P2P LSPs
                        
                        .. attribute:: destination
                        
                        	P2P tunnel destination address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.Config, self).__init__()

                            self.yang_name = "config"
                            self.yang_parent_name = "p2p-tunnel-attributes"

                            self.destination = YLeaf(YType.str, "destination")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("destination") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.Config, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.Config, self).__setattr__(name, value)

                        def has_data(self):
                            return self.destination.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.destination.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "config" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "destination"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "destination"):
                                self.destination = value
                                self.destination.value_namespace = name_space
                                self.destination.value_namespace_prefix = name_space_prefix


                    class P2PPrimaryPaths(Entity):
                        """
                        List of p2p primary paths for a tunnel
                        
                        .. attribute:: name  <key>
                        
                        	Path name
                        	**type**\:  str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config>`
                        
                        .. attribute:: admin_groups
                        
                        	Top\-level container for include/exclude constraints for link affinities
                        	**type**\:   :py:class:`AdminGroups <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups>`
                        
                        .. attribute:: candidate_secondary_paths
                        
                        	The set of candidate secondary paths which may be used for this primary path. When secondary paths are specified in the list the path of the secondary LSP in use must be restricted to those path options referenced. The priority of the secondary paths is specified within the list. Higher priority values are less preferred \- that is to say that a path with priority 0 is the most preferred path. In the case that the list is empty, any secondary path option may be utilised when the current primary path is in use
                        	**type**\:   :py:class:`CandidateSecondaryPaths <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths>`
                        
                        .. attribute:: config
                        
                        	Configuration parameters related to paths
                        	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config>`
                        
                        .. attribute:: state
                        
                        	State parameters related to paths
                        	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.State>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths, self).__init__()

                            self.yang_name = "p2p-primary-paths"
                            self.yang_parent_name = "p2p-tunnel-attributes"

                            self.name = YLeaf(YType.str, "name")

                            self.admin_groups = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups()
                            self.admin_groups.parent = self
                            self._children_name_map["admin_groups"] = "admin-groups"
                            self._children_yang_names.add("admin-groups")

                            self.candidate_secondary_paths = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths()
                            self.candidate_secondary_paths.parent = self
                            self._children_name_map["candidate_secondary_paths"] = "candidate-secondary-paths"
                            self._children_yang_names.add("candidate-secondary-paths")

                            self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                            self._children_yang_names.add("config")

                            self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                            self._children_yang_names.add("state")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths, self).__setattr__(name, value)


                        class Config(Entity):
                            """
                            Configuration parameters related to paths
                            
                            .. attribute:: cspf_tiebreaker
                            
                            	Determine the tie\-breaking method to choose between equally desirable paths during CSFP computation
                            	**type**\:   :py:class:`CspfTieBreaking <ydk.models.openconfig.openconfig_mpls.CspfTieBreaking>`
                            
                            .. attribute:: explicit_path_name
                            
                            	reference to a defined path
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config>`
                            
                            .. attribute:: hold_priority
                            
                            	preemption priority once the LSP is established, lower is higher priority; default 0 indicates other LSPs will not preempt the LSPs once established
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 0
                            
                            .. attribute:: name
                            
                            	Path name
                            	**type**\:  str
                            
                            .. attribute:: path_computation_method
                            
                            	The method used for computing the path, either locally computed, queried from a server or not computed at all (explicitly configured)
                            	**type**\:   :py:class:`PathComputationMethod <ydk.models.openconfig.openconfig_mpls.PathComputationMethod>`
                            
                            	**default value**\: locally-computed
                            
                            .. attribute:: path_computation_server
                            
                            	Address of the external path computation server
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: preference
                            
                            	Specifies a preference for this path. The lower the number higher the preference
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            .. attribute:: retry_timer
                            
                            	sets the time between attempts to establish the LSP
                            	**type**\:  int
                            
                            	**range:** 1..600
                            
                            	**units**\: seconds
                            
                            .. attribute:: setup_priority
                            
                            	RSVP\-TE preemption priority during LSP setup, lower is higher priority; default 7 indicates that LSP will not preempt established LSPs during setup
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 7
                            
                            .. attribute:: use_cspf
                            
                            	Flag to enable CSPF for locally computed LSPs
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config, self).__init__()

                                self.yang_name = "config"
                                self.yang_parent_name = "p2p-primary-paths"

                                self.cspf_tiebreaker = YLeaf(YType.enumeration, "cspf-tiebreaker")

                                self.explicit_path_name = YLeaf(YType.str, "explicit-path-name")

                                self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                                self.name = YLeaf(YType.str, "name")

                                self.path_computation_method = YLeaf(YType.identityref, "path-computation-method")

                                self.path_computation_server = YLeaf(YType.str, "path-computation-server")

                                self.preference = YLeaf(YType.uint8, "preference")

                                self.retry_timer = YLeaf(YType.uint16, "retry-timer")

                                self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                                self.use_cspf = YLeaf(YType.boolean, "use-cspf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cspf_tiebreaker",
                                                "explicit_path_name",
                                                "hold_priority",
                                                "name",
                                                "path_computation_method",
                                                "path_computation_server",
                                                "preference",
                                                "retry_timer",
                                                "setup_priority",
                                                "use_cspf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cspf_tiebreaker.is_set or
                                    self.explicit_path_name.is_set or
                                    self.hold_priority.is_set or
                                    self.name.is_set or
                                    self.path_computation_method.is_set or
                                    self.path_computation_server.is_set or
                                    self.preference.is_set or
                                    self.retry_timer.is_set or
                                    self.setup_priority.is_set or
                                    self.use_cspf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cspf_tiebreaker.yfilter != YFilter.not_set or
                                    self.explicit_path_name.yfilter != YFilter.not_set or
                                    self.hold_priority.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set or
                                    self.path_computation_method.yfilter != YFilter.not_set or
                                    self.path_computation_server.yfilter != YFilter.not_set or
                                    self.preference.yfilter != YFilter.not_set or
                                    self.retry_timer.yfilter != YFilter.not_set or
                                    self.setup_priority.yfilter != YFilter.not_set or
                                    self.use_cspf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "config" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cspf_tiebreaker.is_set or self.cspf_tiebreaker.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cspf_tiebreaker.get_name_leafdata())
                                if (self.explicit_path_name.is_set or self.explicit_path_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.explicit_path_name.get_name_leafdata())
                                if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hold_priority.get_name_leafdata())
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())
                                if (self.path_computation_method.is_set or self.path_computation_method.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_method.get_name_leafdata())
                                if (self.path_computation_server.is_set or self.path_computation_server.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_server.get_name_leafdata())
                                if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preference.get_name_leafdata())
                                if (self.retry_timer.is_set or self.retry_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retry_timer.get_name_leafdata())
                                if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.setup_priority.get_name_leafdata())
                                if (self.use_cspf.is_set or self.use_cspf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.use_cspf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cspf-tiebreaker" or name == "explicit-path-name" or name == "hold-priority" or name == "name" or name == "path-computation-method" or name == "path-computation-server" or name == "preference" or name == "retry-timer" or name == "setup-priority" or name == "use-cspf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cspf-tiebreaker"):
                                    self.cspf_tiebreaker = value
                                    self.cspf_tiebreaker.value_namespace = name_space
                                    self.cspf_tiebreaker.value_namespace_prefix = name_space_prefix
                                if(value_path == "explicit-path-name"):
                                    self.explicit_path_name = value
                                    self.explicit_path_name.value_namespace = name_space
                                    self.explicit_path_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "hold-priority"):
                                    self.hold_priority = value
                                    self.hold_priority.value_namespace = name_space
                                    self.hold_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-method"):
                                    self.path_computation_method = value
                                    self.path_computation_method.value_namespace = name_space
                                    self.path_computation_method.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-server"):
                                    self.path_computation_server = value
                                    self.path_computation_server.value_namespace = name_space
                                    self.path_computation_server.value_namespace_prefix = name_space_prefix
                                if(value_path == "preference"):
                                    self.preference = value
                                    self.preference.value_namespace = name_space
                                    self.preference.value_namespace_prefix = name_space_prefix
                                if(value_path == "retry-timer"):
                                    self.retry_timer = value
                                    self.retry_timer.value_namespace = name_space
                                    self.retry_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "setup-priority"):
                                    self.setup_priority = value
                                    self.setup_priority.value_namespace = name_space
                                    self.setup_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "use-cspf"):
                                    self.use_cspf = value
                                    self.use_cspf.value_namespace = name_space
                                    self.use_cspf.value_namespace_prefix = name_space_prefix


                        class State(Entity):
                            """
                            State parameters related to paths
                            
                            .. attribute:: cspf_tiebreaker
                            
                            	Determine the tie\-breaking method to choose between equally desirable paths during CSFP computation
                            	**type**\:   :py:class:`CspfTieBreaking <ydk.models.openconfig.openconfig_mpls.CspfTieBreaking>`
                            
                            .. attribute:: explicit_path_name
                            
                            	reference to a defined path
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.NamedExplicitPaths.Config>`
                            
                            .. attribute:: hold_priority
                            
                            	preemption priority once the LSP is established, lower is higher priority; default 0 indicates other LSPs will not preempt the LSPs once established
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 0
                            
                            .. attribute:: name
                            
                            	Path name
                            	**type**\:  str
                            
                            .. attribute:: path_computation_method
                            
                            	The method used for computing the path, either locally computed, queried from a server or not computed at all (explicitly configured)
                            	**type**\:   :py:class:`PathComputationMethod <ydk.models.openconfig.openconfig_mpls.PathComputationMethod>`
                            
                            	**default value**\: locally-computed
                            
                            .. attribute:: path_computation_server
                            
                            	Address of the external path computation server
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: preference
                            
                            	Specifies a preference for this path. The lower the number higher the preference
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            .. attribute:: retry_timer
                            
                            	sets the time between attempts to establish the LSP
                            	**type**\:  int
                            
                            	**range:** 1..600
                            
                            	**units**\: seconds
                            
                            .. attribute:: setup_priority
                            
                            	RSVP\-TE preemption priority during LSP setup, lower is higher priority; default 7 indicates that LSP will not preempt established LSPs during setup
                            	**type**\:  int
                            
                            	**range:** 0..7
                            
                            	**default value**\: 7
                            
                            .. attribute:: use_cspf
                            
                            	Flag to enable CSPF for locally computed LSPs
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.State, self).__init__()

                                self.yang_name = "state"
                                self.yang_parent_name = "p2p-primary-paths"

                                self.cspf_tiebreaker = YLeaf(YType.enumeration, "cspf-tiebreaker")

                                self.explicit_path_name = YLeaf(YType.str, "explicit-path-name")

                                self.hold_priority = YLeaf(YType.uint8, "hold-priority")

                                self.name = YLeaf(YType.str, "name")

                                self.path_computation_method = YLeaf(YType.identityref, "path-computation-method")

                                self.path_computation_server = YLeaf(YType.str, "path-computation-server")

                                self.preference = YLeaf(YType.uint8, "preference")

                                self.retry_timer = YLeaf(YType.uint16, "retry-timer")

                                self.setup_priority = YLeaf(YType.uint8, "setup-priority")

                                self.use_cspf = YLeaf(YType.boolean, "use-cspf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cspf_tiebreaker",
                                                "explicit_path_name",
                                                "hold_priority",
                                                "name",
                                                "path_computation_method",
                                                "path_computation_server",
                                                "preference",
                                                "retry_timer",
                                                "setup_priority",
                                                "use_cspf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.State, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.State, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.cspf_tiebreaker.is_set or
                                    self.explicit_path_name.is_set or
                                    self.hold_priority.is_set or
                                    self.name.is_set or
                                    self.path_computation_method.is_set or
                                    self.path_computation_server.is_set or
                                    self.preference.is_set or
                                    self.retry_timer.is_set or
                                    self.setup_priority.is_set or
                                    self.use_cspf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cspf_tiebreaker.yfilter != YFilter.not_set or
                                    self.explicit_path_name.yfilter != YFilter.not_set or
                                    self.hold_priority.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set or
                                    self.path_computation_method.yfilter != YFilter.not_set or
                                    self.path_computation_server.yfilter != YFilter.not_set or
                                    self.preference.yfilter != YFilter.not_set or
                                    self.retry_timer.yfilter != YFilter.not_set or
                                    self.setup_priority.yfilter != YFilter.not_set or
                                    self.use_cspf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cspf_tiebreaker.is_set or self.cspf_tiebreaker.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cspf_tiebreaker.get_name_leafdata())
                                if (self.explicit_path_name.is_set or self.explicit_path_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.explicit_path_name.get_name_leafdata())
                                if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hold_priority.get_name_leafdata())
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())
                                if (self.path_computation_method.is_set or self.path_computation_method.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_method.get_name_leafdata())
                                if (self.path_computation_server.is_set or self.path_computation_server.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_computation_server.get_name_leafdata())
                                if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preference.get_name_leafdata())
                                if (self.retry_timer.is_set or self.retry_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retry_timer.get_name_leafdata())
                                if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.setup_priority.get_name_leafdata())
                                if (self.use_cspf.is_set or self.use_cspf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.use_cspf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cspf-tiebreaker" or name == "explicit-path-name" or name == "hold-priority" or name == "name" or name == "path-computation-method" or name == "path-computation-server" or name == "preference" or name == "retry-timer" or name == "setup-priority" or name == "use-cspf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cspf-tiebreaker"):
                                    self.cspf_tiebreaker = value
                                    self.cspf_tiebreaker.value_namespace = name_space
                                    self.cspf_tiebreaker.value_namespace_prefix = name_space_prefix
                                if(value_path == "explicit-path-name"):
                                    self.explicit_path_name = value
                                    self.explicit_path_name.value_namespace = name_space
                                    self.explicit_path_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "hold-priority"):
                                    self.hold_priority = value
                                    self.hold_priority.value_namespace = name_space
                                    self.hold_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-method"):
                                    self.path_computation_method = value
                                    self.path_computation_method.value_namespace = name_space
                                    self.path_computation_method.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-computation-server"):
                                    self.path_computation_server = value
                                    self.path_computation_server.value_namespace = name_space
                                    self.path_computation_server.value_namespace_prefix = name_space_prefix
                                if(value_path == "preference"):
                                    self.preference = value
                                    self.preference.value_namespace = name_space
                                    self.preference.value_namespace_prefix = name_space_prefix
                                if(value_path == "retry-timer"):
                                    self.retry_timer = value
                                    self.retry_timer.value_namespace = name_space
                                    self.retry_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "setup-priority"):
                                    self.setup_priority = value
                                    self.setup_priority.value_namespace = name_space
                                    self.setup_priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "use-cspf"):
                                    self.use_cspf = value
                                    self.use_cspf.value_namespace = name_space
                                    self.use_cspf.value_namespace_prefix = name_space_prefix


                        class CandidateSecondaryPaths(Entity):
                            """
                            The set of candidate secondary paths which may be used
                            for this primary path. When secondary paths are specified
                            in the list the path of the secondary LSP in use must be
                            restricted to those path options referenced. The
                            priority of the secondary paths is specified within the
                            list. Higher priority values are less preferred \- that is
                            to say that a path with priority 0 is the most preferred
                            path. In the case that the list is empty, any secondary
                            path option may be utilised when the current primary path
                            is in use.
                            
                            .. attribute:: candidate_secondary_path
                            
                            	List of secondary paths which may be utilised when the current primary path is in use
                            	**type**\: list of    :py:class:`CandidateSecondaryPath <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath>`
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths, self).__init__()

                                self.yang_name = "candidate-secondary-paths"
                                self.yang_parent_name = "p2p-primary-paths"

                                self.candidate_secondary_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths, self).__setattr__(name, value)


                            class CandidateSecondaryPath(Entity):
                                """
                                List of secondary paths which may be utilised when the
                                current primary path is in use
                                
                                .. attribute:: secondary_path  <key>
                                
                                	A reference to the secondary path option reference which acts as the key of the candidate\-secondary\-path list
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`secondary_path <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config>`
                                
                                .. attribute:: config
                                
                                	Configuration parameters relating to the candidate secondary path
                                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config>`
                                
                                .. attribute:: state
                                
                                	Operational state parameters relating to the candidate secondary path
                                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.State>`
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath, self).__init__()

                                    self.yang_name = "candidate-secondary-path"
                                    self.yang_parent_name = "candidate-secondary-paths"

                                    self.secondary_path = YLeaf(YType.str, "secondary-path")

                                    self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                    self._children_yang_names.add("config")

                                    self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                    self._children_yang_names.add("state")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("secondary_path") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath, self).__setattr__(name, value)


                                class Config(Entity):
                                    """
                                    Configuration parameters relating to the candidate
                                    secondary path
                                    
                                    .. attribute:: priority
                                    
                                    	The priority of the specified secondary path option. Higher priority options are less preferable \- such that a secondary path reference with a priority of 0 is the most preferred
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: secondary_path
                                    
                                    	A reference to the secondary path that should be utilised when the containing primary path option is in use
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config>`
                                    
                                    

                                    """

                                    _prefix = 'mpls'
                                    _revision = '2015-11-05'

                                    def __init__(self):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config, self).__init__()

                                        self.yang_name = "config"
                                        self.yang_parent_name = "candidate-secondary-path"

                                        self.priority = YLeaf(YType.uint16, "priority")

                                        self.secondary_path = YLeaf(YType.str, "secondary-path")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("priority",
                                                        "secondary_path") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.priority.is_set or
                                            self.secondary_path.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.secondary_path.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "config" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.secondary_path.is_set or self.secondary_path.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.secondary_path.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "priority" or name == "secondary-path"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "secondary-path"):
                                            self.secondary_path = value
                                            self.secondary_path.value_namespace = name_space
                                            self.secondary_path.value_namespace_prefix = name_space_prefix


                                class State(Entity):
                                    """
                                    Operational state parameters relating to the candidate
                                    secondary path
                                    
                                    .. attribute:: active
                                    
                                    	Indicates the current active path option that has been selected of the candidate secondary paths
                                    	**type**\:  bool
                                    
                                    .. attribute:: priority
                                    
                                    	The priority of the specified secondary path option. Higher priority options are less preferable \- such that a secondary path reference with a priority of 0 is the most preferred
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: secondary_path
                                    
                                    	A reference to the secondary path that should be utilised when the containing primary path option is in use
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths.Config>`
                                    
                                    

                                    """

                                    _prefix = 'mpls'
                                    _revision = '2015-11-05'

                                    def __init__(self):
                                        super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.State, self).__init__()

                                        self.yang_name = "state"
                                        self.yang_parent_name = "candidate-secondary-path"

                                        self.active = YLeaf(YType.boolean, "active")

                                        self.priority = YLeaf(YType.uint16, "priority")

                                        self.secondary_path = YLeaf(YType.str, "secondary-path")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("active",
                                                        "priority",
                                                        "secondary_path") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.State, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.State, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.active.is_set or
                                            self.priority.is_set or
                                            self.secondary_path.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.active.yfilter != YFilter.not_set or
                                            self.priority.yfilter != YFilter.not_set or
                                            self.secondary_path.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "state" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.active.get_name_leafdata())
                                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.priority.get_name_leafdata())
                                        if (self.secondary_path.is_set or self.secondary_path.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.secondary_path.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "active" or name == "priority" or name == "secondary-path"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "active"):
                                            self.active = value
                                            self.active.value_namespace = name_space
                                            self.active.value_namespace_prefix = name_space_prefix
                                        if(value_path == "priority"):
                                            self.priority = value
                                            self.priority.value_namespace = name_space
                                            self.priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "secondary-path"):
                                            self.secondary_path = value
                                            self.secondary_path.value_namespace = name_space
                                            self.secondary_path.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.secondary_path.is_set or
                                        (self.config is not None and self.config.has_data()) or
                                        (self.state is not None and self.state.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.secondary_path.yfilter != YFilter.not_set or
                                        (self.config is not None and self.config.has_operation()) or
                                        (self.state is not None and self.state.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "candidate-secondary-path" + "[secondary-path='" + self.secondary_path.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.secondary_path.is_set or self.secondary_path.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.secondary_path.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "config"):
                                        if (self.config is None):
                                            self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.Config()
                                            self.config.parent = self
                                            self._children_name_map["config"] = "config"
                                        return self.config

                                    if (child_yang_name == "state"):
                                        if (self.state is None):
                                            self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath.State()
                                            self.state.parent = self
                                            self._children_name_map["state"] = "state"
                                        return self.state

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "config" or name == "state" or name == "secondary-path"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "secondary-path"):
                                        self.secondary_path = value
                                        self.secondary_path.value_namespace = name_space
                                        self.secondary_path.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.candidate_secondary_path:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.candidate_secondary_path:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "candidate-secondary-paths" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "candidate-secondary-path"):
                                    for c in self.candidate_secondary_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths.CandidateSecondaryPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.candidate_secondary_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "candidate-secondary-path"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class AdminGroups(Entity):
                            """
                            Top\-level container for include/exclude constraints for
                            link affinities
                            
                            .. attribute:: config
                            
                            	Configuration data 
                            	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.Config>`
                            
                            .. attribute:: state
                            
                            	Operational state data 
                            	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.State>`
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups, self).__init__()

                                self.yang_name = "admin-groups"
                                self.yang_parent_name = "p2p-primary-paths"

                                self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                                self._children_yang_names.add("config")

                                self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                                self._children_yang_names.add("state")


                            class Config(Entity):
                                """
                                Configuration data 
                                
                                .. attribute:: exclude_group
                                
                                	list of references to named admin\-groups to exclude in path calculation
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_all_group
                                
                                	list of references to named admin\-groups of which all must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_any_group
                                
                                	list of references to named admin\-groups of which one must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.Config, self).__init__()

                                    self.yang_name = "config"
                                    self.yang_parent_name = "admin-groups"

                                    self.exclude_group = YLeafList(YType.str, "exclude-group")

                                    self.include_all_group = YLeafList(YType.str, "include-all-group")

                                    self.include_any_group = YLeafList(YType.str, "include-any-group")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("exclude_group",
                                                    "include_all_group",
                                                    "include_any_group") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.Config, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.Config, self).__setattr__(name, value)

                                def has_data(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    return False

                                def has_operation(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.exclude_group.yfilter != YFilter.not_set or
                                        self.include_all_group.yfilter != YFilter.not_set or
                                        self.include_any_group.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "config" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    leaf_name_data.extend(self.exclude_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_all_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_any_group.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-group" or name == "include-all-group" or name == "include-any-group"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "exclude-group"):
                                        self.exclude_group.append(value)
                                    if(value_path == "include-all-group"):
                                        self.include_all_group.append(value)
                                    if(value_path == "include-any-group"):
                                        self.include_any_group.append(value)


                            class State(Entity):
                                """
                                Operational state data 
                                
                                .. attribute:: exclude_group
                                
                                	list of references to named admin\-groups to exclude in path calculation
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_all_group
                                
                                	list of references to named admin\-groups of which all must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                .. attribute:: include_any_group
                                
                                	list of references to named admin\-groups of which one must be included
                                	**type**\:  list of str
                                
                                	**refers to**\:  :py:class:`admin_group_name <ydk.models.openconfig.openconfig_mpls.Mpls.TeGlobalAttributes.MplsAdminGroups.AdminGroup>`
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.State, self).__init__()

                                    self.yang_name = "state"
                                    self.yang_parent_name = "admin-groups"

                                    self.exclude_group = YLeafList(YType.str, "exclude-group")

                                    self.include_all_group = YLeafList(YType.str, "include-all-group")

                                    self.include_any_group = YLeafList(YType.str, "include-any-group")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("exclude_group",
                                                    "include_all_group",
                                                    "include_any_group") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.State, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.State, self).__setattr__(name, value)

                                def has_data(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.yfilter != YFilter.not_set):
                                            return True
                                    return False

                                def has_operation(self):
                                    for leaf in self.exclude_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_all_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    for leaf in self.include_any_group.getYLeafs():
                                        if (leaf.is_set):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.exclude_group.yfilter != YFilter.not_set or
                                        self.include_all_group.yfilter != YFilter.not_set or
                                        self.include_any_group.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    leaf_name_data.extend(self.exclude_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_all_group.get_name_leafdata())

                                    leaf_name_data.extend(self.include_any_group.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exclude-group" or name == "include-all-group" or name == "include-any-group"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "exclude-group"):
                                        self.exclude_group.append(value)
                                    if(value_path == "include-all-group"):
                                        self.include_all_group.append(value)
                                    if(value_path == "include-any-group"):
                                        self.include_any_group.append(value)

                            def has_data(self):
                                return (
                                    (self.config is not None and self.config.has_data()) or
                                    (self.state is not None and self.state.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.config is not None and self.config.has_operation()) or
                                    (self.state is not None and self.state.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "admin-groups" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "config"):
                                    if (self.config is None):
                                        self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                    return self.config

                                if (child_yang_name == "state"):
                                    if (self.state is None):
                                        self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                    return self.state

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "config" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.name.is_set or
                                (self.admin_groups is not None and self.admin_groups.has_data()) or
                                (self.candidate_secondary_paths is not None and self.candidate_secondary_paths.has_data()) or
                                (self.config is not None and self.config.has_data()) or
                                (self.state is not None and self.state.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set or
                                (self.admin_groups is not None and self.admin_groups.has_operation()) or
                                (self.candidate_secondary_paths is not None and self.candidate_secondary_paths.has_operation()) or
                                (self.config is not None and self.config.has_operation()) or
                                (self.state is not None and self.state.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "p2p-primary-paths" + "[name='" + self.name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "admin-groups"):
                                if (self.admin_groups is None):
                                    self.admin_groups = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.AdminGroups()
                                    self.admin_groups.parent = self
                                    self._children_name_map["admin_groups"] = "admin-groups"
                                return self.admin_groups

                            if (child_yang_name == "candidate-secondary-paths"):
                                if (self.candidate_secondary_paths is None):
                                    self.candidate_secondary_paths = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.CandidateSecondaryPaths()
                                    self.candidate_secondary_paths.parent = self
                                    self._children_name_map["candidate_secondary_paths"] = "candidate-secondary-paths"
                                return self.candidate_secondary_paths

                            if (child_yang_name == "config"):
                                if (self.config is None):
                                    self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                return self.config

                            if (child_yang_name == "state"):
                                if (self.state is None):
                                    self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                return self.state

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "admin-groups" or name == "candidate-secondary-paths" or name == "config" or name == "state" or name == "name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.p2p_primary_paths:
                            if (c.has_data()):
                                return True
                        for c in self.p2p_secondary_paths:
                            if (c.has_data()):
                                return True
                        return (
                            (self.config is not None and self.config.has_data()) or
                            (self.state is not None and self.state.has_data()))

                    def has_operation(self):
                        for c in self.p2p_primary_paths:
                            if (c.has_operation()):
                                return True
                        for c in self.p2p_secondary_paths:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.config is not None and self.config.has_operation()) or
                            (self.state is not None and self.state.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "p2p-tunnel-attributes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "config"):
                            if (self.config is None):
                                self.config = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.Config()
                                self.config.parent = self
                                self._children_name_map["config"] = "config"
                            return self.config

                        if (child_yang_name == "p2p-primary-paths"):
                            for c in self.p2p_primary_paths:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PPrimaryPaths()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.p2p_primary_paths.append(c)
                            return c

                        if (child_yang_name == "p2p-secondary-paths"):
                            for c in self.p2p_secondary_paths:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.P2PSecondaryPaths()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.p2p_secondary_paths.append(c)
                            return c

                        if (child_yang_name == "state"):
                            if (self.state is None):
                                self.state = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes.State()
                                self.state.parent = self
                                self._children_name_map["state"] = "state"
                            return self.state

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "config" or name == "p2p-primary-paths" or name == "p2p-secondary-paths" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.name.is_set or
                        self.type.is_set or
                        (self.bandwidth is not None and self.bandwidth.has_data()) or
                        (self.config is not None and self.config.has_data()) or
                        (self.p2p_tunnel_attributes is not None and self.p2p_tunnel_attributes.has_data()) or
                        (self.state is not None and self.state.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set or
                        (self.bandwidth is not None and self.bandwidth.has_operation()) or
                        (self.config is not None and self.config.has_operation()) or
                        (self.p2p_tunnel_attributes is not None and self.p2p_tunnel_attributes.has_operation()) or
                        (self.state is not None and self.state.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnel" + "[name='" + self.name.get() + "']" + "[type='" + self.type.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/lsps/constrained-path/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "bandwidth"):
                        if (self.bandwidth is None):
                            self.bandwidth = Mpls.Lsps.ConstrainedPath.Tunnel.Bandwidth()
                            self.bandwidth.parent = self
                            self._children_name_map["bandwidth"] = "bandwidth"
                        return self.bandwidth

                    if (child_yang_name == "config"):
                        if (self.config is None):
                            self.config = Mpls.Lsps.ConstrainedPath.Tunnel.Config()
                            self.config.parent = self
                            self._children_name_map["config"] = "config"
                        return self.config

                    if (child_yang_name == "p2p-tunnel-attributes"):
                        if (self.p2p_tunnel_attributes is None):
                            self.p2p_tunnel_attributes = Mpls.Lsps.ConstrainedPath.Tunnel.P2PTunnelAttributes()
                            self.p2p_tunnel_attributes.parent = self
                            self._children_name_map["p2p_tunnel_attributes"] = "p2p-tunnel-attributes"
                        return self.p2p_tunnel_attributes

                    if (child_yang_name == "state"):
                        if (self.state is None):
                            self.state = Mpls.Lsps.ConstrainedPath.Tunnel.State()
                            self.state.parent = self
                            self._children_name_map["state"] = "state"
                        return self.state

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "bandwidth" or name == "config" or name == "p2p-tunnel-attributes" or name == "state" or name == "name" or name == "type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.named_explicit_paths:
                    if (c.has_data()):
                        return True
                for c in self.tunnel:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.named_explicit_paths:
                    if (c.has_operation()):
                        return True
                for c in self.tunnel:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "constrained-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/lsps/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "named-explicit-paths"):
                    for c in self.named_explicit_paths:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.Lsps.ConstrainedPath.NamedExplicitPaths()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.named_explicit_paths.append(c)
                    return c

                if (child_yang_name == "tunnel"):
                    for c in self.tunnel:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.Lsps.ConstrainedPath.Tunnel()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.tunnel.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "named-explicit-paths" or name == "tunnel"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class UnconstrainedPath(Entity):
            """
            LSPs that use the IGP\-determined path, i.e., non
            traffic\-engineered, or non constrained\-path
            
            .. attribute:: path_setup_protocol
            
            	select and configure the signaling method for  the LSP
            	**type**\:   :py:class:`PathSetupProtocol <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.Lsps.UnconstrainedPath, self).__init__()

                self.yang_name = "unconstrained-path"
                self.yang_parent_name = "lsps"

                self.path_setup_protocol = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol()
                self.path_setup_protocol.parent = self
                self._children_name_map["path_setup_protocol"] = "path-setup-protocol"
                self._children_yang_names.add("path-setup-protocol")


            class PathSetupProtocol(Entity):
                """
                select and configure the signaling method for
                 the LSP
                
                .. attribute:: ldp
                
                	LDP signaling setup for IGP\-congruent LSPs
                	**type**\:   :py:class:`Ldp <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp>`
                
                	**presence node**\: True
                
                .. attribute:: segment_routing
                
                	segment routing signaling extensions for IGP\-confgruent LSPs
                	**type**\:   :py:class:`SegmentRouting <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting>`
                
                	**presence node**\: True
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol, self).__init__()

                    self.yang_name = "path-setup-protocol"
                    self.yang_parent_name = "unconstrained-path"

                    self.ldp = None
                    self._children_name_map["ldp"] = "ldp"
                    self._children_yang_names.add("ldp")

                    self.segment_routing = None
                    self._children_name_map["segment_routing"] = "segment-routing"
                    self._children_yang_names.add("segment-routing")


                class Ldp(Entity):
                    """
                    LDP signaling setup for IGP\-congruent LSPs
                    
                    .. attribute:: tunnel
                    
                    	contains configuration stanzas for different LSP tunnel types (P2P, P2MP, etc.)
                    	**type**\:   :py:class:`Tunnel <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel>`
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp, self).__init__()

                        self.yang_name = "ldp"
                        self.yang_parent_name = "path-setup-protocol"
                        self.is_presence_container = True

                        self.tunnel = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel()
                        self.tunnel.parent = self
                        self._children_name_map["tunnel"] = "tunnel"
                        self._children_yang_names.add("tunnel")


                    class Tunnel(Entity):
                        """
                        contains configuration stanzas for different LSP
                        tunnel types (P2P, P2MP, etc.)
                        
                        .. attribute:: ldp_type
                        
                        	specify basic or targeted LDP LSP
                        	**type**\:   :py:class:`LdpType <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.LdpType>`
                        
                        .. attribute:: mp2mp_lsp
                        
                        	properties of multipoint\-to\-multipoint tunnels
                        	**type**\:   :py:class:`Mp2MpLsp <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.Mp2MpLsp>`
                        
                        .. attribute:: p2mp_lsp
                        
                        	properties of point\-to\-multipoint tunnels
                        	**type**\:   :py:class:`P2MpLsp <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2MpLsp>`
                        
                        .. attribute:: p2p_lsp
                        
                        	properties of point\-to\-point tunnels
                        	**type**\:   :py:class:`P2PLsp <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2PLsp>`
                        
                        .. attribute:: tunnel_type
                        
                        	specifies the type of LSP, e.g., P2P or P2MP
                        	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel, self).__init__()

                            self.yang_name = "tunnel"
                            self.yang_parent_name = "ldp"

                            self.ldp_type = YLeaf(YType.enumeration, "ldp-type")

                            self.tunnel_type = YLeaf(YType.enumeration, "tunnel-type")

                            self.mp2mp_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.Mp2MpLsp()
                            self.mp2mp_lsp.parent = self
                            self._children_name_map["mp2mp_lsp"] = "mp2mp-lsp"
                            self._children_yang_names.add("mp2mp-lsp")

                            self.p2mp_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2MpLsp()
                            self.p2mp_lsp.parent = self
                            self._children_name_map["p2mp_lsp"] = "p2mp-lsp"
                            self._children_yang_names.add("p2mp-lsp")

                            self.p2p_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2PLsp()
                            self.p2p_lsp.parent = self
                            self._children_name_map["p2p_lsp"] = "p2p-lsp"
                            self._children_yang_names.add("p2p-lsp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ldp_type",
                                            "tunnel_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel, self).__setattr__(name, value)

                        class LdpType(Enum):
                            """
                            LdpType

                            specify basic or targeted LDP LSP

                            .. data:: BASIC = 0

                            	basic hop-by-hop LSP

                            .. data:: TARGETED = 1

                            	tLDP LSP

                            """

                            BASIC = Enum.YLeaf(0, "BASIC")

                            TARGETED = Enum.YLeaf(1, "TARGETED")



                        class P2MpLsp(Entity):
                            """
                            properties of point\-to\-multipoint tunnels
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2MpLsp, self).__init__()

                                self.yang_name = "p2mp-lsp"
                                self.yang_parent_name = "tunnel"

                            def has_data(self):
                                return False

                            def has_operation(self):
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "p2mp-lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/ldp/tunnel/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class P2PLsp(Entity):
                            """
                            properties of point\-to\-point tunnels
                            
                            .. attribute:: fec_address
                            
                            	Address prefix for packets sharing the same forwarding equivalence class for the IGP\-based LSP
                            	**type**\: one of the below types:
                            
                            	**type**\:  list of str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                            
                            
                            ----
                            	**type**\:  list of str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                            
                            
                            ----
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2PLsp, self).__init__()

                                self.yang_name = "p2p-lsp"
                                self.yang_parent_name = "tunnel"

                                self.fec_address = YLeafList(YType.str, "fec-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fec_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2PLsp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2PLsp, self).__setattr__(name, value)

                            def has_data(self):
                                for leaf in self.fec_address.getYLeafs():
                                    if (leaf.yfilter != YFilter.not_set):
                                        return True
                                return False

                            def has_operation(self):
                                for leaf in self.fec_address.getYLeafs():
                                    if (leaf.is_set):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fec_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "p2p-lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/ldp/tunnel/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                leaf_name_data.extend(self.fec_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fec-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fec-address"):
                                    self.fec_address.append(value)


                        class Mp2MpLsp(Entity):
                            """
                            properties of multipoint\-to\-multipoint tunnels
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.Mp2MpLsp, self).__init__()

                                self.yang_name = "mp2mp-lsp"
                                self.yang_parent_name = "tunnel"

                            def has_data(self):
                                return False

                            def has_operation(self):
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mp2mp-lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/ldp/tunnel/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.ldp_type.is_set or
                                self.tunnel_type.is_set or
                                (self.mp2mp_lsp is not None and self.mp2mp_lsp.has_data()) or
                                (self.p2mp_lsp is not None and self.p2mp_lsp.has_data()) or
                                (self.p2p_lsp is not None and self.p2p_lsp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ldp_type.yfilter != YFilter.not_set or
                                self.tunnel_type.yfilter != YFilter.not_set or
                                (self.mp2mp_lsp is not None and self.mp2mp_lsp.has_operation()) or
                                (self.p2mp_lsp is not None and self.p2mp_lsp.has_operation()) or
                                (self.p2p_lsp is not None and self.p2p_lsp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "tunnel" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/ldp/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ldp_type.is_set or self.ldp_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldp_type.get_name_leafdata())
                            if (self.tunnel_type.is_set or self.tunnel_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tunnel_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "mp2mp-lsp"):
                                if (self.mp2mp_lsp is None):
                                    self.mp2mp_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.Mp2MpLsp()
                                    self.mp2mp_lsp.parent = self
                                    self._children_name_map["mp2mp_lsp"] = "mp2mp-lsp"
                                return self.mp2mp_lsp

                            if (child_yang_name == "p2mp-lsp"):
                                if (self.p2mp_lsp is None):
                                    self.p2mp_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2MpLsp()
                                    self.p2mp_lsp.parent = self
                                    self._children_name_map["p2mp_lsp"] = "p2mp-lsp"
                                return self.p2mp_lsp

                            if (child_yang_name == "p2p-lsp"):
                                if (self.p2p_lsp is None):
                                    self.p2p_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel.P2PLsp()
                                    self.p2p_lsp.parent = self
                                    self._children_name_map["p2p_lsp"] = "p2p-lsp"
                                return self.p2p_lsp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mp2mp-lsp" or name == "p2mp-lsp" or name == "p2p-lsp" or name == "ldp-type" or name == "tunnel-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ldp-type"):
                                self.ldp_type = value
                                self.ldp_type.value_namespace = name_space
                                self.ldp_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "tunnel-type"):
                                self.tunnel_type = value
                                self.tunnel_type.value_namespace = name_space
                                self.tunnel_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.tunnel is not None and self.tunnel.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.tunnel is not None and self.tunnel.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ldp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "tunnel"):
                            if (self.tunnel is None):
                                self.tunnel = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp.Tunnel()
                                self.tunnel.parent = self
                                self._children_name_map["tunnel"] = "tunnel"
                            return self.tunnel

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "tunnel"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SegmentRouting(Entity):
                    """
                    segment routing signaling extensions for
                    IGP\-confgruent LSPs
                    
                    .. attribute:: tunnel
                    
                    	contains configuration stanzas for different LSP tunnel types (P2P, P2MP, etc.)
                    	**type**\:   :py:class:`Tunnel <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel>`
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting, self).__init__()

                        self.yang_name = "segment-routing"
                        self.yang_parent_name = "path-setup-protocol"
                        self.is_presence_container = True

                        self.tunnel = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel()
                        self.tunnel.parent = self
                        self._children_name_map["tunnel"] = "tunnel"
                        self._children_yang_names.add("tunnel")


                    class Tunnel(Entity):
                        """
                        contains configuration stanzas for different LSP
                        tunnel types (P2P, P2MP, etc.)
                        
                        .. attribute:: p2p_lsp
                        
                        	properties of point\-to\-point tunnels
                        	**type**\:   :py:class:`P2PLsp <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp>`
                        
                        .. attribute:: tunnel_type
                        
                        	specifies the type of LSP, e.g., P2P or P2MP
                        	**type**\:   :py:class:`TunnelType <ydk.models.openconfig.openconfig_mpls_types.TunnelType>`
                        
                        

                        """

                        _prefix = 'mpls'
                        _revision = '2015-11-05'

                        def __init__(self):
                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel, self).__init__()

                            self.yang_name = "tunnel"
                            self.yang_parent_name = "segment-routing"

                            self.tunnel_type = YLeaf(YType.enumeration, "tunnel-type")

                            self.p2p_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp()
                            self.p2p_lsp.parent = self
                            self._children_name_map["p2p_lsp"] = "p2p-lsp"
                            self._children_yang_names.add("p2p-lsp")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("tunnel_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel, self).__setattr__(name, value)


                        class P2PLsp(Entity):
                            """
                            properties of point\-to\-point tunnels
                            
                            .. attribute:: fec
                            
                            	List of FECs that are to be originated as SR LSPs
                            	**type**\: list of    :py:class:`Fec <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec>`
                            
                            

                            """

                            _prefix = 'mpls'
                            _revision = '2015-11-05'

                            def __init__(self):
                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp, self).__init__()

                                self.yang_name = "p2p-lsp"
                                self.yang_parent_name = "tunnel"

                                self.fec = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp, self).__setattr__(name, value)


                            class Fec(Entity):
                                """
                                List of FECs that are to be originated as SR LSPs
                                
                                .. attribute:: fec_address  <key>
                                
                                	FEC that is to be advertised as part of the Prefix\-SID
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                
                                
                                ----
                                .. attribute:: config
                                
                                	Configuration parameters relating to the FEC to be advertised by SR
                                	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.Config>`
                                
                                .. attribute:: prefix_sid
                                
                                	Parameters relating to the Prefix\-SID used for the originated FEC
                                	**type**\:   :py:class:`PrefixSid <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid>`
                                
                                .. attribute:: state
                                
                                	Operational state relating to a FEC advertised by SR
                                	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.State>`
                                
                                

                                """

                                _prefix = 'mpls'
                                _revision = '2015-11-05'

                                def __init__(self):
                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec, self).__init__()

                                    self.yang_name = "fec"
                                    self.yang_parent_name = "p2p-lsp"

                                    self.fec_address = YLeaf(YType.str, "fec-address")

                                    self.config = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.Config()
                                    self.config.parent = self
                                    self._children_name_map["config"] = "config"
                                    self._children_yang_names.add("config")

                                    self.prefix_sid = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid()
                                    self.prefix_sid.parent = self
                                    self._children_name_map["prefix_sid"] = "prefix-sid"
                                    self._children_yang_names.add("prefix-sid")

                                    self.state = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.State()
                                    self.state.parent = self
                                    self._children_name_map["state"] = "state"
                                    self._children_yang_names.add("state")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fec_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec, self).__setattr__(name, value)


                                class Config(Entity):
                                    """
                                    Configuration parameters relating to the FEC to be
                                    advertised by SR
                                    
                                    .. attribute:: fec_address
                                    
                                    	FEC that is to be advertised as part of the Prefix\-SID
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                    
                                    
                                    ----
                                    

                                    """

                                    _prefix = 'mpls'
                                    _revision = '2015-11-05'

                                    def __init__(self):
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.Config, self).__init__()

                                        self.yang_name = "config"
                                        self.yang_parent_name = "fec"

                                        self.fec_address = YLeaf(YType.str, "fec-address")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fec_address") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.Config, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.Config, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.fec_address.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fec_address.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "config" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fec_address.is_set or self.fec_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fec_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fec-address"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fec-address"):
                                            self.fec_address = value
                                            self.fec_address.value_namespace = name_space
                                            self.fec_address.value_namespace_prefix = name_space_prefix


                                class State(Entity):
                                    """
                                    Operational state relating to a FEC advertised by SR
                                    
                                    .. attribute:: fec_address
                                    
                                    	FEC that is to be advertised as part of the Prefix\-SID
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                    
                                    
                                    ----
                                    

                                    """

                                    _prefix = 'mpls'
                                    _revision = '2015-11-05'

                                    def __init__(self):
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.State, self).__init__()

                                        self.yang_name = "state"
                                        self.yang_parent_name = "fec"

                                        self.fec_address = YLeaf(YType.str, "fec-address")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fec_address") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.State, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.State, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.fec_address.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fec_address.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "state" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fec_address.is_set or self.fec_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fec_address.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fec-address"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fec-address"):
                                            self.fec_address = value
                                            self.fec_address.value_namespace = name_space
                                            self.fec_address.value_namespace_prefix = name_space_prefix


                                class PrefixSid(Entity):
                                    """
                                    Parameters relating to the Prefix\-SID
                                    used for the originated FEC
                                    
                                    .. attribute:: config
                                    
                                    	Configuration parameters relating to the Prefix\-SID used for the originated FEC
                                    	**type**\:   :py:class:`Config <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config>`
                                    
                                    .. attribute:: state
                                    
                                    	Operational state parameters relating to the Prefix\-SID used for the originated FEC
                                    	**type**\:   :py:class:`State <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State>`
                                    
                                    

                                    """

                                    _prefix = 'mpls'
                                    _revision = '2015-11-05'

                                    def __init__(self):
                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid, self).__init__()

                                        self.yang_name = "prefix-sid"
                                        self.yang_parent_name = "fec"

                                        self.config = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config()
                                        self.config.parent = self
                                        self._children_name_map["config"] = "config"
                                        self._children_yang_names.add("config")

                                        self.state = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State()
                                        self.state.parent = self
                                        self._children_name_map["state"] = "state"
                                        self._children_yang_names.add("state")


                                    class Config(Entity):
                                        """
                                        Configuration parameters relating to the Prefix\-SID
                                        used for the originated FEC
                                        
                                        .. attribute:: last_hop_behavior
                                        
                                        	Configuration relating to the LFIB actions for the Prefix\-SID to be used by the penultimate\-hop
                                        	**type**\:   :py:class:`LastHopBehavior <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config.LastHopBehavior>`
                                        
                                        .. attribute:: node_flag
                                        
                                        	Specifies that the Prefix\-SID is to be treated as a Node\-SID by setting the N\-flag in the advertised Prefix\-SID TLV in the IGP
                                        	**type**\:  bool
                                        
                                        .. attribute:: type
                                        
                                        	Specifies how the value of the Prefix\-SID should be interpreted \- whether as an offset to the SRGB, or as an absolute value
                                        	**type**\:   :py:class:`Type <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config.Type>`
                                        
                                        	**default value**\: INDEX
                                        
                                        

                                        """

                                        _prefix = 'mpls'
                                        _revision = '2015-11-05'

                                        def __init__(self):
                                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config, self).__init__()

                                            self.yang_name = "config"
                                            self.yang_parent_name = "prefix-sid"

                                            self.last_hop_behavior = YLeaf(YType.enumeration, "last-hop-behavior")

                                            self.node_flag = YLeaf(YType.boolean, "node-flag")

                                            self.type = YLeaf(YType.enumeration, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("last_hop_behavior",
                                                            "node_flag",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config, self).__setattr__(name, value)

                                        class LastHopBehavior(Enum):
                                            """
                                            LastHopBehavior

                                            Configuration relating to the LFIB actions for the

                                            Prefix\-SID to be used by the penultimate\-hop

                                            .. data:: EXPLICIT_NULL = 0

                                            	Specifies that the explicit null label is to be used

                                            	when the penultimate hop forwards a labelled packet to

                                            	this Prefix-SID

                                            .. data:: UNCHANGED = 1

                                            	Specicies that the Prefix-SID's label value is to be

                                            	left in place when the penultimate hop forwards to this

                                            	Prefix-SID

                                            .. data:: PHP = 2

                                            	Specicies that the penultimate hop should pop the

                                            	Prefix-SID label before forwarding to the eLER

                                            """

                                            EXPLICIT_NULL = Enum.YLeaf(0, "EXPLICIT-NULL")

                                            UNCHANGED = Enum.YLeaf(1, "UNCHANGED")

                                            PHP = Enum.YLeaf(2, "PHP")


                                        class Type(Enum):
                                            """
                                            Type

                                            Specifies how the value of the Prefix\-SID should be

                                            interpreted \- whether as an offset to the SRGB, or as an

                                            absolute value

                                            .. data:: INDEX = 0

                                            	Set when the value of the prefix SID should be specified

                                            	as an off-set from the SRGB's zero-value. When multiple

                                            	SRGBs are specified, the zero-value is the minimum

                                            	of their lower bounds

                                            .. data:: ABSOLUTE = 1

                                            	Set when the value of a prefix SID is specified as the

                                            	absolute value within an SRGB. It is an error to specify

                                            	an absolute value outside of a specified SRGB

                                            """

                                            INDEX = Enum.YLeaf(0, "INDEX")

                                            ABSOLUTE = Enum.YLeaf(1, "ABSOLUTE")


                                        def has_data(self):
                                            return (
                                                self.last_hop_behavior.is_set or
                                                self.node_flag.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.last_hop_behavior.yfilter != YFilter.not_set or
                                                self.node_flag.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "config" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.last_hop_behavior.is_set or self.last_hop_behavior.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.last_hop_behavior.get_name_leafdata())
                                            if (self.node_flag.is_set or self.node_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_flag.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "last-hop-behavior" or name == "node-flag" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "last-hop-behavior"):
                                                self.last_hop_behavior = value
                                                self.last_hop_behavior.value_namespace = name_space
                                                self.last_hop_behavior.value_namespace_prefix = name_space_prefix
                                            if(value_path == "node-flag"):
                                                self.node_flag = value
                                                self.node_flag.value_namespace = name_space
                                                self.node_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix


                                    class State(Entity):
                                        """
                                        Operational state parameters relating to the
                                        Prefix\-SID used for the originated FEC
                                        
                                        .. attribute:: last_hop_behavior
                                        
                                        	Configuration relating to the LFIB actions for the Prefix\-SID to be used by the penultimate\-hop
                                        	**type**\:   :py:class:`LastHopBehavior <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State.LastHopBehavior>`
                                        
                                        .. attribute:: node_flag
                                        
                                        	Specifies that the Prefix\-SID is to be treated as a Node\-SID by setting the N\-flag in the advertised Prefix\-SID TLV in the IGP
                                        	**type**\:  bool
                                        
                                        .. attribute:: type
                                        
                                        	Specifies how the value of the Prefix\-SID should be interpreted \- whether as an offset to the SRGB, or as an absolute value
                                        	**type**\:   :py:class:`Type <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State.Type>`
                                        
                                        	**default value**\: INDEX
                                        
                                        

                                        """

                                        _prefix = 'mpls'
                                        _revision = '2015-11-05'

                                        def __init__(self):
                                            super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State, self).__init__()

                                            self.yang_name = "state"
                                            self.yang_parent_name = "prefix-sid"

                                            self.last_hop_behavior = YLeaf(YType.enumeration, "last-hop-behavior")

                                            self.node_flag = YLeaf(YType.boolean, "node-flag")

                                            self.type = YLeaf(YType.enumeration, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("last_hop_behavior",
                                                            "node_flag",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State, self).__setattr__(name, value)

                                        class LastHopBehavior(Enum):
                                            """
                                            LastHopBehavior

                                            Configuration relating to the LFIB actions for the

                                            Prefix\-SID to be used by the penultimate\-hop

                                            .. data:: EXPLICIT_NULL = 0

                                            	Specifies that the explicit null label is to be used

                                            	when the penultimate hop forwards a labelled packet to

                                            	this Prefix-SID

                                            .. data:: UNCHANGED = 1

                                            	Specicies that the Prefix-SID's label value is to be

                                            	left in place when the penultimate hop forwards to this

                                            	Prefix-SID

                                            .. data:: PHP = 2

                                            	Specicies that the penultimate hop should pop the

                                            	Prefix-SID label before forwarding to the eLER

                                            """

                                            EXPLICIT_NULL = Enum.YLeaf(0, "EXPLICIT-NULL")

                                            UNCHANGED = Enum.YLeaf(1, "UNCHANGED")

                                            PHP = Enum.YLeaf(2, "PHP")


                                        class Type(Enum):
                                            """
                                            Type

                                            Specifies how the value of the Prefix\-SID should be

                                            interpreted \- whether as an offset to the SRGB, or as an

                                            absolute value

                                            .. data:: INDEX = 0

                                            	Set when the value of the prefix SID should be specified

                                            	as an off-set from the SRGB's zero-value. When multiple

                                            	SRGBs are specified, the zero-value is the minimum

                                            	of their lower bounds

                                            .. data:: ABSOLUTE = 1

                                            	Set when the value of a prefix SID is specified as the

                                            	absolute value within an SRGB. It is an error to specify

                                            	an absolute value outside of a specified SRGB

                                            """

                                            INDEX = Enum.YLeaf(0, "INDEX")

                                            ABSOLUTE = Enum.YLeaf(1, "ABSOLUTE")


                                        def has_data(self):
                                            return (
                                                self.last_hop_behavior.is_set or
                                                self.node_flag.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.last_hop_behavior.yfilter != YFilter.not_set or
                                                self.node_flag.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "state" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.last_hop_behavior.is_set or self.last_hop_behavior.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.last_hop_behavior.get_name_leafdata())
                                            if (self.node_flag.is_set or self.node_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_flag.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "last-hop-behavior" or name == "node-flag" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "last-hop-behavior"):
                                                self.last_hop_behavior = value
                                                self.last_hop_behavior.value_namespace = name_space
                                                self.last_hop_behavior.value_namespace_prefix = name_space_prefix
                                            if(value_path == "node-flag"):
                                                self.node_flag = value
                                                self.node_flag.value_namespace = name_space
                                                self.node_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            (self.config is not None and self.config.has_data()) or
                                            (self.state is not None and self.state.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.config is not None and self.config.has_operation()) or
                                            (self.state is not None and self.state.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "prefix-sid" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "config"):
                                            if (self.config is None):
                                                self.config = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.Config()
                                                self.config.parent = self
                                                self._children_name_map["config"] = "config"
                                            return self.config

                                        if (child_yang_name == "state"):
                                            if (self.state is None):
                                                self.state = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid.State()
                                                self.state.parent = self
                                                self._children_name_map["state"] = "state"
                                            return self.state

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "config" or name == "state"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.fec_address.is_set or
                                        (self.config is not None and self.config.has_data()) or
                                        (self.prefix_sid is not None and self.prefix_sid.has_data()) or
                                        (self.state is not None and self.state.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fec_address.yfilter != YFilter.not_set or
                                        (self.config is not None and self.config.has_operation()) or
                                        (self.prefix_sid is not None and self.prefix_sid.has_operation()) or
                                        (self.state is not None and self.state.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fec" + "[fec-address='" + self.fec_address.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/segment-routing/tunnel/p2p-lsp/%s" % self.get_segment_path()
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fec_address.is_set or self.fec_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fec_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "config"):
                                        if (self.config is None):
                                            self.config = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.Config()
                                            self.config.parent = self
                                            self._children_name_map["config"] = "config"
                                        return self.config

                                    if (child_yang_name == "prefix-sid"):
                                        if (self.prefix_sid is None):
                                            self.prefix_sid = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.PrefixSid()
                                            self.prefix_sid.parent = self
                                            self._children_name_map["prefix_sid"] = "prefix-sid"
                                        return self.prefix_sid

                                    if (child_yang_name == "state"):
                                        if (self.state is None):
                                            self.state = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec.State()
                                            self.state.parent = self
                                            self._children_name_map["state"] = "state"
                                        return self.state

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "config" or name == "prefix-sid" or name == "state" or name == "fec-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fec-address"):
                                        self.fec_address = value
                                        self.fec_address.value_namespace = name_space
                                        self.fec_address.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.fec:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.fec:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "p2p-lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/segment-routing/tunnel/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fec"):
                                    for c in self.fec:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp.Fec()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fec.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fec"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.tunnel_type.is_set or
                                (self.p2p_lsp is not None and self.p2p_lsp.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.tunnel_type.yfilter != YFilter.not_set or
                                (self.p2p_lsp is not None and self.p2p_lsp.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "tunnel" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/segment-routing/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.tunnel_type.is_set or self.tunnel_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tunnel_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "p2p-lsp"):
                                if (self.p2p_lsp is None):
                                    self.p2p_lsp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel.P2PLsp()
                                    self.p2p_lsp.parent = self
                                    self._children_name_map["p2p_lsp"] = "p2p-lsp"
                                return self.p2p_lsp

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "p2p-lsp" or name == "tunnel-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "tunnel-type"):
                                self.tunnel_type = value
                                self.tunnel_type.value_namespace = name_space
                                self.tunnel_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.tunnel is not None and self.tunnel.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.tunnel is not None and self.tunnel.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "segment-routing" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/path-setup-protocol/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "tunnel"):
                            if (self.tunnel is None):
                                self.tunnel = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting.Tunnel()
                                self.tunnel.parent = self
                                self._children_name_map["tunnel"] = "tunnel"
                            return self.tunnel

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "tunnel"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.ldp is not None) or
                        (self.segment_routing is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.ldp is not None and self.ldp.has_operation()) or
                        (self.segment_routing is not None and self.segment_routing.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "path-setup-protocol" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/lsps/unconstrained-path/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ldp"):
                        if (self.ldp is None):
                            self.ldp = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.Ldp()
                            self.ldp.parent = self
                            self._children_name_map["ldp"] = "ldp"
                        return self.ldp

                    if (child_yang_name == "segment-routing"):
                        if (self.segment_routing is None):
                            self.segment_routing = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol.SegmentRouting()
                            self.segment_routing.parent = self
                            self._children_name_map["segment_routing"] = "segment-routing"
                        return self.segment_routing

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ldp" or name == "segment-routing"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (self.path_setup_protocol is not None and self.path_setup_protocol.has_data())

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.path_setup_protocol is not None and self.path_setup_protocol.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "unconstrained-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/lsps/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "path-setup-protocol"):
                    if (self.path_setup_protocol is None):
                        self.path_setup_protocol = Mpls.Lsps.UnconstrainedPath.PathSetupProtocol()
                        self.path_setup_protocol.parent = self
                        self._children_name_map["path_setup_protocol"] = "path-setup-protocol"
                    return self.path_setup_protocol

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "path-setup-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class StaticLsps(Entity):
            """
            statically configured LSPs, without dynamic
            signaling
            
            .. attribute:: label_switched_path
            
            	list of defined static LSPs
            	**type**\: list of    :py:class:`LabelSwitchedPath <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.StaticLsps.LabelSwitchedPath>`
            
            

            """

            _prefix = 'mpls'
            _revision = '2015-11-05'

            def __init__(self):
                super(Mpls.Lsps.StaticLsps, self).__init__()

                self.yang_name = "static-lsps"
                self.yang_parent_name = "lsps"

                self.label_switched_path = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Mpls.Lsps.StaticLsps, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Mpls.Lsps.StaticLsps, self).__setattr__(name, value)


            class LabelSwitchedPath(Entity):
                """
                list of defined static LSPs
                
                .. attribute:: name  <key>
                
                	name to identify the LSP
                	**type**\:  str
                
                .. attribute:: egress
                
                	static LSPs for which the router is a egress  node
                	**type**\:   :py:class:`Egress <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.StaticLsps.LabelSwitchedPath.Egress>`
                
                .. attribute:: ingress
                
                	Static LSPs for which the router is an ingress node
                	**type**\:   :py:class:`Ingress <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.StaticLsps.LabelSwitchedPath.Ingress>`
                
                .. attribute:: transit
                
                	static LSPs for which the router is a transit node
                	**type**\:   :py:class:`Transit <ydk.models.openconfig.openconfig_mpls.Mpls.Lsps.StaticLsps.LabelSwitchedPath.Transit>`
                
                

                """

                _prefix = 'mpls'
                _revision = '2015-11-05'

                def __init__(self):
                    super(Mpls.Lsps.StaticLsps.LabelSwitchedPath, self).__init__()

                    self.yang_name = "label-switched-path"
                    self.yang_parent_name = "static-lsps"

                    self.name = YLeaf(YType.str, "name")

                    self.egress = Mpls.Lsps.StaticLsps.LabelSwitchedPath.Egress()
                    self.egress.parent = self
                    self._children_name_map["egress"] = "egress"
                    self._children_yang_names.add("egress")

                    self.ingress = Mpls.Lsps.StaticLsps.LabelSwitchedPath.Ingress()
                    self.ingress.parent = self
                    self._children_name_map["ingress"] = "ingress"
                    self._children_yang_names.add("ingress")

                    self.transit = Mpls.Lsps.StaticLsps.LabelSwitchedPath.Transit()
                    self.transit.parent = self
                    self._children_name_map["transit"] = "transit"
                    self._children_yang_names.add("transit")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Mpls.Lsps.StaticLsps.LabelSwitchedPath, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Mpls.Lsps.StaticLsps.LabelSwitchedPath, self).__setattr__(name, value)


                class Ingress(Entity):
                    """
                    Static LSPs for which the router is an
                    ingress node
                    
                    .. attribute:: incoming_label
                    
                    	label value on the incoming packet
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 16..1048575
                    
                    
                    ----
                    	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                    
                    
                    ----
                    .. attribute:: next_hop
                    
                    	next hop IP address for the LSP
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: push_label
                    
                    	label value to push at the current hop for the LSP
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 16..1048575
                    
                    
                    ----
                    	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                    
                    
                    ----
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Ingress, self).__init__()

                        self.yang_name = "ingress"
                        self.yang_parent_name = "label-switched-path"

                        self.incoming_label = YLeaf(YType.str, "incoming-label")

                        self.next_hop = YLeaf(YType.str, "next-hop")

                        self.push_label = YLeaf(YType.str, "push-label")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "next_hop",
                                        "push_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Ingress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Ingress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.next_hop.is_set or
                            self.push_label.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set or
                            self.push_label.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ingress" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())
                        if (self.push_label.is_set or self.push_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.push_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "incoming-label" or name == "next-hop" or name == "push-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix
                        if(value_path == "push-label"):
                            self.push_label = value
                            self.push_label.value_namespace = name_space
                            self.push_label.value_namespace_prefix = name_space_prefix


                class Transit(Entity):
                    """
                    static LSPs for which the router is a
                    transit node
                    
                    .. attribute:: incoming_label
                    
                    	label value on the incoming packet
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 16..1048575
                    
                    
                    ----
                    	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                    
                    
                    ----
                    .. attribute:: next_hop
                    
                    	next hop IP address for the LSP
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: push_label
                    
                    	label value to push at the current hop for the LSP
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 16..1048575
                    
                    
                    ----
                    	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                    
                    
                    ----
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Transit, self).__init__()

                        self.yang_name = "transit"
                        self.yang_parent_name = "label-switched-path"

                        self.incoming_label = YLeaf(YType.str, "incoming-label")

                        self.next_hop = YLeaf(YType.str, "next-hop")

                        self.push_label = YLeaf(YType.str, "push-label")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "next_hop",
                                        "push_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Transit, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Transit, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.next_hop.is_set or
                            self.push_label.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set or
                            self.push_label.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transit" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())
                        if (self.push_label.is_set or self.push_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.push_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "incoming-label" or name == "next-hop" or name == "push-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix
                        if(value_path == "push-label"):
                            self.push_label = value
                            self.push_label.value_namespace = name_space
                            self.push_label.value_namespace_prefix = name_space_prefix


                class Egress(Entity):
                    """
                    static LSPs for which the router is a
                    egress  node
                    
                    .. attribute:: incoming_label
                    
                    	label value on the incoming packet
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 16..1048575
                    
                    
                    ----
                    	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                    
                    
                    ----
                    .. attribute:: next_hop
                    
                    	next hop IP address for the LSP
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: push_label
                    
                    	label value to push at the current hop for the LSP
                    	**type**\: one of the below types:
                    
                    	**type**\:  int
                    
                    	**range:** 16..1048575
                    
                    
                    ----
                    	**type**\:   :py:class:`MplsLabel <ydk.models.openconfig.openconfig_mpls_types.MplsLabel>`
                    
                    
                    ----
                    

                    """

                    _prefix = 'mpls'
                    _revision = '2015-11-05'

                    def __init__(self):
                        super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Egress, self).__init__()

                        self.yang_name = "egress"
                        self.yang_parent_name = "label-switched-path"

                        self.incoming_label = YLeaf(YType.str, "incoming-label")

                        self.next_hop = YLeaf(YType.str, "next-hop")

                        self.push_label = YLeaf(YType.str, "push-label")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "next_hop",
                                        "push_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Egress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Mpls.Lsps.StaticLsps.LabelSwitchedPath.Egress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.next_hop.is_set or
                            self.push_label.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set or
                            self.push_label.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "egress" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())
                        if (self.push_label.is_set or self.push_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.push_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "incoming-label" or name == "next-hop" or name == "push-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix
                        if(value_path == "push-label"):
                            self.push_label = value
                            self.push_label.value_namespace = name_space
                            self.push_label.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.name.is_set or
                        (self.egress is not None and self.egress.has_data()) or
                        (self.ingress is not None and self.ingress.has_data()) or
                        (self.transit is not None and self.transit.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.egress is not None and self.egress.has_operation()) or
                        (self.ingress is not None and self.ingress.has_operation()) or
                        (self.transit is not None and self.transit.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "label-switched-path" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "openconfig-mpls:mpls/lsps/static-lsps/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "egress"):
                        if (self.egress is None):
                            self.egress = Mpls.Lsps.StaticLsps.LabelSwitchedPath.Egress()
                            self.egress.parent = self
                            self._children_name_map["egress"] = "egress"
                        return self.egress

                    if (child_yang_name == "ingress"):
                        if (self.ingress is None):
                            self.ingress = Mpls.Lsps.StaticLsps.LabelSwitchedPath.Ingress()
                            self.ingress.parent = self
                            self._children_name_map["ingress"] = "ingress"
                        return self.ingress

                    if (child_yang_name == "transit"):
                        if (self.transit is None):
                            self.transit = Mpls.Lsps.StaticLsps.LabelSwitchedPath.Transit()
                            self.transit.parent = self
                            self._children_name_map["transit"] = "transit"
                        return self.transit

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "egress" or name == "ingress" or name == "transit" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.label_switched_path:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.label_switched_path:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "static-lsps" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "openconfig-mpls:mpls/lsps/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "label-switched-path"):
                    for c in self.label_switched_path:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Mpls.Lsps.StaticLsps.LabelSwitchedPath()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.label_switched_path.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "label-switched-path"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.constrained_path is not None and self.constrained_path.has_data()) or
                (self.static_lsps is not None and self.static_lsps.has_data()) or
                (self.unconstrained_path is not None and self.unconstrained_path.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.constrained_path is not None and self.constrained_path.has_operation()) or
                (self.static_lsps is not None and self.static_lsps.has_operation()) or
                (self.unconstrained_path is not None and self.unconstrained_path.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "lsps" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "openconfig-mpls:mpls/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "constrained-path"):
                if (self.constrained_path is None):
                    self.constrained_path = Mpls.Lsps.ConstrainedPath()
                    self.constrained_path.parent = self
                    self._children_name_map["constrained_path"] = "constrained-path"
                return self.constrained_path

            if (child_yang_name == "static-lsps"):
                if (self.static_lsps is None):
                    self.static_lsps = Mpls.Lsps.StaticLsps()
                    self.static_lsps.parent = self
                    self._children_name_map["static_lsps"] = "static-lsps"
                return self.static_lsps

            if (child_yang_name == "unconstrained-path"):
                if (self.unconstrained_path is None):
                    self.unconstrained_path = Mpls.Lsps.UnconstrainedPath()
                    self.unconstrained_path.parent = self
                    self._children_name_map["unconstrained_path"] = "unconstrained-path"
                return self.unconstrained_path

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "constrained-path" or name == "static-lsps" or name == "unconstrained-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.global_ is not None and self.global_.has_data()) or
            (self.lsps is not None and self.lsps.has_data()) or
            (self.signaling_protocols is not None and self.signaling_protocols.has_data()) or
            (self.te_global_attributes is not None and self.te_global_attributes.has_data()) or
            (self.te_interface_attributes is not None and self.te_interface_attributes.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.global_ is not None and self.global_.has_operation()) or
            (self.lsps is not None and self.lsps.has_operation()) or
            (self.signaling_protocols is not None and self.signaling_protocols.has_operation()) or
            (self.te_global_attributes is not None and self.te_global_attributes.has_operation()) or
            (self.te_interface_attributes is not None and self.te_interface_attributes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "openconfig-mpls:mpls" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "global"):
            if (self.global_ is None):
                self.global_ = Mpls.Global_()
                self.global_.parent = self
                self._children_name_map["global_"] = "global"
            return self.global_

        if (child_yang_name == "lsps"):
            if (self.lsps is None):
                self.lsps = Mpls.Lsps()
                self.lsps.parent = self
                self._children_name_map["lsps"] = "lsps"
            return self.lsps

        if (child_yang_name == "signaling-protocols"):
            if (self.signaling_protocols is None):
                self.signaling_protocols = Mpls.SignalingProtocols()
                self.signaling_protocols.parent = self
                self._children_name_map["signaling_protocols"] = "signaling-protocols"
            return self.signaling_protocols

        if (child_yang_name == "te-global-attributes"):
            if (self.te_global_attributes is None):
                self.te_global_attributes = Mpls.TeGlobalAttributes()
                self.te_global_attributes.parent = self
                self._children_name_map["te_global_attributes"] = "te-global-attributes"
            return self.te_global_attributes

        if (child_yang_name == "te-interface-attributes"):
            if (self.te_interface_attributes is None):
                self.te_interface_attributes = Mpls.TeInterfaceAttributes()
                self.te_interface_attributes.parent = self
                self._children_name_map["te_interface_attributes"] = "te-interface-attributes"
            return self.te_interface_attributes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "global" or name == "lsps" or name == "signaling-protocols" or name == "te-global-attributes" or name == "te-interface-attributes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Mpls()
        return self._top_entity

class ExternallyQueried(Identity):
    """
    constrained\-path LSP in which the path is
    obtained by querying an external source, such as a PCE server
    
    

    """

    _prefix = 'mpls'
    _revision = '2015-11-05'

    def __init__(self):
        super(ExternallyQueried, self).__init__("http://openconfig.net/yang/mpls", "openconfig-mpls", "openconfig-mpls:externally-queried")


class LocallyComputed(Identity):
    """
    indicates a constrained\-path LSP in which the
    path is computed by the local LER
    
    

    """

    _prefix = 'mpls'
    _revision = '2015-11-05'

    def __init__(self):
        super(LocallyComputed, self).__init__("http://openconfig.net/yang/mpls", "openconfig-mpls", "openconfig-mpls:locally-computed")


class ExplicitlyDefined(Identity):
    """
    constrained\-path LSP in which the path is
    explicitly specified as a collection of strict or/and loose
    hops
    
    

    """

    _prefix = 'mpls'
    _revision = '2015-11-05'

    def __init__(self):
        super(ExplicitlyDefined, self).__init__("http://openconfig.net/yang/mpls", "openconfig-mpls", "openconfig-mpls:explicitly-defined")


