""" ietf_routing 

This YANG module defines essential components for the management
of a routing subsystem.

Copyright (c) 2014 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http\://trustee.ietf.org/license\-info).

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and
'OPTIONAL' in the module text are to be interpreted as described
in RFC 2119 (http\://tools.ietf.org/html/rfc2119).

This version of this YANG module is part of RFC XXXX
(http\://tools.ietf.org/html/rfcXXXX); see the RFC itself for
full legal notices.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error



class AddressFamily(Identity):
    """
    Base identity from which identities describing address
    families are derived.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(AddressFamily, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:address-family")


class RoutingInstance(Identity):
    """
    Base identity from which identities describing routing
    instance types are derived.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(RoutingInstance, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:routing-instance")


class RoutingProtocol(Identity):
    """
    Base identity from which routing protocol identities are
    derived.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(RoutingProtocol, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:routing-protocol")


class RoutingState(Entity):
    """
    State data of the routing subsystem.
    
    .. attribute:: routing_instance
    
    	Each list entry is a container for state data of a routing instance.  An implementation MUST support routing instance(s) of the type 'rt\:default\-routing\-instance', and MAY support other types. An implementation MAY restrict the number of routing instances of each supported type.  An implementation SHOULD create at least one system\-controlled instance, and MAY allow the clients to create user\-controlled routing instances in configuration
    	**type**\: list of    :py:class:`RoutingInstance <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance>`
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(RoutingState, self).__init__()
        self._top_entity = None

        self.yang_name = "routing-state"
        self.yang_parent_name = "ietf-routing"

        self.routing_instance = YList(self)

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in () and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(RoutingState, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(RoutingState, self).__setattr__(name, value)


    class RoutingInstance(Entity):
        """
        Each list entry is a container for state data of a routing
        instance.
        
        An implementation MUST support routing instance(s) of the
        type 'rt\:default\-routing\-instance', and MAY support other
        types. An implementation MAY restrict the number of routing
        instances of each supported type.
        
        An implementation SHOULD create at least one
        system\-controlled instance, and MAY allow the clients to
        create user\-controlled routing instances in
        configuration.
        
        .. attribute:: name  <key>
        
        	The name of the routing instance.  For system\-controlled instances the name is persistent, i.e., it SHOULD NOT change across reboots
        	**type**\:  str
        
        .. attribute:: interfaces
        
        	Network layer interfaces belonging to the routing instance
        	**type**\:   :py:class:`Interfaces <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Interfaces>`
        
        .. attribute:: ribs
        
        	Container for RIBs
        	**type**\:   :py:class:`Ribs <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs>`
        
        .. attribute:: router_id
        
        	A 32\-bit number in the form of a dotted quad that is used by some routing protocols identifying a router
        	**type**\:  str
        
        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
        
        .. attribute:: routing_protocols
        
        	Container for the list of routing protocol instances
        	**type**\:   :py:class:`RoutingProtocols <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols>`
        
        .. attribute:: type
        
        	The routing instance type
        	**type**\:   :py:class:`RoutingInstance <ydk.models.ietf.ietf_routing.RoutingInstance>`
        
        

        """

        _prefix = 'rt'
        _revision = '2015-05-25'

        def __init__(self):
            super(RoutingState.RoutingInstance, self).__init__()

            self.yang_name = "routing-instance"
            self.yang_parent_name = "routing-state"

            self.name = YLeaf(YType.str, "name")

            self.router_id = YLeaf(YType.str, "router-id")

            self.type = YLeaf(YType.identityref, "type")

            self.interfaces = RoutingState.RoutingInstance.Interfaces()
            self.interfaces.parent = self
            self._children_name_map["interfaces"] = "interfaces"
            self._children_yang_names.add("interfaces")

            self.ribs = RoutingState.RoutingInstance.Ribs()
            self.ribs.parent = self
            self._children_name_map["ribs"] = "ribs"
            self._children_yang_names.add("ribs")

            self.routing_protocols = RoutingState.RoutingInstance.RoutingProtocols()
            self.routing_protocols.parent = self
            self._children_name_map["routing_protocols"] = "routing-protocols"
            self._children_yang_names.add("routing-protocols")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("name",
                            "router_id",
                            "type") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(RoutingState.RoutingInstance, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(RoutingState.RoutingInstance, self).__setattr__(name, value)


        class Interfaces(Entity):
            """
            Network layer interfaces belonging to the routing
            instance.
            
            .. attribute:: interface
            
            	Each entry is a reference to the name of a configured network layer interface
            	**type**\:  list of str
            
            	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.InterfacesState.Interface>`
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(RoutingState.RoutingInstance.Interfaces, self).__init__()

                self.yang_name = "interfaces"
                self.yang_parent_name = "routing-instance"

                self.interface = YLeafList(YType.str, "interface")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(RoutingState.RoutingInstance.Interfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(RoutingState.RoutingInstance.Interfaces, self).__setattr__(name, value)

            def has_data(self):
                for leaf in self.interface.getYLeafs():
                    if (leaf.yfilter != YFilter.not_set):
                        return True
                return False

            def has_operation(self):
                for leaf in self.interface.getYLeafs():
                    if (leaf.is_set):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                leaf_name_data.extend(self.interface.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface"):
                    self.interface.append(value)


        class RoutingProtocols(Entity):
            """
            Container for the list of routing protocol instances.
            
            .. attribute:: routing_protocol
            
            	State data of a routing protocol instance.  An implementation MUST provide exactly one system\-controlled instance of the type 'direct'. Other instances MAY be created by configuration
            	**type**\: list of    :py:class:`RoutingProtocol <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol>`
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(RoutingState.RoutingInstance.RoutingProtocols, self).__init__()

                self.yang_name = "routing-protocols"
                self.yang_parent_name = "routing-instance"

                self.routing_protocol = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(RoutingState.RoutingInstance.RoutingProtocols, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(RoutingState.RoutingInstance.RoutingProtocols, self).__setattr__(name, value)


            class RoutingProtocol(Entity):
                """
                State data of a routing protocol instance.
                
                An implementation MUST provide exactly one
                system\-controlled instance of the type 'direct'. Other
                instances MAY be created by configuration.
                
                .. attribute:: type  <key>
                
                	Type of the routing protocol
                	**type**\:   :py:class:`RoutingProtocol <ydk.models.ietf.ietf_routing.RoutingProtocol>`
                
                .. attribute:: name  <key>
                
                	The name of the routing protocol instance.  For system\-controlled instances this name is persistent, i.e., it SHOULD NOT change across reboots
                	**type**\:  str
                
                .. attribute:: ospf
                
                	OSPF
                	**type**\:   :py:class:`Ospf <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf>`
                
                

                """

                _prefix = 'rt'
                _revision = '2015-05-25'

                def __init__(self):
                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol, self).__init__()

                    self.yang_name = "routing-protocol"
                    self.yang_parent_name = "routing-protocols"

                    self.type = YLeaf(YType.identityref, "type")

                    self.name = YLeaf(YType.str, "name")

                    self.ospf = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf()
                    self.ospf.parent = self
                    self._children_name_map["ospf"] = "ospf"
                    self._children_yang_names.add("ospf")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("type",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol, self).__setattr__(name, value)


                class Ospf(Entity):
                    """
                    OSPF
                    
                    .. attribute:: instance
                    
                    	An OSPF routing protocol instance
                    	**type**\: list of    :py:class:`Instance <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance>`
                    
                    .. attribute:: operation_mode
                    
                    	OSPF operation mode
                    	**type**\:   :py:class:`OperationMode <ydk.models.ietf.ietf_ospf.OperationMode>`
                    
                    

                    """

                    _prefix = 'ospf'
                    _revision = '2015-03-09'

                    def __init__(self):
                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf, self).__init__()

                        self.yang_name = "ospf"
                        self.yang_parent_name = "routing-protocol"

                        self.operation_mode = YLeaf(YType.identityref, "operation-mode")

                        self.instance = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("operation_mode") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf, self).__setattr__(name, value)


                    class Instance(Entity):
                        """
                        An OSPF routing protocol instance.
                        
                        .. attribute:: af  <key>
                        
                        	Address\-family of the instance
                        	**type**\:   :py:class:`AddressFamily <ydk.models.ietf.ietf_routing.AddressFamily>`
                        
                        .. attribute:: area
                        
                        	List of OSPF areas
                        	**type**\: list of    :py:class:`Area <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area>`
                        
                        .. attribute:: as_scope_lsas
                        
                        	List OSPF AS scope LSA databases
                        	**type**\: list of    :py:class:`AsScopeLsas <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas>`
                        
                        .. attribute:: router_id
                        
                        	Defined in RFC 2328. A 32\-bit number that uniquely identifies the router
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                        
                        .. attribute:: topology
                        
                        	OSPF topology
                        	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology>`
                        
                        

                        """

                        _prefix = 'ospf'
                        _revision = '2015-03-09'

                        def __init__(self):
                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance, self).__init__()

                            self.yang_name = "instance"
                            self.yang_parent_name = "ospf"

                            self.af = YLeaf(YType.identityref, "af")

                            self.router_id = YLeaf(YType.str, "router-id")

                            self.area = YList(self)
                            self.as_scope_lsas = YList(self)
                            self.topology = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af",
                                            "router_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance, self).__setattr__(name, value)


                        class Area(Entity):
                            """
                            List of OSPF areas
                            
                            .. attribute:: area_id  <key>
                            
                            	Area ID
                            	**type**\: one of the below types:
                            
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                            
                            
                            ----
                            .. attribute:: area_scope_lsas
                            
                            	List OSPF area scope LSA databases
                            	**type**\: list of    :py:class:`AreaScopeLsas <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas>`
                            
                            .. attribute:: interfaces
                            
                            	List of OSPF interfaces
                            	**type**\: list of    :py:class:`Interfaces <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area, self).__init__()

                                self.yang_name = "area"
                                self.yang_parent_name = "instance"

                                self.area_id = YLeaf(YType.str, "area-id")

                                self.area_scope_lsas = YList(self)
                                self.interfaces = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area, self).__setattr__(name, value)


                            class Interfaces(Entity):
                                """
                                List of OSPF interfaces.
                                
                                .. attribute:: interface  <key>
                                
                                	Interface
                                	**type**\:  str
                                
                                .. attribute:: authentication
                                
                                	Authentication configuration
                                	**type**\:   :py:class:`Authentication <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication>`
                                
                                .. attribute:: bdr
                                
                                	BDR
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: bfd
                                
                                	Enable/disable bfd
                                	**type**\:  bool
                                
                                .. attribute:: cost
                                
                                	Interface cost
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: demand_circuit
                                
                                	Enable/Disable demand circuit
                                	**type**\:  bool
                                
                                .. attribute:: dr
                                
                                	DR
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: enable
                                
                                	Enable/disable protocol on the interface
                                	**type**\:  bool
                                
                                	**default value**\: true
                                
                                .. attribute:: fast_reroute
                                
                                	Fast\-reroute configuration
                                	**type**\:   :py:class:`FastReroute <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute>`
                                
                                .. attribute:: hello_interval
                                
                                	Time between hello packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: hello_timer
                                
                                	Hello timer
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: milliseconds
                                
                                .. attribute:: link_scope_lsas
                                
                                	List OSPF link scope LSA databases
                                	**type**\: list of    :py:class:`LinkScopeLsas <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas>`
                                
                                .. attribute:: lls
                                
                                	Enable/Disable link\-local signaling (LLS) support
                                	**type**\:  bool
                                
                                .. attribute:: mtu_ignore
                                
                                	Enable/Disable ignoring of MTU in DBD packets
                                	**type**\:  bool
                                
                                .. attribute:: multi_area
                                
                                	Configure ospf multi\-area
                                	**type**\:   :py:class:`MultiArea <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.MultiArea>`
                                
                                .. attribute:: neighbor
                                
                                	List of OSPF neighbors
                                	**type**\: list of    :py:class:`Neighbor <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Neighbor>`
                                
                                .. attribute:: network_type
                                
                                	Network type
                                	**type**\:   :py:class:`NetworkType <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.NetworkType>`
                                
                                .. attribute:: node_flag
                                
                                	Set prefix as a node representative prefix
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: passive
                                
                                	Enable/Disable passive
                                	**type**\:  bool
                                
                                .. attribute:: prefix_suppression
                                
                                	Suppress advertisement of the prefixes
                                	**type**\:  bool
                                
                                .. attribute:: retransmit_interval
                                
                                	Time between retransmitting unacknowledged Link State Advertisements (LSAs)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: state
                                
                                	Interface state
                                	**type**\:  str
                                
                                .. attribute:: static_neighbors
                                
                                	Static configured neighbors
                                	**type**\:   :py:class:`StaticNeighbors <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors>`
                                
                                .. attribute:: topology
                                
                                	OSPF interface topology
                                	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Topology>`
                                
                                .. attribute:: transmit_delay
                                
                                	Estimated time needed to send link\-state update
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: ttl_security
                                
                                	TTL security check
                                	**type**\:   :py:class:`TtlSecurity <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.TtlSecurity>`
                                
                                .. attribute:: wait_timer
                                
                                	Wait timer
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: milliseconds
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces, self).__init__()

                                    self.yang_name = "interfaces"
                                    self.yang_parent_name = "area"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.bdr = YLeaf(YType.str, "bdr")

                                    self.bfd = YLeaf(YType.boolean, "bfd")

                                    self.cost = YLeaf(YType.uint16, "cost")

                                    self.dead_interval = YLeaf(YType.uint16, "dead-interval")

                                    self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                    self.dr = YLeaf(YType.str, "dr")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                                    self.hello_timer = YLeaf(YType.uint32, "hello-timer")

                                    self.lls = YLeaf(YType.boolean, "lls")

                                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                    self.network_type = YLeaf(YType.enumeration, "network-type")

                                    self.node_flag = YLeaf(YType.boolean, "node-flag")

                                    self.passive = YLeaf(YType.boolean, "passive")

                                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                    self.retransmit_interval = YLeaf(YType.uint16, "retransmit-interval")

                                    self.state = YLeaf(YType.str, "state")

                                    self.transmit_delay = YLeaf(YType.uint16, "transmit-delay")

                                    self.wait_timer = YLeaf(YType.uint32, "wait-timer")

                                    self.authentication = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.fast_reroute = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                    self._children_yang_names.add("fast-reroute")

                                    self.multi_area = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.MultiArea()
                                    self.multi_area.parent = self
                                    self._children_name_map["multi_area"] = "multi-area"
                                    self._children_yang_names.add("multi-area")

                                    self.static_neighbors = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors()
                                    self.static_neighbors.parent = self
                                    self._children_name_map["static_neighbors"] = "static-neighbors"
                                    self._children_yang_names.add("static-neighbors")

                                    self.ttl_security = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.TtlSecurity()
                                    self.ttl_security.parent = self
                                    self._children_name_map["ttl_security"] = "ttl-security"
                                    self._children_yang_names.add("ttl-security")

                                    self.link_scope_lsas = YList(self)
                                    self.neighbor = YList(self)
                                    self.topology = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "bdr",
                                                    "bfd",
                                                    "cost",
                                                    "dead_interval",
                                                    "demand_circuit",
                                                    "dr",
                                                    "enable",
                                                    "hello_interval",
                                                    "hello_timer",
                                                    "lls",
                                                    "mtu_ignore",
                                                    "network_type",
                                                    "node_flag",
                                                    "passive",
                                                    "prefix_suppression",
                                                    "retransmit_interval",
                                                    "state",
                                                    "transmit_delay",
                                                    "wait_timer") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces, self).__setattr__(name, value)

                                class NetworkType(Enum):
                                    """
                                    NetworkType

                                    Network type.

                                    .. data:: broadcast = 0

                                    	Specify OSPF broadcast multi-access network.

                                    .. data:: non_broadcast = 1

                                    	Specify OSPF Non-Broadcast Multi-Access

                                    	(NBMA) network.

                                    .. data:: point_to_multipoint = 2

                                    	Specify OSPF point-to-multipoint network.

                                    .. data:: point_to_point = 3

                                    	Specify OSPF point-to-point network.

                                    """

                                    broadcast = Enum.YLeaf(0, "broadcast")

                                    non_broadcast = Enum.YLeaf(1, "non-broadcast")

                                    point_to_multipoint = Enum.YLeaf(2, "point-to-multipoint")

                                    point_to_point = Enum.YLeaf(3, "point-to-point")



                                class MultiArea(Entity):
                                    """
                                    Configure ospf multi\-area.
                                    
                                    .. attribute:: cost
                                    
                                    	Interface cost for multi\-area
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: multi_area_id
                                    
                                    	Multi\-area ID
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                    
                                    
                                    ----
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.MultiArea, self).__init__()

                                        self.yang_name = "multi-area"
                                        self.yang_parent_name = "interfaces"

                                        self.cost = YLeaf(YType.uint16, "cost")

                                        self.multi_area_id = YLeaf(YType.str, "multi-area-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("cost",
                                                        "multi_area_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.MultiArea, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.MultiArea, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.cost.is_set or
                                            self.multi_area_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set or
                                            self.multi_area_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "multi-area" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())
                                        if (self.multi_area_id.is_set or self.multi_area_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.multi_area_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "cost" or name == "multi-area-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix
                                        if(value_path == "multi-area-id"):
                                            self.multi_area_id = value
                                            self.multi_area_id.value_namespace = name_space
                                            self.multi_area_id.value_namespace_prefix = name_space_prefix


                                class StaticNeighbors(Entity):
                                    """
                                    Static configured neighbors.
                                    
                                    .. attribute:: neighbor
                                    
                                    	Specify a neighbor router
                                    	**type**\: list of    :py:class:`Neighbor <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors.Neighbor>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors, self).__init__()

                                        self.yang_name = "static-neighbors"
                                        self.yang_parent_name = "interfaces"

                                        self.neighbor = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors, self).__setattr__(name, value)


                                    class Neighbor(Entity):
                                        """
                                        Specify a neighbor router.
                                        
                                        .. attribute:: address  <key>
                                        
                                        	Neighbor IP address
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: cost
                                        
                                        	Neighbor cost
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: poll_interval
                                        
                                        	Neighbor poll interval
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        	**units**\: seconds
                                        
                                        .. attribute:: priority
                                        
                                        	Neighbor priority for DR election
                                        	**type**\:  int
                                        
                                        	**range:** 1..255
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors.Neighbor, self).__init__()

                                            self.yang_name = "neighbor"
                                            self.yang_parent_name = "static-neighbors"

                                            self.address = YLeaf(YType.str, "address")

                                            self.cost = YLeaf(YType.uint16, "cost")

                                            self.poll_interval = YLeaf(YType.uint16, "poll-interval")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("address",
                                                            "cost",
                                                            "poll_interval",
                                                            "priority") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors.Neighbor, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors.Neighbor, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.address.is_set or
                                                self.cost.is_set or
                                                self.poll_interval.is_set or
                                                self.priority.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.address.yfilter != YFilter.not_set or
                                                self.cost.yfilter != YFilter.not_set or
                                                self.poll_interval.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "neighbor" + "[address='" + self.address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.address.get_name_leafdata())
                                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.cost.get_name_leafdata())
                                            if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.poll_interval.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "address" or name == "cost" or name == "poll-interval" or name == "priority"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "address"):
                                                self.address = value
                                                self.address.value_namespace = name_space
                                                self.address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "cost"):
                                                self.cost = value
                                                self.cost.value_namespace = name_space
                                                self.cost.value_namespace_prefix = name_space_prefix
                                            if(value_path == "poll-interval"):
                                                self.poll_interval = value
                                                self.poll_interval.value_namespace = name_space
                                                self.poll_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.neighbor:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.neighbor:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "static-neighbors" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "neighbor"):
                                            for c in self.neighbor:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors.Neighbor()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.neighbor.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "neighbor"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class FastReroute(Entity):
                                    """
                                    Fast\-reroute configuration.
                                    
                                    .. attribute:: lfa
                                    
                                    	LFA configuration
                                    	**type**\:   :py:class:`Lfa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute, self).__init__()

                                        self.yang_name = "fast-reroute"
                                        self.yang_parent_name = "interfaces"

                                        self.lfa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa()
                                        self.lfa.parent = self
                                        self._children_name_map["lfa"] = "lfa"
                                        self._children_yang_names.add("lfa")


                                    class Lfa(Entity):
                                        """
                                        LFA configuration.
                                        
                                        .. attribute:: candidate_disabled
                                        
                                        	Prevent the interface to be used as backup
                                        	**type**\:  bool
                                        
                                        .. attribute:: enabled
                                        
                                        	Activates LFA. This model assumes activation of per\-prefix LFA
                                        	**type**\:  bool
                                        
                                        .. attribute:: remote_lfa
                                        
                                        	Remote LFA configuration
                                        	**type**\:   :py:class:`RemoteLfa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa.RemoteLfa>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa, self).__init__()

                                            self.yang_name = "lfa"
                                            self.yang_parent_name = "fast-reroute"

                                            self.candidate_disabled = YLeaf(YType.boolean, "candidate-disabled")

                                            self.enabled = YLeaf(YType.boolean, "enabled")

                                            self.remote_lfa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa.RemoteLfa()
                                            self.remote_lfa.parent = self
                                            self._children_name_map["remote_lfa"] = "remote-lfa"
                                            self._children_yang_names.add("remote-lfa")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("candidate_disabled",
                                                            "enabled") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa, self).__setattr__(name, value)


                                        class RemoteLfa(Entity):
                                            """
                                            Remote LFA configuration.
                                            
                                            .. attribute:: enabled
                                            
                                            	Activates remote LFA
                                            	**type**\:  bool
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa.RemoteLfa, self).__init__()

                                                self.yang_name = "remote-lfa"
                                                self.yang_parent_name = "lfa"

                                                self.enabled = YLeaf(YType.boolean, "enabled")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("enabled") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa.RemoteLfa, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa.RemoteLfa, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.enabled.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.enabled.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "remote-lfa" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "enabled"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "enabled"):
                                                    self.enabled = value
                                                    self.enabled.value_namespace = name_space
                                                    self.enabled.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.candidate_disabled.is_set or
                                                self.enabled.is_set or
                                                (self.remote_lfa is not None and self.remote_lfa.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.candidate_disabled.yfilter != YFilter.not_set or
                                                self.enabled.yfilter != YFilter.not_set or
                                                (self.remote_lfa is not None and self.remote_lfa.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lfa" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.candidate_disabled.is_set or self.candidate_disabled.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.candidate_disabled.get_name_leafdata())
                                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enabled.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "remote-lfa"):
                                                if (self.remote_lfa is None):
                                                    self.remote_lfa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa.RemoteLfa()
                                                    self.remote_lfa.parent = self
                                                    self._children_name_map["remote_lfa"] = "remote-lfa"
                                                return self.remote_lfa

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "remote-lfa" or name == "candidate-disabled" or name == "enabled"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "candidate-disabled"):
                                                self.candidate_disabled = value
                                                self.candidate_disabled.value_namespace = name_space
                                                self.candidate_disabled.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enabled"):
                                                self.enabled = value
                                                self.enabled.value_namespace = name_space
                                                self.enabled.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.lfa is not None and self.lfa.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.lfa is not None and self.lfa.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fast-reroute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lfa"):
                                            if (self.lfa is None):
                                                self.lfa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute.Lfa()
                                                self.lfa.parent = self
                                                self._children_name_map["lfa"] = "lfa"
                                            return self.lfa

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lfa"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class TtlSecurity(Entity):
                                    """
                                    TTL security check.
                                    
                                    .. attribute:: enable
                                    
                                    	Enable/Disable TTL security check
                                    	**type**\:  bool
                                    
                                    .. attribute:: hops
                                    
                                    	Maximum number of hops that a OSPF packet may have traveled
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.TtlSecurity, self).__init__()

                                        self.yang_name = "ttl-security"
                                        self.yang_parent_name = "interfaces"

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.hops = YLeaf(YType.uint8, "hops")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("enable",
                                                        "hops") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.TtlSecurity, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.TtlSecurity, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.enable.is_set or
                                            self.hops.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hops.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ttl-security" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hops.is_set or self.hops.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hops.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "enable" or name == "hops"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hops"):
                                            self.hops = value
                                            self.hops.value_namespace = name_space
                                            self.hops.value_namespace_prefix = name_space_prefix


                                class Authentication(Entity):
                                    """
                                    Authentication configuration.
                                    
                                    .. attribute:: crypto_algorithm
                                    
                                    	Cryptographic algorithm associated with key
                                    	**type**\:   :py:class:`CryptoAlgorithm <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication.CryptoAlgorithm>`
                                    
                                    .. attribute:: key
                                    
                                    	Key string in ASCII format
                                    	**type**\:  str
                                    
                                    .. attribute:: key_chain
                                    
                                    	key\-chain name
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_key_chain.KeyChains>`
                                    
                                    .. attribute:: sa
                                    
                                    	SA name
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "interfaces"

                                        self.key = YLeaf(YType.str, "key")

                                        self.key_chain = YLeaf(YType.str, "key-chain")

                                        self.sa = YLeaf(YType.str, "sa")

                                        self.crypto_algorithm = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication.CryptoAlgorithm()
                                        self.crypto_algorithm.parent = self
                                        self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                        self._children_yang_names.add("crypto-algorithm")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("key",
                                                        "key_chain",
                                                        "sa") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication, self).__setattr__(name, value)


                                    class CryptoAlgorithm(Entity):
                                        """
                                        Cryptographic algorithm associated with key.
                                        
                                        .. attribute:: hmac_sha1_12
                                        
                                        	The HMAC\-SHA1\-12 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha1_20
                                        
                                        	The HMAC\-SHA1\-20 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_1
                                        
                                        	HMAC\-SHA\-1 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_256
                                        
                                        	HMAC\-SHA\-256 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_384
                                        
                                        	HMAC\-SHA\-384 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_512
                                        
                                        	HMAC\-SHA\-512 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: md5
                                        
                                        	The MD5 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: sha_1
                                        
                                        	The SHA\-1 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication.CryptoAlgorithm, self).__init__()

                                            self.yang_name = "crypto-algorithm"
                                            self.yang_parent_name = "authentication"

                                            self.hmac_sha1_12 = YLeaf(YType.empty, "hmac-sha1-12")

                                            self.hmac_sha1_20 = YLeaf(YType.empty, "hmac-sha1-20")

                                            self.hmac_sha_1 = YLeaf(YType.empty, "hmac-sha-1")

                                            self.hmac_sha_256 = YLeaf(YType.empty, "hmac-sha-256")

                                            self.hmac_sha_384 = YLeaf(YType.empty, "hmac-sha-384")

                                            self.hmac_sha_512 = YLeaf(YType.empty, "hmac-sha-512")

                                            self.md5 = YLeaf(YType.empty, "md5")

                                            self.sha_1 = YLeaf(YType.empty, "sha-1")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("hmac_sha1_12",
                                                            "hmac_sha1_20",
                                                            "hmac_sha_1",
                                                            "hmac_sha_256",
                                                            "hmac_sha_384",
                                                            "hmac_sha_512",
                                                            "md5",
                                                            "sha_1") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication.CryptoAlgorithm, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication.CryptoAlgorithm, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.hmac_sha1_12.is_set or
                                                self.hmac_sha1_20.is_set or
                                                self.hmac_sha_1.is_set or
                                                self.hmac_sha_256.is_set or
                                                self.hmac_sha_384.is_set or
                                                self.hmac_sha_512.is_set or
                                                self.md5.is_set or
                                                self.sha_1.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.hmac_sha1_12.yfilter != YFilter.not_set or
                                                self.hmac_sha1_20.yfilter != YFilter.not_set or
                                                self.hmac_sha_1.yfilter != YFilter.not_set or
                                                self.hmac_sha_256.yfilter != YFilter.not_set or
                                                self.hmac_sha_384.yfilter != YFilter.not_set or
                                                self.hmac_sha_512.yfilter != YFilter.not_set or
                                                self.md5.yfilter != YFilter.not_set or
                                                self.sha_1.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "crypto-algorithm" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.hmac_sha1_12.is_set or self.hmac_sha1_12.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_12.get_name_leafdata())
                                            if (self.hmac_sha1_20.is_set or self.hmac_sha1_20.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_20.get_name_leafdata())
                                            if (self.hmac_sha_1.is_set or self.hmac_sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_1.get_name_leafdata())
                                            if (self.hmac_sha_256.is_set or self.hmac_sha_256.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_256.get_name_leafdata())
                                            if (self.hmac_sha_384.is_set or self.hmac_sha_384.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_384.get_name_leafdata())
                                            if (self.hmac_sha_512.is_set or self.hmac_sha_512.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_512.get_name_leafdata())
                                            if (self.md5.is_set or self.md5.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.md5.get_name_leafdata())
                                            if (self.sha_1.is_set or self.sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sha_1.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "hmac-sha1-12" or name == "hmac-sha1-20" or name == "hmac-sha-1" or name == "hmac-sha-256" or name == "hmac-sha-384" or name == "hmac-sha-512" or name == "md5" or name == "sha-1"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "hmac-sha1-12"):
                                                self.hmac_sha1_12 = value
                                                self.hmac_sha1_12.value_namespace = name_space
                                                self.hmac_sha1_12.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha1-20"):
                                                self.hmac_sha1_20 = value
                                                self.hmac_sha1_20.value_namespace = name_space
                                                self.hmac_sha1_20.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-1"):
                                                self.hmac_sha_1 = value
                                                self.hmac_sha_1.value_namespace = name_space
                                                self.hmac_sha_1.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-256"):
                                                self.hmac_sha_256 = value
                                                self.hmac_sha_256.value_namespace = name_space
                                                self.hmac_sha_256.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-384"):
                                                self.hmac_sha_384 = value
                                                self.hmac_sha_384.value_namespace = name_space
                                                self.hmac_sha_384.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-512"):
                                                self.hmac_sha_512 = value
                                                self.hmac_sha_512.value_namespace = name_space
                                                self.hmac_sha_512.value_namespace_prefix = name_space_prefix
                                            if(value_path == "md5"):
                                                self.md5 = value
                                                self.md5.value_namespace = name_space
                                                self.md5.value_namespace_prefix = name_space_prefix
                                            if(value_path == "sha-1"):
                                                self.sha_1 = value
                                                self.sha_1.value_namespace = name_space
                                                self.sha_1.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.key.is_set or
                                            self.key_chain.is_set or
                                            self.sa.is_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.key.yfilter != YFilter.not_set or
                                            self.key_chain.yfilter != YFilter.not_set or
                                            self.sa.yfilter != YFilter.not_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key.get_name_leafdata())
                                        if (self.key_chain.is_set or self.key_chain.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key_chain.get_name_leafdata())
                                        if (self.sa.is_set or self.sa.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.sa.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "crypto-algorithm"):
                                            if (self.crypto_algorithm is None):
                                                self.crypto_algorithm = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication.CryptoAlgorithm()
                                                self.crypto_algorithm.parent = self
                                                self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                            return self.crypto_algorithm

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "crypto-algorithm" or name == "key" or name == "key-chain" or name == "sa"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "key"):
                                            self.key = value
                                            self.key.value_namespace = name_space
                                            self.key.value_namespace_prefix = name_space_prefix
                                        if(value_path == "key-chain"):
                                            self.key_chain = value
                                            self.key_chain.value_namespace = name_space
                                            self.key_chain.value_namespace_prefix = name_space_prefix
                                        if(value_path == "sa"):
                                            self.sa = value
                                            self.sa.value_namespace = name_space
                                            self.sa.value_namespace_prefix = name_space_prefix


                                class Neighbor(Entity):
                                    """
                                    List of OSPF neighbors.
                                    
                                    .. attribute:: neighbor_id  <key>
                                    
                                    	Neighbor ID
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: address
                                    
                                    	Neighbor address
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: bdr
                                    
                                    	Backup Designated Router
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: dr
                                    
                                    	Designated Router
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: state
                                    
                                    	OSPF neighbor state
                                    	**type**\:   :py:class:`NbrStateType <ydk.models.ietf.ietf_ospf.NbrStateType>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Neighbor, self).__init__()

                                        self.yang_name = "neighbor"
                                        self.yang_parent_name = "interfaces"

                                        self.neighbor_id = YLeaf(YType.str, "neighbor-id")

                                        self.address = YLeaf(YType.str, "address")

                                        self.bdr = YLeaf(YType.str, "bdr")

                                        self.dr = YLeaf(YType.str, "dr")

                                        self.state = YLeaf(YType.enumeration, "state")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("neighbor_id",
                                                        "address",
                                                        "bdr",
                                                        "dr",
                                                        "state") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Neighbor, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Neighbor, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.neighbor_id.is_set or
                                            self.address.is_set or
                                            self.bdr.is_set or
                                            self.dr.is_set or
                                            self.state.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.neighbor_id.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.bdr.yfilter != YFilter.not_set or
                                            self.dr.yfilter != YFilter.not_set or
                                            self.state.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "neighbor" + "[neighbor-id='" + self.neighbor_id.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.neighbor_id.is_set or self.neighbor_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.neighbor_id.get_name_leafdata())
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.bdr.is_set or self.bdr.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.bdr.get_name_leafdata())
                                        if (self.dr.is_set or self.dr.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dr.get_name_leafdata())
                                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.state.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "neighbor-id" or name == "address" or name == "bdr" or name == "dr" or name == "state"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "neighbor-id"):
                                            self.neighbor_id = value
                                            self.neighbor_id.value_namespace = name_space
                                            self.neighbor_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "bdr"):
                                            self.bdr = value
                                            self.bdr.value_namespace = name_space
                                            self.bdr.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dr"):
                                            self.dr = value
                                            self.dr.value_namespace = name_space
                                            self.dr.value_namespace_prefix = name_space_prefix
                                        if(value_path == "state"):
                                            self.state = value
                                            self.state.value_namespace = name_space
                                            self.state.value_namespace_prefix = name_space_prefix


                                class LinkScopeLsas(Entity):
                                    """
                                    List OSPF link scope LSA databases
                                    
                                    .. attribute:: lsa_type  <key>
                                    
                                    	OSPF link scope LSA type
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: link_scope_lsa
                                    
                                    	List of OSPF link scope LSAs
                                    	**type**\: list of    :py:class:`LinkScopeLsa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas, self).__init__()

                                        self.yang_name = "link-scope-lsas"
                                        self.yang_parent_name = "interfaces"

                                        self.lsa_type = YLeaf(YType.uint8, "lsa-type")

                                        self.link_scope_lsa = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("lsa_type") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas, self).__setattr__(name, value)


                                    class LinkScopeLsa(Entity):
                                        """
                                        List of OSPF link scope LSAs
                                        
                                        .. attribute:: lsa_id  <key>
                                        
                                        	LSA ID
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        
                                        ----
                                        .. attribute:: adv_router  <key>
                                        
                                        	Advertising router
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: decoded_completed
                                        
                                        	The OSPF LSA body is fully decoded
                                        	**type**\:  bool
                                        
                                        .. attribute:: ospfv2
                                        
                                        	OSPFv2 LSA
                                        	**type**\:   :py:class:`Ospfv2 <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2>`
                                        
                                        .. attribute:: ospfv3
                                        
                                        	OSPFv3 LSA
                                        	**type**\:   :py:class:`Ospfv3 <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3>`
                                        
                                        .. attribute:: raw_data
                                        
                                        	The complete LSA in network byte order as received/sent over the wire
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa, self).__init__()

                                            self.yang_name = "link-scope-lsa"
                                            self.yang_parent_name = "link-scope-lsas"

                                            self.lsa_id = YLeaf(YType.str, "lsa-id")

                                            self.adv_router = YLeaf(YType.str, "adv-router")

                                            self.decoded_completed = YLeaf(YType.boolean, "decoded-completed")

                                            self.raw_data = YLeaf(YType.str, "raw-data")

                                            self.ospfv2 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2()
                                            self.ospfv2.parent = self
                                            self._children_name_map["ospfv2"] = "ospfv2"
                                            self._children_yang_names.add("ospfv2")

                                            self.ospfv3 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3()
                                            self.ospfv3.parent = self
                                            self._children_name_map["ospfv3"] = "ospfv3"
                                            self._children_yang_names.add("ospfv3")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("lsa_id",
                                                            "adv_router",
                                                            "decoded_completed",
                                                            "raw_data") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa, self).__setattr__(name, value)


                                        class Ospfv2(Entity):
                                            """
                                            OSPFv2 LSA
                                            
                                            .. attribute:: body
                                            
                                            	Decoded OSPFv2 LSA body data
                                            	**type**\:   :py:class:`Body <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body>`
                                            
                                            .. attribute:: header
                                            
                                            	Decoded OSPFv2 LSA header data
                                            	**type**\:   :py:class:`Header <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2, self).__init__()

                                                self.yang_name = "ospfv2"
                                                self.yang_parent_name = "link-scope-lsa"

                                                self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body()
                                                self.body.parent = self
                                                self._children_name_map["body"] = "body"
                                                self._children_yang_names.add("body")

                                                self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header()
                                                self.header.parent = self
                                                self._children_name_map["header"] = "header"
                                                self._children_yang_names.add("header")


                                            class Header(Entity):
                                                """
                                                Decoded OSPFv2 LSA header data.
                                                
                                                .. attribute:: adv_router
                                                
                                                	LSA advertising router
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: age
                                                
                                                	LSA age
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: checksum
                                                
                                                	LSA checksum
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: length
                                                
                                                	LSA length
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: lsa_id
                                                
                                                	LSA ID
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: opaque_id
                                                
                                                	Opaque id
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: opaque_type
                                                
                                                	Opaque type
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: options
                                                
                                                	LSA option
                                                	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header.Options>`
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: seq_num
                                                
                                                	LSA sequence number
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: type
                                                
                                                	LSA type
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header, self).__init__()

                                                    self.yang_name = "header"
                                                    self.yang_parent_name = "ospfv2"

                                                    self.adv_router = YLeaf(YType.str, "adv-router")

                                                    self.age = YLeaf(YType.uint16, "age")

                                                    self.checksum = YLeaf(YType.str, "checksum")

                                                    self.length = YLeaf(YType.uint16, "length")

                                                    self.lsa_id = YLeaf(YType.str, "lsa-id")

                                                    self.opaque_id = YLeaf(YType.uint32, "opaque-id")

                                                    self.opaque_type = YLeaf(YType.uint8, "opaque-type")

                                                    self.options = YLeaf(YType.bits, "options")

                                                    self.seq_num = YLeaf(YType.str, "seq-num")

                                                    self.type = YLeaf(YType.uint16, "type")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("adv_router",
                                                                    "age",
                                                                    "checksum",
                                                                    "length",
                                                                    "lsa_id",
                                                                    "opaque_id",
                                                                    "opaque_type",
                                                                    "options",
                                                                    "seq_num",
                                                                    "type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.adv_router.is_set or
                                                        self.age.is_set or
                                                        self.checksum.is_set or
                                                        self.length.is_set or
                                                        self.lsa_id.is_set or
                                                        self.opaque_id.is_set or
                                                        self.opaque_type.is_set or
                                                        self.options.is_set or
                                                        self.seq_num.is_set or
                                                        self.type.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.adv_router.yfilter != YFilter.not_set or
                                                        self.age.yfilter != YFilter.not_set or
                                                        self.checksum.yfilter != YFilter.not_set or
                                                        self.length.yfilter != YFilter.not_set or
                                                        self.lsa_id.yfilter != YFilter.not_set or
                                                        self.opaque_id.yfilter != YFilter.not_set or
                                                        self.opaque_type.yfilter != YFilter.not_set or
                                                        self.options.yfilter != YFilter.not_set or
                                                        self.seq_num.yfilter != YFilter.not_set or
                                                        self.type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "header" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.adv_router.get_name_leafdata())
                                                    if (self.age.is_set or self.age.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.age.get_name_leafdata())
                                                    if (self.checksum.is_set or self.checksum.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.checksum.get_name_leafdata())
                                                    if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.length.get_name_leafdata())
                                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                                    if (self.opaque_id.is_set or self.opaque_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.opaque_id.get_name_leafdata())
                                                    if (self.opaque_type.is_set or self.opaque_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.opaque_type.get_name_leafdata())
                                                    if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.options.get_name_leafdata())
                                                    if (self.seq_num.is_set or self.seq_num.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.seq_num.get_name_leafdata())
                                                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "adv-router" or name == "age" or name == "checksum" or name == "length" or name == "lsa-id" or name == "opaque-id" or name == "opaque-type" or name == "options" or name == "seq-num" or name == "type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "adv-router"):
                                                        self.adv_router = value
                                                        self.adv_router.value_namespace = name_space
                                                        self.adv_router.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "age"):
                                                        self.age = value
                                                        self.age.value_namespace = name_space
                                                        self.age.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "checksum"):
                                                        self.checksum = value
                                                        self.checksum.value_namespace = name_space
                                                        self.checksum.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "length"):
                                                        self.length = value
                                                        self.length.value_namespace = name_space
                                                        self.length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "lsa-id"):
                                                        self.lsa_id = value
                                                        self.lsa_id.value_namespace = name_space
                                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "opaque-id"):
                                                        self.opaque_id = value
                                                        self.opaque_id.value_namespace = name_space
                                                        self.opaque_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "opaque-type"):
                                                        self.opaque_type = value
                                                        self.opaque_type.value_namespace = name_space
                                                        self.opaque_type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "options"):
                                                        self.options[value] = True
                                                    if(value_path == "seq-num"):
                                                        self.seq_num = value
                                                        self.seq_num.value_namespace = name_space
                                                        self.seq_num.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "type"):
                                                        self.type = value
                                                        self.type.value_namespace = name_space
                                                        self.type.value_namespace_prefix = name_space_prefix


                                            class Body(Entity):
                                                """
                                                Decoded OSPFv2 LSA body data.
                                                
                                                .. attribute:: external
                                                
                                                	External LSA
                                                	**type**\:   :py:class:`External <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External>`
                                                
                                                .. attribute:: network
                                                
                                                	Network LSA
                                                	**type**\:   :py:class:`Network <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Network>`
                                                
                                                .. attribute:: opaque
                                                
                                                	Opaque LSA
                                                	**type**\:   :py:class:`Opaque <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque>`
                                                
                                                .. attribute:: router
                                                
                                                	Router LSA
                                                	**type**\:   :py:class:`Router <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router>`
                                                
                                                .. attribute:: summary
                                                
                                                	Summary LSA
                                                	**type**\:   :py:class:`Summary <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary>`
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body, self).__init__()

                                                    self.yang_name = "body"
                                                    self.yang_parent_name = "ospfv2"

                                                    self.external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External()
                                                    self.external.parent = self
                                                    self._children_name_map["external"] = "external"
                                                    self._children_yang_names.add("external")

                                                    self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Network()
                                                    self.network.parent = self
                                                    self._children_name_map["network"] = "network"
                                                    self._children_yang_names.add("network")

                                                    self.opaque = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque()
                                                    self.opaque.parent = self
                                                    self._children_name_map["opaque"] = "opaque"
                                                    self._children_yang_names.add("opaque")

                                                    self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router()
                                                    self.router.parent = self
                                                    self._children_name_map["router"] = "router"
                                                    self._children_yang_names.add("router")

                                                    self.summary = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary()
                                                    self.summary.parent = self
                                                    self._children_name_map["summary"] = "summary"
                                                    self._children_yang_names.add("summary")


                                                class Router(Entity):
                                                    """
                                                    Router LSA.
                                                    
                                                    .. attribute:: flags
                                                    
                                                    	Flags
                                                    	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Flags>`
                                                    
                                                    .. attribute:: link
                                                    
                                                    	Router LSA link
                                                    	**type**\: list of    :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link>`
                                                    
                                                    .. attribute:: num_of_links
                                                    
                                                    	Number of links
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router, self).__init__()

                                                        self.yang_name = "router"
                                                        self.yang_parent_name = "body"

                                                        self.flags = YLeaf(YType.bits, "flags")

                                                        self.num_of_links = YLeaf(YType.uint16, "num-of-links")

                                                        self.link = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("flags",
                                                                        "num_of_links") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router, self).__setattr__(name, value)


                                                    class Link(Entity):
                                                        """
                                                        Router LSA link.
                                                        
                                                        .. attribute:: link_id  <key>
                                                        
                                                        	Link ID
                                                        	**type**\: one of the below types:
                                                        
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        
                                                        ----
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                        
                                                        
                                                        ----
                                                        .. attribute:: link_data  <key>
                                                        
                                                        	Link data
                                                        	**type**\: one of the below types:
                                                        
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        
                                                        ----
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        
                                                        ----
                                                        .. attribute:: topology
                                                        
                                                        	Topology specific information
                                                        	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link.Topology>`
                                                        
                                                        .. attribute:: type
                                                        
                                                        	Link type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link, self).__init__()

                                                            self.yang_name = "link"
                                                            self.yang_parent_name = "router"

                                                            self.link_id = YLeaf(YType.str, "link-id")

                                                            self.link_data = YLeaf(YType.str, "link-data")

                                                            self.type = YLeaf(YType.uint8, "type")

                                                            self.topology = YList(self)

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("link_id",
                                                                            "link_data",
                                                                            "type") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link, self).__setattr__(name, value)


                                                        class Topology(Entity):
                                                            """
                                                            Topology specific information.
                                                            
                                                            .. attribute:: mt_id  <key>
                                                            
                                                            	The MT\-ID for topology enabled on the link
                                                            	**type**\:  int
                                                            
                                                            	**range:** 0..255
                                                            
                                                            .. attribute:: metric
                                                            
                                                            	Metric for the topology
                                                            	**type**\:  int
                                                            
                                                            	**range:** 0..65535
                                                            
                                                            

                                                            """

                                                            _prefix = 'ospf'
                                                            _revision = '2015-03-09'

                                                            def __init__(self):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__init__()

                                                                self.yang_name = "topology"
                                                                self.yang_parent_name = "link"

                                                                self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                                self.metric = YLeaf(YType.uint16, "metric")

                                                            def __setattr__(self, name, value):
                                                                self._check_monkey_patching_error(name, value)
                                                                with _handle_type_error():
                                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                            "Please use list append or extend method."
                                                                                            .format(value))
                                                                    if isinstance(value, Enum.YLeaf):
                                                                        value = value.name
                                                                    if name in ("mt_id",
                                                                                "metric") and name in self.__dict__:
                                                                        if isinstance(value, YLeaf):
                                                                            self.__dict__[name].set(value.get())
                                                                        elif isinstance(value, YLeafList):
                                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__setattr__(name, value)
                                                                        else:
                                                                            self.__dict__[name].set(value)
                                                                    else:
                                                                        if hasattr(value, "parent") and name != "parent":
                                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                                value.parent = self
                                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                                value.parent = self
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__setattr__(name, value)

                                                            def has_data(self):
                                                                return (
                                                                    self.mt_id.is_set or
                                                                    self.metric.is_set)

                                                            def has_operation(self):
                                                                return (
                                                                    self.yfilter != YFilter.not_set or
                                                                    self.mt_id.yfilter != YFilter.not_set or
                                                                    self.metric.yfilter != YFilter.not_set)

                                                            def get_segment_path(self):
                                                                path_buffer = ""
                                                                path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                                return path_buffer

                                                            def get_entity_path(self, ancestor):
                                                                path_buffer = ""
                                                                if (ancestor is None):
                                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                                else:
                                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                                leaf_name_data = LeafDataList()
                                                                if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.metric.get_name_leafdata())

                                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                                return entity_path

                                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                                if child is not None:
                                                                    return child

                                                                return None

                                                            def has_leaf_or_child_of_name(self, name):
                                                                if(name == "mt-id" or name == "metric"):
                                                                    return True
                                                                return False

                                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                                if(value_path == "mt-id"):
                                                                    self.mt_id = value
                                                                    self.mt_id.value_namespace = name_space
                                                                    self.mt_id.value_namespace_prefix = name_space_prefix
                                                                if(value_path == "metric"):
                                                                    self.metric = value
                                                                    self.metric.value_namespace = name_space
                                                                    self.metric.value_namespace_prefix = name_space_prefix

                                                        def has_data(self):
                                                            for c in self.topology:
                                                                if (c.has_data()):
                                                                    return True
                                                            return (
                                                                self.link_id.is_set or
                                                                self.link_data.is_set or
                                                                self.type.is_set)

                                                        def has_operation(self):
                                                            for c in self.topology:
                                                                if (c.has_operation()):
                                                                    return True
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.link_id.yfilter != YFilter.not_set or
                                                                self.link_data.yfilter != YFilter.not_set or
                                                                self.type.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "link" + "[link-id='" + self.link_id.get() + "']" + "[link-data='" + self.link_data.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.link_id.get_name_leafdata())
                                                            if (self.link_data.is_set or self.link_data.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.link_data.get_name_leafdata())
                                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.type.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            if (child_yang_name == "topology"):
                                                                for c in self.topology:
                                                                    segment = c.get_segment_path()
                                                                    if (segment_path == segment):
                                                                        return c
                                                                c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link.Topology()
                                                                c.parent = self
                                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                                self._local_refs[local_reference_key] = c
                                                                self.topology.append(c)
                                                                return c

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "topology" or name == "link-id" or name == "link-data" or name == "type"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "link-id"):
                                                                self.link_id = value
                                                                self.link_id.value_namespace = name_space
                                                                self.link_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "link-data"):
                                                                self.link_data = value
                                                                self.link_data.value_namespace = name_space
                                                                self.link_data.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "type"):
                                                                self.type = value
                                                                self.type.value_namespace = name_space
                                                                self.type.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.link:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.flags.is_set or
                                                            self.num_of_links.is_set)

                                                    def has_operation(self):
                                                        for c in self.link:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.flags.yfilter != YFilter.not_set or
                                                            self.num_of_links.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "router" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.flags.get_name_leafdata())
                                                        if (self.num_of_links.is_set or self.num_of_links.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.num_of_links.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "link"):
                                                            for c in self.link:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router.Link()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.link.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "link" or name == "flags" or name == "num-of-links"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "flags"):
                                                            self.flags[value] = True
                                                        if(value_path == "num-of-links"):
                                                            self.num_of_links = value
                                                            self.num_of_links.value_namespace = name_space
                                                            self.num_of_links.value_namespace_prefix = name_space_prefix


                                                class Network(Entity):
                                                    """
                                                    Network LSA.
                                                    
                                                    .. attribute:: attached_router
                                                    
                                                    	List of the routers attached to the network
                                                    	**type**\:  list of str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                    
                                                    .. attribute:: network_mask
                                                    
                                                    	The IP address mask for the network
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Network, self).__init__()

                                                        self.yang_name = "network"
                                                        self.yang_parent_name = "body"

                                                        self.attached_router = YLeafList(YType.str, "attached-router")

                                                        self.network_mask = YLeaf(YType.str, "network-mask")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("attached_router",
                                                                        "network_mask") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Network, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Network, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        for leaf in self.attached_router.getYLeafs():
                                                            if (leaf.yfilter != YFilter.not_set):
                                                                return True
                                                        return self.network_mask.is_set

                                                    def has_operation(self):
                                                        for leaf in self.attached_router.getYLeafs():
                                                            if (leaf.is_set):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.attached_router.yfilter != YFilter.not_set or
                                                            self.network_mask.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "network" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                        leaf_name_data.extend(self.attached_router.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "attached-router" or name == "network-mask"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "attached-router"):
                                                            self.attached_router.append(value)
                                                        if(value_path == "network-mask"):
                                                            self.network_mask = value
                                                            self.network_mask.value_namespace = name_space
                                                            self.network_mask.value_namespace_prefix = name_space_prefix


                                                class Summary(Entity):
                                                    """
                                                    Summary LSA.
                                                    
                                                    .. attribute:: network_mask
                                                    
                                                    	The IP address mask for the network
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: topology
                                                    
                                                    	Topology specific information
                                                    	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary.Topology>`
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary, self).__init__()

                                                        self.yang_name = "summary"
                                                        self.yang_parent_name = "body"

                                                        self.network_mask = YLeaf(YType.str, "network-mask")

                                                        self.topology = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("network_mask") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary, self).__setattr__(name, value)


                                                    class Topology(Entity):
                                                        """
                                                        Topology specific information.
                                                        
                                                        .. attribute:: mt_id  <key>
                                                        
                                                        	The MT\-ID for topology enabled on the link
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        .. attribute:: metric
                                                        
                                                        	Metric for the topology
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..16777215
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary.Topology, self).__init__()

                                                            self.yang_name = "topology"
                                                            self.yang_parent_name = "summary"

                                                            self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                            self.metric = YLeaf(YType.uint32, "metric")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("mt_id",
                                                                            "metric") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary.Topology, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary.Topology, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.mt_id.is_set or
                                                                self.metric.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.mt_id.yfilter != YFilter.not_set or
                                                                self.metric.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.metric.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "mt-id" or name == "metric"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "mt-id"):
                                                                self.mt_id = value
                                                                self.mt_id.value_namespace = name_space
                                                                self.mt_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "metric"):
                                                                self.metric = value
                                                                self.metric.value_namespace = name_space
                                                                self.metric.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.topology:
                                                            if (c.has_data()):
                                                                return True
                                                        return self.network_mask.is_set

                                                    def has_operation(self):
                                                        for c in self.topology:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.network_mask.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "summary" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "topology"):
                                                            for c in self.topology:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary.Topology()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.topology.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "topology" or name == "network-mask"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "network-mask"):
                                                            self.network_mask = value
                                                            self.network_mask.value_namespace = name_space
                                                            self.network_mask.value_namespace_prefix = name_space_prefix


                                                class External(Entity):
                                                    """
                                                    External LSA.
                                                    
                                                    .. attribute:: network_mask
                                                    
                                                    	The IP address mask for the network
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: topology
                                                    
                                                    	Topology specific information
                                                    	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External.Topology>`
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External, self).__init__()

                                                        self.yang_name = "external"
                                                        self.yang_parent_name = "body"

                                                        self.network_mask = YLeaf(YType.str, "network-mask")

                                                        self.topology = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("network_mask") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External, self).__setattr__(name, value)


                                                    class Topology(Entity):
                                                        """
                                                        Topology specific information.
                                                        
                                                        .. attribute:: mt_id  <key>
                                                        
                                                        	The MT\-ID for topology enabled on the link
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        .. attribute:: external_route_tag
                                                        
                                                        	Route tag
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: flags
                                                        
                                                        	Flags
                                                        	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External.Topology.Flags>`
                                                        
                                                        .. attribute:: forwarding_address
                                                        
                                                        	Forwarding address
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        .. attribute:: metric
                                                        
                                                        	Metric for the topology
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..16777215
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External.Topology, self).__init__()

                                                            self.yang_name = "topology"
                                                            self.yang_parent_name = "external"

                                                            self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                            self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                            self.flags = YLeaf(YType.bits, "flags")

                                                            self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                            self.metric = YLeaf(YType.uint32, "metric")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("mt_id",
                                                                            "external_route_tag",
                                                                            "flags",
                                                                            "forwarding_address",
                                                                            "metric") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External.Topology, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External.Topology, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.mt_id.is_set or
                                                                self.external_route_tag.is_set or
                                                                self.flags.is_set or
                                                                self.forwarding_address.is_set or
                                                                self.metric.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.mt_id.yfilter != YFilter.not_set or
                                                                self.external_route_tag.yfilter != YFilter.not_set or
                                                                self.flags.yfilter != YFilter.not_set or
                                                                self.forwarding_address.yfilter != YFilter.not_set or
                                                                self.metric.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                            if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                            if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.flags.get_name_leafdata())
                                                            if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.metric.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "mt-id" or name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "mt-id"):
                                                                self.mt_id = value
                                                                self.mt_id.value_namespace = name_space
                                                                self.mt_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "external-route-tag"):
                                                                self.external_route_tag = value
                                                                self.external_route_tag.value_namespace = name_space
                                                                self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "flags"):
                                                                self.flags[value] = True
                                                            if(value_path == "forwarding-address"):
                                                                self.forwarding_address = value
                                                                self.forwarding_address.value_namespace = name_space
                                                                self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "metric"):
                                                                self.metric = value
                                                                self.metric.value_namespace = name_space
                                                                self.metric.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.topology:
                                                            if (c.has_data()):
                                                                return True
                                                        return self.network_mask.is_set

                                                    def has_operation(self):
                                                        for c in self.topology:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.network_mask.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "external" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "topology"):
                                                            for c in self.topology:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External.Topology()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.topology.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "topology" or name == "network-mask"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "network-mask"):
                                                            self.network_mask = value
                                                            self.network_mask.value_namespace = name_space
                                                            self.network_mask.value_namespace_prefix = name_space_prefix


                                                class Opaque(Entity):
                                                    """
                                                    Opaque LSA.
                                                    
                                                    .. attribute:: link_tlv
                                                    
                                                    	Link TLV
                                                    	**type**\:   :py:class:`LinkTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv>`
                                                    
                                                    .. attribute:: router_address_tlv
                                                    
                                                    	Router address TLV
                                                    	**type**\:   :py:class:`RouterAddressTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv>`
                                                    
                                                    .. attribute:: unknown_tlv
                                                    
                                                    	Unknown TLV
                                                    	**type**\: list of    :py:class:`UnknownTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.UnknownTlv>`
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque, self).__init__()

                                                        self.yang_name = "opaque"
                                                        self.yang_parent_name = "body"

                                                        self.link_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv()
                                                        self.link_tlv.parent = self
                                                        self._children_name_map["link_tlv"] = "link-tlv"
                                                        self._children_yang_names.add("link-tlv")

                                                        self.router_address_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv()
                                                        self.router_address_tlv.parent = self
                                                        self._children_name_map["router_address_tlv"] = "router-address-tlv"
                                                        self._children_yang_names.add("router-address-tlv")

                                                        self.unknown_tlv = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in () and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque, self).__setattr__(name, value)


                                                    class UnknownTlv(Entity):
                                                        """
                                                        Unknown TLV.
                                                        
                                                        .. attribute:: type  <key>
                                                        
                                                        	TLV type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..65535
                                                        
                                                        .. attribute:: length
                                                        
                                                        	TLV length
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..65535
                                                        
                                                        .. attribute:: value
                                                        
                                                        	TLV value
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__init__()

                                                            self.yang_name = "unknown-tlv"
                                                            self.yang_parent_name = "opaque"

                                                            self.type = YLeaf(YType.uint16, "type")

                                                            self.length = YLeaf(YType.uint16, "length")

                                                            self.value = YLeaf(YType.str, "value")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("type",
                                                                            "length",
                                                                            "value") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.type.is_set or
                                                                self.length.is_set or
                                                                self.value.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.type.yfilter != YFilter.not_set or
                                                                self.length.yfilter != YFilter.not_set or
                                                                self.value.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "unknown-tlv" + "[type='" + self.type.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.type.get_name_leafdata())
                                                            if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.length.get_name_leafdata())
                                                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.value.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "type" or name == "length" or name == "value"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "type"):
                                                                self.type = value
                                                                self.type.value_namespace = name_space
                                                                self.type.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "length"):
                                                                self.length = value
                                                                self.length.value_namespace = name_space
                                                                self.length.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "value"):
                                                                self.value = value
                                                                self.value.value_namespace = name_space
                                                                self.value.value_namespace_prefix = name_space_prefix


                                                    class RouterAddressTlv(Entity):
                                                        """
                                                        Router address TLV.
                                                        
                                                        .. attribute:: router_address
                                                        
                                                        	Router address
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__init__()

                                                            self.yang_name = "router-address-tlv"
                                                            self.yang_parent_name = "opaque"

                                                            self.router_address = YLeaf(YType.str, "router-address")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("router_address") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return self.router_address.is_set

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.router_address.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "router-address-tlv" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.router_address.is_set or self.router_address.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.router_address.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "router-address"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "router-address"):
                                                                self.router_address = value
                                                                self.router_address.value_namespace = name_space
                                                                self.router_address.value_namespace_prefix = name_space_prefix


                                                    class LinkTlv(Entity):
                                                        """
                                                        Link TLV.
                                                        
                                                        .. attribute:: admin_group
                                                        
                                                        	Administrative group/Resource class/Color
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: link_id
                                                        
                                                        	Link ID
                                                        	**type**\: one of the below types:
                                                        
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        	**mandatory**\: True
                                                        
                                                        
                                                        ----
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                        
                                                        	**mandatory**\: True
                                                        
                                                        
                                                        ----
                                                        .. attribute:: link_type
                                                        
                                                        	Link type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        	**mandatory**\: True
                                                        
                                                        .. attribute:: local_if_ipv4_addr
                                                        
                                                        	List of local interface IPv4 addresses
                                                        	**type**\:  list of str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        .. attribute:: local_remote_ipv4_addr
                                                        
                                                        	List of remote interface IPv4 addresses
                                                        	**type**\:  list of str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                        
                                                        .. attribute:: max_bandwidth
                                                        
                                                        	Maximum bandwidth
                                                        	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                        
                                                        	**range:** \-92233720368547758.08..92233720368547758.07
                                                        
                                                        .. attribute:: max_reservable_bandwidth
                                                        
                                                        	Maximum reservable bandwidth
                                                        	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                        
                                                        	**range:** \-92233720368547758.08..92233720368547758.07
                                                        
                                                        .. attribute:: te_metric
                                                        
                                                        	TE metric
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: unknown_subtlv
                                                        
                                                        	Unknown sub\-TLV
                                                        	**type**\: list of    :py:class:`UnknownSubtlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv>`
                                                        
                                                        .. attribute:: unreserved_bandwidth
                                                        
                                                        	Unreserved bandwidth
                                                        	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                        
                                                        	**range:** \-92233720368547758.08..92233720368547758.07
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__init__()

                                                            self.yang_name = "link-tlv"
                                                            self.yang_parent_name = "opaque"

                                                            self.admin_group = YLeaf(YType.uint32, "admin-group")

                                                            self.link_id = YLeaf(YType.str, "link-id")

                                                            self.link_type = YLeaf(YType.uint8, "link-type")

                                                            self.local_if_ipv4_addr = YLeafList(YType.str, "local-if-ipv4-addr")

                                                            self.local_remote_ipv4_addr = YLeafList(YType.str, "local-remote-ipv4-addr")

                                                            self.max_bandwidth = YLeaf(YType.str, "max-bandwidth")

                                                            self.max_reservable_bandwidth = YLeaf(YType.str, "max-reservable-bandwidth")

                                                            self.te_metric = YLeaf(YType.uint32, "te-metric")

                                                            self.unreserved_bandwidth = YLeaf(YType.str, "unreserved-bandwidth")

                                                            self.unknown_subtlv = YList(self)

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("admin_group",
                                                                            "link_id",
                                                                            "link_type",
                                                                            "local_if_ipv4_addr",
                                                                            "local_remote_ipv4_addr",
                                                                            "max_bandwidth",
                                                                            "max_reservable_bandwidth",
                                                                            "te_metric",
                                                                            "unreserved_bandwidth") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__setattr__(name, value)


                                                        class UnknownSubtlv(Entity):
                                                            """
                                                            Unknown sub\-TLV.
                                                            
                                                            .. attribute:: type  <key>
                                                            
                                                            	TLV type
                                                            	**type**\:  int
                                                            
                                                            	**range:** 0..65535
                                                            
                                                            .. attribute:: length
                                                            
                                                            	TLV length
                                                            	**type**\:  int
                                                            
                                                            	**range:** 0..65535
                                                            
                                                            .. attribute:: value
                                                            
                                                            	TLV value
                                                            	**type**\:  str
                                                            
                                                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                            
                                                            

                                                            """

                                                            _prefix = 'ospf'
                                                            _revision = '2015-03-09'

                                                            def __init__(self):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__init__()

                                                                self.yang_name = "unknown-subtlv"
                                                                self.yang_parent_name = "link-tlv"

                                                                self.type = YLeaf(YType.uint16, "type")

                                                                self.length = YLeaf(YType.uint16, "length")

                                                                self.value = YLeaf(YType.str, "value")

                                                            def __setattr__(self, name, value):
                                                                self._check_monkey_patching_error(name, value)
                                                                with _handle_type_error():
                                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                            "Please use list append or extend method."
                                                                                            .format(value))
                                                                    if isinstance(value, Enum.YLeaf):
                                                                        value = value.name
                                                                    if name in ("type",
                                                                                "length",
                                                                                "value") and name in self.__dict__:
                                                                        if isinstance(value, YLeaf):
                                                                            self.__dict__[name].set(value.get())
                                                                        elif isinstance(value, YLeafList):
                                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__setattr__(name, value)
                                                                        else:
                                                                            self.__dict__[name].set(value)
                                                                    else:
                                                                        if hasattr(value, "parent") and name != "parent":
                                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                                value.parent = self
                                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                                value.parent = self
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__setattr__(name, value)

                                                            def has_data(self):
                                                                return (
                                                                    self.type.is_set or
                                                                    self.length.is_set or
                                                                    self.value.is_set)

                                                            def has_operation(self):
                                                                return (
                                                                    self.yfilter != YFilter.not_set or
                                                                    self.type.yfilter != YFilter.not_set or
                                                                    self.length.yfilter != YFilter.not_set or
                                                                    self.value.yfilter != YFilter.not_set)

                                                            def get_segment_path(self):
                                                                path_buffer = ""
                                                                path_buffer = "unknown-subtlv" + "[type='" + self.type.get() + "']" + path_buffer

                                                                return path_buffer

                                                            def get_entity_path(self, ancestor):
                                                                path_buffer = ""
                                                                if (ancestor is None):
                                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                                else:
                                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                                leaf_name_data = LeafDataList()
                                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.type.get_name_leafdata())
                                                                if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.length.get_name_leafdata())
                                                                if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.value.get_name_leafdata())

                                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                                return entity_path

                                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                                if child is not None:
                                                                    return child

                                                                return None

                                                            def has_leaf_or_child_of_name(self, name):
                                                                if(name == "type" or name == "length" or name == "value"):
                                                                    return True
                                                                return False

                                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                                if(value_path == "type"):
                                                                    self.type = value
                                                                    self.type.value_namespace = name_space
                                                                    self.type.value_namespace_prefix = name_space_prefix
                                                                if(value_path == "length"):
                                                                    self.length = value
                                                                    self.length.value_namespace = name_space
                                                                    self.length.value_namespace_prefix = name_space_prefix
                                                                if(value_path == "value"):
                                                                    self.value = value
                                                                    self.value.value_namespace = name_space
                                                                    self.value.value_namespace_prefix = name_space_prefix

                                                        def has_data(self):
                                                            for c in self.unknown_subtlv:
                                                                if (c.has_data()):
                                                                    return True
                                                            for leaf in self.local_if_ipv4_addr.getYLeafs():
                                                                if (leaf.yfilter != YFilter.not_set):
                                                                    return True
                                                            for leaf in self.local_remote_ipv4_addr.getYLeafs():
                                                                if (leaf.yfilter != YFilter.not_set):
                                                                    return True
                                                            return (
                                                                self.admin_group.is_set or
                                                                self.link_id.is_set or
                                                                self.link_type.is_set or
                                                                self.max_bandwidth.is_set or
                                                                self.max_reservable_bandwidth.is_set or
                                                                self.te_metric.is_set or
                                                                self.unreserved_bandwidth.is_set)

                                                        def has_operation(self):
                                                            for c in self.unknown_subtlv:
                                                                if (c.has_operation()):
                                                                    return True
                                                            for leaf in self.local_if_ipv4_addr.getYLeafs():
                                                                if (leaf.is_set):
                                                                    return True
                                                            for leaf in self.local_remote_ipv4_addr.getYLeafs():
                                                                if (leaf.is_set):
                                                                    return True
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.admin_group.yfilter != YFilter.not_set or
                                                                self.link_id.yfilter != YFilter.not_set or
                                                                self.link_type.yfilter != YFilter.not_set or
                                                                self.local_if_ipv4_addr.yfilter != YFilter.not_set or
                                                                self.local_remote_ipv4_addr.yfilter != YFilter.not_set or
                                                                self.max_bandwidth.yfilter != YFilter.not_set or
                                                                self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                                                                self.te_metric.yfilter != YFilter.not_set or
                                                                self.unreserved_bandwidth.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "link-tlv" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.admin_group.is_set or self.admin_group.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.admin_group.get_name_leafdata())
                                                            if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.link_id.get_name_leafdata())
                                                            if (self.link_type.is_set or self.link_type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.link_type.get_name_leafdata())
                                                            if (self.max_bandwidth.is_set or self.max_bandwidth.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.max_bandwidth.get_name_leafdata())
                                                            if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                                                            if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.te_metric.get_name_leafdata())
                                                            if (self.unreserved_bandwidth.is_set or self.unreserved_bandwidth.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.unreserved_bandwidth.get_name_leafdata())

                                                            leaf_name_data.extend(self.local_if_ipv4_addr.get_name_leafdata())

                                                            leaf_name_data.extend(self.local_remote_ipv4_addr.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            if (child_yang_name == "unknown-subtlv"):
                                                                for c in self.unknown_subtlv:
                                                                    segment = c.get_segment_path()
                                                                    if (segment_path == segment):
                                                                        return c
                                                                c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv()
                                                                c.parent = self
                                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                                self._local_refs[local_reference_key] = c
                                                                self.unknown_subtlv.append(c)
                                                                return c

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "unknown-subtlv" or name == "admin-group" or name == "link-id" or name == "link-type" or name == "local-if-ipv4-addr" or name == "local-remote-ipv4-addr" or name == "max-bandwidth" or name == "max-reservable-bandwidth" or name == "te-metric" or name == "unreserved-bandwidth"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "admin-group"):
                                                                self.admin_group = value
                                                                self.admin_group.value_namespace = name_space
                                                                self.admin_group.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "link-id"):
                                                                self.link_id = value
                                                                self.link_id.value_namespace = name_space
                                                                self.link_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "link-type"):
                                                                self.link_type = value
                                                                self.link_type.value_namespace = name_space
                                                                self.link_type.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "local-if-ipv4-addr"):
                                                                self.local_if_ipv4_addr.append(value)
                                                            if(value_path == "local-remote-ipv4-addr"):
                                                                self.local_remote_ipv4_addr.append(value)
                                                            if(value_path == "max-bandwidth"):
                                                                self.max_bandwidth = value
                                                                self.max_bandwidth.value_namespace = name_space
                                                                self.max_bandwidth.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "max-reservable-bandwidth"):
                                                                self.max_reservable_bandwidth = value
                                                                self.max_reservable_bandwidth.value_namespace = name_space
                                                                self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "te-metric"):
                                                                self.te_metric = value
                                                                self.te_metric.value_namespace = name_space
                                                                self.te_metric.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "unreserved-bandwidth"):
                                                                self.unreserved_bandwidth = value
                                                                self.unreserved_bandwidth.value_namespace = name_space
                                                                self.unreserved_bandwidth.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.unknown_tlv:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            (self.link_tlv is not None and self.link_tlv.has_data()) or
                                                            (self.router_address_tlv is not None and self.router_address_tlv.has_data()))

                                                    def has_operation(self):
                                                        for c in self.unknown_tlv:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            (self.link_tlv is not None and self.link_tlv.has_operation()) or
                                                            (self.router_address_tlv is not None and self.router_address_tlv.has_operation()))

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "opaque" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "link-tlv"):
                                                            if (self.link_tlv is None):
                                                                self.link_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.LinkTlv()
                                                                self.link_tlv.parent = self
                                                                self._children_name_map["link_tlv"] = "link-tlv"
                                                            return self.link_tlv

                                                        if (child_yang_name == "router-address-tlv"):
                                                            if (self.router_address_tlv is None):
                                                                self.router_address_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv()
                                                                self.router_address_tlv.parent = self
                                                                self._children_name_map["router_address_tlv"] = "router-address-tlv"
                                                            return self.router_address_tlv

                                                        if (child_yang_name == "unknown-tlv"):
                                                            for c in self.unknown_tlv:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque.UnknownTlv()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.unknown_tlv.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "link-tlv" or name == "router-address-tlv" or name == "unknown-tlv"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        pass

                                                def has_data(self):
                                                    return (
                                                        (self.external is not None and self.external.has_data()) or
                                                        (self.network is not None and self.network.has_data()) or
                                                        (self.opaque is not None and self.opaque.has_data()) or
                                                        (self.router is not None and self.router.has_data()) or
                                                        (self.summary is not None and self.summary.has_data()))

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        (self.external is not None and self.external.has_operation()) or
                                                        (self.network is not None and self.network.has_operation()) or
                                                        (self.opaque is not None and self.opaque.has_operation()) or
                                                        (self.router is not None and self.router.has_operation()) or
                                                        (self.summary is not None and self.summary.has_operation()))

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "body" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "external"):
                                                        if (self.external is None):
                                                            self.external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.External()
                                                            self.external.parent = self
                                                            self._children_name_map["external"] = "external"
                                                        return self.external

                                                    if (child_yang_name == "network"):
                                                        if (self.network is None):
                                                            self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Network()
                                                            self.network.parent = self
                                                            self._children_name_map["network"] = "network"
                                                        return self.network

                                                    if (child_yang_name == "opaque"):
                                                        if (self.opaque is None):
                                                            self.opaque = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Opaque()
                                                            self.opaque.parent = self
                                                            self._children_name_map["opaque"] = "opaque"
                                                        return self.opaque

                                                    if (child_yang_name == "router"):
                                                        if (self.router is None):
                                                            self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Router()
                                                            self.router.parent = self
                                                            self._children_name_map["router"] = "router"
                                                        return self.router

                                                    if (child_yang_name == "summary"):
                                                        if (self.summary is None):
                                                            self.summary = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body.Summary()
                                                            self.summary.parent = self
                                                            self._children_name_map["summary"] = "summary"
                                                        return self.summary

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "external" or name == "network" or name == "opaque" or name == "router" or name == "summary"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    (self.body is not None and self.body.has_data()) or
                                                    (self.header is not None and self.header.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    (self.body is not None and self.body.has_operation()) or
                                                    (self.header is not None and self.header.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "ospfv2" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "body"):
                                                    if (self.body is None):
                                                        self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Body()
                                                        self.body.parent = self
                                                        self._children_name_map["body"] = "body"
                                                    return self.body

                                                if (child_yang_name == "header"):
                                                    if (self.header is None):
                                                        self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2.Header()
                                                        self.header.parent = self
                                                        self._children_name_map["header"] = "header"
                                                    return self.header

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "body" or name == "header"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass


                                        class Ospfv3(Entity):
                                            """
                                            OSPFv3 LSA
                                            
                                            .. attribute:: body
                                            
                                            	Decoded OSPF LSA body data
                                            	**type**\:   :py:class:`Body <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body>`
                                            
                                            .. attribute:: header
                                            
                                            	Decoded OSPFv3 LSA header data
                                            	**type**\:   :py:class:`Header <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3, self).__init__()

                                                self.yang_name = "ospfv3"
                                                self.yang_parent_name = "link-scope-lsa"

                                                self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body()
                                                self.body.parent = self
                                                self._children_name_map["body"] = "body"
                                                self._children_yang_names.add("body")

                                                self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header()
                                                self.header.parent = self
                                                self._children_name_map["header"] = "header"
                                                self._children_yang_names.add("header")


                                            class Header(Entity):
                                                """
                                                Decoded OSPFv3 LSA header data.
                                                
                                                .. attribute:: adv_router
                                                
                                                	LSA advertising router
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: age
                                                
                                                	LSA age
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: checksum
                                                
                                                	LSA checksum
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: length
                                                
                                                	LSA length
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: lsa_id
                                                
                                                	LSA ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: options
                                                
                                                	OSPFv3 LSA options
                                                	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header.Options>`
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: seq_num
                                                
                                                	LSA sequence number
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: type
                                                
                                                	LSA type
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header, self).__init__()

                                                    self.yang_name = "header"
                                                    self.yang_parent_name = "ospfv3"

                                                    self.adv_router = YLeaf(YType.str, "adv-router")

                                                    self.age = YLeaf(YType.uint16, "age")

                                                    self.checksum = YLeaf(YType.str, "checksum")

                                                    self.length = YLeaf(YType.uint16, "length")

                                                    self.lsa_id = YLeaf(YType.uint32, "lsa-id")

                                                    self.options = YLeaf(YType.bits, "options")

                                                    self.seq_num = YLeaf(YType.str, "seq-num")

                                                    self.type = YLeaf(YType.uint16, "type")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("adv_router",
                                                                    "age",
                                                                    "checksum",
                                                                    "length",
                                                                    "lsa_id",
                                                                    "options",
                                                                    "seq_num",
                                                                    "type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.adv_router.is_set or
                                                        self.age.is_set or
                                                        self.checksum.is_set or
                                                        self.length.is_set or
                                                        self.lsa_id.is_set or
                                                        self.options.is_set or
                                                        self.seq_num.is_set or
                                                        self.type.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.adv_router.yfilter != YFilter.not_set or
                                                        self.age.yfilter != YFilter.not_set or
                                                        self.checksum.yfilter != YFilter.not_set or
                                                        self.length.yfilter != YFilter.not_set or
                                                        self.lsa_id.yfilter != YFilter.not_set or
                                                        self.options.yfilter != YFilter.not_set or
                                                        self.seq_num.yfilter != YFilter.not_set or
                                                        self.type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "header" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.adv_router.get_name_leafdata())
                                                    if (self.age.is_set or self.age.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.age.get_name_leafdata())
                                                    if (self.checksum.is_set or self.checksum.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.checksum.get_name_leafdata())
                                                    if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.length.get_name_leafdata())
                                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                                    if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.options.get_name_leafdata())
                                                    if (self.seq_num.is_set or self.seq_num.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.seq_num.get_name_leafdata())
                                                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "adv-router" or name == "age" or name == "checksum" or name == "length" or name == "lsa-id" or name == "options" or name == "seq-num" or name == "type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "adv-router"):
                                                        self.adv_router = value
                                                        self.adv_router.value_namespace = name_space
                                                        self.adv_router.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "age"):
                                                        self.age = value
                                                        self.age.value_namespace = name_space
                                                        self.age.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "checksum"):
                                                        self.checksum = value
                                                        self.checksum.value_namespace = name_space
                                                        self.checksum.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "length"):
                                                        self.length = value
                                                        self.length.value_namespace = name_space
                                                        self.length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "lsa-id"):
                                                        self.lsa_id = value
                                                        self.lsa_id.value_namespace = name_space
                                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "options"):
                                                        self.options[value] = True
                                                    if(value_path == "seq-num"):
                                                        self.seq_num = value
                                                        self.seq_num.value_namespace = name_space
                                                        self.seq_num.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "type"):
                                                        self.type = value
                                                        self.type.value_namespace = name_space
                                                        self.type.value_namespace_prefix = name_space_prefix


                                            class Body(Entity):
                                                """
                                                Decoded OSPF LSA body data.
                                                
                                                .. attribute:: as_external
                                                
                                                	AS\-External LSA
                                                	**type**\:   :py:class:`AsExternal <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal>`
                                                
                                                .. attribute:: inter_area_prefix
                                                
                                                	Inter\-Area\-Prefix LSA
                                                	**type**\:   :py:class:`InterAreaPrefix <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaPrefix>`
                                                
                                                .. attribute:: inter_area_router
                                                
                                                	Inter\-Area\-Router LSA
                                                	**type**\:   :py:class:`InterAreaRouter <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter>`
                                                
                                                .. attribute:: intra_area_prefix
                                                
                                                	Intra\-Area\-Prefix LSA
                                                	**type**\:   :py:class:`IntraAreaPrefix <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix>`
                                                
                                                .. attribute:: link
                                                
                                                	Link LSA
                                                	**type**\:   :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link>`
                                                
                                                .. attribute:: network
                                                
                                                	Network LSA
                                                	**type**\:   :py:class:`Network <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network>`
                                                
                                                .. attribute:: nssa
                                                
                                                	NSSA LSA
                                                	**type**\:   :py:class:`Nssa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa>`
                                                
                                                .. attribute:: router
                                                
                                                	Router LSA
                                                	**type**\:   :py:class:`Router <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router>`
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body, self).__init__()

                                                    self.yang_name = "body"
                                                    self.yang_parent_name = "ospfv3"

                                                    self.as_external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal()
                                                    self.as_external.parent = self
                                                    self._children_name_map["as_external"] = "as-external"
                                                    self._children_yang_names.add("as-external")

                                                    self.inter_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaPrefix()
                                                    self.inter_area_prefix.parent = self
                                                    self._children_name_map["inter_area_prefix"] = "inter-area-prefix"
                                                    self._children_yang_names.add("inter-area-prefix")

                                                    self.inter_area_router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter()
                                                    self.inter_area_router.parent = self
                                                    self._children_name_map["inter_area_router"] = "inter-area-router"
                                                    self._children_yang_names.add("inter-area-router")

                                                    self.intra_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix()
                                                    self.intra_area_prefix.parent = self
                                                    self._children_name_map["intra_area_prefix"] = "intra-area-prefix"
                                                    self._children_yang_names.add("intra-area-prefix")

                                                    self.link = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link()
                                                    self.link.parent = self
                                                    self._children_name_map["link"] = "link"
                                                    self._children_yang_names.add("link")

                                                    self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network()
                                                    self.network.parent = self
                                                    self._children_name_map["network"] = "network"
                                                    self._children_yang_names.add("network")

                                                    self.nssa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa()
                                                    self.nssa.parent = self
                                                    self._children_name_map["nssa"] = "nssa"
                                                    self._children_yang_names.add("nssa")

                                                    self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router()
                                                    self.router.parent = self
                                                    self._children_name_map["router"] = "router"
                                                    self._children_yang_names.add("router")


                                                class Router(Entity):
                                                    """
                                                    Router LSA.
                                                    
                                                    .. attribute:: flags
                                                    
                                                    	LSA option
                                                    	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Flags>`
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    .. attribute:: link
                                                    
                                                    	Router LSA link
                                                    	**type**\: list of    :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Link>`
                                                    
                                                    .. attribute:: options
                                                    
                                                    	OSPFv3 LSA options
                                                    	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Options>`
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router, self).__init__()

                                                        self.yang_name = "router"
                                                        self.yang_parent_name = "body"

                                                        self.flags = YLeaf(YType.bits, "flags")

                                                        self.options = YLeaf(YType.bits, "options")

                                                        self.link = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("flags",
                                                                        "options") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router, self).__setattr__(name, value)


                                                    class Link(Entity):
                                                        """
                                                        Router LSA link.
                                                        
                                                        .. attribute:: interface_id  <key>
                                                        
                                                        	Interface ID
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: neighbor_interface_id  <key>
                                                        
                                                        	Neighbor Interface ID
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: neighbor_router_id  <key>
                                                        
                                                        	Neighbor Router ID
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                        
                                                        .. attribute:: metric
                                                        
                                                        	Metric
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..65535
                                                        
                                                        .. attribute:: type
                                                        
                                                        	Link type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Link, self).__init__()

                                                            self.yang_name = "link"
                                                            self.yang_parent_name = "router"

                                                            self.interface_id = YLeaf(YType.uint32, "interface-id")

                                                            self.neighbor_interface_id = YLeaf(YType.uint32, "neighbor-interface-id")

                                                            self.neighbor_router_id = YLeaf(YType.str, "neighbor-router-id")

                                                            self.metric = YLeaf(YType.uint16, "metric")

                                                            self.type = YLeaf(YType.uint8, "type")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("interface_id",
                                                                            "neighbor_interface_id",
                                                                            "neighbor_router_id",
                                                                            "metric",
                                                                            "type") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Link, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Link, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.interface_id.is_set or
                                                                self.neighbor_interface_id.is_set or
                                                                self.neighbor_router_id.is_set or
                                                                self.metric.is_set or
                                                                self.type.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.interface_id.yfilter != YFilter.not_set or
                                                                self.neighbor_interface_id.yfilter != YFilter.not_set or
                                                                self.neighbor_router_id.yfilter != YFilter.not_set or
                                                                self.metric.yfilter != YFilter.not_set or
                                                                self.type.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "link" + "[interface-id='" + self.interface_id.get() + "']" + "[neighbor-interface-id='" + self.neighbor_interface_id.get() + "']" + "[neighbor-router-id='" + self.neighbor_router_id.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.interface_id.is_set or self.interface_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.interface_id.get_name_leafdata())
                                                            if (self.neighbor_interface_id.is_set or self.neighbor_interface_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.neighbor_interface_id.get_name_leafdata())
                                                            if (self.neighbor_router_id.is_set or self.neighbor_router_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.neighbor_router_id.get_name_leafdata())
                                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.type.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "interface-id" or name == "neighbor-interface-id" or name == "neighbor-router-id" or name == "metric" or name == "type"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "interface-id"):
                                                                self.interface_id = value
                                                                self.interface_id.value_namespace = name_space
                                                                self.interface_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "neighbor-interface-id"):
                                                                self.neighbor_interface_id = value
                                                                self.neighbor_interface_id.value_namespace = name_space
                                                                self.neighbor_interface_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "neighbor-router-id"):
                                                                self.neighbor_router_id = value
                                                                self.neighbor_router_id.value_namespace = name_space
                                                                self.neighbor_router_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "metric"):
                                                                self.metric = value
                                                                self.metric.value_namespace = name_space
                                                                self.metric.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "type"):
                                                                self.type = value
                                                                self.type.value_namespace = name_space
                                                                self.type.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.link:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.flags.is_set or
                                                            self.options.is_set)

                                                    def has_operation(self):
                                                        for c in self.link:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.flags.yfilter != YFilter.not_set or
                                                            self.options.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "router" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.flags.get_name_leafdata())
                                                        if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.options.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "link"):
                                                            for c in self.link:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router.Link()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.link.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "link" or name == "flags" or name == "options"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "flags"):
                                                            self.flags[value] = True
                                                        if(value_path == "options"):
                                                            self.options[value] = True


                                                class Network(Entity):
                                                    """
                                                    Network LSA.
                                                    
                                                    .. attribute:: attached_router
                                                    
                                                    	List of the routers attached to the network
                                                    	**type**\:  list of str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                    
                                                    .. attribute:: options
                                                    
                                                    	OSPFv3 LSA options
                                                    	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network.Options>`
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network, self).__init__()

                                                        self.yang_name = "network"
                                                        self.yang_parent_name = "body"

                                                        self.attached_router = YLeafList(YType.str, "attached-router")

                                                        self.options = YLeaf(YType.bits, "options")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("attached_router",
                                                                        "options") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        for leaf in self.attached_router.getYLeafs():
                                                            if (leaf.yfilter != YFilter.not_set):
                                                                return True
                                                        return self.options.is_set

                                                    def has_operation(self):
                                                        for leaf in self.attached_router.getYLeafs():
                                                            if (leaf.is_set):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.attached_router.yfilter != YFilter.not_set or
                                                            self.options.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "network" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.options.get_name_leafdata())

                                                        leaf_name_data.extend(self.attached_router.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "attached-router" or name == "options"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "attached-router"):
                                                            self.attached_router.append(value)
                                                        if(value_path == "options"):
                                                            self.options[value] = True


                                                class InterAreaPrefix(Entity):
                                                    """
                                                    Inter\-Area\-Prefix LSA.
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    .. attribute:: prefix
                                                    
                                                    	Prefix
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: prefix_options
                                                    
                                                    	Prefix options
                                                    	**type**\:  str
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__init__()

                                                        self.yang_name = "inter-area-prefix"
                                                        self.yang_parent_name = "body"

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                        self.prefix = YLeaf(YType.str, "prefix")

                                                        self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("metric",
                                                                        "prefix",
                                                                        "prefix_options") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.metric.is_set or
                                                            self.prefix.is_set or
                                                            self.prefix_options.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set or
                                                            self.prefix.yfilter != YFilter.not_set or
                                                            self.prefix_options.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "inter-area-prefix" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                                        if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "metric" or name == "prefix" or name == "prefix-options"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix"):
                                                            self.prefix = value
                                                            self.prefix.value_namespace = name_space
                                                            self.prefix.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix-options"):
                                                            self.prefix_options = value
                                                            self.prefix_options.value_namespace = name_space
                                                            self.prefix_options.value_namespace_prefix = name_space_prefix


                                                class InterAreaRouter(Entity):
                                                    """
                                                    Inter\-Area\-Router LSA.
                                                    
                                                    .. attribute:: destination_router_id
                                                    
                                                    	The Router ID of the router being described by the LSA
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    .. attribute:: options
                                                    
                                                    	OSPFv3 LSA options
                                                    	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter.Options>`
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter, self).__init__()

                                                        self.yang_name = "inter-area-router"
                                                        self.yang_parent_name = "body"

                                                        self.destination_router_id = YLeaf(YType.str, "destination-router-id")

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                        self.options = YLeaf(YType.bits, "options")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("destination_router_id",
                                                                        "metric",
                                                                        "options") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.destination_router_id.is_set or
                                                            self.metric.is_set or
                                                            self.options.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.destination_router_id.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set or
                                                            self.options.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "inter-area-router" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.destination_router_id.is_set or self.destination_router_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.destination_router_id.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                                        if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.options.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "destination-router-id" or name == "metric" or name == "options"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "destination-router-id"):
                                                            self.destination_router_id = value
                                                            self.destination_router_id.value_namespace = name_space
                                                            self.destination_router_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "options"):
                                                            self.options[value] = True


                                                class AsExternal(Entity):
                                                    """
                                                    AS\-External LSA.
                                                    
                                                    .. attribute:: external_route_tag
                                                    
                                                    	Route tag
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: flags
                                                    
                                                    	Flags
                                                    	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal.Flags>`
                                                    
                                                    .. attribute:: forwarding_address
                                                    
                                                    	Forwarding address
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    .. attribute:: prefix
                                                    
                                                    	Prefix
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: prefix_options
                                                    
                                                    	Prefix options
                                                    	**type**\:  str
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    .. attribute:: referenced_link_state_id
                                                    
                                                    	Referenced Link State ID
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: referenced_ls_type
                                                    
                                                    	Referenced Link State type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal, self).__init__()

                                                        self.yang_name = "as-external"
                                                        self.yang_parent_name = "body"

                                                        self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                        self.flags = YLeaf(YType.bits, "flags")

                                                        self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                        self.prefix = YLeaf(YType.str, "prefix")

                                                        self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                        self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                        self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("external_route_tag",
                                                                        "flags",
                                                                        "forwarding_address",
                                                                        "metric",
                                                                        "prefix",
                                                                        "prefix_options",
                                                                        "referenced_link_state_id",
                                                                        "referenced_ls_type") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.external_route_tag.is_set or
                                                            self.flags.is_set or
                                                            self.forwarding_address.is_set or
                                                            self.metric.is_set or
                                                            self.prefix.is_set or
                                                            self.prefix_options.is_set or
                                                            self.referenced_link_state_id.is_set or
                                                            self.referenced_ls_type.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.external_route_tag.yfilter != YFilter.not_set or
                                                            self.flags.yfilter != YFilter.not_set or
                                                            self.forwarding_address.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set or
                                                            self.prefix.yfilter != YFilter.not_set or
                                                            self.prefix_options.yfilter != YFilter.not_set or
                                                            self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                            self.referenced_ls_type.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "as-external" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.flags.get_name_leafdata())
                                                        if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                                        if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix_options.get_name_leafdata())
                                                        if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                        if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric" or name == "prefix" or name == "prefix-options" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "external-route-tag"):
                                                            self.external_route_tag = value
                                                            self.external_route_tag.value_namespace = name_space
                                                            self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "flags"):
                                                            self.flags[value] = True
                                                        if(value_path == "forwarding-address"):
                                                            self.forwarding_address = value
                                                            self.forwarding_address.value_namespace = name_space
                                                            self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix"):
                                                            self.prefix = value
                                                            self.prefix.value_namespace = name_space
                                                            self.prefix.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix-options"):
                                                            self.prefix_options = value
                                                            self.prefix_options.value_namespace = name_space
                                                            self.prefix_options.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-link-state-id"):
                                                            self.referenced_link_state_id = value
                                                            self.referenced_link_state_id.value_namespace = name_space
                                                            self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-ls-type"):
                                                            self.referenced_ls_type = value
                                                            self.referenced_ls_type.value_namespace = name_space
                                                            self.referenced_ls_type.value_namespace_prefix = name_space_prefix


                                                class Nssa(Entity):
                                                    """
                                                    NSSA LSA.
                                                    
                                                    .. attribute:: external_route_tag
                                                    
                                                    	Route tag
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: flags
                                                    
                                                    	Flags
                                                    	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa.Flags>`
                                                    
                                                    .. attribute:: forwarding_address
                                                    
                                                    	Forwarding address
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    .. attribute:: prefix
                                                    
                                                    	Prefix
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: prefix_options
                                                    
                                                    	Prefix options
                                                    	**type**\:  str
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    .. attribute:: referenced_link_state_id
                                                    
                                                    	Referenced Link State ID
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: referenced_ls_type
                                                    
                                                    	Referenced Link State type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa, self).__init__()

                                                        self.yang_name = "nssa"
                                                        self.yang_parent_name = "body"

                                                        self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                        self.flags = YLeaf(YType.bits, "flags")

                                                        self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                        self.prefix = YLeaf(YType.str, "prefix")

                                                        self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                        self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                        self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("external_route_tag",
                                                                        "flags",
                                                                        "forwarding_address",
                                                                        "metric",
                                                                        "prefix",
                                                                        "prefix_options",
                                                                        "referenced_link_state_id",
                                                                        "referenced_ls_type") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.external_route_tag.is_set or
                                                            self.flags.is_set or
                                                            self.forwarding_address.is_set or
                                                            self.metric.is_set or
                                                            self.prefix.is_set or
                                                            self.prefix_options.is_set or
                                                            self.referenced_link_state_id.is_set or
                                                            self.referenced_ls_type.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.external_route_tag.yfilter != YFilter.not_set or
                                                            self.flags.yfilter != YFilter.not_set or
                                                            self.forwarding_address.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set or
                                                            self.prefix.yfilter != YFilter.not_set or
                                                            self.prefix_options.yfilter != YFilter.not_set or
                                                            self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                            self.referenced_ls_type.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "nssa" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.flags.get_name_leafdata())
                                                        if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                                        if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix_options.get_name_leafdata())
                                                        if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                        if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric" or name == "prefix" or name == "prefix-options" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "external-route-tag"):
                                                            self.external_route_tag = value
                                                            self.external_route_tag.value_namespace = name_space
                                                            self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "flags"):
                                                            self.flags[value] = True
                                                        if(value_path == "forwarding-address"):
                                                            self.forwarding_address = value
                                                            self.forwarding_address.value_namespace = name_space
                                                            self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix"):
                                                            self.prefix = value
                                                            self.prefix.value_namespace = name_space
                                                            self.prefix.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix-options"):
                                                            self.prefix_options = value
                                                            self.prefix_options.value_namespace = name_space
                                                            self.prefix_options.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-link-state-id"):
                                                            self.referenced_link_state_id = value
                                                            self.referenced_link_state_id.value_namespace = name_space
                                                            self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-ls-type"):
                                                            self.referenced_ls_type = value
                                                            self.referenced_ls_type.value_namespace = name_space
                                                            self.referenced_ls_type.value_namespace_prefix = name_space_prefix


                                                class Link(Entity):
                                                    """
                                                    Link LSA.
                                                    
                                                    .. attribute:: link_local_interface_address
                                                    
                                                    	The originating router's link\-local interface address on the link
                                                    	**type**\: one of the below types:
                                                    
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    
                                                    ----
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                                    
                                                    
                                                    ----
                                                    .. attribute:: num_of_prefixes
                                                    
                                                    	Number of prefixes
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: options
                                                    
                                                    	OSPFv3 LSA options
                                                    	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link.Options>`
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    .. attribute:: prefix_list
                                                    
                                                    	List of prefixes associated with the link
                                                    	**type**\: list of    :py:class:`PrefixList <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link.PrefixList>`
                                                    
                                                    .. attribute:: rtr_priority
                                                    
                                                    	Router Priority of the interface
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link, self).__init__()

                                                        self.yang_name = "link"
                                                        self.yang_parent_name = "body"

                                                        self.link_local_interface_address = YLeaf(YType.str, "link-local-interface-address")

                                                        self.num_of_prefixes = YLeaf(YType.uint32, "num-of-prefixes")

                                                        self.options = YLeaf(YType.bits, "options")

                                                        self.rtr_priority = YLeaf(YType.uint8, "rtr-priority")

                                                        self.prefix_list = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("link_local_interface_address",
                                                                        "num_of_prefixes",
                                                                        "options",
                                                                        "rtr_priority") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link, self).__setattr__(name, value)


                                                    class PrefixList(Entity):
                                                        """
                                                        List of prefixes associated with the link.
                                                        
                                                        .. attribute:: prefix  <key>
                                                        
                                                        	Prefix
                                                        	**type**\:  str
                                                        
                                                        .. attribute:: prefix_options
                                                        
                                                        	Prefix options
                                                        	**type**\:  str
                                                        
                                                        	**mandatory**\: True
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link.PrefixList, self).__init__()

                                                            self.yang_name = "prefix-list"
                                                            self.yang_parent_name = "link"

                                                            self.prefix = YLeaf(YType.str, "prefix")

                                                            self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("prefix",
                                                                            "prefix_options") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link.PrefixList, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link.PrefixList, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.prefix.is_set or
                                                                self.prefix_options.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.prefix.yfilter != YFilter.not_set or
                                                                self.prefix_options.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "prefix-list" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.prefix.get_name_leafdata())
                                                            if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "prefix" or name == "prefix-options"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "prefix"):
                                                                self.prefix = value
                                                                self.prefix.value_namespace = name_space
                                                                self.prefix.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "prefix-options"):
                                                                self.prefix_options = value
                                                                self.prefix_options.value_namespace = name_space
                                                                self.prefix_options.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.prefix_list:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.link_local_interface_address.is_set or
                                                            self.num_of_prefixes.is_set or
                                                            self.options.is_set or
                                                            self.rtr_priority.is_set)

                                                    def has_operation(self):
                                                        for c in self.prefix_list:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.link_local_interface_address.yfilter != YFilter.not_set or
                                                            self.num_of_prefixes.yfilter != YFilter.not_set or
                                                            self.options.yfilter != YFilter.not_set or
                                                            self.rtr_priority.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "link" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.link_local_interface_address.is_set or self.link_local_interface_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.link_local_interface_address.get_name_leafdata())
                                                        if (self.num_of_prefixes.is_set or self.num_of_prefixes.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.num_of_prefixes.get_name_leafdata())
                                                        if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.options.get_name_leafdata())
                                                        if (self.rtr_priority.is_set or self.rtr_priority.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.rtr_priority.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "prefix-list"):
                                                            for c in self.prefix_list:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link.PrefixList()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.prefix_list.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "prefix-list" or name == "link-local-interface-address" or name == "num-of-prefixes" or name == "options" or name == "rtr-priority"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "link-local-interface-address"):
                                                            self.link_local_interface_address = value
                                                            self.link_local_interface_address.value_namespace = name_space
                                                            self.link_local_interface_address.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "num-of-prefixes"):
                                                            self.num_of_prefixes = value
                                                            self.num_of_prefixes.value_namespace = name_space
                                                            self.num_of_prefixes.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "options"):
                                                            self.options[value] = True
                                                        if(value_path == "rtr-priority"):
                                                            self.rtr_priority = value
                                                            self.rtr_priority.value_namespace = name_space
                                                            self.rtr_priority.value_namespace_prefix = name_space_prefix


                                                class IntraAreaPrefix(Entity):
                                                    """
                                                    Intra\-Area\-Prefix LSA.
                                                    
                                                    .. attribute:: num_of_prefixes
                                                    
                                                    	Number of prefixes
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: prefix_list
                                                    
                                                    	List of prefixes associated with the link
                                                    	**type**\: list of    :py:class:`PrefixList <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList>`
                                                    
                                                    .. attribute:: referenced_adv_router
                                                    
                                                    	Referenced Advertising Router
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: referenced_link_state_id
                                                    
                                                    	Referenced Link State ID
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: referenced_ls_type
                                                    
                                                    	Referenced Link State type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__init__()

                                                        self.yang_name = "intra-area-prefix"
                                                        self.yang_parent_name = "body"

                                                        self.num_of_prefixes = YLeaf(YType.uint16, "num-of-prefixes")

                                                        self.referenced_adv_router = YLeaf(YType.str, "referenced-adv-router")

                                                        self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                        self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                        self.prefix_list = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("num_of_prefixes",
                                                                        "referenced_adv_router",
                                                                        "referenced_link_state_id",
                                                                        "referenced_ls_type") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__setattr__(name, value)


                                                    class PrefixList(Entity):
                                                        """
                                                        List of prefixes associated with the link.
                                                        
                                                        .. attribute:: prefix  <key>
                                                        
                                                        	Prefix
                                                        	**type**\:  str
                                                        
                                                        .. attribute:: metric
                                                        
                                                        	Metric
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..16777215
                                                        
                                                        .. attribute:: prefix_options
                                                        
                                                        	Prefix options
                                                        	**type**\:  str
                                                        
                                                        	**mandatory**\: True
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__init__()

                                                            self.yang_name = "prefix-list"
                                                            self.yang_parent_name = "intra-area-prefix"

                                                            self.prefix = YLeaf(YType.str, "prefix")

                                                            self.metric = YLeaf(YType.uint32, "metric")

                                                            self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("prefix",
                                                                            "metric",
                                                                            "prefix_options") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.prefix.is_set or
                                                                self.metric.is_set or
                                                                self.prefix_options.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.prefix.yfilter != YFilter.not_set or
                                                                self.metric.yfilter != YFilter.not_set or
                                                                self.prefix_options.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "prefix-list" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.prefix.get_name_leafdata())
                                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                                            if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "prefix" or name == "metric" or name == "prefix-options"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "prefix"):
                                                                self.prefix = value
                                                                self.prefix.value_namespace = name_space
                                                                self.prefix.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "metric"):
                                                                self.metric = value
                                                                self.metric.value_namespace = name_space
                                                                self.metric.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "prefix-options"):
                                                                self.prefix_options = value
                                                                self.prefix_options.value_namespace = name_space
                                                                self.prefix_options.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.prefix_list:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.num_of_prefixes.is_set or
                                                            self.referenced_adv_router.is_set or
                                                            self.referenced_link_state_id.is_set or
                                                            self.referenced_ls_type.is_set)

                                                    def has_operation(self):
                                                        for c in self.prefix_list:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.num_of_prefixes.yfilter != YFilter.not_set or
                                                            self.referenced_adv_router.yfilter != YFilter.not_set or
                                                            self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                            self.referenced_ls_type.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "intra-area-prefix" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.num_of_prefixes.is_set or self.num_of_prefixes.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.num_of_prefixes.get_name_leafdata())
                                                        if (self.referenced_adv_router.is_set or self.referenced_adv_router.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_adv_router.get_name_leafdata())
                                                        if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                        if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "prefix-list"):
                                                            for c in self.prefix_list:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.prefix_list.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "prefix-list" or name == "num-of-prefixes" or name == "referenced-adv-router" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "num-of-prefixes"):
                                                            self.num_of_prefixes = value
                                                            self.num_of_prefixes.value_namespace = name_space
                                                            self.num_of_prefixes.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-adv-router"):
                                                            self.referenced_adv_router = value
                                                            self.referenced_adv_router.value_namespace = name_space
                                                            self.referenced_adv_router.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-link-state-id"):
                                                            self.referenced_link_state_id = value
                                                            self.referenced_link_state_id.value_namespace = name_space
                                                            self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "referenced-ls-type"):
                                                            self.referenced_ls_type = value
                                                            self.referenced_ls_type.value_namespace = name_space
                                                            self.referenced_ls_type.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    return (
                                                        (self.as_external is not None and self.as_external.has_data()) or
                                                        (self.inter_area_prefix is not None and self.inter_area_prefix.has_data()) or
                                                        (self.inter_area_router is not None and self.inter_area_router.has_data()) or
                                                        (self.intra_area_prefix is not None and self.intra_area_prefix.has_data()) or
                                                        (self.link is not None and self.link.has_data()) or
                                                        (self.network is not None and self.network.has_data()) or
                                                        (self.nssa is not None and self.nssa.has_data()) or
                                                        (self.router is not None and self.router.has_data()))

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        (self.as_external is not None and self.as_external.has_operation()) or
                                                        (self.inter_area_prefix is not None and self.inter_area_prefix.has_operation()) or
                                                        (self.inter_area_router is not None and self.inter_area_router.has_operation()) or
                                                        (self.intra_area_prefix is not None and self.intra_area_prefix.has_operation()) or
                                                        (self.link is not None and self.link.has_operation()) or
                                                        (self.network is not None and self.network.has_operation()) or
                                                        (self.nssa is not None and self.nssa.has_operation()) or
                                                        (self.router is not None and self.router.has_operation()))

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "body" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "as-external"):
                                                        if (self.as_external is None):
                                                            self.as_external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.AsExternal()
                                                            self.as_external.parent = self
                                                            self._children_name_map["as_external"] = "as-external"
                                                        return self.as_external

                                                    if (child_yang_name == "inter-area-prefix"):
                                                        if (self.inter_area_prefix is None):
                                                            self.inter_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaPrefix()
                                                            self.inter_area_prefix.parent = self
                                                            self._children_name_map["inter_area_prefix"] = "inter-area-prefix"
                                                        return self.inter_area_prefix

                                                    if (child_yang_name == "inter-area-router"):
                                                        if (self.inter_area_router is None):
                                                            self.inter_area_router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.InterAreaRouter()
                                                            self.inter_area_router.parent = self
                                                            self._children_name_map["inter_area_router"] = "inter-area-router"
                                                        return self.inter_area_router

                                                    if (child_yang_name == "intra-area-prefix"):
                                                        if (self.intra_area_prefix is None):
                                                            self.intra_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.IntraAreaPrefix()
                                                            self.intra_area_prefix.parent = self
                                                            self._children_name_map["intra_area_prefix"] = "intra-area-prefix"
                                                        return self.intra_area_prefix

                                                    if (child_yang_name == "link"):
                                                        if (self.link is None):
                                                            self.link = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Link()
                                                            self.link.parent = self
                                                            self._children_name_map["link"] = "link"
                                                        return self.link

                                                    if (child_yang_name == "network"):
                                                        if (self.network is None):
                                                            self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Network()
                                                            self.network.parent = self
                                                            self._children_name_map["network"] = "network"
                                                        return self.network

                                                    if (child_yang_name == "nssa"):
                                                        if (self.nssa is None):
                                                            self.nssa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Nssa()
                                                            self.nssa.parent = self
                                                            self._children_name_map["nssa"] = "nssa"
                                                        return self.nssa

                                                    if (child_yang_name == "router"):
                                                        if (self.router is None):
                                                            self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body.Router()
                                                            self.router.parent = self
                                                            self._children_name_map["router"] = "router"
                                                        return self.router

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "as-external" or name == "inter-area-prefix" or name == "inter-area-router" or name == "intra-area-prefix" or name == "link" or name == "network" or name == "nssa" or name == "router"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    (self.body is not None and self.body.has_data()) or
                                                    (self.header is not None and self.header.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    (self.body is not None and self.body.has_operation()) or
                                                    (self.header is not None and self.header.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "ospfv3" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "body"):
                                                    if (self.body is None):
                                                        self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Body()
                                                        self.body.parent = self
                                                        self._children_name_map["body"] = "body"
                                                    return self.body

                                                if (child_yang_name == "header"):
                                                    if (self.header is None):
                                                        self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3.Header()
                                                        self.header.parent = self
                                                        self._children_name_map["header"] = "header"
                                                    return self.header

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "body" or name == "header"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                self.lsa_id.is_set or
                                                self.adv_router.is_set or
                                                self.decoded_completed.is_set or
                                                self.raw_data.is_set or
                                                (self.ospfv2 is not None and self.ospfv2.has_data()) or
                                                (self.ospfv3 is not None and self.ospfv3.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.lsa_id.yfilter != YFilter.not_set or
                                                self.adv_router.yfilter != YFilter.not_set or
                                                self.decoded_completed.yfilter != YFilter.not_set or
                                                self.raw_data.yfilter != YFilter.not_set or
                                                (self.ospfv2 is not None and self.ospfv2.has_operation()) or
                                                (self.ospfv3 is not None and self.ospfv3.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "link-scope-lsa" + "[lsa-id='" + self.lsa_id.get() + "']" + "[adv-router='" + self.adv_router.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                            if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adv_router.get_name_leafdata())
                                            if (self.decoded_completed.is_set or self.decoded_completed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.decoded_completed.get_name_leafdata())
                                            if (self.raw_data.is_set or self.raw_data.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.raw_data.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "ospfv2"):
                                                if (self.ospfv2 is None):
                                                    self.ospfv2 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv2()
                                                    self.ospfv2.parent = self
                                                    self._children_name_map["ospfv2"] = "ospfv2"
                                                return self.ospfv2

                                            if (child_yang_name == "ospfv3"):
                                                if (self.ospfv3 is None):
                                                    self.ospfv3 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa.Ospfv3()
                                                    self.ospfv3.parent = self
                                                    self._children_name_map["ospfv3"] = "ospfv3"
                                                return self.ospfv3

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "ospfv2" or name == "ospfv3" or name == "lsa-id" or name == "adv-router" or name == "decoded-completed" or name == "raw-data"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "lsa-id"):
                                                self.lsa_id = value
                                                self.lsa_id.value_namespace = name_space
                                                self.lsa_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "adv-router"):
                                                self.adv_router = value
                                                self.adv_router.value_namespace = name_space
                                                self.adv_router.value_namespace_prefix = name_space_prefix
                                            if(value_path == "decoded-completed"):
                                                self.decoded_completed = value
                                                self.decoded_completed.value_namespace = name_space
                                                self.decoded_completed.value_namespace_prefix = name_space_prefix
                                            if(value_path == "raw-data"):
                                                self.raw_data = value
                                                self.raw_data.value_namespace = name_space
                                                self.raw_data.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.link_scope_lsa:
                                            if (c.has_data()):
                                                return True
                                        return self.lsa_type.is_set

                                    def has_operation(self):
                                        for c in self.link_scope_lsa:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.lsa_type.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "link-scope-lsas" + "[lsa-type='" + self.lsa_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lsa_type.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "link-scope-lsa"):
                                            for c in self.link_scope_lsa:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas.LinkScopeLsa()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.link_scope_lsa.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "link-scope-lsa" or name == "lsa-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "lsa-type"):
                                            self.lsa_type = value
                                            self.lsa_type.value_namespace = name_space
                                            self.lsa_type.value_namespace_prefix = name_space_prefix


                                class Topology(Entity):
                                    """
                                    OSPF interface topology.
                                    
                                    .. attribute:: name  <key>
                                    
                                    	One of the topology enabled on this interface
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Ribs.Rib>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Topology, self).__init__()

                                        self.yang_name = "topology"
                                        self.yang_parent_name = "interfaces"

                                        self.name = YLeaf(YType.str, "name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Topology, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Topology, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.name.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "topology" + "[name='" + self.name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "name"):
                                            self.name = value
                                            self.name.value_namespace = name_space
                                            self.name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.link_scope_lsas:
                                        if (c.has_data()):
                                            return True
                                    for c in self.neighbor:
                                        if (c.has_data()):
                                            return True
                                    for c in self.topology:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.interface.is_set or
                                        self.bdr.is_set or
                                        self.bfd.is_set or
                                        self.cost.is_set or
                                        self.dead_interval.is_set or
                                        self.demand_circuit.is_set or
                                        self.dr.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.hello_timer.is_set or
                                        self.lls.is_set or
                                        self.mtu_ignore.is_set or
                                        self.network_type.is_set or
                                        self.node_flag.is_set or
                                        self.passive.is_set or
                                        self.prefix_suppression.is_set or
                                        self.retransmit_interval.is_set or
                                        self.state.is_set or
                                        self.transmit_delay.is_set or
                                        self.wait_timer.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                        (self.multi_area is not None and self.multi_area.has_data()) or
                                        (self.static_neighbors is not None and self.static_neighbors.has_data()) or
                                        (self.ttl_security is not None and self.ttl_security.has_data()))

                                def has_operation(self):
                                    for c in self.link_scope_lsas:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.neighbor:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.topology:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.bdr.yfilter != YFilter.not_set or
                                        self.bfd.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.demand_circuit.yfilter != YFilter.not_set or
                                        self.dr.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.hello_timer.yfilter != YFilter.not_set or
                                        self.lls.yfilter != YFilter.not_set or
                                        self.mtu_ignore.yfilter != YFilter.not_set or
                                        self.network_type.yfilter != YFilter.not_set or
                                        self.node_flag.yfilter != YFilter.not_set or
                                        self.passive.yfilter != YFilter.not_set or
                                        self.prefix_suppression.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.state.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        self.wait_timer.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                        (self.multi_area is not None and self.multi_area.has_operation()) or
                                        (self.static_neighbors is not None and self.static_neighbors.has_operation()) or
                                        (self.ttl_security is not None and self.ttl_security.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interfaces" + "[interface='" + self.interface.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.bdr.is_set or self.bdr.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bdr.get_name_leafdata())
                                    if (self.bfd.is_set or self.bfd.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bfd.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                    if (self.dr.is_set or self.dr.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dr.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.hello_timer.is_set or self.hello_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_timer.get_name_leafdata())
                                    if (self.lls.is_set or self.lls.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lls.get_name_leafdata())
                                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                    if (self.network_type.is_set or self.network_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.network_type.get_name_leafdata())
                                    if (self.node_flag.is_set or self.node_flag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_flag.get_name_leafdata())
                                    if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.passive.get_name_leafdata())
                                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.state.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())
                                    if (self.wait_timer.is_set or self.wait_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wait_timer.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "fast-reroute"):
                                        if (self.fast_reroute is None):
                                            self.fast_reroute = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.FastReroute()
                                            self.fast_reroute.parent = self
                                            self._children_name_map["fast_reroute"] = "fast-reroute"
                                        return self.fast_reroute

                                    if (child_yang_name == "link-scope-lsas"):
                                        for c in self.link_scope_lsas:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.LinkScopeLsas()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.link_scope_lsas.append(c)
                                        return c

                                    if (child_yang_name == "multi-area"):
                                        if (self.multi_area is None):
                                            self.multi_area = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.MultiArea()
                                            self.multi_area.parent = self
                                            self._children_name_map["multi_area"] = "multi-area"
                                        return self.multi_area

                                    if (child_yang_name == "neighbor"):
                                        for c in self.neighbor:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Neighbor()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.neighbor.append(c)
                                        return c

                                    if (child_yang_name == "static-neighbors"):
                                        if (self.static_neighbors is None):
                                            self.static_neighbors = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.StaticNeighbors()
                                            self.static_neighbors.parent = self
                                            self._children_name_map["static_neighbors"] = "static-neighbors"
                                        return self.static_neighbors

                                    if (child_yang_name == "topology"):
                                        for c in self.topology:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.Topology()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.topology.append(c)
                                        return c

                                    if (child_yang_name == "ttl-security"):
                                        if (self.ttl_security is None):
                                            self.ttl_security = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces.TtlSecurity()
                                            self.ttl_security.parent = self
                                            self._children_name_map["ttl_security"] = "ttl-security"
                                        return self.ttl_security

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "fast-reroute" or name == "link-scope-lsas" or name == "multi-area" or name == "neighbor" or name == "static-neighbors" or name == "topology" or name == "ttl-security" or name == "interface" or name == "bdr" or name == "bfd" or name == "cost" or name == "dead-interval" or name == "demand-circuit" or name == "dr" or name == "enable" or name == "hello-interval" or name == "hello-timer" or name == "lls" or name == "mtu-ignore" or name == "network-type" or name == "node-flag" or name == "passive" or name == "prefix-suppression" or name == "retransmit-interval" or name == "state" or name == "transmit-delay" or name == "wait-timer"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bdr"):
                                        self.bdr = value
                                        self.bdr.value_namespace = name_space
                                        self.bdr.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bfd"):
                                        self.bfd = value
                                        self.bfd.value_namespace = name_space
                                        self.bfd.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "demand-circuit"):
                                        self.demand_circuit = value
                                        self.demand_circuit.value_namespace = name_space
                                        self.demand_circuit.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dr"):
                                        self.dr = value
                                        self.dr.value_namespace = name_space
                                        self.dr.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-timer"):
                                        self.hello_timer = value
                                        self.hello_timer.value_namespace = name_space
                                        self.hello_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lls"):
                                        self.lls = value
                                        self.lls.value_namespace = name_space
                                        self.lls.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mtu-ignore"):
                                        self.mtu_ignore = value
                                        self.mtu_ignore.value_namespace = name_space
                                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                    if(value_path == "network-type"):
                                        self.network_type = value
                                        self.network_type.value_namespace = name_space
                                        self.network_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-flag"):
                                        self.node_flag = value
                                        self.node_flag.value_namespace = name_space
                                        self.node_flag.value_namespace_prefix = name_space_prefix
                                    if(value_path == "passive"):
                                        self.passive = value
                                        self.passive.value_namespace = name_space
                                        self.passive.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-suppression"):
                                        self.prefix_suppression = value
                                        self.prefix_suppression.value_namespace = name_space
                                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "state"):
                                        self.state = value
                                        self.state.value_namespace = name_space
                                        self.state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wait-timer"):
                                        self.wait_timer = value
                                        self.wait_timer.value_namespace = name_space
                                        self.wait_timer.value_namespace_prefix = name_space_prefix


                            class AreaScopeLsas(Entity):
                                """
                                List OSPF area scope LSA databases
                                
                                .. attribute:: lsa_type  <key>
                                
                                	OSPF area scope LSA type
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: area_scope_lsa
                                
                                	List of OSPF area scope LSAs
                                	**type**\: list of    :py:class:`AreaScopeLsa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa>`
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas, self).__init__()

                                    self.yang_name = "area-scope-lsas"
                                    self.yang_parent_name = "area"

                                    self.lsa_type = YLeaf(YType.uint8, "lsa-type")

                                    self.area_scope_lsa = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("lsa_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas, self).__setattr__(name, value)


                                class AreaScopeLsa(Entity):
                                    """
                                    List of OSPF area scope LSAs
                                    
                                    .. attribute:: lsa_id  <key>
                                    
                                    	LSA ID
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    
                                    ----
                                    .. attribute:: adv_router  <key>
                                    
                                    	Advertising router
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: decoded_completed
                                    
                                    	The OSPF LSA body is fully decoded
                                    	**type**\:  bool
                                    
                                    .. attribute:: ospfv2
                                    
                                    	OSPFv2 LSA
                                    	**type**\:   :py:class:`Ospfv2 <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2>`
                                    
                                    .. attribute:: ospfv3
                                    
                                    	OSPFv3 LSA
                                    	**type**\:   :py:class:`Ospfv3 <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3>`
                                    
                                    .. attribute:: raw_data
                                    
                                    	The complete LSA in network byte order as received/sent over the wire
                                    	**type**\:  str
                                    
                                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa, self).__init__()

                                        self.yang_name = "area-scope-lsa"
                                        self.yang_parent_name = "area-scope-lsas"

                                        self.lsa_id = YLeaf(YType.str, "lsa-id")

                                        self.adv_router = YLeaf(YType.str, "adv-router")

                                        self.decoded_completed = YLeaf(YType.boolean, "decoded-completed")

                                        self.raw_data = YLeaf(YType.str, "raw-data")

                                        self.ospfv2 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2()
                                        self.ospfv2.parent = self
                                        self._children_name_map["ospfv2"] = "ospfv2"
                                        self._children_yang_names.add("ospfv2")

                                        self.ospfv3 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3()
                                        self.ospfv3.parent = self
                                        self._children_name_map["ospfv3"] = "ospfv3"
                                        self._children_yang_names.add("ospfv3")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("lsa_id",
                                                        "adv_router",
                                                        "decoded_completed",
                                                        "raw_data") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa, self).__setattr__(name, value)


                                    class Ospfv2(Entity):
                                        """
                                        OSPFv2 LSA
                                        
                                        .. attribute:: body
                                        
                                        	Decoded OSPFv2 LSA body data
                                        	**type**\:   :py:class:`Body <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body>`
                                        
                                        .. attribute:: header
                                        
                                        	Decoded OSPFv2 LSA header data
                                        	**type**\:   :py:class:`Header <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2, self).__init__()

                                            self.yang_name = "ospfv2"
                                            self.yang_parent_name = "area-scope-lsa"

                                            self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body()
                                            self.body.parent = self
                                            self._children_name_map["body"] = "body"
                                            self._children_yang_names.add("body")

                                            self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header()
                                            self.header.parent = self
                                            self._children_name_map["header"] = "header"
                                            self._children_yang_names.add("header")


                                        class Header(Entity):
                                            """
                                            Decoded OSPFv2 LSA header data.
                                            
                                            .. attribute:: adv_router
                                            
                                            	LSA advertising router
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: age
                                            
                                            	LSA age
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: checksum
                                            
                                            	LSA checksum
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: length
                                            
                                            	LSA length
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: lsa_id
                                            
                                            	LSA ID
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: opaque_id
                                            
                                            	Opaque id
                                            	**type**\:  int
                                            
                                            	**range:** 0..16777215
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: opaque_type
                                            
                                            	Opaque type
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: options
                                            
                                            	LSA option
                                            	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header.Options>`
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: seq_num
                                            
                                            	LSA sequence number
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: type
                                            
                                            	LSA type
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header, self).__init__()

                                                self.yang_name = "header"
                                                self.yang_parent_name = "ospfv2"

                                                self.adv_router = YLeaf(YType.str, "adv-router")

                                                self.age = YLeaf(YType.uint16, "age")

                                                self.checksum = YLeaf(YType.str, "checksum")

                                                self.length = YLeaf(YType.uint16, "length")

                                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                                self.opaque_id = YLeaf(YType.uint32, "opaque-id")

                                                self.opaque_type = YLeaf(YType.uint8, "opaque-type")

                                                self.options = YLeaf(YType.bits, "options")

                                                self.seq_num = YLeaf(YType.str, "seq-num")

                                                self.type = YLeaf(YType.uint16, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("adv_router",
                                                                "age",
                                                                "checksum",
                                                                "length",
                                                                "lsa_id",
                                                                "opaque_id",
                                                                "opaque_type",
                                                                "options",
                                                                "seq_num",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.adv_router.is_set or
                                                    self.age.is_set or
                                                    self.checksum.is_set or
                                                    self.length.is_set or
                                                    self.lsa_id.is_set or
                                                    self.opaque_id.is_set or
                                                    self.opaque_type.is_set or
                                                    self.options.is_set or
                                                    self.seq_num.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.adv_router.yfilter != YFilter.not_set or
                                                    self.age.yfilter != YFilter.not_set or
                                                    self.checksum.yfilter != YFilter.not_set or
                                                    self.length.yfilter != YFilter.not_set or
                                                    self.lsa_id.yfilter != YFilter.not_set or
                                                    self.opaque_id.yfilter != YFilter.not_set or
                                                    self.opaque_type.yfilter != YFilter.not_set or
                                                    self.options.yfilter != YFilter.not_set or
                                                    self.seq_num.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "header" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.adv_router.get_name_leafdata())
                                                if (self.age.is_set or self.age.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.age.get_name_leafdata())
                                                if (self.checksum.is_set or self.checksum.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.checksum.get_name_leafdata())
                                                if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.length.get_name_leafdata())
                                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                                if (self.opaque_id.is_set or self.opaque_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.opaque_id.get_name_leafdata())
                                                if (self.opaque_type.is_set or self.opaque_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.opaque_type.get_name_leafdata())
                                                if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.options.get_name_leafdata())
                                                if (self.seq_num.is_set or self.seq_num.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.seq_num.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "adv-router" or name == "age" or name == "checksum" or name == "length" or name == "lsa-id" or name == "opaque-id" or name == "opaque-type" or name == "options" or name == "seq-num" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "adv-router"):
                                                    self.adv_router = value
                                                    self.adv_router.value_namespace = name_space
                                                    self.adv_router.value_namespace_prefix = name_space_prefix
                                                if(value_path == "age"):
                                                    self.age = value
                                                    self.age.value_namespace = name_space
                                                    self.age.value_namespace_prefix = name_space_prefix
                                                if(value_path == "checksum"):
                                                    self.checksum = value
                                                    self.checksum.value_namespace = name_space
                                                    self.checksum.value_namespace_prefix = name_space_prefix
                                                if(value_path == "length"):
                                                    self.length = value
                                                    self.length.value_namespace = name_space
                                                    self.length.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lsa-id"):
                                                    self.lsa_id = value
                                                    self.lsa_id.value_namespace = name_space
                                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "opaque-id"):
                                                    self.opaque_id = value
                                                    self.opaque_id.value_namespace = name_space
                                                    self.opaque_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "opaque-type"):
                                                    self.opaque_type = value
                                                    self.opaque_type.value_namespace = name_space
                                                    self.opaque_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "options"):
                                                    self.options[value] = True
                                                if(value_path == "seq-num"):
                                                    self.seq_num = value
                                                    self.seq_num.value_namespace = name_space
                                                    self.seq_num.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix


                                        class Body(Entity):
                                            """
                                            Decoded OSPFv2 LSA body data.
                                            
                                            .. attribute:: external
                                            
                                            	External LSA
                                            	**type**\:   :py:class:`External <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External>`
                                            
                                            .. attribute:: network
                                            
                                            	Network LSA
                                            	**type**\:   :py:class:`Network <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Network>`
                                            
                                            .. attribute:: opaque
                                            
                                            	Opaque LSA
                                            	**type**\:   :py:class:`Opaque <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque>`
                                            
                                            .. attribute:: router
                                            
                                            	Router LSA
                                            	**type**\:   :py:class:`Router <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router>`
                                            
                                            .. attribute:: summary
                                            
                                            	Summary LSA
                                            	**type**\:   :py:class:`Summary <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body, self).__init__()

                                                self.yang_name = "body"
                                                self.yang_parent_name = "ospfv2"

                                                self.external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External()
                                                self.external.parent = self
                                                self._children_name_map["external"] = "external"
                                                self._children_yang_names.add("external")

                                                self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Network()
                                                self.network.parent = self
                                                self._children_name_map["network"] = "network"
                                                self._children_yang_names.add("network")

                                                self.opaque = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque()
                                                self.opaque.parent = self
                                                self._children_name_map["opaque"] = "opaque"
                                                self._children_yang_names.add("opaque")

                                                self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router()
                                                self.router.parent = self
                                                self._children_name_map["router"] = "router"
                                                self._children_yang_names.add("router")

                                                self.summary = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary()
                                                self.summary.parent = self
                                                self._children_name_map["summary"] = "summary"
                                                self._children_yang_names.add("summary")


                                            class Router(Entity):
                                                """
                                                Router LSA.
                                                
                                                .. attribute:: flags
                                                
                                                	Flags
                                                	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Flags>`
                                                
                                                .. attribute:: link
                                                
                                                	Router LSA link
                                                	**type**\: list of    :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link>`
                                                
                                                .. attribute:: num_of_links
                                                
                                                	Number of links
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router, self).__init__()

                                                    self.yang_name = "router"
                                                    self.yang_parent_name = "body"

                                                    self.flags = YLeaf(YType.bits, "flags")

                                                    self.num_of_links = YLeaf(YType.uint16, "num-of-links")

                                                    self.link = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("flags",
                                                                    "num_of_links") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router, self).__setattr__(name, value)


                                                class Link(Entity):
                                                    """
                                                    Router LSA link.
                                                    
                                                    .. attribute:: link_id  <key>
                                                    
                                                    	Link ID
                                                    	**type**\: one of the below types:
                                                    
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    
                                                    ----
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                    
                                                    
                                                    ----
                                                    .. attribute:: link_data  <key>
                                                    
                                                    	Link data
                                                    	**type**\: one of the below types:
                                                    
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    
                                                    ----
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    
                                                    ----
                                                    .. attribute:: topology
                                                    
                                                    	Topology specific information
                                                    	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link.Topology>`
                                                    
                                                    .. attribute:: type
                                                    
                                                    	Link type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link, self).__init__()

                                                        self.yang_name = "link"
                                                        self.yang_parent_name = "router"

                                                        self.link_id = YLeaf(YType.str, "link-id")

                                                        self.link_data = YLeaf(YType.str, "link-data")

                                                        self.type = YLeaf(YType.uint8, "type")

                                                        self.topology = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("link_id",
                                                                        "link_data",
                                                                        "type") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link, self).__setattr__(name, value)


                                                    class Topology(Entity):
                                                        """
                                                        Topology specific information.
                                                        
                                                        .. attribute:: mt_id  <key>
                                                        
                                                        	The MT\-ID for topology enabled on the link
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        .. attribute:: metric
                                                        
                                                        	Metric for the topology
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..65535
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__init__()

                                                            self.yang_name = "topology"
                                                            self.yang_parent_name = "link"

                                                            self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                            self.metric = YLeaf(YType.uint16, "metric")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("mt_id",
                                                                            "metric") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.mt_id.is_set or
                                                                self.metric.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.mt_id.yfilter != YFilter.not_set or
                                                                self.metric.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.metric.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "mt-id" or name == "metric"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "mt-id"):
                                                                self.mt_id = value
                                                                self.mt_id.value_namespace = name_space
                                                                self.mt_id.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "metric"):
                                                                self.metric = value
                                                                self.metric.value_namespace = name_space
                                                                self.metric.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.topology:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.link_id.is_set or
                                                            self.link_data.is_set or
                                                            self.type.is_set)

                                                    def has_operation(self):
                                                        for c in self.topology:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.link_id.yfilter != YFilter.not_set or
                                                            self.link_data.yfilter != YFilter.not_set or
                                                            self.type.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "link" + "[link-id='" + self.link_id.get() + "']" + "[link-data='" + self.link_data.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.link_id.get_name_leafdata())
                                                        if (self.link_data.is_set or self.link_data.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.link_data.get_name_leafdata())
                                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.type.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "topology"):
                                                            for c in self.topology:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link.Topology()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.topology.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "topology" or name == "link-id" or name == "link-data" or name == "type"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "link-id"):
                                                            self.link_id = value
                                                            self.link_id.value_namespace = name_space
                                                            self.link_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "link-data"):
                                                            self.link_data = value
                                                            self.link_data.value_namespace = name_space
                                                            self.link_data.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "type"):
                                                            self.type = value
                                                            self.type.value_namespace = name_space
                                                            self.type.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.link:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.flags.is_set or
                                                        self.num_of_links.is_set)

                                                def has_operation(self):
                                                    for c in self.link:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.flags.yfilter != YFilter.not_set or
                                                        self.num_of_links.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "router" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.flags.get_name_leafdata())
                                                    if (self.num_of_links.is_set or self.num_of_links.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.num_of_links.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "link"):
                                                        for c in self.link:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router.Link()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.link.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "link" or name == "flags" or name == "num-of-links"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "flags"):
                                                        self.flags[value] = True
                                                    if(value_path == "num-of-links"):
                                                        self.num_of_links = value
                                                        self.num_of_links.value_namespace = name_space
                                                        self.num_of_links.value_namespace_prefix = name_space_prefix


                                            class Network(Entity):
                                                """
                                                Network LSA.
                                                
                                                .. attribute:: attached_router
                                                
                                                	List of the routers attached to the network
                                                	**type**\:  list of str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                .. attribute:: network_mask
                                                
                                                	The IP address mask for the network
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Network, self).__init__()

                                                    self.yang_name = "network"
                                                    self.yang_parent_name = "body"

                                                    self.attached_router = YLeafList(YType.str, "attached-router")

                                                    self.network_mask = YLeaf(YType.str, "network-mask")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("attached_router",
                                                                    "network_mask") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Network, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Network, self).__setattr__(name, value)

                                                def has_data(self):
                                                    for leaf in self.attached_router.getYLeafs():
                                                        if (leaf.yfilter != YFilter.not_set):
                                                            return True
                                                    return self.network_mask.is_set

                                                def has_operation(self):
                                                    for leaf in self.attached_router.getYLeafs():
                                                        if (leaf.is_set):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.attached_router.yfilter != YFilter.not_set or
                                                        self.network_mask.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "network" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                    leaf_name_data.extend(self.attached_router.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "attached-router" or name == "network-mask"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "attached-router"):
                                                        self.attached_router.append(value)
                                                    if(value_path == "network-mask"):
                                                        self.network_mask = value
                                                        self.network_mask.value_namespace = name_space
                                                        self.network_mask.value_namespace_prefix = name_space_prefix


                                            class Summary(Entity):
                                                """
                                                Summary LSA.
                                                
                                                .. attribute:: network_mask
                                                
                                                	The IP address mask for the network
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: topology
                                                
                                                	Topology specific information
                                                	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary.Topology>`
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary, self).__init__()

                                                    self.yang_name = "summary"
                                                    self.yang_parent_name = "body"

                                                    self.network_mask = YLeaf(YType.str, "network-mask")

                                                    self.topology = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("network_mask") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary, self).__setattr__(name, value)


                                                class Topology(Entity):
                                                    """
                                                    Topology specific information.
                                                    
                                                    .. attribute:: mt_id  <key>
                                                    
                                                    	The MT\-ID for topology enabled on the link
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric for the topology
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary.Topology, self).__init__()

                                                        self.yang_name = "topology"
                                                        self.yang_parent_name = "summary"

                                                        self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("mt_id",
                                                                        "metric") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary.Topology, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary.Topology, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.mt_id.is_set or
                                                            self.metric.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.mt_id.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "mt-id" or name == "metric"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "mt-id"):
                                                            self.mt_id = value
                                                            self.mt_id.value_namespace = name_space
                                                            self.mt_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.topology:
                                                        if (c.has_data()):
                                                            return True
                                                    return self.network_mask.is_set

                                                def has_operation(self):
                                                    for c in self.topology:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.network_mask.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "summary" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "topology"):
                                                        for c in self.topology:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary.Topology()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.topology.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "topology" or name == "network-mask"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "network-mask"):
                                                        self.network_mask = value
                                                        self.network_mask.value_namespace = name_space
                                                        self.network_mask.value_namespace_prefix = name_space_prefix


                                            class External(Entity):
                                                """
                                                External LSA.
                                                
                                                .. attribute:: network_mask
                                                
                                                	The IP address mask for the network
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: topology
                                                
                                                	Topology specific information
                                                	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External.Topology>`
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External, self).__init__()

                                                    self.yang_name = "external"
                                                    self.yang_parent_name = "body"

                                                    self.network_mask = YLeaf(YType.str, "network-mask")

                                                    self.topology = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("network_mask") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External, self).__setattr__(name, value)


                                                class Topology(Entity):
                                                    """
                                                    Topology specific information.
                                                    
                                                    .. attribute:: mt_id  <key>
                                                    
                                                    	The MT\-ID for topology enabled on the link
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    .. attribute:: external_route_tag
                                                    
                                                    	Route tag
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: flags
                                                    
                                                    	Flags
                                                    	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External.Topology.Flags>`
                                                    
                                                    .. attribute:: forwarding_address
                                                    
                                                    	Forwarding address
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric for the topology
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External.Topology, self).__init__()

                                                        self.yang_name = "topology"
                                                        self.yang_parent_name = "external"

                                                        self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                        self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                        self.flags = YLeaf(YType.bits, "flags")

                                                        self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("mt_id",
                                                                        "external_route_tag",
                                                                        "flags",
                                                                        "forwarding_address",
                                                                        "metric") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External.Topology, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External.Topology, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.mt_id.is_set or
                                                            self.external_route_tag.is_set or
                                                            self.flags.is_set or
                                                            self.forwarding_address.is_set or
                                                            self.metric.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.mt_id.yfilter != YFilter.not_set or
                                                            self.external_route_tag.yfilter != YFilter.not_set or
                                                            self.flags.yfilter != YFilter.not_set or
                                                            self.forwarding_address.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                        if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                        if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.flags.get_name_leafdata())
                                                        if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "mt-id" or name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "mt-id"):
                                                            self.mt_id = value
                                                            self.mt_id.value_namespace = name_space
                                                            self.mt_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "external-route-tag"):
                                                            self.external_route_tag = value
                                                            self.external_route_tag.value_namespace = name_space
                                                            self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "flags"):
                                                            self.flags[value] = True
                                                        if(value_path == "forwarding-address"):
                                                            self.forwarding_address = value
                                                            self.forwarding_address.value_namespace = name_space
                                                            self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.topology:
                                                        if (c.has_data()):
                                                            return True
                                                    return self.network_mask.is_set

                                                def has_operation(self):
                                                    for c in self.topology:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.network_mask.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "external" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "topology"):
                                                        for c in self.topology:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External.Topology()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.topology.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "topology" or name == "network-mask"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "network-mask"):
                                                        self.network_mask = value
                                                        self.network_mask.value_namespace = name_space
                                                        self.network_mask.value_namespace_prefix = name_space_prefix


                                            class Opaque(Entity):
                                                """
                                                Opaque LSA.
                                                
                                                .. attribute:: link_tlv
                                                
                                                	Link TLV
                                                	**type**\:   :py:class:`LinkTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv>`
                                                
                                                .. attribute:: router_address_tlv
                                                
                                                	Router address TLV
                                                	**type**\:   :py:class:`RouterAddressTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv>`
                                                
                                                .. attribute:: unknown_tlv
                                                
                                                	Unknown TLV
                                                	**type**\: list of    :py:class:`UnknownTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.UnknownTlv>`
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque, self).__init__()

                                                    self.yang_name = "opaque"
                                                    self.yang_parent_name = "body"

                                                    self.link_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv()
                                                    self.link_tlv.parent = self
                                                    self._children_name_map["link_tlv"] = "link-tlv"
                                                    self._children_yang_names.add("link-tlv")

                                                    self.router_address_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv()
                                                    self.router_address_tlv.parent = self
                                                    self._children_name_map["router_address_tlv"] = "router-address-tlv"
                                                    self._children_yang_names.add("router-address-tlv")

                                                    self.unknown_tlv = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in () and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque, self).__setattr__(name, value)


                                                class UnknownTlv(Entity):
                                                    """
                                                    Unknown TLV.
                                                    
                                                    .. attribute:: type  <key>
                                                    
                                                    	TLV type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: length
                                                    
                                                    	TLV length
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: value
                                                    
                                                    	TLV value
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__init__()

                                                        self.yang_name = "unknown-tlv"
                                                        self.yang_parent_name = "opaque"

                                                        self.type = YLeaf(YType.uint16, "type")

                                                        self.length = YLeaf(YType.uint16, "length")

                                                        self.value = YLeaf(YType.str, "value")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("type",
                                                                        "length",
                                                                        "value") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.type.is_set or
                                                            self.length.is_set or
                                                            self.value.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.type.yfilter != YFilter.not_set or
                                                            self.length.yfilter != YFilter.not_set or
                                                            self.value.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "unknown-tlv" + "[type='" + self.type.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.type.get_name_leafdata())
                                                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.length.get_name_leafdata())
                                                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.value.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "type" or name == "length" or name == "value"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "type"):
                                                            self.type = value
                                                            self.type.value_namespace = name_space
                                                            self.type.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "length"):
                                                            self.length = value
                                                            self.length.value_namespace = name_space
                                                            self.length.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "value"):
                                                            self.value = value
                                                            self.value.value_namespace = name_space
                                                            self.value.value_namespace_prefix = name_space_prefix


                                                class RouterAddressTlv(Entity):
                                                    """
                                                    Router address TLV.
                                                    
                                                    .. attribute:: router_address
                                                    
                                                    	Router address
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__init__()

                                                        self.yang_name = "router-address-tlv"
                                                        self.yang_parent_name = "opaque"

                                                        self.router_address = YLeaf(YType.str, "router-address")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("router_address") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.router_address.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.router_address.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "router-address-tlv" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.router_address.is_set or self.router_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.router_address.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "router-address"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "router-address"):
                                                            self.router_address = value
                                                            self.router_address.value_namespace = name_space
                                                            self.router_address.value_namespace_prefix = name_space_prefix


                                                class LinkTlv(Entity):
                                                    """
                                                    Link TLV.
                                                    
                                                    .. attribute:: admin_group
                                                    
                                                    	Administrative group/Resource class/Color
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: link_id
                                                    
                                                    	Link ID
                                                    	**type**\: one of the below types:
                                                    
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    
                                                    ----
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    
                                                    ----
                                                    .. attribute:: link_type
                                                    
                                                    	Link type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    .. attribute:: local_if_ipv4_addr
                                                    
                                                    	List of local interface IPv4 addresses
                                                    	**type**\:  list of str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: local_remote_ipv4_addr
                                                    
                                                    	List of remote interface IPv4 addresses
                                                    	**type**\:  list of str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                    
                                                    .. attribute:: max_bandwidth
                                                    
                                                    	Maximum bandwidth
                                                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                    
                                                    	**range:** \-92233720368547758.08..92233720368547758.07
                                                    
                                                    .. attribute:: max_reservable_bandwidth
                                                    
                                                    	Maximum reservable bandwidth
                                                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                    
                                                    	**range:** \-92233720368547758.08..92233720368547758.07
                                                    
                                                    .. attribute:: te_metric
                                                    
                                                    	TE metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: unknown_subtlv
                                                    
                                                    	Unknown sub\-TLV
                                                    	**type**\: list of    :py:class:`UnknownSubtlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv>`
                                                    
                                                    .. attribute:: unreserved_bandwidth
                                                    
                                                    	Unreserved bandwidth
                                                    	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                    
                                                    	**range:** \-92233720368547758.08..92233720368547758.07
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__init__()

                                                        self.yang_name = "link-tlv"
                                                        self.yang_parent_name = "opaque"

                                                        self.admin_group = YLeaf(YType.uint32, "admin-group")

                                                        self.link_id = YLeaf(YType.str, "link-id")

                                                        self.link_type = YLeaf(YType.uint8, "link-type")

                                                        self.local_if_ipv4_addr = YLeafList(YType.str, "local-if-ipv4-addr")

                                                        self.local_remote_ipv4_addr = YLeafList(YType.str, "local-remote-ipv4-addr")

                                                        self.max_bandwidth = YLeaf(YType.str, "max-bandwidth")

                                                        self.max_reservable_bandwidth = YLeaf(YType.str, "max-reservable-bandwidth")

                                                        self.te_metric = YLeaf(YType.uint32, "te-metric")

                                                        self.unreserved_bandwidth = YLeaf(YType.str, "unreserved-bandwidth")

                                                        self.unknown_subtlv = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("admin_group",
                                                                        "link_id",
                                                                        "link_type",
                                                                        "local_if_ipv4_addr",
                                                                        "local_remote_ipv4_addr",
                                                                        "max_bandwidth",
                                                                        "max_reservable_bandwidth",
                                                                        "te_metric",
                                                                        "unreserved_bandwidth") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__setattr__(name, value)


                                                    class UnknownSubtlv(Entity):
                                                        """
                                                        Unknown sub\-TLV.
                                                        
                                                        .. attribute:: type  <key>
                                                        
                                                        	TLV type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..65535
                                                        
                                                        .. attribute:: length
                                                        
                                                        	TLV length
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..65535
                                                        
                                                        .. attribute:: value
                                                        
                                                        	TLV value
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                        
                                                        

                                                        """

                                                        _prefix = 'ospf'
                                                        _revision = '2015-03-09'

                                                        def __init__(self):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__init__()

                                                            self.yang_name = "unknown-subtlv"
                                                            self.yang_parent_name = "link-tlv"

                                                            self.type = YLeaf(YType.uint16, "type")

                                                            self.length = YLeaf(YType.uint16, "length")

                                                            self.value = YLeaf(YType.str, "value")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("type",
                                                                            "length",
                                                                            "value") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.type.is_set or
                                                                self.length.is_set or
                                                                self.value.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.type.yfilter != YFilter.not_set or
                                                                self.length.yfilter != YFilter.not_set or
                                                                self.value.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "unknown-subtlv" + "[type='" + self.type.get() + "']" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.type.get_name_leafdata())
                                                            if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.length.get_name_leafdata())
                                                            if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.value.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "type" or name == "length" or name == "value"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "type"):
                                                                self.type = value
                                                                self.type.value_namespace = name_space
                                                                self.type.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "length"):
                                                                self.length = value
                                                                self.length.value_namespace = name_space
                                                                self.length.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "value"):
                                                                self.value = value
                                                                self.value.value_namespace = name_space
                                                                self.value.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.unknown_subtlv:
                                                            if (c.has_data()):
                                                                return True
                                                        for leaf in self.local_if_ipv4_addr.getYLeafs():
                                                            if (leaf.yfilter != YFilter.not_set):
                                                                return True
                                                        for leaf in self.local_remote_ipv4_addr.getYLeafs():
                                                            if (leaf.yfilter != YFilter.not_set):
                                                                return True
                                                        return (
                                                            self.admin_group.is_set or
                                                            self.link_id.is_set or
                                                            self.link_type.is_set or
                                                            self.max_bandwidth.is_set or
                                                            self.max_reservable_bandwidth.is_set or
                                                            self.te_metric.is_set or
                                                            self.unreserved_bandwidth.is_set)

                                                    def has_operation(self):
                                                        for c in self.unknown_subtlv:
                                                            if (c.has_operation()):
                                                                return True
                                                        for leaf in self.local_if_ipv4_addr.getYLeafs():
                                                            if (leaf.is_set):
                                                                return True
                                                        for leaf in self.local_remote_ipv4_addr.getYLeafs():
                                                            if (leaf.is_set):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.admin_group.yfilter != YFilter.not_set or
                                                            self.link_id.yfilter != YFilter.not_set or
                                                            self.link_type.yfilter != YFilter.not_set or
                                                            self.local_if_ipv4_addr.yfilter != YFilter.not_set or
                                                            self.local_remote_ipv4_addr.yfilter != YFilter.not_set or
                                                            self.max_bandwidth.yfilter != YFilter.not_set or
                                                            self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                                                            self.te_metric.yfilter != YFilter.not_set or
                                                            self.unreserved_bandwidth.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "link-tlv" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.admin_group.is_set or self.admin_group.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.admin_group.get_name_leafdata())
                                                        if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.link_id.get_name_leafdata())
                                                        if (self.link_type.is_set or self.link_type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.link_type.get_name_leafdata())
                                                        if (self.max_bandwidth.is_set or self.max_bandwidth.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.max_bandwidth.get_name_leafdata())
                                                        if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                                                        if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.te_metric.get_name_leafdata())
                                                        if (self.unreserved_bandwidth.is_set or self.unreserved_bandwidth.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.unreserved_bandwidth.get_name_leafdata())

                                                        leaf_name_data.extend(self.local_if_ipv4_addr.get_name_leafdata())

                                                        leaf_name_data.extend(self.local_remote_ipv4_addr.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "unknown-subtlv"):
                                                            for c in self.unknown_subtlv:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.unknown_subtlv.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "unknown-subtlv" or name == "admin-group" or name == "link-id" or name == "link-type" or name == "local-if-ipv4-addr" or name == "local-remote-ipv4-addr" or name == "max-bandwidth" or name == "max-reservable-bandwidth" or name == "te-metric" or name == "unreserved-bandwidth"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "admin-group"):
                                                            self.admin_group = value
                                                            self.admin_group.value_namespace = name_space
                                                            self.admin_group.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "link-id"):
                                                            self.link_id = value
                                                            self.link_id.value_namespace = name_space
                                                            self.link_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "link-type"):
                                                            self.link_type = value
                                                            self.link_type.value_namespace = name_space
                                                            self.link_type.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "local-if-ipv4-addr"):
                                                            self.local_if_ipv4_addr.append(value)
                                                        if(value_path == "local-remote-ipv4-addr"):
                                                            self.local_remote_ipv4_addr.append(value)
                                                        if(value_path == "max-bandwidth"):
                                                            self.max_bandwidth = value
                                                            self.max_bandwidth.value_namespace = name_space
                                                            self.max_bandwidth.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "max-reservable-bandwidth"):
                                                            self.max_reservable_bandwidth = value
                                                            self.max_reservable_bandwidth.value_namespace = name_space
                                                            self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "te-metric"):
                                                            self.te_metric = value
                                                            self.te_metric.value_namespace = name_space
                                                            self.te_metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "unreserved-bandwidth"):
                                                            self.unreserved_bandwidth = value
                                                            self.unreserved_bandwidth.value_namespace = name_space
                                                            self.unreserved_bandwidth.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.unknown_tlv:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        (self.link_tlv is not None and self.link_tlv.has_data()) or
                                                        (self.router_address_tlv is not None and self.router_address_tlv.has_data()))

                                                def has_operation(self):
                                                    for c in self.unknown_tlv:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        (self.link_tlv is not None and self.link_tlv.has_operation()) or
                                                        (self.router_address_tlv is not None and self.router_address_tlv.has_operation()))

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "opaque" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "link-tlv"):
                                                        if (self.link_tlv is None):
                                                            self.link_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.LinkTlv()
                                                            self.link_tlv.parent = self
                                                            self._children_name_map["link_tlv"] = "link-tlv"
                                                        return self.link_tlv

                                                    if (child_yang_name == "router-address-tlv"):
                                                        if (self.router_address_tlv is None):
                                                            self.router_address_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv()
                                                            self.router_address_tlv.parent = self
                                                            self._children_name_map["router_address_tlv"] = "router-address-tlv"
                                                        return self.router_address_tlv

                                                    if (child_yang_name == "unknown-tlv"):
                                                        for c in self.unknown_tlv:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque.UnknownTlv()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.unknown_tlv.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "link-tlv" or name == "router-address-tlv" or name == "unknown-tlv"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    (self.external is not None and self.external.has_data()) or
                                                    (self.network is not None and self.network.has_data()) or
                                                    (self.opaque is not None and self.opaque.has_data()) or
                                                    (self.router is not None and self.router.has_data()) or
                                                    (self.summary is not None and self.summary.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    (self.external is not None and self.external.has_operation()) or
                                                    (self.network is not None and self.network.has_operation()) or
                                                    (self.opaque is not None and self.opaque.has_operation()) or
                                                    (self.router is not None and self.router.has_operation()) or
                                                    (self.summary is not None and self.summary.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "body" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "external"):
                                                    if (self.external is None):
                                                        self.external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.External()
                                                        self.external.parent = self
                                                        self._children_name_map["external"] = "external"
                                                    return self.external

                                                if (child_yang_name == "network"):
                                                    if (self.network is None):
                                                        self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Network()
                                                        self.network.parent = self
                                                        self._children_name_map["network"] = "network"
                                                    return self.network

                                                if (child_yang_name == "opaque"):
                                                    if (self.opaque is None):
                                                        self.opaque = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Opaque()
                                                        self.opaque.parent = self
                                                        self._children_name_map["opaque"] = "opaque"
                                                    return self.opaque

                                                if (child_yang_name == "router"):
                                                    if (self.router is None):
                                                        self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Router()
                                                        self.router.parent = self
                                                        self._children_name_map["router"] = "router"
                                                    return self.router

                                                if (child_yang_name == "summary"):
                                                    if (self.summary is None):
                                                        self.summary = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body.Summary()
                                                        self.summary.parent = self
                                                        self._children_name_map["summary"] = "summary"
                                                    return self.summary

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "external" or name == "network" or name == "opaque" or name == "router" or name == "summary"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                (self.body is not None and self.body.has_data()) or
                                                (self.header is not None and self.header.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.body is not None and self.body.has_operation()) or
                                                (self.header is not None and self.header.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ospfv2" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "body"):
                                                if (self.body is None):
                                                    self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Body()
                                                    self.body.parent = self
                                                    self._children_name_map["body"] = "body"
                                                return self.body

                                            if (child_yang_name == "header"):
                                                if (self.header is None):
                                                    self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2.Header()
                                                    self.header.parent = self
                                                    self._children_name_map["header"] = "header"
                                                return self.header

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "body" or name == "header"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class Ospfv3(Entity):
                                        """
                                        OSPFv3 LSA
                                        
                                        .. attribute:: body
                                        
                                        	Decoded OSPF LSA body data
                                        	**type**\:   :py:class:`Body <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body>`
                                        
                                        .. attribute:: header
                                        
                                        	Decoded OSPFv3 LSA header data
                                        	**type**\:   :py:class:`Header <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3, self).__init__()

                                            self.yang_name = "ospfv3"
                                            self.yang_parent_name = "area-scope-lsa"

                                            self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body()
                                            self.body.parent = self
                                            self._children_name_map["body"] = "body"
                                            self._children_yang_names.add("body")

                                            self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header()
                                            self.header.parent = self
                                            self._children_name_map["header"] = "header"
                                            self._children_yang_names.add("header")


                                        class Header(Entity):
                                            """
                                            Decoded OSPFv3 LSA header data.
                                            
                                            .. attribute:: adv_router
                                            
                                            	LSA advertising router
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: age
                                            
                                            	LSA age
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: checksum
                                            
                                            	LSA checksum
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: length
                                            
                                            	LSA length
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: lsa_id
                                            
                                            	LSA ID
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: options
                                            
                                            	OSPFv3 LSA options
                                            	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header.Options>`
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: seq_num
                                            
                                            	LSA sequence number
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: type
                                            
                                            	LSA type
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header, self).__init__()

                                                self.yang_name = "header"
                                                self.yang_parent_name = "ospfv3"

                                                self.adv_router = YLeaf(YType.str, "adv-router")

                                                self.age = YLeaf(YType.uint16, "age")

                                                self.checksum = YLeaf(YType.str, "checksum")

                                                self.length = YLeaf(YType.uint16, "length")

                                                self.lsa_id = YLeaf(YType.uint32, "lsa-id")

                                                self.options = YLeaf(YType.bits, "options")

                                                self.seq_num = YLeaf(YType.str, "seq-num")

                                                self.type = YLeaf(YType.uint16, "type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("adv_router",
                                                                "age",
                                                                "checksum",
                                                                "length",
                                                                "lsa_id",
                                                                "options",
                                                                "seq_num",
                                                                "type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.adv_router.is_set or
                                                    self.age.is_set or
                                                    self.checksum.is_set or
                                                    self.length.is_set or
                                                    self.lsa_id.is_set or
                                                    self.options.is_set or
                                                    self.seq_num.is_set or
                                                    self.type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.adv_router.yfilter != YFilter.not_set or
                                                    self.age.yfilter != YFilter.not_set or
                                                    self.checksum.yfilter != YFilter.not_set or
                                                    self.length.yfilter != YFilter.not_set or
                                                    self.lsa_id.yfilter != YFilter.not_set or
                                                    self.options.yfilter != YFilter.not_set or
                                                    self.seq_num.yfilter != YFilter.not_set or
                                                    self.type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "header" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.adv_router.get_name_leafdata())
                                                if (self.age.is_set or self.age.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.age.get_name_leafdata())
                                                if (self.checksum.is_set or self.checksum.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.checksum.get_name_leafdata())
                                                if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.length.get_name_leafdata())
                                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                                if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.options.get_name_leafdata())
                                                if (self.seq_num.is_set or self.seq_num.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.seq_num.get_name_leafdata())
                                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "adv-router" or name == "age" or name == "checksum" or name == "length" or name == "lsa-id" or name == "options" or name == "seq-num" or name == "type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "adv-router"):
                                                    self.adv_router = value
                                                    self.adv_router.value_namespace = name_space
                                                    self.adv_router.value_namespace_prefix = name_space_prefix
                                                if(value_path == "age"):
                                                    self.age = value
                                                    self.age.value_namespace = name_space
                                                    self.age.value_namespace_prefix = name_space_prefix
                                                if(value_path == "checksum"):
                                                    self.checksum = value
                                                    self.checksum.value_namespace = name_space
                                                    self.checksum.value_namespace_prefix = name_space_prefix
                                                if(value_path == "length"):
                                                    self.length = value
                                                    self.length.value_namespace = name_space
                                                    self.length.value_namespace_prefix = name_space_prefix
                                                if(value_path == "lsa-id"):
                                                    self.lsa_id = value
                                                    self.lsa_id.value_namespace = name_space
                                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "options"):
                                                    self.options[value] = True
                                                if(value_path == "seq-num"):
                                                    self.seq_num = value
                                                    self.seq_num.value_namespace = name_space
                                                    self.seq_num.value_namespace_prefix = name_space_prefix
                                                if(value_path == "type"):
                                                    self.type = value
                                                    self.type.value_namespace = name_space
                                                    self.type.value_namespace_prefix = name_space_prefix


                                        class Body(Entity):
                                            """
                                            Decoded OSPF LSA body data.
                                            
                                            .. attribute:: as_external
                                            
                                            	AS\-External LSA
                                            	**type**\:   :py:class:`AsExternal <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal>`
                                            
                                            .. attribute:: inter_area_prefix
                                            
                                            	Inter\-Area\-Prefix LSA
                                            	**type**\:   :py:class:`InterAreaPrefix <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaPrefix>`
                                            
                                            .. attribute:: inter_area_router
                                            
                                            	Inter\-Area\-Router LSA
                                            	**type**\:   :py:class:`InterAreaRouter <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter>`
                                            
                                            .. attribute:: intra_area_prefix
                                            
                                            	Intra\-Area\-Prefix LSA
                                            	**type**\:   :py:class:`IntraAreaPrefix <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix>`
                                            
                                            .. attribute:: link
                                            
                                            	Link LSA
                                            	**type**\:   :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link>`
                                            
                                            .. attribute:: network
                                            
                                            	Network LSA
                                            	**type**\:   :py:class:`Network <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network>`
                                            
                                            .. attribute:: nssa
                                            
                                            	NSSA LSA
                                            	**type**\:   :py:class:`Nssa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa>`
                                            
                                            .. attribute:: router
                                            
                                            	Router LSA
                                            	**type**\:   :py:class:`Router <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body, self).__init__()

                                                self.yang_name = "body"
                                                self.yang_parent_name = "ospfv3"

                                                self.as_external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal()
                                                self.as_external.parent = self
                                                self._children_name_map["as_external"] = "as-external"
                                                self._children_yang_names.add("as-external")

                                                self.inter_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaPrefix()
                                                self.inter_area_prefix.parent = self
                                                self._children_name_map["inter_area_prefix"] = "inter-area-prefix"
                                                self._children_yang_names.add("inter-area-prefix")

                                                self.inter_area_router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter()
                                                self.inter_area_router.parent = self
                                                self._children_name_map["inter_area_router"] = "inter-area-router"
                                                self._children_yang_names.add("inter-area-router")

                                                self.intra_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix()
                                                self.intra_area_prefix.parent = self
                                                self._children_name_map["intra_area_prefix"] = "intra-area-prefix"
                                                self._children_yang_names.add("intra-area-prefix")

                                                self.link = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link()
                                                self.link.parent = self
                                                self._children_name_map["link"] = "link"
                                                self._children_yang_names.add("link")

                                                self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network()
                                                self.network.parent = self
                                                self._children_name_map["network"] = "network"
                                                self._children_yang_names.add("network")

                                                self.nssa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa()
                                                self.nssa.parent = self
                                                self._children_name_map["nssa"] = "nssa"
                                                self._children_yang_names.add("nssa")

                                                self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router()
                                                self.router.parent = self
                                                self._children_name_map["router"] = "router"
                                                self._children_yang_names.add("router")


                                            class Router(Entity):
                                                """
                                                Router LSA.
                                                
                                                .. attribute:: flags
                                                
                                                	LSA option
                                                	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Flags>`
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: link
                                                
                                                	Router LSA link
                                                	**type**\: list of    :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Link>`
                                                
                                                .. attribute:: options
                                                
                                                	OSPFv3 LSA options
                                                	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Options>`
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router, self).__init__()

                                                    self.yang_name = "router"
                                                    self.yang_parent_name = "body"

                                                    self.flags = YLeaf(YType.bits, "flags")

                                                    self.options = YLeaf(YType.bits, "options")

                                                    self.link = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("flags",
                                                                    "options") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router, self).__setattr__(name, value)


                                                class Link(Entity):
                                                    """
                                                    Router LSA link.
                                                    
                                                    .. attribute:: interface_id  <key>
                                                    
                                                    	Interface ID
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: neighbor_interface_id  <key>
                                                    
                                                    	Neighbor Interface ID
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: neighbor_router_id  <key>
                                                    
                                                    	Neighbor Router ID
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: type
                                                    
                                                    	Link type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Link, self).__init__()

                                                        self.yang_name = "link"
                                                        self.yang_parent_name = "router"

                                                        self.interface_id = YLeaf(YType.uint32, "interface-id")

                                                        self.neighbor_interface_id = YLeaf(YType.uint32, "neighbor-interface-id")

                                                        self.neighbor_router_id = YLeaf(YType.str, "neighbor-router-id")

                                                        self.metric = YLeaf(YType.uint16, "metric")

                                                        self.type = YLeaf(YType.uint8, "type")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("interface_id",
                                                                        "neighbor_interface_id",
                                                                        "neighbor_router_id",
                                                                        "metric",
                                                                        "type") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Link, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Link, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.interface_id.is_set or
                                                            self.neighbor_interface_id.is_set or
                                                            self.neighbor_router_id.is_set or
                                                            self.metric.is_set or
                                                            self.type.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.interface_id.yfilter != YFilter.not_set or
                                                            self.neighbor_interface_id.yfilter != YFilter.not_set or
                                                            self.neighbor_router_id.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set or
                                                            self.type.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "link" + "[interface-id='" + self.interface_id.get() + "']" + "[neighbor-interface-id='" + self.neighbor_interface_id.get() + "']" + "[neighbor-router-id='" + self.neighbor_router_id.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.interface_id.is_set or self.interface_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.interface_id.get_name_leafdata())
                                                        if (self.neighbor_interface_id.is_set or self.neighbor_interface_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.neighbor_interface_id.get_name_leafdata())
                                                        if (self.neighbor_router_id.is_set or self.neighbor_router_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.neighbor_router_id.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.type.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "interface-id" or name == "neighbor-interface-id" or name == "neighbor-router-id" or name == "metric" or name == "type"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "interface-id"):
                                                            self.interface_id = value
                                                            self.interface_id.value_namespace = name_space
                                                            self.interface_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "neighbor-interface-id"):
                                                            self.neighbor_interface_id = value
                                                            self.neighbor_interface_id.value_namespace = name_space
                                                            self.neighbor_interface_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "neighbor-router-id"):
                                                            self.neighbor_router_id = value
                                                            self.neighbor_router_id.value_namespace = name_space
                                                            self.neighbor_router_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "type"):
                                                            self.type = value
                                                            self.type.value_namespace = name_space
                                                            self.type.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.link:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.flags.is_set or
                                                        self.options.is_set)

                                                def has_operation(self):
                                                    for c in self.link:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.flags.yfilter != YFilter.not_set or
                                                        self.options.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "router" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.flags.get_name_leafdata())
                                                    if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.options.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "link"):
                                                        for c in self.link:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router.Link()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.link.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "link" or name == "flags" or name == "options"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "flags"):
                                                        self.flags[value] = True
                                                    if(value_path == "options"):
                                                        self.options[value] = True


                                            class Network(Entity):
                                                """
                                                Network LSA.
                                                
                                                .. attribute:: attached_router
                                                
                                                	List of the routers attached to the network
                                                	**type**\:  list of str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                .. attribute:: options
                                                
                                                	OSPFv3 LSA options
                                                	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network.Options>`
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network, self).__init__()

                                                    self.yang_name = "network"
                                                    self.yang_parent_name = "body"

                                                    self.attached_router = YLeafList(YType.str, "attached-router")

                                                    self.options = YLeaf(YType.bits, "options")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("attached_router",
                                                                    "options") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network, self).__setattr__(name, value)

                                                def has_data(self):
                                                    for leaf in self.attached_router.getYLeafs():
                                                        if (leaf.yfilter != YFilter.not_set):
                                                            return True
                                                    return self.options.is_set

                                                def has_operation(self):
                                                    for leaf in self.attached_router.getYLeafs():
                                                        if (leaf.is_set):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.attached_router.yfilter != YFilter.not_set or
                                                        self.options.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "network" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.options.get_name_leafdata())

                                                    leaf_name_data.extend(self.attached_router.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "attached-router" or name == "options"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "attached-router"):
                                                        self.attached_router.append(value)
                                                    if(value_path == "options"):
                                                        self.options[value] = True


                                            class InterAreaPrefix(Entity):
                                                """
                                                Inter\-Area\-Prefix LSA.
                                                
                                                .. attribute:: metric
                                                
                                                	Metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                .. attribute:: prefix
                                                
                                                	Prefix
                                                	**type**\:  str
                                                
                                                .. attribute:: prefix_options
                                                
                                                	Prefix options
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__init__()

                                                    self.yang_name = "inter-area-prefix"
                                                    self.yang_parent_name = "body"

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                    self.prefix = YLeaf(YType.str, "prefix")

                                                    self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("metric",
                                                                    "prefix",
                                                                    "prefix_options") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.metric.is_set or
                                                        self.prefix.is_set or
                                                        self.prefix_options.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set or
                                                        self.prefix.yfilter != YFilter.not_set or
                                                        self.prefix_options.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "inter-area-prefix" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                                    if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "metric" or name == "prefix" or name == "prefix-options"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix"):
                                                        self.prefix = value
                                                        self.prefix.value_namespace = name_space
                                                        self.prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix-options"):
                                                        self.prefix_options = value
                                                        self.prefix_options.value_namespace = name_space
                                                        self.prefix_options.value_namespace_prefix = name_space_prefix


                                            class InterAreaRouter(Entity):
                                                """
                                                Inter\-Area\-Router LSA.
                                                
                                                .. attribute:: destination_router_id
                                                
                                                	The Router ID of the router being described by the LSA
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                .. attribute:: metric
                                                
                                                	Metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                .. attribute:: options
                                                
                                                	OSPFv3 LSA options
                                                	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter.Options>`
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter, self).__init__()

                                                    self.yang_name = "inter-area-router"
                                                    self.yang_parent_name = "body"

                                                    self.destination_router_id = YLeaf(YType.str, "destination-router-id")

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                    self.options = YLeaf(YType.bits, "options")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("destination_router_id",
                                                                    "metric",
                                                                    "options") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.destination_router_id.is_set or
                                                        self.metric.is_set or
                                                        self.options.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.destination_router_id.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set or
                                                        self.options.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "inter-area-router" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.destination_router_id.is_set or self.destination_router_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.destination_router_id.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                                    if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.options.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "destination-router-id" or name == "metric" or name == "options"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "destination-router-id"):
                                                        self.destination_router_id = value
                                                        self.destination_router_id.value_namespace = name_space
                                                        self.destination_router_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "options"):
                                                        self.options[value] = True


                                            class AsExternal(Entity):
                                                """
                                                AS\-External LSA.
                                                
                                                .. attribute:: external_route_tag
                                                
                                                	Route tag
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: flags
                                                
                                                	Flags
                                                	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal.Flags>`
                                                
                                                .. attribute:: forwarding_address
                                                
                                                	Forwarding address
                                                	**type**\:  str
                                                
                                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: metric
                                                
                                                	Metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                .. attribute:: prefix
                                                
                                                	Prefix
                                                	**type**\:  str
                                                
                                                .. attribute:: prefix_options
                                                
                                                	Prefix options
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: referenced_link_state_id
                                                
                                                	Referenced Link State ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: referenced_ls_type
                                                
                                                	Referenced Link State type
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal, self).__init__()

                                                    self.yang_name = "as-external"
                                                    self.yang_parent_name = "body"

                                                    self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                    self.flags = YLeaf(YType.bits, "flags")

                                                    self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                    self.prefix = YLeaf(YType.str, "prefix")

                                                    self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                    self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                    self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("external_route_tag",
                                                                    "flags",
                                                                    "forwarding_address",
                                                                    "metric",
                                                                    "prefix",
                                                                    "prefix_options",
                                                                    "referenced_link_state_id",
                                                                    "referenced_ls_type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.external_route_tag.is_set or
                                                        self.flags.is_set or
                                                        self.forwarding_address.is_set or
                                                        self.metric.is_set or
                                                        self.prefix.is_set or
                                                        self.prefix_options.is_set or
                                                        self.referenced_link_state_id.is_set or
                                                        self.referenced_ls_type.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.external_route_tag.yfilter != YFilter.not_set or
                                                        self.flags.yfilter != YFilter.not_set or
                                                        self.forwarding_address.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set or
                                                        self.prefix.yfilter != YFilter.not_set or
                                                        self.prefix_options.yfilter != YFilter.not_set or
                                                        self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                        self.referenced_ls_type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "as-external" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                    if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.flags.get_name_leafdata())
                                                    if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                                    if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix_options.get_name_leafdata())
                                                    if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                    if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric" or name == "prefix" or name == "prefix-options" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "external-route-tag"):
                                                        self.external_route_tag = value
                                                        self.external_route_tag.value_namespace = name_space
                                                        self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "flags"):
                                                        self.flags[value] = True
                                                    if(value_path == "forwarding-address"):
                                                        self.forwarding_address = value
                                                        self.forwarding_address.value_namespace = name_space
                                                        self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix"):
                                                        self.prefix = value
                                                        self.prefix.value_namespace = name_space
                                                        self.prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix-options"):
                                                        self.prefix_options = value
                                                        self.prefix_options.value_namespace = name_space
                                                        self.prefix_options.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-link-state-id"):
                                                        self.referenced_link_state_id = value
                                                        self.referenced_link_state_id.value_namespace = name_space
                                                        self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-ls-type"):
                                                        self.referenced_ls_type = value
                                                        self.referenced_ls_type.value_namespace = name_space
                                                        self.referenced_ls_type.value_namespace_prefix = name_space_prefix


                                            class Nssa(Entity):
                                                """
                                                NSSA LSA.
                                                
                                                .. attribute:: external_route_tag
                                                
                                                	Route tag
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: flags
                                                
                                                	Flags
                                                	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa.Flags>`
                                                
                                                .. attribute:: forwarding_address
                                                
                                                	Forwarding address
                                                	**type**\:  str
                                                
                                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: metric
                                                
                                                	Metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                .. attribute:: prefix
                                                
                                                	Prefix
                                                	**type**\:  str
                                                
                                                .. attribute:: prefix_options
                                                
                                                	Prefix options
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: referenced_link_state_id
                                                
                                                	Referenced Link State ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: referenced_ls_type
                                                
                                                	Referenced Link State type
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa, self).__init__()

                                                    self.yang_name = "nssa"
                                                    self.yang_parent_name = "body"

                                                    self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                    self.flags = YLeaf(YType.bits, "flags")

                                                    self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                    self.prefix = YLeaf(YType.str, "prefix")

                                                    self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                    self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                    self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("external_route_tag",
                                                                    "flags",
                                                                    "forwarding_address",
                                                                    "metric",
                                                                    "prefix",
                                                                    "prefix_options",
                                                                    "referenced_link_state_id",
                                                                    "referenced_ls_type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.external_route_tag.is_set or
                                                        self.flags.is_set or
                                                        self.forwarding_address.is_set or
                                                        self.metric.is_set or
                                                        self.prefix.is_set or
                                                        self.prefix_options.is_set or
                                                        self.referenced_link_state_id.is_set or
                                                        self.referenced_ls_type.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.external_route_tag.yfilter != YFilter.not_set or
                                                        self.flags.yfilter != YFilter.not_set or
                                                        self.forwarding_address.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set or
                                                        self.prefix.yfilter != YFilter.not_set or
                                                        self.prefix_options.yfilter != YFilter.not_set or
                                                        self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                        self.referenced_ls_type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "nssa" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                    if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.flags.get_name_leafdata())
                                                    if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                                    if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix_options.get_name_leafdata())
                                                    if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                    if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric" or name == "prefix" or name == "prefix-options" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "external-route-tag"):
                                                        self.external_route_tag = value
                                                        self.external_route_tag.value_namespace = name_space
                                                        self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "flags"):
                                                        self.flags[value] = True
                                                    if(value_path == "forwarding-address"):
                                                        self.forwarding_address = value
                                                        self.forwarding_address.value_namespace = name_space
                                                        self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix"):
                                                        self.prefix = value
                                                        self.prefix.value_namespace = name_space
                                                        self.prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix-options"):
                                                        self.prefix_options = value
                                                        self.prefix_options.value_namespace = name_space
                                                        self.prefix_options.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-link-state-id"):
                                                        self.referenced_link_state_id = value
                                                        self.referenced_link_state_id.value_namespace = name_space
                                                        self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-ls-type"):
                                                        self.referenced_ls_type = value
                                                        self.referenced_ls_type.value_namespace = name_space
                                                        self.referenced_ls_type.value_namespace_prefix = name_space_prefix


                                            class Link(Entity):
                                                """
                                                Link LSA.
                                                
                                                .. attribute:: link_local_interface_address
                                                
                                                	The originating router's link\-local interface address on the link
                                                	**type**\: one of the below types:
                                                
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                
                                                ----
                                                	**type**\:  str
                                                
                                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                                
                                                
                                                ----
                                                .. attribute:: num_of_prefixes
                                                
                                                	Number of prefixes
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: options
                                                
                                                	OSPFv3 LSA options
                                                	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link.Options>`
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: prefix_list
                                                
                                                	List of prefixes associated with the link
                                                	**type**\: list of    :py:class:`PrefixList <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link.PrefixList>`
                                                
                                                .. attribute:: rtr_priority
                                                
                                                	Router Priority of the interface
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link, self).__init__()

                                                    self.yang_name = "link"
                                                    self.yang_parent_name = "body"

                                                    self.link_local_interface_address = YLeaf(YType.str, "link-local-interface-address")

                                                    self.num_of_prefixes = YLeaf(YType.uint32, "num-of-prefixes")

                                                    self.options = YLeaf(YType.bits, "options")

                                                    self.rtr_priority = YLeaf(YType.uint8, "rtr-priority")

                                                    self.prefix_list = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("link_local_interface_address",
                                                                    "num_of_prefixes",
                                                                    "options",
                                                                    "rtr_priority") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link, self).__setattr__(name, value)


                                                class PrefixList(Entity):
                                                    """
                                                    List of prefixes associated with the link.
                                                    
                                                    .. attribute:: prefix  <key>
                                                    
                                                    	Prefix
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: prefix_options
                                                    
                                                    	Prefix options
                                                    	**type**\:  str
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link.PrefixList, self).__init__()

                                                        self.yang_name = "prefix-list"
                                                        self.yang_parent_name = "link"

                                                        self.prefix = YLeaf(YType.str, "prefix")

                                                        self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("prefix",
                                                                        "prefix_options") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link.PrefixList, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link.PrefixList, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.prefix.is_set or
                                                            self.prefix_options.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.prefix.yfilter != YFilter.not_set or
                                                            self.prefix_options.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "prefix-list" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                                        if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "prefix" or name == "prefix-options"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "prefix"):
                                                            self.prefix = value
                                                            self.prefix.value_namespace = name_space
                                                            self.prefix.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix-options"):
                                                            self.prefix_options = value
                                                            self.prefix_options.value_namespace = name_space
                                                            self.prefix_options.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.prefix_list:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.link_local_interface_address.is_set or
                                                        self.num_of_prefixes.is_set or
                                                        self.options.is_set or
                                                        self.rtr_priority.is_set)

                                                def has_operation(self):
                                                    for c in self.prefix_list:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.link_local_interface_address.yfilter != YFilter.not_set or
                                                        self.num_of_prefixes.yfilter != YFilter.not_set or
                                                        self.options.yfilter != YFilter.not_set or
                                                        self.rtr_priority.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "link" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.link_local_interface_address.is_set or self.link_local_interface_address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.link_local_interface_address.get_name_leafdata())
                                                    if (self.num_of_prefixes.is_set or self.num_of_prefixes.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.num_of_prefixes.get_name_leafdata())
                                                    if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.options.get_name_leafdata())
                                                    if (self.rtr_priority.is_set or self.rtr_priority.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.rtr_priority.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "prefix-list"):
                                                        for c in self.prefix_list:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link.PrefixList()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.prefix_list.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "prefix-list" or name == "link-local-interface-address" or name == "num-of-prefixes" or name == "options" or name == "rtr-priority"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "link-local-interface-address"):
                                                        self.link_local_interface_address = value
                                                        self.link_local_interface_address.value_namespace = name_space
                                                        self.link_local_interface_address.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "num-of-prefixes"):
                                                        self.num_of_prefixes = value
                                                        self.num_of_prefixes.value_namespace = name_space
                                                        self.num_of_prefixes.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "options"):
                                                        self.options[value] = True
                                                    if(value_path == "rtr-priority"):
                                                        self.rtr_priority = value
                                                        self.rtr_priority.value_namespace = name_space
                                                        self.rtr_priority.value_namespace_prefix = name_space_prefix


                                            class IntraAreaPrefix(Entity):
                                                """
                                                Intra\-Area\-Prefix LSA.
                                                
                                                .. attribute:: num_of_prefixes
                                                
                                                	Number of prefixes
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                .. attribute:: prefix_list
                                                
                                                	List of prefixes associated with the link
                                                	**type**\: list of    :py:class:`PrefixList <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList>`
                                                
                                                .. attribute:: referenced_adv_router
                                                
                                                	Referenced Advertising Router
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: referenced_link_state_id
                                                
                                                	Referenced Link State ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: referenced_ls_type
                                                
                                                	Referenced Link State type
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__init__()

                                                    self.yang_name = "intra-area-prefix"
                                                    self.yang_parent_name = "body"

                                                    self.num_of_prefixes = YLeaf(YType.uint16, "num-of-prefixes")

                                                    self.referenced_adv_router = YLeaf(YType.str, "referenced-adv-router")

                                                    self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                    self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                    self.prefix_list = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("num_of_prefixes",
                                                                    "referenced_adv_router",
                                                                    "referenced_link_state_id",
                                                                    "referenced_ls_type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__setattr__(name, value)


                                                class PrefixList(Entity):
                                                    """
                                                    List of prefixes associated with the link.
                                                    
                                                    .. attribute:: prefix  <key>
                                                    
                                                    	Prefix
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..16777215
                                                    
                                                    .. attribute:: prefix_options
                                                    
                                                    	Prefix options
                                                    	**type**\:  str
                                                    
                                                    	**mandatory**\: True
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__init__()

                                                        self.yang_name = "prefix-list"
                                                        self.yang_parent_name = "intra-area-prefix"

                                                        self.prefix = YLeaf(YType.str, "prefix")

                                                        self.metric = YLeaf(YType.uint32, "metric")

                                                        self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("prefix",
                                                                        "metric",
                                                                        "prefix_options") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.prefix.is_set or
                                                            self.metric.is_set or
                                                            self.prefix_options.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.prefix.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set or
                                                            self.prefix_options.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "prefix-list" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                                        if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "prefix" or name == "metric" or name == "prefix-options"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "prefix"):
                                                            self.prefix = value
                                                            self.prefix.value_namespace = name_space
                                                            self.prefix.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "prefix-options"):
                                                            self.prefix_options = value
                                                            self.prefix_options.value_namespace = name_space
                                                            self.prefix_options.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.prefix_list:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.num_of_prefixes.is_set or
                                                        self.referenced_adv_router.is_set or
                                                        self.referenced_link_state_id.is_set or
                                                        self.referenced_ls_type.is_set)

                                                def has_operation(self):
                                                    for c in self.prefix_list:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.num_of_prefixes.yfilter != YFilter.not_set or
                                                        self.referenced_adv_router.yfilter != YFilter.not_set or
                                                        self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                        self.referenced_ls_type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "intra-area-prefix" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.num_of_prefixes.is_set or self.num_of_prefixes.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.num_of_prefixes.get_name_leafdata())
                                                    if (self.referenced_adv_router.is_set or self.referenced_adv_router.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_adv_router.get_name_leafdata())
                                                    if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                    if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "prefix-list"):
                                                        for c in self.prefix_list:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.prefix_list.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "prefix-list" or name == "num-of-prefixes" or name == "referenced-adv-router" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "num-of-prefixes"):
                                                        self.num_of_prefixes = value
                                                        self.num_of_prefixes.value_namespace = name_space
                                                        self.num_of_prefixes.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-adv-router"):
                                                        self.referenced_adv_router = value
                                                        self.referenced_adv_router.value_namespace = name_space
                                                        self.referenced_adv_router.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-link-state-id"):
                                                        self.referenced_link_state_id = value
                                                        self.referenced_link_state_id.value_namespace = name_space
                                                        self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "referenced-ls-type"):
                                                        self.referenced_ls_type = value
                                                        self.referenced_ls_type.value_namespace = name_space
                                                        self.referenced_ls_type.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    (self.as_external is not None and self.as_external.has_data()) or
                                                    (self.inter_area_prefix is not None and self.inter_area_prefix.has_data()) or
                                                    (self.inter_area_router is not None and self.inter_area_router.has_data()) or
                                                    (self.intra_area_prefix is not None and self.intra_area_prefix.has_data()) or
                                                    (self.link is not None and self.link.has_data()) or
                                                    (self.network is not None and self.network.has_data()) or
                                                    (self.nssa is not None and self.nssa.has_data()) or
                                                    (self.router is not None and self.router.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    (self.as_external is not None and self.as_external.has_operation()) or
                                                    (self.inter_area_prefix is not None and self.inter_area_prefix.has_operation()) or
                                                    (self.inter_area_router is not None and self.inter_area_router.has_operation()) or
                                                    (self.intra_area_prefix is not None and self.intra_area_prefix.has_operation()) or
                                                    (self.link is not None and self.link.has_operation()) or
                                                    (self.network is not None and self.network.has_operation()) or
                                                    (self.nssa is not None and self.nssa.has_operation()) or
                                                    (self.router is not None and self.router.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "body" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "as-external"):
                                                    if (self.as_external is None):
                                                        self.as_external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.AsExternal()
                                                        self.as_external.parent = self
                                                        self._children_name_map["as_external"] = "as-external"
                                                    return self.as_external

                                                if (child_yang_name == "inter-area-prefix"):
                                                    if (self.inter_area_prefix is None):
                                                        self.inter_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaPrefix()
                                                        self.inter_area_prefix.parent = self
                                                        self._children_name_map["inter_area_prefix"] = "inter-area-prefix"
                                                    return self.inter_area_prefix

                                                if (child_yang_name == "inter-area-router"):
                                                    if (self.inter_area_router is None):
                                                        self.inter_area_router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.InterAreaRouter()
                                                        self.inter_area_router.parent = self
                                                        self._children_name_map["inter_area_router"] = "inter-area-router"
                                                    return self.inter_area_router

                                                if (child_yang_name == "intra-area-prefix"):
                                                    if (self.intra_area_prefix is None):
                                                        self.intra_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.IntraAreaPrefix()
                                                        self.intra_area_prefix.parent = self
                                                        self._children_name_map["intra_area_prefix"] = "intra-area-prefix"
                                                    return self.intra_area_prefix

                                                if (child_yang_name == "link"):
                                                    if (self.link is None):
                                                        self.link = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Link()
                                                        self.link.parent = self
                                                        self._children_name_map["link"] = "link"
                                                    return self.link

                                                if (child_yang_name == "network"):
                                                    if (self.network is None):
                                                        self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Network()
                                                        self.network.parent = self
                                                        self._children_name_map["network"] = "network"
                                                    return self.network

                                                if (child_yang_name == "nssa"):
                                                    if (self.nssa is None):
                                                        self.nssa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Nssa()
                                                        self.nssa.parent = self
                                                        self._children_name_map["nssa"] = "nssa"
                                                    return self.nssa

                                                if (child_yang_name == "router"):
                                                    if (self.router is None):
                                                        self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body.Router()
                                                        self.router.parent = self
                                                        self._children_name_map["router"] = "router"
                                                    return self.router

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "as-external" or name == "inter-area-prefix" or name == "inter-area-router" or name == "intra-area-prefix" or name == "link" or name == "network" or name == "nssa" or name == "router"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                (self.body is not None and self.body.has_data()) or
                                                (self.header is not None and self.header.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.body is not None and self.body.has_operation()) or
                                                (self.header is not None and self.header.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ospfv3" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "body"):
                                                if (self.body is None):
                                                    self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Body()
                                                    self.body.parent = self
                                                    self._children_name_map["body"] = "body"
                                                return self.body

                                            if (child_yang_name == "header"):
                                                if (self.header is None):
                                                    self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3.Header()
                                                    self.header.parent = self
                                                    self._children_name_map["header"] = "header"
                                                return self.header

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "body" or name == "header"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.lsa_id.is_set or
                                            self.adv_router.is_set or
                                            self.decoded_completed.is_set or
                                            self.raw_data.is_set or
                                            (self.ospfv2 is not None and self.ospfv2.has_data()) or
                                            (self.ospfv3 is not None and self.ospfv3.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.lsa_id.yfilter != YFilter.not_set or
                                            self.adv_router.yfilter != YFilter.not_set or
                                            self.decoded_completed.yfilter != YFilter.not_set or
                                            self.raw_data.yfilter != YFilter.not_set or
                                            (self.ospfv2 is not None and self.ospfv2.has_operation()) or
                                            (self.ospfv3 is not None and self.ospfv3.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "area-scope-lsa" + "[lsa-id='" + self.lsa_id.get() + "']" + "[adv-router='" + self.adv_router.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                        if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adv_router.get_name_leafdata())
                                        if (self.decoded_completed.is_set or self.decoded_completed.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.decoded_completed.get_name_leafdata())
                                        if (self.raw_data.is_set or self.raw_data.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.raw_data.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "ospfv2"):
                                            if (self.ospfv2 is None):
                                                self.ospfv2 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv2()
                                                self.ospfv2.parent = self
                                                self._children_name_map["ospfv2"] = "ospfv2"
                                            return self.ospfv2

                                        if (child_yang_name == "ospfv3"):
                                            if (self.ospfv3 is None):
                                                self.ospfv3 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa.Ospfv3()
                                                self.ospfv3.parent = self
                                                self._children_name_map["ospfv3"] = "ospfv3"
                                            return self.ospfv3

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ospfv2" or name == "ospfv3" or name == "lsa-id" or name == "adv-router" or name == "decoded-completed" or name == "raw-data"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "lsa-id"):
                                            self.lsa_id = value
                                            self.lsa_id.value_namespace = name_space
                                            self.lsa_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "adv-router"):
                                            self.adv_router = value
                                            self.adv_router.value_namespace = name_space
                                            self.adv_router.value_namespace_prefix = name_space_prefix
                                        if(value_path == "decoded-completed"):
                                            self.decoded_completed = value
                                            self.decoded_completed.value_namespace = name_space
                                            self.decoded_completed.value_namespace_prefix = name_space_prefix
                                        if(value_path == "raw-data"):
                                            self.raw_data = value
                                            self.raw_data.value_namespace = name_space
                                            self.raw_data.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.area_scope_lsa:
                                        if (c.has_data()):
                                            return True
                                    return self.lsa_type.is_set

                                def has_operation(self):
                                    for c in self.area_scope_lsa:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.lsa_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "area-scope-lsas" + "[lsa-type='" + self.lsa_type.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "area-scope-lsa"):
                                        for c in self.area_scope_lsa:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas.AreaScopeLsa()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.area_scope_lsa.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area-scope-lsa" or name == "lsa-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "lsa-type"):
                                        self.lsa_type = value
                                        self.lsa_type.value_namespace = name_space
                                        self.lsa_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.area_scope_lsas:
                                    if (c.has_data()):
                                        return True
                                for c in self.interfaces:
                                    if (c.has_data()):
                                        return True
                                return self.area_id.is_set

                            def has_operation(self):
                                for c in self.area_scope_lsas:
                                    if (c.has_operation()):
                                        return True
                                for c in self.interfaces:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area" + "[area-id='" + self.area_id.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "area-scope-lsas"):
                                    for c in self.area_scope_lsas:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AreaScopeLsas()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.area_scope_lsas.append(c)
                                    return c

                                if (child_yang_name == "interfaces"):
                                    for c in self.interfaces:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interfaces()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.interfaces.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area-scope-lsas" or name == "interfaces" or name == "area-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area-id"):
                                    self.area_id = value
                                    self.area_id.value_namespace = name_space
                                    self.area_id.value_namespace_prefix = name_space_prefix


                        class AsScopeLsas(Entity):
                            """
                            List OSPF AS scope LSA databases
                            
                            .. attribute:: lsa_type  <key>
                            
                            	OSPF AS scope LSA type
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: as_scope_lsa
                            
                            	List of OSPF AS scope LSAs
                            	**type**\: list of    :py:class:`AsScopeLsa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas, self).__init__()

                                self.yang_name = "as-scope-lsas"
                                self.yang_parent_name = "instance"

                                self.lsa_type = YLeaf(YType.uint8, "lsa-type")

                                self.as_scope_lsa = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("lsa_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas, self).__setattr__(name, value)


                            class AsScopeLsa(Entity):
                                """
                                List of OSPF AS scope LSAs
                                
                                .. attribute:: lsa_id  <key>
                                
                                	LSA ID
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                
                                ----
                                .. attribute:: adv_router  <key>
                                
                                	Advertising router
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: decoded_completed
                                
                                	The OSPF LSA body is fully decoded
                                	**type**\:  bool
                                
                                .. attribute:: ospfv2
                                
                                	OSPFv2 LSA
                                	**type**\:   :py:class:`Ospfv2 <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2>`
                                
                                .. attribute:: ospfv3
                                
                                	OSPFv3 LSA
                                	**type**\:   :py:class:`Ospfv3 <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3>`
                                
                                .. attribute:: raw_data
                                
                                	The complete LSA in network byte order as received/sent over the wire
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa, self).__init__()

                                    self.yang_name = "as-scope-lsa"
                                    self.yang_parent_name = "as-scope-lsas"

                                    self.lsa_id = YLeaf(YType.str, "lsa-id")

                                    self.adv_router = YLeaf(YType.str, "adv-router")

                                    self.decoded_completed = YLeaf(YType.boolean, "decoded-completed")

                                    self.raw_data = YLeaf(YType.str, "raw-data")

                                    self.ospfv2 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2()
                                    self.ospfv2.parent = self
                                    self._children_name_map["ospfv2"] = "ospfv2"
                                    self._children_yang_names.add("ospfv2")

                                    self.ospfv3 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3()
                                    self.ospfv3.parent = self
                                    self._children_name_map["ospfv3"] = "ospfv3"
                                    self._children_yang_names.add("ospfv3")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("lsa_id",
                                                    "adv_router",
                                                    "decoded_completed",
                                                    "raw_data") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa, self).__setattr__(name, value)


                                class Ospfv2(Entity):
                                    """
                                    OSPFv2 LSA
                                    
                                    .. attribute:: body
                                    
                                    	Decoded OSPFv2 LSA body data
                                    	**type**\:   :py:class:`Body <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body>`
                                    
                                    .. attribute:: header
                                    
                                    	Decoded OSPFv2 LSA header data
                                    	**type**\:   :py:class:`Header <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2, self).__init__()

                                        self.yang_name = "ospfv2"
                                        self.yang_parent_name = "as-scope-lsa"

                                        self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body()
                                        self.body.parent = self
                                        self._children_name_map["body"] = "body"
                                        self._children_yang_names.add("body")

                                        self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header()
                                        self.header.parent = self
                                        self._children_name_map["header"] = "header"
                                        self._children_yang_names.add("header")


                                    class Header(Entity):
                                        """
                                        Decoded OSPFv2 LSA header data.
                                        
                                        .. attribute:: adv_router
                                        
                                        	LSA advertising router
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: age
                                        
                                        	LSA age
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: checksum
                                        
                                        	LSA checksum
                                        	**type**\:  str
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: length
                                        
                                        	LSA length
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: lsa_id
                                        
                                        	LSA ID
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: opaque_id
                                        
                                        	Opaque id
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: opaque_type
                                        
                                        	Opaque type
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: options
                                        
                                        	LSA option
                                        	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header.Options>`
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: seq_num
                                        
                                        	LSA sequence number
                                        	**type**\:  str
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: type
                                        
                                        	LSA type
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header, self).__init__()

                                            self.yang_name = "header"
                                            self.yang_parent_name = "ospfv2"

                                            self.adv_router = YLeaf(YType.str, "adv-router")

                                            self.age = YLeaf(YType.uint16, "age")

                                            self.checksum = YLeaf(YType.str, "checksum")

                                            self.length = YLeaf(YType.uint16, "length")

                                            self.lsa_id = YLeaf(YType.str, "lsa-id")

                                            self.opaque_id = YLeaf(YType.uint32, "opaque-id")

                                            self.opaque_type = YLeaf(YType.uint8, "opaque-type")

                                            self.options = YLeaf(YType.bits, "options")

                                            self.seq_num = YLeaf(YType.str, "seq-num")

                                            self.type = YLeaf(YType.uint16, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adv_router",
                                                            "age",
                                                            "checksum",
                                                            "length",
                                                            "lsa_id",
                                                            "opaque_id",
                                                            "opaque_type",
                                                            "options",
                                                            "seq_num",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.adv_router.is_set or
                                                self.age.is_set or
                                                self.checksum.is_set or
                                                self.length.is_set or
                                                self.lsa_id.is_set or
                                                self.opaque_id.is_set or
                                                self.opaque_type.is_set or
                                                self.options.is_set or
                                                self.seq_num.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adv_router.yfilter != YFilter.not_set or
                                                self.age.yfilter != YFilter.not_set or
                                                self.checksum.yfilter != YFilter.not_set or
                                                self.length.yfilter != YFilter.not_set or
                                                self.lsa_id.yfilter != YFilter.not_set or
                                                self.opaque_id.yfilter != YFilter.not_set or
                                                self.opaque_type.yfilter != YFilter.not_set or
                                                self.options.yfilter != YFilter.not_set or
                                                self.seq_num.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "header" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adv_router.get_name_leafdata())
                                            if (self.age.is_set or self.age.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.age.get_name_leafdata())
                                            if (self.checksum.is_set or self.checksum.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.checksum.get_name_leafdata())
                                            if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.length.get_name_leafdata())
                                            if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                            if (self.opaque_id.is_set or self.opaque_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.opaque_id.get_name_leafdata())
                                            if (self.opaque_type.is_set or self.opaque_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.opaque_type.get_name_leafdata())
                                            if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.options.get_name_leafdata())
                                            if (self.seq_num.is_set or self.seq_num.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.seq_num.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "adv-router" or name == "age" or name == "checksum" or name == "length" or name == "lsa-id" or name == "opaque-id" or name == "opaque-type" or name == "options" or name == "seq-num" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adv-router"):
                                                self.adv_router = value
                                                self.adv_router.value_namespace = name_space
                                                self.adv_router.value_namespace_prefix = name_space_prefix
                                            if(value_path == "age"):
                                                self.age = value
                                                self.age.value_namespace = name_space
                                                self.age.value_namespace_prefix = name_space_prefix
                                            if(value_path == "checksum"):
                                                self.checksum = value
                                                self.checksum.value_namespace = name_space
                                                self.checksum.value_namespace_prefix = name_space_prefix
                                            if(value_path == "length"):
                                                self.length = value
                                                self.length.value_namespace = name_space
                                                self.length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "lsa-id"):
                                                self.lsa_id = value
                                                self.lsa_id.value_namespace = name_space
                                                self.lsa_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "opaque-id"):
                                                self.opaque_id = value
                                                self.opaque_id.value_namespace = name_space
                                                self.opaque_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "opaque-type"):
                                                self.opaque_type = value
                                                self.opaque_type.value_namespace = name_space
                                                self.opaque_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "options"):
                                                self.options[value] = True
                                            if(value_path == "seq-num"):
                                                self.seq_num = value
                                                self.seq_num.value_namespace = name_space
                                                self.seq_num.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix


                                    class Body(Entity):
                                        """
                                        Decoded OSPFv2 LSA body data.
                                        
                                        .. attribute:: external
                                        
                                        	External LSA
                                        	**type**\:   :py:class:`External <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External>`
                                        
                                        .. attribute:: network
                                        
                                        	Network LSA
                                        	**type**\:   :py:class:`Network <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Network>`
                                        
                                        .. attribute:: opaque
                                        
                                        	Opaque LSA
                                        	**type**\:   :py:class:`Opaque <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque>`
                                        
                                        .. attribute:: router
                                        
                                        	Router LSA
                                        	**type**\:   :py:class:`Router <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router>`
                                        
                                        .. attribute:: summary
                                        
                                        	Summary LSA
                                        	**type**\:   :py:class:`Summary <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body, self).__init__()

                                            self.yang_name = "body"
                                            self.yang_parent_name = "ospfv2"

                                            self.external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External()
                                            self.external.parent = self
                                            self._children_name_map["external"] = "external"
                                            self._children_yang_names.add("external")

                                            self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Network()
                                            self.network.parent = self
                                            self._children_name_map["network"] = "network"
                                            self._children_yang_names.add("network")

                                            self.opaque = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque()
                                            self.opaque.parent = self
                                            self._children_name_map["opaque"] = "opaque"
                                            self._children_yang_names.add("opaque")

                                            self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router()
                                            self.router.parent = self
                                            self._children_name_map["router"] = "router"
                                            self._children_yang_names.add("router")

                                            self.summary = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary()
                                            self.summary.parent = self
                                            self._children_name_map["summary"] = "summary"
                                            self._children_yang_names.add("summary")


                                        class Router(Entity):
                                            """
                                            Router LSA.
                                            
                                            .. attribute:: flags
                                            
                                            	Flags
                                            	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Flags>`
                                            
                                            .. attribute:: link
                                            
                                            	Router LSA link
                                            	**type**\: list of    :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link>`
                                            
                                            .. attribute:: num_of_links
                                            
                                            	Number of links
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router, self).__init__()

                                                self.yang_name = "router"
                                                self.yang_parent_name = "body"

                                                self.flags = YLeaf(YType.bits, "flags")

                                                self.num_of_links = YLeaf(YType.uint16, "num-of-links")

                                                self.link = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("flags",
                                                                "num_of_links") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router, self).__setattr__(name, value)


                                            class Link(Entity):
                                                """
                                                Router LSA link.
                                                
                                                .. attribute:: link_id  <key>
                                                
                                                	Link ID
                                                	**type**\: one of the below types:
                                                
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                
                                                ----
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                
                                                ----
                                                .. attribute:: link_data  <key>
                                                
                                                	Link data
                                                	**type**\: one of the below types:
                                                
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                
                                                ----
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                
                                                ----
                                                .. attribute:: topology
                                                
                                                	Topology specific information
                                                	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link.Topology>`
                                                
                                                .. attribute:: type
                                                
                                                	Link type
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link, self).__init__()

                                                    self.yang_name = "link"
                                                    self.yang_parent_name = "router"

                                                    self.link_id = YLeaf(YType.str, "link-id")

                                                    self.link_data = YLeaf(YType.str, "link-data")

                                                    self.type = YLeaf(YType.uint8, "type")

                                                    self.topology = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("link_id",
                                                                    "link_data",
                                                                    "type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link, self).__setattr__(name, value)


                                                class Topology(Entity):
                                                    """
                                                    Topology specific information.
                                                    
                                                    .. attribute:: mt_id  <key>
                                                    
                                                    	The MT\-ID for topology enabled on the link
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    .. attribute:: metric
                                                    
                                                    	Metric for the topology
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__init__()

                                                        self.yang_name = "topology"
                                                        self.yang_parent_name = "link"

                                                        self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                        self.metric = YLeaf(YType.uint16, "metric")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("mt_id",
                                                                        "metric") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link.Topology, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.mt_id.is_set or
                                                            self.metric.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.mt_id.yfilter != YFilter.not_set or
                                                            self.metric.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.metric.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "mt-id" or name == "metric"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "mt-id"):
                                                            self.mt_id = value
                                                            self.mt_id.value_namespace = name_space
                                                            self.mt_id.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "metric"):
                                                            self.metric = value
                                                            self.metric.value_namespace = name_space
                                                            self.metric.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.topology:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.link_id.is_set or
                                                        self.link_data.is_set or
                                                        self.type.is_set)

                                                def has_operation(self):
                                                    for c in self.topology:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.link_id.yfilter != YFilter.not_set or
                                                        self.link_data.yfilter != YFilter.not_set or
                                                        self.type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "link" + "[link-id='" + self.link_id.get() + "']" + "[link-data='" + self.link_data.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.link_id.get_name_leafdata())
                                                    if (self.link_data.is_set or self.link_data.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.link_data.get_name_leafdata())
                                                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "topology"):
                                                        for c in self.topology:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link.Topology()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.topology.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "topology" or name == "link-id" or name == "link-data" or name == "type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "link-id"):
                                                        self.link_id = value
                                                        self.link_id.value_namespace = name_space
                                                        self.link_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "link-data"):
                                                        self.link_data = value
                                                        self.link_data.value_namespace = name_space
                                                        self.link_data.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "type"):
                                                        self.type = value
                                                        self.type.value_namespace = name_space
                                                        self.type.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.link:
                                                    if (c.has_data()):
                                                        return True
                                                return (
                                                    self.flags.is_set or
                                                    self.num_of_links.is_set)

                                            def has_operation(self):
                                                for c in self.link:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.flags.yfilter != YFilter.not_set or
                                                    self.num_of_links.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "router" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.flags.get_name_leafdata())
                                                if (self.num_of_links.is_set or self.num_of_links.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.num_of_links.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "link"):
                                                    for c in self.link:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router.Link()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.link.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "link" or name == "flags" or name == "num-of-links"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "flags"):
                                                    self.flags[value] = True
                                                if(value_path == "num-of-links"):
                                                    self.num_of_links = value
                                                    self.num_of_links.value_namespace = name_space
                                                    self.num_of_links.value_namespace_prefix = name_space_prefix


                                        class Network(Entity):
                                            """
                                            Network LSA.
                                            
                                            .. attribute:: attached_router
                                            
                                            	List of the routers attached to the network
                                            	**type**\:  list of str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                            
                                            .. attribute:: network_mask
                                            
                                            	The IP address mask for the network
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Network, self).__init__()

                                                self.yang_name = "network"
                                                self.yang_parent_name = "body"

                                                self.attached_router = YLeafList(YType.str, "attached-router")

                                                self.network_mask = YLeaf(YType.str, "network-mask")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("attached_router",
                                                                "network_mask") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Network, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Network, self).__setattr__(name, value)

                                            def has_data(self):
                                                for leaf in self.attached_router.getYLeafs():
                                                    if (leaf.yfilter != YFilter.not_set):
                                                        return True
                                                return self.network_mask.is_set

                                            def has_operation(self):
                                                for leaf in self.attached_router.getYLeafs():
                                                    if (leaf.is_set):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.attached_router.yfilter != YFilter.not_set or
                                                    self.network_mask.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "network" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                leaf_name_data.extend(self.attached_router.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "attached-router" or name == "network-mask"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "attached-router"):
                                                    self.attached_router.append(value)
                                                if(value_path == "network-mask"):
                                                    self.network_mask = value
                                                    self.network_mask.value_namespace = name_space
                                                    self.network_mask.value_namespace_prefix = name_space_prefix


                                        class Summary(Entity):
                                            """
                                            Summary LSA.
                                            
                                            .. attribute:: network_mask
                                            
                                            	The IP address mask for the network
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: topology
                                            
                                            	Topology specific information
                                            	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary.Topology>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary, self).__init__()

                                                self.yang_name = "summary"
                                                self.yang_parent_name = "body"

                                                self.network_mask = YLeaf(YType.str, "network-mask")

                                                self.topology = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("network_mask") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary, self).__setattr__(name, value)


                                            class Topology(Entity):
                                                """
                                                Topology specific information.
                                                
                                                .. attribute:: mt_id  <key>
                                                
                                                	The MT\-ID for topology enabled on the link
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: metric
                                                
                                                	Metric for the topology
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary.Topology, self).__init__()

                                                    self.yang_name = "topology"
                                                    self.yang_parent_name = "summary"

                                                    self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("mt_id",
                                                                    "metric") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary.Topology, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary.Topology, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.mt_id.is_set or
                                                        self.metric.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.mt_id.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "mt-id" or name == "metric"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "mt-id"):
                                                        self.mt_id = value
                                                        self.mt_id.value_namespace = name_space
                                                        self.mt_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.topology:
                                                    if (c.has_data()):
                                                        return True
                                                return self.network_mask.is_set

                                            def has_operation(self):
                                                for c in self.topology:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.network_mask.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "summary" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "topology"):
                                                    for c in self.topology:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary.Topology()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.topology.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "topology" or name == "network-mask"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "network-mask"):
                                                    self.network_mask = value
                                                    self.network_mask.value_namespace = name_space
                                                    self.network_mask.value_namespace_prefix = name_space_prefix


                                        class External(Entity):
                                            """
                                            External LSA.
                                            
                                            .. attribute:: network_mask
                                            
                                            	The IP address mask for the network
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: topology
                                            
                                            	Topology specific information
                                            	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External.Topology>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External, self).__init__()

                                                self.yang_name = "external"
                                                self.yang_parent_name = "body"

                                                self.network_mask = YLeaf(YType.str, "network-mask")

                                                self.topology = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("network_mask") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External, self).__setattr__(name, value)


                                            class Topology(Entity):
                                                """
                                                Topology specific information.
                                                
                                                .. attribute:: mt_id  <key>
                                                
                                                	The MT\-ID for topology enabled on the link
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: external_route_tag
                                                
                                                	Route tag
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: flags
                                                
                                                	Flags
                                                	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External.Topology.Flags>`
                                                
                                                .. attribute:: forwarding_address
                                                
                                                	Forwarding address
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: metric
                                                
                                                	Metric for the topology
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External.Topology, self).__init__()

                                                    self.yang_name = "topology"
                                                    self.yang_parent_name = "external"

                                                    self.mt_id = YLeaf(YType.uint8, "mt-id")

                                                    self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                    self.flags = YLeaf(YType.bits, "flags")

                                                    self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("mt_id",
                                                                    "external_route_tag",
                                                                    "flags",
                                                                    "forwarding_address",
                                                                    "metric") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External.Topology, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External.Topology, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.mt_id.is_set or
                                                        self.external_route_tag.is_set or
                                                        self.flags.is_set or
                                                        self.forwarding_address.is_set or
                                                        self.metric.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.mt_id.yfilter != YFilter.not_set or
                                                        self.external_route_tag.yfilter != YFilter.not_set or
                                                        self.flags.yfilter != YFilter.not_set or
                                                        self.forwarding_address.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "topology" + "[mt-id='" + self.mt_id.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.mt_id.is_set or self.mt_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.mt_id.get_name_leafdata())
                                                    if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                    if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.flags.get_name_leafdata())
                                                    if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "mt-id" or name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "mt-id"):
                                                        self.mt_id = value
                                                        self.mt_id.value_namespace = name_space
                                                        self.mt_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "external-route-tag"):
                                                        self.external_route_tag = value
                                                        self.external_route_tag.value_namespace = name_space
                                                        self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "flags"):
                                                        self.flags[value] = True
                                                    if(value_path == "forwarding-address"):
                                                        self.forwarding_address = value
                                                        self.forwarding_address.value_namespace = name_space
                                                        self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.topology:
                                                    if (c.has_data()):
                                                        return True
                                                return self.network_mask.is_set

                                            def has_operation(self):
                                                for c in self.topology:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.network_mask.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "external" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.network_mask.is_set or self.network_mask.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.network_mask.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "topology"):
                                                    for c in self.topology:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External.Topology()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.topology.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "topology" or name == "network-mask"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "network-mask"):
                                                    self.network_mask = value
                                                    self.network_mask.value_namespace = name_space
                                                    self.network_mask.value_namespace_prefix = name_space_prefix


                                        class Opaque(Entity):
                                            """
                                            Opaque LSA.
                                            
                                            .. attribute:: link_tlv
                                            
                                            	Link TLV
                                            	**type**\:   :py:class:`LinkTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv>`
                                            
                                            .. attribute:: router_address_tlv
                                            
                                            	Router address TLV
                                            	**type**\:   :py:class:`RouterAddressTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv>`
                                            
                                            .. attribute:: unknown_tlv
                                            
                                            	Unknown TLV
                                            	**type**\: list of    :py:class:`UnknownTlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.UnknownTlv>`
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque, self).__init__()

                                                self.yang_name = "opaque"
                                                self.yang_parent_name = "body"

                                                self.link_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv()
                                                self.link_tlv.parent = self
                                                self._children_name_map["link_tlv"] = "link-tlv"
                                                self._children_yang_names.add("link-tlv")

                                                self.router_address_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv()
                                                self.router_address_tlv.parent = self
                                                self._children_name_map["router_address_tlv"] = "router-address-tlv"
                                                self._children_yang_names.add("router-address-tlv")

                                                self.unknown_tlv = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in () and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque, self).__setattr__(name, value)


                                            class UnknownTlv(Entity):
                                                """
                                                Unknown TLV.
                                                
                                                .. attribute:: type  <key>
                                                
                                                	TLV type
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                .. attribute:: length
                                                
                                                	TLV length
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                .. attribute:: value
                                                
                                                	TLV value
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__init__()

                                                    self.yang_name = "unknown-tlv"
                                                    self.yang_parent_name = "opaque"

                                                    self.type = YLeaf(YType.uint16, "type")

                                                    self.length = YLeaf(YType.uint16, "length")

                                                    self.value = YLeaf(YType.str, "value")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("type",
                                                                    "length",
                                                                    "value") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.UnknownTlv, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.type.is_set or
                                                        self.length.is_set or
                                                        self.value.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.type.yfilter != YFilter.not_set or
                                                        self.length.yfilter != YFilter.not_set or
                                                        self.value.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "unknown-tlv" + "[type='" + self.type.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.type.get_name_leafdata())
                                                    if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.length.get_name_leafdata())
                                                    if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.value.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "type" or name == "length" or name == "value"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "type"):
                                                        self.type = value
                                                        self.type.value_namespace = name_space
                                                        self.type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "length"):
                                                        self.length = value
                                                        self.length.value_namespace = name_space
                                                        self.length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "value"):
                                                        self.value = value
                                                        self.value.value_namespace = name_space
                                                        self.value.value_namespace_prefix = name_space_prefix


                                            class RouterAddressTlv(Entity):
                                                """
                                                Router address TLV.
                                                
                                                .. attribute:: router_address
                                                
                                                	Router address
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__init__()

                                                    self.yang_name = "router-address-tlv"
                                                    self.yang_parent_name = "opaque"

                                                    self.router_address = YLeaf(YType.str, "router-address")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("router_address") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return self.router_address.is_set

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.router_address.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "router-address-tlv" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.router_address.is_set or self.router_address.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.router_address.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "router-address"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "router-address"):
                                                        self.router_address = value
                                                        self.router_address.value_namespace = name_space
                                                        self.router_address.value_namespace_prefix = name_space_prefix


                                            class LinkTlv(Entity):
                                                """
                                                Link TLV.
                                                
                                                .. attribute:: admin_group
                                                
                                                	Administrative group/Resource class/Color
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: link_id
                                                
                                                	Link ID
                                                	**type**\: one of the below types:
                                                
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                	**mandatory**\: True
                                                
                                                
                                                ----
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                	**mandatory**\: True
                                                
                                                
                                                ----
                                                .. attribute:: link_type
                                                
                                                	Link type
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                	**mandatory**\: True
                                                
                                                .. attribute:: local_if_ipv4_addr
                                                
                                                	List of local interface IPv4 addresses
                                                	**type**\:  list of str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: local_remote_ipv4_addr
                                                
                                                	List of remote interface IPv4 addresses
                                                	**type**\:  list of str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                                
                                                .. attribute:: max_bandwidth
                                                
                                                	Maximum bandwidth
                                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                
                                                	**range:** \-92233720368547758.08..92233720368547758.07
                                                
                                                .. attribute:: max_reservable_bandwidth
                                                
                                                	Maximum reservable bandwidth
                                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                
                                                	**range:** \-92233720368547758.08..92233720368547758.07
                                                
                                                .. attribute:: te_metric
                                                
                                                	TE metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: unknown_subtlv
                                                
                                                	Unknown sub\-TLV
                                                	**type**\: list of    :py:class:`UnknownSubtlv <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv>`
                                                
                                                .. attribute:: unreserved_bandwidth
                                                
                                                	Unreserved bandwidth
                                                	**type**\:  :py:class:`Decimal64<ydk.types.Decimal64>`
                                                
                                                	**range:** \-92233720368547758.08..92233720368547758.07
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__init__()

                                                    self.yang_name = "link-tlv"
                                                    self.yang_parent_name = "opaque"

                                                    self.admin_group = YLeaf(YType.uint32, "admin-group")

                                                    self.link_id = YLeaf(YType.str, "link-id")

                                                    self.link_type = YLeaf(YType.uint8, "link-type")

                                                    self.local_if_ipv4_addr = YLeafList(YType.str, "local-if-ipv4-addr")

                                                    self.local_remote_ipv4_addr = YLeafList(YType.str, "local-remote-ipv4-addr")

                                                    self.max_bandwidth = YLeaf(YType.str, "max-bandwidth")

                                                    self.max_reservable_bandwidth = YLeaf(YType.str, "max-reservable-bandwidth")

                                                    self.te_metric = YLeaf(YType.uint32, "te-metric")

                                                    self.unreserved_bandwidth = YLeaf(YType.str, "unreserved-bandwidth")

                                                    self.unknown_subtlv = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("admin_group",
                                                                    "link_id",
                                                                    "link_type",
                                                                    "local_if_ipv4_addr",
                                                                    "local_remote_ipv4_addr",
                                                                    "max_bandwidth",
                                                                    "max_reservable_bandwidth",
                                                                    "te_metric",
                                                                    "unreserved_bandwidth") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv, self).__setattr__(name, value)


                                                class UnknownSubtlv(Entity):
                                                    """
                                                    Unknown sub\-TLV.
                                                    
                                                    .. attribute:: type  <key>
                                                    
                                                    	TLV type
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: length
                                                    
                                                    	TLV length
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: value
                                                    
                                                    	TLV value
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                    
                                                    

                                                    """

                                                    _prefix = 'ospf'
                                                    _revision = '2015-03-09'

                                                    def __init__(self):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__init__()

                                                        self.yang_name = "unknown-subtlv"
                                                        self.yang_parent_name = "link-tlv"

                                                        self.type = YLeaf(YType.uint16, "type")

                                                        self.length = YLeaf(YType.uint16, "length")

                                                        self.value = YLeaf(YType.str, "value")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("type",
                                                                        "length",
                                                                        "value") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return (
                                                            self.type.is_set or
                                                            self.length.is_set or
                                                            self.value.is_set)

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.type.yfilter != YFilter.not_set or
                                                            self.length.yfilter != YFilter.not_set or
                                                            self.value.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "unknown-subtlv" + "[type='" + self.type.get() + "']" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.type.get_name_leafdata())
                                                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.length.get_name_leafdata())
                                                        if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.value.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "type" or name == "length" or name == "value"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "type"):
                                                            self.type = value
                                                            self.type.value_namespace = name_space
                                                            self.type.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "length"):
                                                            self.length = value
                                                            self.length.value_namespace = name_space
                                                            self.length.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "value"):
                                                            self.value = value
                                                            self.value.value_namespace = name_space
                                                            self.value.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.unknown_subtlv:
                                                        if (c.has_data()):
                                                            return True
                                                    for leaf in self.local_if_ipv4_addr.getYLeafs():
                                                        if (leaf.yfilter != YFilter.not_set):
                                                            return True
                                                    for leaf in self.local_remote_ipv4_addr.getYLeafs():
                                                        if (leaf.yfilter != YFilter.not_set):
                                                            return True
                                                    return (
                                                        self.admin_group.is_set or
                                                        self.link_id.is_set or
                                                        self.link_type.is_set or
                                                        self.max_bandwidth.is_set or
                                                        self.max_reservable_bandwidth.is_set or
                                                        self.te_metric.is_set or
                                                        self.unreserved_bandwidth.is_set)

                                                def has_operation(self):
                                                    for c in self.unknown_subtlv:
                                                        if (c.has_operation()):
                                                            return True
                                                    for leaf in self.local_if_ipv4_addr.getYLeafs():
                                                        if (leaf.is_set):
                                                            return True
                                                    for leaf in self.local_remote_ipv4_addr.getYLeafs():
                                                        if (leaf.is_set):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.admin_group.yfilter != YFilter.not_set or
                                                        self.link_id.yfilter != YFilter.not_set or
                                                        self.link_type.yfilter != YFilter.not_set or
                                                        self.local_if_ipv4_addr.yfilter != YFilter.not_set or
                                                        self.local_remote_ipv4_addr.yfilter != YFilter.not_set or
                                                        self.max_bandwidth.yfilter != YFilter.not_set or
                                                        self.max_reservable_bandwidth.yfilter != YFilter.not_set or
                                                        self.te_metric.yfilter != YFilter.not_set or
                                                        self.unreserved_bandwidth.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "link-tlv" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.admin_group.is_set or self.admin_group.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.admin_group.get_name_leafdata())
                                                    if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.link_id.get_name_leafdata())
                                                    if (self.link_type.is_set or self.link_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.link_type.get_name_leafdata())
                                                    if (self.max_bandwidth.is_set or self.max_bandwidth.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.max_bandwidth.get_name_leafdata())
                                                    if (self.max_reservable_bandwidth.is_set or self.max_reservable_bandwidth.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.max_reservable_bandwidth.get_name_leafdata())
                                                    if (self.te_metric.is_set or self.te_metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.te_metric.get_name_leafdata())
                                                    if (self.unreserved_bandwidth.is_set or self.unreserved_bandwidth.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.unreserved_bandwidth.get_name_leafdata())

                                                    leaf_name_data.extend(self.local_if_ipv4_addr.get_name_leafdata())

                                                    leaf_name_data.extend(self.local_remote_ipv4_addr.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "unknown-subtlv"):
                                                        for c in self.unknown_subtlv:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv.UnknownSubtlv()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.unknown_subtlv.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "unknown-subtlv" or name == "admin-group" or name == "link-id" or name == "link-type" or name == "local-if-ipv4-addr" or name == "local-remote-ipv4-addr" or name == "max-bandwidth" or name == "max-reservable-bandwidth" or name == "te-metric" or name == "unreserved-bandwidth"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "admin-group"):
                                                        self.admin_group = value
                                                        self.admin_group.value_namespace = name_space
                                                        self.admin_group.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "link-id"):
                                                        self.link_id = value
                                                        self.link_id.value_namespace = name_space
                                                        self.link_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "link-type"):
                                                        self.link_type = value
                                                        self.link_type.value_namespace = name_space
                                                        self.link_type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "local-if-ipv4-addr"):
                                                        self.local_if_ipv4_addr.append(value)
                                                    if(value_path == "local-remote-ipv4-addr"):
                                                        self.local_remote_ipv4_addr.append(value)
                                                    if(value_path == "max-bandwidth"):
                                                        self.max_bandwidth = value
                                                        self.max_bandwidth.value_namespace = name_space
                                                        self.max_bandwidth.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "max-reservable-bandwidth"):
                                                        self.max_reservable_bandwidth = value
                                                        self.max_reservable_bandwidth.value_namespace = name_space
                                                        self.max_reservable_bandwidth.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "te-metric"):
                                                        self.te_metric = value
                                                        self.te_metric.value_namespace = name_space
                                                        self.te_metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "unreserved-bandwidth"):
                                                        self.unreserved_bandwidth = value
                                                        self.unreserved_bandwidth.value_namespace = name_space
                                                        self.unreserved_bandwidth.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.unknown_tlv:
                                                    if (c.has_data()):
                                                        return True
                                                return (
                                                    (self.link_tlv is not None and self.link_tlv.has_data()) or
                                                    (self.router_address_tlv is not None and self.router_address_tlv.has_data()))

                                            def has_operation(self):
                                                for c in self.unknown_tlv:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    (self.link_tlv is not None and self.link_tlv.has_operation()) or
                                                    (self.router_address_tlv is not None and self.router_address_tlv.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "opaque" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "link-tlv"):
                                                    if (self.link_tlv is None):
                                                        self.link_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.LinkTlv()
                                                        self.link_tlv.parent = self
                                                        self._children_name_map["link_tlv"] = "link-tlv"
                                                    return self.link_tlv

                                                if (child_yang_name == "router-address-tlv"):
                                                    if (self.router_address_tlv is None):
                                                        self.router_address_tlv = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.RouterAddressTlv()
                                                        self.router_address_tlv.parent = self
                                                        self._children_name_map["router_address_tlv"] = "router-address-tlv"
                                                    return self.router_address_tlv

                                                if (child_yang_name == "unknown-tlv"):
                                                    for c in self.unknown_tlv:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque.UnknownTlv()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.unknown_tlv.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "link-tlv" or name == "router-address-tlv" or name == "unknown-tlv"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                pass

                                        def has_data(self):
                                            return (
                                                (self.external is not None and self.external.has_data()) or
                                                (self.network is not None and self.network.has_data()) or
                                                (self.opaque is not None and self.opaque.has_data()) or
                                                (self.router is not None and self.router.has_data()) or
                                                (self.summary is not None and self.summary.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.external is not None and self.external.has_operation()) or
                                                (self.network is not None and self.network.has_operation()) or
                                                (self.opaque is not None and self.opaque.has_operation()) or
                                                (self.router is not None and self.router.has_operation()) or
                                                (self.summary is not None and self.summary.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "body" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "external"):
                                                if (self.external is None):
                                                    self.external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.External()
                                                    self.external.parent = self
                                                    self._children_name_map["external"] = "external"
                                                return self.external

                                            if (child_yang_name == "network"):
                                                if (self.network is None):
                                                    self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Network()
                                                    self.network.parent = self
                                                    self._children_name_map["network"] = "network"
                                                return self.network

                                            if (child_yang_name == "opaque"):
                                                if (self.opaque is None):
                                                    self.opaque = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Opaque()
                                                    self.opaque.parent = self
                                                    self._children_name_map["opaque"] = "opaque"
                                                return self.opaque

                                            if (child_yang_name == "router"):
                                                if (self.router is None):
                                                    self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Router()
                                                    self.router.parent = self
                                                    self._children_name_map["router"] = "router"
                                                return self.router

                                            if (child_yang_name == "summary"):
                                                if (self.summary is None):
                                                    self.summary = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body.Summary()
                                                    self.summary.parent = self
                                                    self._children_name_map["summary"] = "summary"
                                                return self.summary

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external" or name == "network" or name == "opaque" or name == "router" or name == "summary"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            (self.body is not None and self.body.has_data()) or
                                            (self.header is not None and self.header.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.body is not None and self.body.has_operation()) or
                                            (self.header is not None and self.header.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ospfv2" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "body"):
                                            if (self.body is None):
                                                self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Body()
                                                self.body.parent = self
                                                self._children_name_map["body"] = "body"
                                            return self.body

                                        if (child_yang_name == "header"):
                                            if (self.header is None):
                                                self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2.Header()
                                                self.header.parent = self
                                                self._children_name_map["header"] = "header"
                                            return self.header

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "body" or name == "header"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class Ospfv3(Entity):
                                    """
                                    OSPFv3 LSA
                                    
                                    .. attribute:: body
                                    
                                    	Decoded OSPF LSA body data
                                    	**type**\:   :py:class:`Body <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body>`
                                    
                                    .. attribute:: header
                                    
                                    	Decoded OSPFv3 LSA header data
                                    	**type**\:   :py:class:`Header <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3, self).__init__()

                                        self.yang_name = "ospfv3"
                                        self.yang_parent_name = "as-scope-lsa"

                                        self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body()
                                        self.body.parent = self
                                        self._children_name_map["body"] = "body"
                                        self._children_yang_names.add("body")

                                        self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header()
                                        self.header.parent = self
                                        self._children_name_map["header"] = "header"
                                        self._children_yang_names.add("header")


                                    class Header(Entity):
                                        """
                                        Decoded OSPFv3 LSA header data.
                                        
                                        .. attribute:: adv_router
                                        
                                        	LSA advertising router
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: age
                                        
                                        	LSA age
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: checksum
                                        
                                        	LSA checksum
                                        	**type**\:  str
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: length
                                        
                                        	LSA length
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: lsa_id
                                        
                                        	LSA ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: options
                                        
                                        	OSPFv3 LSA options
                                        	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header.Options>`
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: seq_num
                                        
                                        	LSA sequence number
                                        	**type**\:  str
                                        
                                        	**mandatory**\: True
                                        
                                        .. attribute:: type
                                        
                                        	LSA type
                                        	**type**\:  int
                                        
                                        	**range:** 0..65535
                                        
                                        	**mandatory**\: True
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header, self).__init__()

                                            self.yang_name = "header"
                                            self.yang_parent_name = "ospfv3"

                                            self.adv_router = YLeaf(YType.str, "adv-router")

                                            self.age = YLeaf(YType.uint16, "age")

                                            self.checksum = YLeaf(YType.str, "checksum")

                                            self.length = YLeaf(YType.uint16, "length")

                                            self.lsa_id = YLeaf(YType.uint32, "lsa-id")

                                            self.options = YLeaf(YType.bits, "options")

                                            self.seq_num = YLeaf(YType.str, "seq-num")

                                            self.type = YLeaf(YType.uint16, "type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adv_router",
                                                            "age",
                                                            "checksum",
                                                            "length",
                                                            "lsa_id",
                                                            "options",
                                                            "seq_num",
                                                            "type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.adv_router.is_set or
                                                self.age.is_set or
                                                self.checksum.is_set or
                                                self.length.is_set or
                                                self.lsa_id.is_set or
                                                self.options.is_set or
                                                self.seq_num.is_set or
                                                self.type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adv_router.yfilter != YFilter.not_set or
                                                self.age.yfilter != YFilter.not_set or
                                                self.checksum.yfilter != YFilter.not_set or
                                                self.length.yfilter != YFilter.not_set or
                                                self.lsa_id.yfilter != YFilter.not_set or
                                                self.options.yfilter != YFilter.not_set or
                                                self.seq_num.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "header" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adv_router.get_name_leafdata())
                                            if (self.age.is_set or self.age.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.age.get_name_leafdata())
                                            if (self.checksum.is_set or self.checksum.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.checksum.get_name_leafdata())
                                            if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.length.get_name_leafdata())
                                            if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                            if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.options.get_name_leafdata())
                                            if (self.seq_num.is_set or self.seq_num.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.seq_num.get_name_leafdata())
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "adv-router" or name == "age" or name == "checksum" or name == "length" or name == "lsa-id" or name == "options" or name == "seq-num" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adv-router"):
                                                self.adv_router = value
                                                self.adv_router.value_namespace = name_space
                                                self.adv_router.value_namespace_prefix = name_space_prefix
                                            if(value_path == "age"):
                                                self.age = value
                                                self.age.value_namespace = name_space
                                                self.age.value_namespace_prefix = name_space_prefix
                                            if(value_path == "checksum"):
                                                self.checksum = value
                                                self.checksum.value_namespace = name_space
                                                self.checksum.value_namespace_prefix = name_space_prefix
                                            if(value_path == "length"):
                                                self.length = value
                                                self.length.value_namespace = name_space
                                                self.length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "lsa-id"):
                                                self.lsa_id = value
                                                self.lsa_id.value_namespace = name_space
                                                self.lsa_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "options"):
                                                self.options[value] = True
                                            if(value_path == "seq-num"):
                                                self.seq_num = value
                                                self.seq_num.value_namespace = name_space
                                                self.seq_num.value_namespace_prefix = name_space_prefix
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix


                                    class Body(Entity):
                                        """
                                        Decoded OSPF LSA body data.
                                        
                                        .. attribute:: as_external
                                        
                                        	AS\-External LSA
                                        	**type**\:   :py:class:`AsExternal <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal>`
                                        
                                        .. attribute:: inter_area_prefix
                                        
                                        	Inter\-Area\-Prefix LSA
                                        	**type**\:   :py:class:`InterAreaPrefix <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaPrefix>`
                                        
                                        .. attribute:: inter_area_router
                                        
                                        	Inter\-Area\-Router LSA
                                        	**type**\:   :py:class:`InterAreaRouter <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter>`
                                        
                                        .. attribute:: intra_area_prefix
                                        
                                        	Intra\-Area\-Prefix LSA
                                        	**type**\:   :py:class:`IntraAreaPrefix <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix>`
                                        
                                        .. attribute:: link
                                        
                                        	Link LSA
                                        	**type**\:   :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link>`
                                        
                                        .. attribute:: network
                                        
                                        	Network LSA
                                        	**type**\:   :py:class:`Network <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network>`
                                        
                                        .. attribute:: nssa
                                        
                                        	NSSA LSA
                                        	**type**\:   :py:class:`Nssa <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa>`
                                        
                                        .. attribute:: router
                                        
                                        	Router LSA
                                        	**type**\:   :py:class:`Router <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body, self).__init__()

                                            self.yang_name = "body"
                                            self.yang_parent_name = "ospfv3"

                                            self.as_external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal()
                                            self.as_external.parent = self
                                            self._children_name_map["as_external"] = "as-external"
                                            self._children_yang_names.add("as-external")

                                            self.inter_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaPrefix()
                                            self.inter_area_prefix.parent = self
                                            self._children_name_map["inter_area_prefix"] = "inter-area-prefix"
                                            self._children_yang_names.add("inter-area-prefix")

                                            self.inter_area_router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter()
                                            self.inter_area_router.parent = self
                                            self._children_name_map["inter_area_router"] = "inter-area-router"
                                            self._children_yang_names.add("inter-area-router")

                                            self.intra_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix()
                                            self.intra_area_prefix.parent = self
                                            self._children_name_map["intra_area_prefix"] = "intra-area-prefix"
                                            self._children_yang_names.add("intra-area-prefix")

                                            self.link = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link()
                                            self.link.parent = self
                                            self._children_name_map["link"] = "link"
                                            self._children_yang_names.add("link")

                                            self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network()
                                            self.network.parent = self
                                            self._children_name_map["network"] = "network"
                                            self._children_yang_names.add("network")

                                            self.nssa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa()
                                            self.nssa.parent = self
                                            self._children_name_map["nssa"] = "nssa"
                                            self._children_yang_names.add("nssa")

                                            self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router()
                                            self.router.parent = self
                                            self._children_name_map["router"] = "router"
                                            self._children_yang_names.add("router")


                                        class Router(Entity):
                                            """
                                            Router LSA.
                                            
                                            .. attribute:: flags
                                            
                                            	LSA option
                                            	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Flags>`
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: link
                                            
                                            	Router LSA link
                                            	**type**\: list of    :py:class:`Link <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Link>`
                                            
                                            .. attribute:: options
                                            
                                            	OSPFv3 LSA options
                                            	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Options>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router, self).__init__()

                                                self.yang_name = "router"
                                                self.yang_parent_name = "body"

                                                self.flags = YLeaf(YType.bits, "flags")

                                                self.options = YLeaf(YType.bits, "options")

                                                self.link = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("flags",
                                                                "options") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router, self).__setattr__(name, value)


                                            class Link(Entity):
                                                """
                                                Router LSA link.
                                                
                                                .. attribute:: interface_id  <key>
                                                
                                                	Interface ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: neighbor_interface_id  <key>
                                                
                                                	Neighbor Interface ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: neighbor_router_id  <key>
                                                
                                                	Neighbor Router ID
                                                	**type**\:  str
                                                
                                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                                
                                                .. attribute:: metric
                                                
                                                	Metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                .. attribute:: type
                                                
                                                	Link type
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Link, self).__init__()

                                                    self.yang_name = "link"
                                                    self.yang_parent_name = "router"

                                                    self.interface_id = YLeaf(YType.uint32, "interface-id")

                                                    self.neighbor_interface_id = YLeaf(YType.uint32, "neighbor-interface-id")

                                                    self.neighbor_router_id = YLeaf(YType.str, "neighbor-router-id")

                                                    self.metric = YLeaf(YType.uint16, "metric")

                                                    self.type = YLeaf(YType.uint8, "type")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("interface_id",
                                                                    "neighbor_interface_id",
                                                                    "neighbor_router_id",
                                                                    "metric",
                                                                    "type") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Link, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Link, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.interface_id.is_set or
                                                        self.neighbor_interface_id.is_set or
                                                        self.neighbor_router_id.is_set or
                                                        self.metric.is_set or
                                                        self.type.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.interface_id.yfilter != YFilter.not_set or
                                                        self.neighbor_interface_id.yfilter != YFilter.not_set or
                                                        self.neighbor_router_id.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set or
                                                        self.type.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "link" + "[interface-id='" + self.interface_id.get() + "']" + "[neighbor-interface-id='" + self.neighbor_interface_id.get() + "']" + "[neighbor-router-id='" + self.neighbor_router_id.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.interface_id.is_set or self.interface_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_id.get_name_leafdata())
                                                    if (self.neighbor_interface_id.is_set or self.neighbor_interface_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.neighbor_interface_id.get_name_leafdata())
                                                    if (self.neighbor_router_id.is_set or self.neighbor_router_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.neighbor_router_id.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.type.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "interface-id" or name == "neighbor-interface-id" or name == "neighbor-router-id" or name == "metric" or name == "type"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "interface-id"):
                                                        self.interface_id = value
                                                        self.interface_id.value_namespace = name_space
                                                        self.interface_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "neighbor-interface-id"):
                                                        self.neighbor_interface_id = value
                                                        self.neighbor_interface_id.value_namespace = name_space
                                                        self.neighbor_interface_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "neighbor-router-id"):
                                                        self.neighbor_router_id = value
                                                        self.neighbor_router_id.value_namespace = name_space
                                                        self.neighbor_router_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "type"):
                                                        self.type = value
                                                        self.type.value_namespace = name_space
                                                        self.type.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.link:
                                                    if (c.has_data()):
                                                        return True
                                                return (
                                                    self.flags.is_set or
                                                    self.options.is_set)

                                            def has_operation(self):
                                                for c in self.link:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.flags.yfilter != YFilter.not_set or
                                                    self.options.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "router" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.flags.get_name_leafdata())
                                                if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.options.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "link"):
                                                    for c in self.link:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router.Link()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.link.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "link" or name == "flags" or name == "options"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "flags"):
                                                    self.flags[value] = True
                                                if(value_path == "options"):
                                                    self.options[value] = True


                                        class Network(Entity):
                                            """
                                            Network LSA.
                                            
                                            .. attribute:: attached_router
                                            
                                            	List of the routers attached to the network
                                            	**type**\:  list of str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                            
                                            .. attribute:: options
                                            
                                            	OSPFv3 LSA options
                                            	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network.Options>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network, self).__init__()

                                                self.yang_name = "network"
                                                self.yang_parent_name = "body"

                                                self.attached_router = YLeafList(YType.str, "attached-router")

                                                self.options = YLeaf(YType.bits, "options")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("attached_router",
                                                                "options") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network, self).__setattr__(name, value)

                                            def has_data(self):
                                                for leaf in self.attached_router.getYLeafs():
                                                    if (leaf.yfilter != YFilter.not_set):
                                                        return True
                                                return self.options.is_set

                                            def has_operation(self):
                                                for leaf in self.attached_router.getYLeafs():
                                                    if (leaf.is_set):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.attached_router.yfilter != YFilter.not_set or
                                                    self.options.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "network" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.options.get_name_leafdata())

                                                leaf_name_data.extend(self.attached_router.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "attached-router" or name == "options"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "attached-router"):
                                                    self.attached_router.append(value)
                                                if(value_path == "options"):
                                                    self.options[value] = True


                                        class InterAreaPrefix(Entity):
                                            """
                                            Inter\-Area\-Prefix LSA.
                                            
                                            .. attribute:: metric
                                            
                                            	Metric
                                            	**type**\:  int
                                            
                                            	**range:** 0..16777215
                                            
                                            .. attribute:: prefix
                                            
                                            	Prefix
                                            	**type**\:  str
                                            
                                            .. attribute:: prefix_options
                                            
                                            	Prefix options
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__init__()

                                                self.yang_name = "inter-area-prefix"
                                                self.yang_parent_name = "body"

                                                self.metric = YLeaf(YType.uint32, "metric")

                                                self.prefix = YLeaf(YType.str, "prefix")

                                                self.prefix_options = YLeaf(YType.str, "prefix-options")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("metric",
                                                                "prefix",
                                                                "prefix_options") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaPrefix, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.metric.is_set or
                                                    self.prefix.is_set or
                                                    self.prefix_options.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.metric.yfilter != YFilter.not_set or
                                                    self.prefix.yfilter != YFilter.not_set or
                                                    self.prefix_options.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "inter-area-prefix" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                                if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix.get_name_leafdata())
                                                if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "metric" or name == "prefix" or name == "prefix-options"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "metric"):
                                                    self.metric = value
                                                    self.metric.value_namespace = name_space
                                                    self.metric.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix"):
                                                    self.prefix = value
                                                    self.prefix.value_namespace = name_space
                                                    self.prefix.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix-options"):
                                                    self.prefix_options = value
                                                    self.prefix_options.value_namespace = name_space
                                                    self.prefix_options.value_namespace_prefix = name_space_prefix


                                        class InterAreaRouter(Entity):
                                            """
                                            Inter\-Area\-Router LSA.
                                            
                                            .. attribute:: destination_router_id
                                            
                                            	The Router ID of the router being described by the LSA
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                            
                                            .. attribute:: metric
                                            
                                            	Metric
                                            	**type**\:  int
                                            
                                            	**range:** 0..16777215
                                            
                                            .. attribute:: options
                                            
                                            	OSPFv3 LSA options
                                            	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter.Options>`
                                            
                                            	**mandatory**\: True
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter, self).__init__()

                                                self.yang_name = "inter-area-router"
                                                self.yang_parent_name = "body"

                                                self.destination_router_id = YLeaf(YType.str, "destination-router-id")

                                                self.metric = YLeaf(YType.uint32, "metric")

                                                self.options = YLeaf(YType.bits, "options")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("destination_router_id",
                                                                "metric",
                                                                "options") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.destination_router_id.is_set or
                                                    self.metric.is_set or
                                                    self.options.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.destination_router_id.yfilter != YFilter.not_set or
                                                    self.metric.yfilter != YFilter.not_set or
                                                    self.options.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "inter-area-router" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.destination_router_id.is_set or self.destination_router_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.destination_router_id.get_name_leafdata())
                                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                                if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.options.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "destination-router-id" or name == "metric" or name == "options"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "destination-router-id"):
                                                    self.destination_router_id = value
                                                    self.destination_router_id.value_namespace = name_space
                                                    self.destination_router_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "metric"):
                                                    self.metric = value
                                                    self.metric.value_namespace = name_space
                                                    self.metric.value_namespace_prefix = name_space_prefix
                                                if(value_path == "options"):
                                                    self.options[value] = True


                                        class AsExternal(Entity):
                                            """
                                            AS\-External LSA.
                                            
                                            .. attribute:: external_route_tag
                                            
                                            	Route tag
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: flags
                                            
                                            	Flags
                                            	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal.Flags>`
                                            
                                            .. attribute:: forwarding_address
                                            
                                            	Forwarding address
                                            	**type**\:  str
                                            
                                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: metric
                                            
                                            	Metric
                                            	**type**\:  int
                                            
                                            	**range:** 0..16777215
                                            
                                            .. attribute:: prefix
                                            
                                            	Prefix
                                            	**type**\:  str
                                            
                                            .. attribute:: prefix_options
                                            
                                            	Prefix options
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: referenced_link_state_id
                                            
                                            	Referenced Link State ID
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: referenced_ls_type
                                            
                                            	Referenced Link State type
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal, self).__init__()

                                                self.yang_name = "as-external"
                                                self.yang_parent_name = "body"

                                                self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                self.flags = YLeaf(YType.bits, "flags")

                                                self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                self.metric = YLeaf(YType.uint32, "metric")

                                                self.prefix = YLeaf(YType.str, "prefix")

                                                self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("external_route_tag",
                                                                "flags",
                                                                "forwarding_address",
                                                                "metric",
                                                                "prefix",
                                                                "prefix_options",
                                                                "referenced_link_state_id",
                                                                "referenced_ls_type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.external_route_tag.is_set or
                                                    self.flags.is_set or
                                                    self.forwarding_address.is_set or
                                                    self.metric.is_set or
                                                    self.prefix.is_set or
                                                    self.prefix_options.is_set or
                                                    self.referenced_link_state_id.is_set or
                                                    self.referenced_ls_type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.external_route_tag.yfilter != YFilter.not_set or
                                                    self.flags.yfilter != YFilter.not_set or
                                                    self.forwarding_address.yfilter != YFilter.not_set or
                                                    self.metric.yfilter != YFilter.not_set or
                                                    self.prefix.yfilter != YFilter.not_set or
                                                    self.prefix_options.yfilter != YFilter.not_set or
                                                    self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                    self.referenced_ls_type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "as-external" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.flags.get_name_leafdata())
                                                if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                                if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix.get_name_leafdata())
                                                if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_options.get_name_leafdata())
                                                if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric" or name == "prefix" or name == "prefix-options" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "external-route-tag"):
                                                    self.external_route_tag = value
                                                    self.external_route_tag.value_namespace = name_space
                                                    self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "flags"):
                                                    self.flags[value] = True
                                                if(value_path == "forwarding-address"):
                                                    self.forwarding_address = value
                                                    self.forwarding_address.value_namespace = name_space
                                                    self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "metric"):
                                                    self.metric = value
                                                    self.metric.value_namespace = name_space
                                                    self.metric.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix"):
                                                    self.prefix = value
                                                    self.prefix.value_namespace = name_space
                                                    self.prefix.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix-options"):
                                                    self.prefix_options = value
                                                    self.prefix_options.value_namespace = name_space
                                                    self.prefix_options.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-link-state-id"):
                                                    self.referenced_link_state_id = value
                                                    self.referenced_link_state_id.value_namespace = name_space
                                                    self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-ls-type"):
                                                    self.referenced_ls_type = value
                                                    self.referenced_ls_type.value_namespace = name_space
                                                    self.referenced_ls_type.value_namespace_prefix = name_space_prefix


                                        class Nssa(Entity):
                                            """
                                            NSSA LSA.
                                            
                                            .. attribute:: external_route_tag
                                            
                                            	Route tag
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: flags
                                            
                                            	Flags
                                            	**type**\:   :py:class:`Flags <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa.Flags>`
                                            
                                            .. attribute:: forwarding_address
                                            
                                            	Forwarding address
                                            	**type**\:  str
                                            
                                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: metric
                                            
                                            	Metric
                                            	**type**\:  int
                                            
                                            	**range:** 0..16777215
                                            
                                            .. attribute:: prefix
                                            
                                            	Prefix
                                            	**type**\:  str
                                            
                                            .. attribute:: prefix_options
                                            
                                            	Prefix options
                                            	**type**\:  str
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: referenced_link_state_id
                                            
                                            	Referenced Link State ID
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: referenced_ls_type
                                            
                                            	Referenced Link State type
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa, self).__init__()

                                                self.yang_name = "nssa"
                                                self.yang_parent_name = "body"

                                                self.external_route_tag = YLeaf(YType.uint32, "external-route-tag")

                                                self.flags = YLeaf(YType.bits, "flags")

                                                self.forwarding_address = YLeaf(YType.str, "forwarding-address")

                                                self.metric = YLeaf(YType.uint32, "metric")

                                                self.prefix = YLeaf(YType.str, "prefix")

                                                self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("external_route_tag",
                                                                "flags",
                                                                "forwarding_address",
                                                                "metric",
                                                                "prefix",
                                                                "prefix_options",
                                                                "referenced_link_state_id",
                                                                "referenced_ls_type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.external_route_tag.is_set or
                                                    self.flags.is_set or
                                                    self.forwarding_address.is_set or
                                                    self.metric.is_set or
                                                    self.prefix.is_set or
                                                    self.prefix_options.is_set or
                                                    self.referenced_link_state_id.is_set or
                                                    self.referenced_ls_type.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.external_route_tag.yfilter != YFilter.not_set or
                                                    self.flags.yfilter != YFilter.not_set or
                                                    self.forwarding_address.yfilter != YFilter.not_set or
                                                    self.metric.yfilter != YFilter.not_set or
                                                    self.prefix.yfilter != YFilter.not_set or
                                                    self.prefix_options.yfilter != YFilter.not_set or
                                                    self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                    self.referenced_ls_type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "nssa" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.external_route_tag.is_set or self.external_route_tag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.external_route_tag.get_name_leafdata())
                                                if (self.flags.is_set or self.flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.flags.get_name_leafdata())
                                                if (self.forwarding_address.is_set or self.forwarding_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.forwarding_address.get_name_leafdata())
                                                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.metric.get_name_leafdata())
                                                if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix.get_name_leafdata())
                                                if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_options.get_name_leafdata())
                                                if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "external-route-tag" or name == "flags" or name == "forwarding-address" or name == "metric" or name == "prefix" or name == "prefix-options" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "external-route-tag"):
                                                    self.external_route_tag = value
                                                    self.external_route_tag.value_namespace = name_space
                                                    self.external_route_tag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "flags"):
                                                    self.flags[value] = True
                                                if(value_path == "forwarding-address"):
                                                    self.forwarding_address = value
                                                    self.forwarding_address.value_namespace = name_space
                                                    self.forwarding_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "metric"):
                                                    self.metric = value
                                                    self.metric.value_namespace = name_space
                                                    self.metric.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix"):
                                                    self.prefix = value
                                                    self.prefix.value_namespace = name_space
                                                    self.prefix.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix-options"):
                                                    self.prefix_options = value
                                                    self.prefix_options.value_namespace = name_space
                                                    self.prefix_options.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-link-state-id"):
                                                    self.referenced_link_state_id = value
                                                    self.referenced_link_state_id.value_namespace = name_space
                                                    self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-ls-type"):
                                                    self.referenced_ls_type = value
                                                    self.referenced_ls_type.value_namespace = name_space
                                                    self.referenced_ls_type.value_namespace_prefix = name_space_prefix


                                        class Link(Entity):
                                            """
                                            Link LSA.
                                            
                                            .. attribute:: link_local_interface_address
                                            
                                            	The originating router's link\-local interface address on the link
                                            	**type**\: one of the below types:
                                            
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            
                                            ----
                                            	**type**\:  str
                                            
                                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                            
                                            
                                            ----
                                            .. attribute:: num_of_prefixes
                                            
                                            	Number of prefixes
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: options
                                            
                                            	OSPFv3 LSA options
                                            	**type**\:   :py:class:`Options <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link.Options>`
                                            
                                            	**mandatory**\: True
                                            
                                            .. attribute:: prefix_list
                                            
                                            	List of prefixes associated with the link
                                            	**type**\: list of    :py:class:`PrefixList <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link.PrefixList>`
                                            
                                            .. attribute:: rtr_priority
                                            
                                            	Router Priority of the interface
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link, self).__init__()

                                                self.yang_name = "link"
                                                self.yang_parent_name = "body"

                                                self.link_local_interface_address = YLeaf(YType.str, "link-local-interface-address")

                                                self.num_of_prefixes = YLeaf(YType.uint32, "num-of-prefixes")

                                                self.options = YLeaf(YType.bits, "options")

                                                self.rtr_priority = YLeaf(YType.uint8, "rtr-priority")

                                                self.prefix_list = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("link_local_interface_address",
                                                                "num_of_prefixes",
                                                                "options",
                                                                "rtr_priority") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link, self).__setattr__(name, value)


                                            class PrefixList(Entity):
                                                """
                                                List of prefixes associated with the link.
                                                
                                                .. attribute:: prefix  <key>
                                                
                                                	Prefix
                                                	**type**\:  str
                                                
                                                .. attribute:: prefix_options
                                                
                                                	Prefix options
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link.PrefixList, self).__init__()

                                                    self.yang_name = "prefix-list"
                                                    self.yang_parent_name = "link"

                                                    self.prefix = YLeaf(YType.str, "prefix")

                                                    self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("prefix",
                                                                    "prefix_options") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link.PrefixList, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link.PrefixList, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.prefix.is_set or
                                                        self.prefix_options.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.prefix.yfilter != YFilter.not_set or
                                                        self.prefix_options.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "prefix-list" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                                    if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "prefix" or name == "prefix-options"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "prefix"):
                                                        self.prefix = value
                                                        self.prefix.value_namespace = name_space
                                                        self.prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix-options"):
                                                        self.prefix_options = value
                                                        self.prefix_options.value_namespace = name_space
                                                        self.prefix_options.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.prefix_list:
                                                    if (c.has_data()):
                                                        return True
                                                return (
                                                    self.link_local_interface_address.is_set or
                                                    self.num_of_prefixes.is_set or
                                                    self.options.is_set or
                                                    self.rtr_priority.is_set)

                                            def has_operation(self):
                                                for c in self.prefix_list:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.link_local_interface_address.yfilter != YFilter.not_set or
                                                    self.num_of_prefixes.yfilter != YFilter.not_set or
                                                    self.options.yfilter != YFilter.not_set or
                                                    self.rtr_priority.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "link" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.link_local_interface_address.is_set or self.link_local_interface_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.link_local_interface_address.get_name_leafdata())
                                                if (self.num_of_prefixes.is_set or self.num_of_prefixes.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.num_of_prefixes.get_name_leafdata())
                                                if (self.options.is_set or self.options.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.options.get_name_leafdata())
                                                if (self.rtr_priority.is_set or self.rtr_priority.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.rtr_priority.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "prefix-list"):
                                                    for c in self.prefix_list:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link.PrefixList()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.prefix_list.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "prefix-list" or name == "link-local-interface-address" or name == "num-of-prefixes" or name == "options" or name == "rtr-priority"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "link-local-interface-address"):
                                                    self.link_local_interface_address = value
                                                    self.link_local_interface_address.value_namespace = name_space
                                                    self.link_local_interface_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "num-of-prefixes"):
                                                    self.num_of_prefixes = value
                                                    self.num_of_prefixes.value_namespace = name_space
                                                    self.num_of_prefixes.value_namespace_prefix = name_space_prefix
                                                if(value_path == "options"):
                                                    self.options[value] = True
                                                if(value_path == "rtr-priority"):
                                                    self.rtr_priority = value
                                                    self.rtr_priority.value_namespace = name_space
                                                    self.rtr_priority.value_namespace_prefix = name_space_prefix


                                        class IntraAreaPrefix(Entity):
                                            """
                                            Intra\-Area\-Prefix LSA.
                                            
                                            .. attribute:: num_of_prefixes
                                            
                                            	Number of prefixes
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            .. attribute:: prefix_list
                                            
                                            	List of prefixes associated with the link
                                            	**type**\: list of    :py:class:`PrefixList <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList>`
                                            
                                            .. attribute:: referenced_adv_router
                                            
                                            	Referenced Advertising Router
                                            	**type**\:  str
                                            
                                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                            
                                            .. attribute:: referenced_link_state_id
                                            
                                            	Referenced Link State ID
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: referenced_ls_type
                                            
                                            	Referenced Link State type
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__init__()

                                                self.yang_name = "intra-area-prefix"
                                                self.yang_parent_name = "body"

                                                self.num_of_prefixes = YLeaf(YType.uint16, "num-of-prefixes")

                                                self.referenced_adv_router = YLeaf(YType.str, "referenced-adv-router")

                                                self.referenced_link_state_id = YLeaf(YType.uint32, "referenced-link-state-id")

                                                self.referenced_ls_type = YLeaf(YType.uint16, "referenced-ls-type")

                                                self.prefix_list = YList(self)

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("num_of_prefixes",
                                                                "referenced_adv_router",
                                                                "referenced_link_state_id",
                                                                "referenced_ls_type") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix, self).__setattr__(name, value)


                                            class PrefixList(Entity):
                                                """
                                                List of prefixes associated with the link.
                                                
                                                .. attribute:: prefix  <key>
                                                
                                                	Prefix
                                                	**type**\:  str
                                                
                                                .. attribute:: metric
                                                
                                                	Metric
                                                	**type**\:  int
                                                
                                                	**range:** 0..16777215
                                                
                                                .. attribute:: prefix_options
                                                
                                                	Prefix options
                                                	**type**\:  str
                                                
                                                	**mandatory**\: True
                                                
                                                

                                                """

                                                _prefix = 'ospf'
                                                _revision = '2015-03-09'

                                                def __init__(self):
                                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__init__()

                                                    self.yang_name = "prefix-list"
                                                    self.yang_parent_name = "intra-area-prefix"

                                                    self.prefix = YLeaf(YType.str, "prefix")

                                                    self.metric = YLeaf(YType.uint32, "metric")

                                                    self.prefix_options = YLeaf(YType.str, "prefix-options")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("prefix",
                                                                    "metric",
                                                                    "prefix_options") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.prefix.is_set or
                                                        self.metric.is_set or
                                                        self.prefix_options.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.prefix.yfilter != YFilter.not_set or
                                                        self.metric.yfilter != YFilter.not_set or
                                                        self.prefix_options.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "prefix-list" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                                    if (self.prefix_options.is_set or self.prefix_options.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.prefix_options.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "prefix" or name == "metric" or name == "prefix-options"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "prefix"):
                                                        self.prefix = value
                                                        self.prefix.value_namespace = name_space
                                                        self.prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "metric"):
                                                        self.metric = value
                                                        self.metric.value_namespace = name_space
                                                        self.metric.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "prefix-options"):
                                                        self.prefix_options = value
                                                        self.prefix_options.value_namespace = name_space
                                                        self.prefix_options.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                for c in self.prefix_list:
                                                    if (c.has_data()):
                                                        return True
                                                return (
                                                    self.num_of_prefixes.is_set or
                                                    self.referenced_adv_router.is_set or
                                                    self.referenced_link_state_id.is_set or
                                                    self.referenced_ls_type.is_set)

                                            def has_operation(self):
                                                for c in self.prefix_list:
                                                    if (c.has_operation()):
                                                        return True
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.num_of_prefixes.yfilter != YFilter.not_set or
                                                    self.referenced_adv_router.yfilter != YFilter.not_set or
                                                    self.referenced_link_state_id.yfilter != YFilter.not_set or
                                                    self.referenced_ls_type.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "intra-area-prefix" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.num_of_prefixes.is_set or self.num_of_prefixes.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.num_of_prefixes.get_name_leafdata())
                                                if (self.referenced_adv_router.is_set or self.referenced_adv_router.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_adv_router.get_name_leafdata())
                                                if (self.referenced_link_state_id.is_set or self.referenced_link_state_id.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_link_state_id.get_name_leafdata())
                                                if (self.referenced_ls_type.is_set or self.referenced_ls_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referenced_ls_type.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "prefix-list"):
                                                    for c in self.prefix_list:
                                                        segment = c.get_segment_path()
                                                        if (segment_path == segment):
                                                            return c
                                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix.PrefixList()
                                                    c.parent = self
                                                    local_reference_key = "ydk::seg::%s" % segment_path
                                                    self._local_refs[local_reference_key] = c
                                                    self.prefix_list.append(c)
                                                    return c

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "prefix-list" or name == "num-of-prefixes" or name == "referenced-adv-router" or name == "referenced-link-state-id" or name == "referenced-ls-type"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "num-of-prefixes"):
                                                    self.num_of_prefixes = value
                                                    self.num_of_prefixes.value_namespace = name_space
                                                    self.num_of_prefixes.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-adv-router"):
                                                    self.referenced_adv_router = value
                                                    self.referenced_adv_router.value_namespace = name_space
                                                    self.referenced_adv_router.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-link-state-id"):
                                                    self.referenced_link_state_id = value
                                                    self.referenced_link_state_id.value_namespace = name_space
                                                    self.referenced_link_state_id.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referenced-ls-type"):
                                                    self.referenced_ls_type = value
                                                    self.referenced_ls_type.value_namespace = name_space
                                                    self.referenced_ls_type.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                (self.as_external is not None and self.as_external.has_data()) or
                                                (self.inter_area_prefix is not None and self.inter_area_prefix.has_data()) or
                                                (self.inter_area_router is not None and self.inter_area_router.has_data()) or
                                                (self.intra_area_prefix is not None and self.intra_area_prefix.has_data()) or
                                                (self.link is not None and self.link.has_data()) or
                                                (self.network is not None and self.network.has_data()) or
                                                (self.nssa is not None and self.nssa.has_data()) or
                                                (self.router is not None and self.router.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                (self.as_external is not None and self.as_external.has_operation()) or
                                                (self.inter_area_prefix is not None and self.inter_area_prefix.has_operation()) or
                                                (self.inter_area_router is not None and self.inter_area_router.has_operation()) or
                                                (self.intra_area_prefix is not None and self.intra_area_prefix.has_operation()) or
                                                (self.link is not None and self.link.has_operation()) or
                                                (self.network is not None and self.network.has_operation()) or
                                                (self.nssa is not None and self.nssa.has_operation()) or
                                                (self.router is not None and self.router.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "body" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "as-external"):
                                                if (self.as_external is None):
                                                    self.as_external = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.AsExternal()
                                                    self.as_external.parent = self
                                                    self._children_name_map["as_external"] = "as-external"
                                                return self.as_external

                                            if (child_yang_name == "inter-area-prefix"):
                                                if (self.inter_area_prefix is None):
                                                    self.inter_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaPrefix()
                                                    self.inter_area_prefix.parent = self
                                                    self._children_name_map["inter_area_prefix"] = "inter-area-prefix"
                                                return self.inter_area_prefix

                                            if (child_yang_name == "inter-area-router"):
                                                if (self.inter_area_router is None):
                                                    self.inter_area_router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.InterAreaRouter()
                                                    self.inter_area_router.parent = self
                                                    self._children_name_map["inter_area_router"] = "inter-area-router"
                                                return self.inter_area_router

                                            if (child_yang_name == "intra-area-prefix"):
                                                if (self.intra_area_prefix is None):
                                                    self.intra_area_prefix = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.IntraAreaPrefix()
                                                    self.intra_area_prefix.parent = self
                                                    self._children_name_map["intra_area_prefix"] = "intra-area-prefix"
                                                return self.intra_area_prefix

                                            if (child_yang_name == "link"):
                                                if (self.link is None):
                                                    self.link = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Link()
                                                    self.link.parent = self
                                                    self._children_name_map["link"] = "link"
                                                return self.link

                                            if (child_yang_name == "network"):
                                                if (self.network is None):
                                                    self.network = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Network()
                                                    self.network.parent = self
                                                    self._children_name_map["network"] = "network"
                                                return self.network

                                            if (child_yang_name == "nssa"):
                                                if (self.nssa is None):
                                                    self.nssa = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Nssa()
                                                    self.nssa.parent = self
                                                    self._children_name_map["nssa"] = "nssa"
                                                return self.nssa

                                            if (child_yang_name == "router"):
                                                if (self.router is None):
                                                    self.router = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body.Router()
                                                    self.router.parent = self
                                                    self._children_name_map["router"] = "router"
                                                return self.router

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "as-external" or name == "inter-area-prefix" or name == "inter-area-router" or name == "intra-area-prefix" or name == "link" or name == "network" or name == "nssa" or name == "router"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            (self.body is not None and self.body.has_data()) or
                                            (self.header is not None and self.header.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.body is not None and self.body.has_operation()) or
                                            (self.header is not None and self.header.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ospfv3" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "body"):
                                            if (self.body is None):
                                                self.body = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Body()
                                                self.body.parent = self
                                                self._children_name_map["body"] = "body"
                                            return self.body

                                        if (child_yang_name == "header"):
                                            if (self.header is None):
                                                self.header = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3.Header()
                                                self.header.parent = self
                                                self._children_name_map["header"] = "header"
                                            return self.header

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "body" or name == "header"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.lsa_id.is_set or
                                        self.adv_router.is_set or
                                        self.decoded_completed.is_set or
                                        self.raw_data.is_set or
                                        (self.ospfv2 is not None and self.ospfv2.has_data()) or
                                        (self.ospfv3 is not None and self.ospfv3.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.lsa_id.yfilter != YFilter.not_set or
                                        self.adv_router.yfilter != YFilter.not_set or
                                        self.decoded_completed.yfilter != YFilter.not_set or
                                        self.raw_data.yfilter != YFilter.not_set or
                                        (self.ospfv2 is not None and self.ospfv2.has_operation()) or
                                        (self.ospfv3 is not None and self.ospfv3.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "as-scope-lsa" + "[lsa-id='" + self.lsa_id.get() + "']" + "[adv-router='" + self.adv_router.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                    if (self.adv_router.is_set or self.adv_router.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.adv_router.get_name_leafdata())
                                    if (self.decoded_completed.is_set or self.decoded_completed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.decoded_completed.get_name_leafdata())
                                    if (self.raw_data.is_set or self.raw_data.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.raw_data.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ospfv2"):
                                        if (self.ospfv2 is None):
                                            self.ospfv2 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv2()
                                            self.ospfv2.parent = self
                                            self._children_name_map["ospfv2"] = "ospfv2"
                                        return self.ospfv2

                                    if (child_yang_name == "ospfv3"):
                                        if (self.ospfv3 is None):
                                            self.ospfv3 = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa.Ospfv3()
                                            self.ospfv3.parent = self
                                            self._children_name_map["ospfv3"] = "ospfv3"
                                        return self.ospfv3

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ospfv2" or name == "ospfv3" or name == "lsa-id" or name == "adv-router" or name == "decoded-completed" or name == "raw-data"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "lsa-id"):
                                        self.lsa_id = value
                                        self.lsa_id.value_namespace = name_space
                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "adv-router"):
                                        self.adv_router = value
                                        self.adv_router.value_namespace = name_space
                                        self.adv_router.value_namespace_prefix = name_space_prefix
                                    if(value_path == "decoded-completed"):
                                        self.decoded_completed = value
                                        self.decoded_completed.value_namespace = name_space
                                        self.decoded_completed.value_namespace_prefix = name_space_prefix
                                    if(value_path == "raw-data"):
                                        self.raw_data = value
                                        self.raw_data.value_namespace = name_space
                                        self.raw_data.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.as_scope_lsa:
                                    if (c.has_data()):
                                        return True
                                return self.lsa_type.is_set

                            def has_operation(self):
                                for c in self.as_scope_lsa:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "as-scope-lsas" + "[lsa-type='" + self.lsa_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "as-scope-lsa"):
                                    for c in self.as_scope_lsa:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas.AsScopeLsa()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.as_scope_lsa.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "as-scope-lsa" or name == "lsa-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix


                        class Topology(Entity):
                            """
                            OSPF topology.
                            
                            .. attribute:: name  <key>
                            
                            	RIB
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Ribs.Rib>`
                            
                            .. attribute:: area
                            
                            	List of ospf areas
                            	**type**\: list of    :py:class:`Area <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology, self).__init__()

                                self.yang_name = "topology"
                                self.yang_parent_name = "instance"

                                self.name = YLeaf(YType.str, "name")

                                self.area = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology, self).__setattr__(name, value)


                            class Area(Entity):
                                """
                                List of ospf areas
                                
                                .. attribute:: area_id  <key>
                                
                                	Area ID
                                	**type**\: one of the below types:
                                
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                
                                
                                ----
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area, self).__init__()

                                    self.yang_name = "area"
                                    self.yang_parent_name = "topology"

                                    self.area_id = YLeaf(YType.str, "area-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.area_id.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "area" + "[area-id='" + self.area_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "area-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area-id"):
                                        self.area_id = value
                                        self.area_id.value_namespace = name_space
                                        self.area_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.area:
                                    if (c.has_data()):
                                        return True
                                return self.name.is_set

                            def has_operation(self):
                                for c in self.area:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "topology" + "[name='" + self.name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "area"):
                                    for c in self.area:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.area.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.area:
                                if (c.has_data()):
                                    return True
                            for c in self.as_scope_lsas:
                                if (c.has_data()):
                                    return True
                            for c in self.topology:
                                if (c.has_data()):
                                    return True
                            return (
                                self.af.is_set or
                                self.router_id.is_set)

                        def has_operation(self):
                            for c in self.area:
                                if (c.has_operation()):
                                    return True
                            for c in self.as_scope_lsas:
                                if (c.has_operation()):
                                    return True
                            for c in self.topology:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af.yfilter != YFilter.not_set or
                                self.router_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "instance" + "[af='" + self.af.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af.is_set or self.af.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af.get_name_leafdata())
                            if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.router_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "area"):
                                for c in self.area:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.area.append(c)
                                return c

                            if (child_yang_name == "as-scope-lsas"):
                                for c in self.as_scope_lsas:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AsScopeLsas()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.as_scope_lsas.append(c)
                                return c

                            if (child_yang_name == "topology"):
                                for c in self.topology:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.topology.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "area" or name == "as-scope-lsas" or name == "topology" or name == "af" or name == "router-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af"):
                                self.af = value
                                self.af.value_namespace = name_space
                                self.af.value_namespace_prefix = name_space_prefix
                            if(value_path == "router-id"):
                                self.router_id = value
                                self.router_id.value_namespace = name_space
                                self.router_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.instance:
                            if (c.has_data()):
                                return True
                        return self.operation_mode.is_set

                    def has_operation(self):
                        for c in self.instance:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.operation_mode.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ietf-ospf:ospf" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.operation_mode.is_set or self.operation_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.operation_mode.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "instance"):
                            for c in self.instance:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.instance.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "instance" or name == "operation-mode"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "operation-mode"):
                            self.operation_mode = value
                            self.operation_mode.value_namespace = name_space
                            self.operation_mode.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.type.is_set or
                        self.name.is_set or
                        (self.ospf is not None and self.ospf.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        (self.ospf is not None and self.ospf.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "routing-protocol" + "[type='" + self.type.get() + "']" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ospf"):
                        if (self.ospf is None):
                            self.ospf = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                        return self.ospf

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ospf" or name == "type" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.routing_protocol:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.routing_protocol:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "routing-protocols" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "routing-protocol"):
                    for c in self.routing_protocol:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = RoutingState.RoutingInstance.RoutingProtocols.RoutingProtocol()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.routing_protocol.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "routing-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Ribs(Entity):
            """
            Container for RIBs.
            
            .. attribute:: rib
            
            	Each entry represents a RIB identified by the 'name' key. All routes in a RIB MUST belong to the same address family.  For each routing instance, an implementation SHOULD provide one system\-controlled default RIB for each supported address family
            	**type**\: list of    :py:class:`Rib <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs.Rib>`
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(RoutingState.RoutingInstance.Ribs, self).__init__()

                self.yang_name = "ribs"
                self.yang_parent_name = "routing-instance"

                self.rib = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(RoutingState.RoutingInstance.Ribs, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(RoutingState.RoutingInstance.Ribs, self).__setattr__(name, value)


            class Rib(Entity):
                """
                Each entry represents a RIB identified by the 'name'
                key. All routes in a RIB MUST belong to the same address
                family.
                
                For each routing instance, an implementation SHOULD
                provide one system\-controlled default RIB for each
                supported address family.
                
                .. attribute:: name  <key>
                
                	The name of the RIB
                	**type**\:  str
                
                .. attribute:: address_family
                
                	Address family
                	**type**\:   :py:class:`AddressFamily <ydk.models.ietf.ietf_routing.AddressFamily>`
                
                	**mandatory**\: True
                
                .. attribute:: default_rib
                
                	This flag has the value of 'true' if and only if the RIB is the default RIB for the given address family.  A default RIB always receives direct routes. By default it also receives routes from all routing protocols
                	**type**\:  bool
                
                	**default value**\: true
                
                .. attribute:: routes
                
                	Current content of the RIB
                	**type**\:   :py:class:`Routes <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs.Rib.Routes>`
                
                

                """

                _prefix = 'rt'
                _revision = '2015-05-25'

                def __init__(self):
                    super(RoutingState.RoutingInstance.Ribs.Rib, self).__init__()

                    self.yang_name = "rib"
                    self.yang_parent_name = "ribs"

                    self.name = YLeaf(YType.str, "name")

                    self.address_family = YLeaf(YType.identityref, "address-family")

                    self.default_rib = YLeaf(YType.boolean, "default-rib")

                    self.routes = RoutingState.RoutingInstance.Ribs.Rib.Routes()
                    self.routes.parent = self
                    self._children_name_map["routes"] = "routes"
                    self._children_yang_names.add("routes")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name",
                                    "address_family",
                                    "default_rib") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(RoutingState.RoutingInstance.Ribs.Rib, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(RoutingState.RoutingInstance.Ribs.Rib, self).__setattr__(name, value)


                class Routes(Entity):
                    """
                    Current content of the RIB.
                    
                    .. attribute:: route
                    
                    	A RIB route entry. This data node MUST be augmented with information specific for routes of each address family
                    	**type**\: list of    :py:class:`Route <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs.Rib.Routes.Route>`
                    
                    

                    """

                    _prefix = 'rt'
                    _revision = '2015-05-25'

                    def __init__(self):
                        super(RoutingState.RoutingInstance.Ribs.Rib.Routes, self).__init__()

                        self.yang_name = "routes"
                        self.yang_parent_name = "rib"

                        self.route = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(RoutingState.RoutingInstance.Ribs.Rib.Routes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(RoutingState.RoutingInstance.Ribs.Rib.Routes, self).__setattr__(name, value)


                    class Route(Entity):
                        """
                        A RIB route entry. This data node MUST be augmented
                        with information specific for routes of each address
                        family.
                        
                        .. attribute:: destination_prefix  <key>
                        
                        	Destination IP address with prefix
                        	**type**\:  str
                        
                        .. attribute:: active
                        
                        	Presence of this leaf indicates that the route is preferred among all routes in the same RIB that have the same destination prefix
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: last_updated
                        
                        	Time stamp of the last modification of the route. If the route was never modified, it is the time when the route was inserted into the RIB
                        	**type**\:  str
                        
                        	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
                        
                        .. attribute:: metric
                        
                        	Route metric
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: next_hop
                        
                        	Route's next\-hop attribute
                        	**type**\:   :py:class:`NextHop <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop>`
                        
                        .. attribute:: route_preference
                        
                        	This route attribute, also known as administrative distance, allows for selecting the preferred route among routes with the same destination prefix. A smaller value means a more preferred route
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: route_type
                        
                        	OSPF route type
                        	**type**\:   :py:class:`RouteType <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.RouteType>`
                        
                        .. attribute:: source_protocol
                        
                        	Type of the routing protocol from which the route originated
                        	**type**\:   :py:class:`RoutingProtocol <ydk.models.ietf.ietf_routing.RoutingProtocol>`
                        
                        	**mandatory**\: True
                        
                        .. attribute:: tag
                        
                        	OSPF route tag
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**default value**\: 0
                        
                        .. attribute:: update_source
                        
                        	Update source for the route
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'rt'
                        _revision = '2015-05-25'

                        def __init__(self):
                            super(RoutingState.RoutingInstance.Ribs.Rib.Routes.Route, self).__init__()

                            self.yang_name = "route"
                            self.yang_parent_name = "routes"

                            self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                            self.active = YLeaf(YType.empty, "active")

                            self.last_updated = YLeaf(YType.str, "last-updated")

                            self.metric = YLeaf(YType.uint32, "metric")

                            self.route_preference = YLeaf(YType.uint32, "route-preference")

                            self.route_type = YLeaf(YType.enumeration, "ietf-ospf:route-type")

                            self.source_protocol = YLeaf(YType.identityref, "source-protocol")

                            self.tag = YLeaf(YType.uint32, "ietf-ospf:tag")

                            self.update_source = YLeaf(YType.str, "update-source")

                            self.next_hop = RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop()
                            self.next_hop.parent = self
                            self._children_name_map["next_hop"] = "next-hop"
                            self._children_yang_names.add("next-hop")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("destination_prefix",
                                            "active",
                                            "last_updated",
                                            "metric",
                                            "route_preference",
                                            "route_type",
                                            "source_protocol",
                                            "tag",
                                            "update_source") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(RoutingState.RoutingInstance.Ribs.Rib.Routes.Route, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(RoutingState.RoutingInstance.Ribs.Rib.Routes.Route, self).__setattr__(name, value)

                        class RouteType(Enum):
                            """
                            RouteType

                            OSPF route type

                            .. data:: intra_area = 0

                            	OSPF intra-area route

                            .. data:: inter_area = 1

                            	OSPF inter-area route

                            .. data:: external_1 = 2

                            	OSPF external route type 1

                            .. data:: external_2 = 3

                            	OSPF External route type 2

                            .. data:: nssa_1 = 4

                            	OSPF NSSA external route type 1

                            .. data:: nssa_2 = 5

                            	OSPF NSSA external route type 2

                            """

                            intra_area = Enum.YLeaf(0, "intra-area")

                            inter_area = Enum.YLeaf(1, "inter-area")

                            external_1 = Enum.YLeaf(2, "external-1")

                            external_2 = Enum.YLeaf(3, "external-2")

                            nssa_1 = Enum.YLeaf(4, "nssa-1")

                            nssa_2 = Enum.YLeaf(5, "nssa-2")



                        class NextHop(Entity):
                            """
                            Route's next\-hop attribute.
                            
                            .. attribute:: next_hop_address
                            
                            	IP address
                            	**type**\:  str
                            
                            .. attribute:: outgoing_interface
                            
                            	Name of the outgoing interface
                            	**type**\:  str
                            
                            .. attribute:: special_next_hop
                            
                            	Special next\-hop options
                            	**type**\:   :py:class:`SpecialNextHop <ydk.models.ietf.ietf_routing.RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop.SpecialNextHop>`
                            
                            

                            """

                            _prefix = 'rt'
                            _revision = '2015-05-25'

                            def __init__(self):
                                super(RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop, self).__init__()

                                self.yang_name = "next-hop"
                                self.yang_parent_name = "route"

                                self.next_hop_address = YLeaf(YType.str, "next-hop-address")

                                self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                self.special_next_hop = YLeaf(YType.enumeration, "special-next-hop")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("next_hop_address",
                                                "outgoing_interface",
                                                "special_next_hop") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop, self).__setattr__(name, value)

                            class SpecialNextHop(Enum):
                                """
                                SpecialNextHop

                                Special next\-hop options.

                                .. data:: blackhole = 0

                                	Silently discard the packet.

                                .. data:: unreachable = 1

                                	Discard the packet and notify the sender with an error

                                	message indicating that the destination host is

                                	unreachable.

                                .. data:: prohibit = 2

                                	Discard the packet and notify the sender with an error

                                	message indicating that the communication is

                                	administratively prohibited.

                                .. data:: receive = 3

                                	The packet will be received by the local system.

                                """

                                blackhole = Enum.YLeaf(0, "blackhole")

                                unreachable = Enum.YLeaf(1, "unreachable")

                                prohibit = Enum.YLeaf(2, "prohibit")

                                receive = Enum.YLeaf(3, "receive")


                            def has_data(self):
                                return (
                                    self.next_hop_address.is_set or
                                    self.outgoing_interface.is_set or
                                    self.special_next_hop.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.next_hop_address.yfilter != YFilter.not_set or
                                    self.outgoing_interface.yfilter != YFilter.not_set or
                                    self.special_next_hop.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "next-hop" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.next_hop_address.is_set or self.next_hop_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hop_address.get_name_leafdata())
                                if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                if (self.special_next_hop.is_set or self.special_next_hop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.special_next_hop.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop-address" or name == "outgoing-interface" or name == "special-next-hop"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "next-hop-address"):
                                    self.next_hop_address = value
                                    self.next_hop_address.value_namespace = name_space
                                    self.next_hop_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface"):
                                    self.outgoing_interface = value
                                    self.outgoing_interface.value_namespace = name_space
                                    self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "special-next-hop"):
                                    self.special_next_hop = value
                                    self.special_next_hop.value_namespace = name_space
                                    self.special_next_hop.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.destination_prefix.is_set or
                                self.active.is_set or
                                self.last_updated.is_set or
                                self.metric.is_set or
                                self.route_preference.is_set or
                                self.route_type.is_set or
                                self.source_protocol.is_set or
                                self.tag.is_set or
                                self.update_source.is_set or
                                (self.next_hop is not None and self.next_hop.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.destination_prefix.yfilter != YFilter.not_set or
                                self.active.yfilter != YFilter.not_set or
                                self.last_updated.yfilter != YFilter.not_set or
                                self.metric.yfilter != YFilter.not_set or
                                self.route_preference.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.source_protocol.yfilter != YFilter.not_set or
                                self.tag.yfilter != YFilter.not_set or
                                self.update_source.yfilter != YFilter.not_set or
                                (self.next_hop is not None and self.next_hop.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "route" + "[destination-prefix='" + self.destination_prefix.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                            if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.active.get_name_leafdata())
                            if (self.last_updated.is_set or self.last_updated.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_updated.get_name_leafdata())
                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.metric.get_name_leafdata())
                            if (self.route_preference.is_set or self.route_preference.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_preference.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.source_protocol.is_set or self.source_protocol.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source_protocol.get_name_leafdata())
                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tag.get_name_leafdata())
                            if (self.update_source.is_set or self.update_source.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.update_source.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "next-hop"):
                                if (self.next_hop is None):
                                    self.next_hop = RoutingState.RoutingInstance.Ribs.Rib.Routes.Route.NextHop()
                                    self.next_hop.parent = self
                                    self._children_name_map["next_hop"] = "next-hop"
                                return self.next_hop

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "next-hop" or name == "destination-prefix" or name == "active" or name == "last-updated" or name == "metric" or name == "route-preference" or name == "route-type" or name == "source-protocol" or name == "tag" or name == "update-source"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "destination-prefix"):
                                self.destination_prefix = value
                                self.destination_prefix.value_namespace = name_space
                                self.destination_prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "active"):
                                self.active = value
                                self.active.value_namespace = name_space
                                self.active.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-updated"):
                                self.last_updated = value
                                self.last_updated.value_namespace = name_space
                                self.last_updated.value_namespace_prefix = name_space_prefix
                            if(value_path == "metric"):
                                self.metric = value
                                self.metric.value_namespace = name_space
                                self.metric.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-preference"):
                                self.route_preference = value
                                self.route_preference.value_namespace = name_space
                                self.route_preference.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "source-protocol"):
                                self.source_protocol = value
                                self.source_protocol.value_namespace = name_space
                                self.source_protocol.value_namespace_prefix = name_space_prefix
                            if(value_path == "tag"):
                                self.tag = value
                                self.tag.value_namespace = name_space
                                self.tag.value_namespace_prefix = name_space_prefix
                            if(value_path == "update-source"):
                                self.update_source = value
                                self.update_source.value_namespace = name_space
                                self.update_source.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.route:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.route:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "routes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "route"):
                            for c in self.route:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = RoutingState.RoutingInstance.Ribs.Rib.Routes.Route()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.route.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "route"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.name.is_set or
                        self.address_family.is_set or
                        self.default_rib.is_set or
                        (self.routes is not None and self.routes.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.address_family.yfilter != YFilter.not_set or
                        self.default_rib.yfilter != YFilter.not_set or
                        (self.routes is not None and self.routes.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rib" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address_family.get_name_leafdata())
                    if (self.default_rib.is_set or self.default_rib.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.default_rib.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "routes"):
                        if (self.routes is None):
                            self.routes = RoutingState.RoutingInstance.Ribs.Rib.Routes()
                            self.routes.parent = self
                            self._children_name_map["routes"] = "routes"
                        return self.routes

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "routes" or name == "name" or name == "address-family" or name == "default-rib"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "address-family"):
                        self.address_family = value
                        self.address_family.value_namespace = name_space
                        self.address_family.value_namespace_prefix = name_space_prefix
                    if(value_path == "default-rib"):
                        self.default_rib = value
                        self.default_rib.value_namespace = name_space
                        self.default_rib.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.rib:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.rib:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ribs" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "rib"):
                    for c in self.rib:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = RoutingState.RoutingInstance.Ribs.Rib()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.rib.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "rib"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.name.is_set or
                self.router_id.is_set or
                self.type.is_set or
                (self.interfaces is not None and self.interfaces.has_data()) or
                (self.ribs is not None and self.ribs.has_data()) or
                (self.routing_protocols is not None and self.routing_protocols.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.name.yfilter != YFilter.not_set or
                self.router_id.yfilter != YFilter.not_set or
                self.type.yfilter != YFilter.not_set or
                (self.interfaces is not None and self.interfaces.has_operation()) or
                (self.ribs is not None and self.ribs.has_operation()) or
                (self.routing_protocols is not None and self.routing_protocols.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "routing-instance" + "[name='" + self.name.get() + "']" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "ietf-routing:routing-state/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.name.get_name_leafdata())
            if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                leaf_name_data.append(self.router_id.get_name_leafdata())
            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                leaf_name_data.append(self.type.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interfaces"):
                if (self.interfaces is None):
                    self.interfaces = RoutingState.RoutingInstance.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                return self.interfaces

            if (child_yang_name == "ribs"):
                if (self.ribs is None):
                    self.ribs = RoutingState.RoutingInstance.Ribs()
                    self.ribs.parent = self
                    self._children_name_map["ribs"] = "ribs"
                return self.ribs

            if (child_yang_name == "routing-protocols"):
                if (self.routing_protocols is None):
                    self.routing_protocols = RoutingState.RoutingInstance.RoutingProtocols()
                    self.routing_protocols.parent = self
                    self._children_name_map["routing_protocols"] = "routing-protocols"
                return self.routing_protocols

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interfaces" or name == "ribs" or name == "routing-protocols" or name == "name" or name == "router-id" or name == "type"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "name"):
                self.name = value
                self.name.value_namespace = name_space
                self.name.value_namespace_prefix = name_space_prefix
            if(value_path == "router-id"):
                self.router_id = value
                self.router_id.value_namespace = name_space
                self.router_id.value_namespace_prefix = name_space_prefix
            if(value_path == "type"):
                self.type = value
                self.type.value_namespace = name_space
                self.type.value_namespace_prefix = name_space_prefix

    def has_data(self):
        for c in self.routing_instance:
            if (c.has_data()):
                return True
        return False

    def has_operation(self):
        for c in self.routing_instance:
            if (c.has_operation()):
                return True
        return self.yfilter != YFilter.not_set

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "ietf-routing:routing-state" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "routing-instance"):
            for c in self.routing_instance:
                segment = c.get_segment_path()
                if (segment_path == segment):
                    return c
            c = RoutingState.RoutingInstance()
            c.parent = self
            local_reference_key = "ydk::seg::%s" % segment_path
            self._local_refs[local_reference_key] = c
            self.routing_instance.append(c)
            return c

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "routing-instance"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = RoutingState()
        return self._top_entity

class Routing(Entity):
    """
    Configuration parameters for the routing subsystem.
    
    .. attribute:: routing_instance
    
    	Configuration of a routing instance
    	**type**\: list of    :py:class:`RoutingInstance <ydk.models.ietf.ietf_routing.Routing.RoutingInstance>`
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(Routing, self).__init__()
        self._top_entity = None

        self.yang_name = "routing"
        self.yang_parent_name = "ietf-routing"

        self.routing_instance = YList(self)

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in () and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(Routing, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(Routing, self).__setattr__(name, value)


    class RoutingInstance(Entity):
        """
        Configuration of a routing instance.
        
        .. attribute:: name  <key>
        
        	The name of the routing instance.  For system\-controlled entries, the value of this leaf must be the same as the name of the corresponding entry in state data.  For user\-controlled entries, an arbitrary name can be used
        	**type**\:  str
        
        .. attribute:: description
        
        	Textual description of the routing instance
        	**type**\:  str
        
        .. attribute:: enabled
        
        	Enable/disable the routing instance.  If this parameter is false, the parent routing instance is disabled and does not appear in state data, despite any other configuration that might be present
        	**type**\:  bool
        
        	**default value**\: true
        
        .. attribute:: interfaces
        
        	Assignment of the routing instance's interfaces
        	**type**\:   :py:class:`Interfaces <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Interfaces>`
        
        .. attribute:: ribs
        
        	Configuration of RIBs
        	**type**\:   :py:class:`Ribs <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Ribs>`
        
        .. attribute:: router_id
        
        	A 32\-bit number in the form of a dotted quad that is used by some routing protocols identifying a router
        	**type**\:  str
        
        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
        
        .. attribute:: routing_protocols
        
        	Configuration of routing protocol instances
        	**type**\:   :py:class:`RoutingProtocols <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols>`
        
        .. attribute:: type
        
        	The type of the routing instance
        	**type**\:   :py:class:`RoutingInstance <ydk.models.ietf.ietf_routing.RoutingInstance>`
        
        	**default value**\: rt:default-routing-instance
        
        

        """

        _prefix = 'rt'
        _revision = '2015-05-25'

        def __init__(self):
            super(Routing.RoutingInstance, self).__init__()

            self.yang_name = "routing-instance"
            self.yang_parent_name = "routing"

            self.name = YLeaf(YType.str, "name")

            self.description = YLeaf(YType.str, "description")

            self.enabled = YLeaf(YType.boolean, "enabled")

            self.router_id = YLeaf(YType.str, "router-id")

            self.type = YLeaf(YType.identityref, "type")

            self.interfaces = Routing.RoutingInstance.Interfaces()
            self.interfaces.parent = self
            self._children_name_map["interfaces"] = "interfaces"
            self._children_yang_names.add("interfaces")

            self.ribs = Routing.RoutingInstance.Ribs()
            self.ribs.parent = self
            self._children_name_map["ribs"] = "ribs"
            self._children_yang_names.add("ribs")

            self.routing_protocols = Routing.RoutingInstance.RoutingProtocols()
            self.routing_protocols.parent = self
            self._children_name_map["routing_protocols"] = "routing-protocols"
            self._children_yang_names.add("routing-protocols")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("name",
                            "description",
                            "enabled",
                            "router_id",
                            "type") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Routing.RoutingInstance, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Routing.RoutingInstance, self).__setattr__(name, value)


        class Interfaces(Entity):
            """
            Assignment of the routing instance's interfaces.
            
            .. attribute:: interface
            
            	The name of a configured network layer interface to be assigned to the routing\-instance
            	**type**\:  list of str
            
            	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(Routing.RoutingInstance.Interfaces, self).__init__()

                self.yang_name = "interfaces"
                self.yang_parent_name = "routing-instance"

                self.interface = YLeafList(YType.str, "interface")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Routing.RoutingInstance.Interfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Routing.RoutingInstance.Interfaces, self).__setattr__(name, value)

            def has_data(self):
                for leaf in self.interface.getYLeafs():
                    if (leaf.yfilter != YFilter.not_set):
                        return True
                return False

            def has_operation(self):
                for leaf in self.interface.getYLeafs():
                    if (leaf.is_set):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                leaf_name_data.extend(self.interface.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface"):
                    self.interface.append(value)


        class RoutingProtocols(Entity):
            """
            Configuration of routing protocol instances.
            
            .. attribute:: routing_protocol
            
            	Each entry contains configuration of a routing protocol instance
            	**type**\: list of    :py:class:`RoutingProtocol <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol>`
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(Routing.RoutingInstance.RoutingProtocols, self).__init__()

                self.yang_name = "routing-protocols"
                self.yang_parent_name = "routing-instance"

                self.routing_protocol = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Routing.RoutingInstance.RoutingProtocols, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Routing.RoutingInstance.RoutingProtocols, self).__setattr__(name, value)


            class RoutingProtocol(Entity):
                """
                Each entry contains configuration of a routing protocol
                instance.
                
                .. attribute:: type  <key>
                
                	Type of the routing protocol \- an identity derived from the 'routing\-protocol' base identity
                	**type**\:   :py:class:`RoutingProtocol <ydk.models.ietf.ietf_routing.RoutingProtocol>`
                
                .. attribute:: name  <key>
                
                	An arbitrary name of the routing protocol instance
                	**type**\:  str
                
                .. attribute:: description
                
                	Textual description of the routing protocol instance
                	**type**\:  str
                
                .. attribute:: ospf
                
                	OSPF
                	**type**\:   :py:class:`Ospf <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf>`
                
                .. attribute:: static_routes
                
                	Configuration of the 'static' pseudo\-protocol.  Address\-family\-specific modules augment this node with their lists of routes
                	**type**\:   :py:class:`StaticRoutes <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes>`
                
                

                """

                _prefix = 'rt'
                _revision = '2015-05-25'

                def __init__(self):
                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol, self).__init__()

                    self.yang_name = "routing-protocol"
                    self.yang_parent_name = "routing-protocols"

                    self.type = YLeaf(YType.identityref, "type")

                    self.name = YLeaf(YType.str, "name")

                    self.description = YLeaf(YType.str, "description")

                    self.ospf = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf()
                    self.ospf.parent = self
                    self._children_name_map["ospf"] = "ospf"
                    self._children_yang_names.add("ospf")

                    self.static_routes = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes()
                    self.static_routes.parent = self
                    self._children_name_map["static_routes"] = "static-routes"
                    self._children_yang_names.add("static-routes")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("type",
                                    "name",
                                    "description") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol, self).__setattr__(name, value)


                class Ospf(Entity):
                    """
                    OSPF.
                    
                    .. attribute:: all_instances_inherit
                    
                    	Inheritance support to all instances
                    	**type**\:   :py:class:`AllInstancesInherit <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit>`
                    
                    .. attribute:: instance
                    
                    	An OSPF routing protocol instance
                    	**type**\: list of    :py:class:`Instance <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance>`
                    
                    .. attribute:: operation_mode
                    
                    	OSPF operation mode
                    	**type**\:   :py:class:`OperationMode <ydk.models.ietf.ietf_ospf.OperationMode>`
                    
                    	**default value**\: ospf:ships-in-the-night
                    
                    

                    """

                    _prefix = 'ospf'
                    _revision = '2015-03-09'

                    def __init__(self):
                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf, self).__init__()

                        self.yang_name = "ospf"
                        self.yang_parent_name = "routing-protocol"

                        self.operation_mode = YLeaf(YType.identityref, "operation-mode")

                        self.all_instances_inherit = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit()
                        self.all_instances_inherit.parent = self
                        self._children_name_map["all_instances_inherit"] = "all-instances-inherit"
                        self._children_yang_names.add("all-instances-inherit")

                        self.instance = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("operation_mode") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf, self).__setattr__(name, value)


                    class Instance(Entity):
                        """
                        An OSPF routing protocol instance.
                        
                        .. attribute:: af  <key>
                        
                        	Address\-family of the instance
                        	**type**\:   :py:class:`AddressFamily <ydk.models.ietf.ietf_routing.AddressFamily>`
                        
                        .. attribute:: admin_distance
                        
                        	Admin distance config state
                        	**type**\:   :py:class:`AdminDistance <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance>`
                        
                        .. attribute:: all_areas_inherit
                        
                        	Inheritance for all areas
                        	**type**\:   :py:class:`AllAreasInherit <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit>`
                        
                        .. attribute:: area
                        
                        	List of ospf areas
                        	**type**\: list of    :py:class:`Area <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area>`
                        
                        .. attribute:: auto_cost
                        
                        	Auto cost config state
                        	**type**\:   :py:class:`AutoCost <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AutoCost>`
                        
                        .. attribute:: database_control
                        
                        	Database maintenance control
                        	**type**\:   :py:class:`DatabaseControl <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl>`
                        
                        .. attribute:: default_information
                        
                        	Control distribution of default information
                        	**type**\:   :py:class:`DefaultInformation <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation>`
                        
                        .. attribute:: default_metric
                        
                        	OSPF default metric
                        	**type**\:   :py:class:`DefaultMetric <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultMetric>`
                        
                        .. attribute:: discard_route
                        
                        	Enable or disable discard\-route installation
                        	**type**\:   :py:class:`DiscardRoute <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DiscardRoute>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: enable
                        
                        	Enable/Disable the protocol
                        	**type**\:  bool
                        
                        	**default value**\: true
                        
                        .. attribute:: fast_reroute
                        
                        	This container may be augmented with global parameters for IPFRR
                        	**type**\:   :py:class:`FastReroute <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute>`
                        
                        .. attribute:: graceful_restart
                        
                        	Graceful restart config state
                        	**type**\:   :py:class:`GracefulRestart <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulRestart>`
                        
                        .. attribute:: graceful_shutdown
                        
                        	Timers for graceful shutdown
                        	**type**\:   :py:class:`GracefulShutdown <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulShutdown>`
                        
                        .. attribute:: log_adjacency_changes
                        
                        	Log adjacency changes
                        	**type**\:   :py:class:`LogAdjacencyChanges <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.LogAdjacencyChanges>`
                        
                        .. attribute:: microloop_avoidance
                        
                        	Microloop avoidance configuration
                        	**type**\:   :py:class:`MicroloopAvoidance <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.MicroloopAvoidance>`
                        
                        .. attribute:: mpls
                        
                        	OSPF MPLS config state
                        	**type**\:   :py:class:`Mpls <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls>`
                        
                        .. attribute:: nsr
                        
                        	NSR config state
                        	**type**\:   :py:class:`Nsr <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Nsr>`
                        
                        .. attribute:: redistribution
                        
                        	redistribute other routing protocols inside ospf
                        	**type**\:   :py:class:`Redistribution <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution>`
                        
                        .. attribute:: reload_control
                        
                        	Protocol reload control
                        	**type**\:   :py:class:`ReloadControl <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl>`
                        
                        .. attribute:: router_id
                        
                        	Defined in RFC 2328. A 32\-bit number that uniquely identifies the router
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                        
                        .. attribute:: spf_control
                        
                        	SPF calculation control
                        	**type**\:   :py:class:`SpfControl <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl>`
                        
                        .. attribute:: summary_prefixes
                        
                        	Configure IP address summaries
                        	**type**\:   :py:class:`SummaryPrefixes <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes>`
                        
                        .. attribute:: topology
                        
                        	OSPF topology
                        	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology>`
                        
                        

                        """

                        _prefix = 'ospf'
                        _revision = '2015-03-09'

                        def __init__(self):
                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance, self).__init__()

                            self.yang_name = "instance"
                            self.yang_parent_name = "ospf"

                            self.af = YLeaf(YType.identityref, "af")

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.router_id = YLeaf(YType.str, "router-id")

                            self.admin_distance = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance()
                            self.admin_distance.parent = self
                            self._children_name_map["admin_distance"] = "admin-distance"
                            self._children_yang_names.add("admin-distance")

                            self.all_areas_inherit = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit()
                            self.all_areas_inherit.parent = self
                            self._children_name_map["all_areas_inherit"] = "all-areas-inherit"
                            self._children_yang_names.add("all-areas-inherit")

                            self.auto_cost = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AutoCost()
                            self.auto_cost.parent = self
                            self._children_name_map["auto_cost"] = "auto-cost"
                            self._children_yang_names.add("auto-cost")

                            self.database_control = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl()
                            self.database_control.parent = self
                            self._children_name_map["database_control"] = "database-control"
                            self._children_yang_names.add("database-control")

                            self.default_information = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation()
                            self.default_information.parent = self
                            self._children_name_map["default_information"] = "default-information"
                            self._children_yang_names.add("default-information")

                            self.default_metric = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultMetric()
                            self.default_metric.parent = self
                            self._children_name_map["default_metric"] = "default-metric"
                            self._children_yang_names.add("default-metric")

                            self.discard_route = None
                            self._children_name_map["discard_route"] = "discard-route"
                            self._children_yang_names.add("discard-route")

                            self.fast_reroute = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute()
                            self.fast_reroute.parent = self
                            self._children_name_map["fast_reroute"] = "fast-reroute"
                            self._children_yang_names.add("fast-reroute")

                            self.graceful_restart = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulRestart()
                            self.graceful_restart.parent = self
                            self._children_name_map["graceful_restart"] = "graceful-restart"
                            self._children_yang_names.add("graceful-restart")

                            self.graceful_shutdown = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulShutdown()
                            self.graceful_shutdown.parent = self
                            self._children_name_map["graceful_shutdown"] = "graceful-shutdown"
                            self._children_yang_names.add("graceful-shutdown")

                            self.log_adjacency_changes = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.LogAdjacencyChanges()
                            self.log_adjacency_changes.parent = self
                            self._children_name_map["log_adjacency_changes"] = "log-adjacency-changes"
                            self._children_yang_names.add("log-adjacency-changes")

                            self.microloop_avoidance = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.MicroloopAvoidance()
                            self.microloop_avoidance.parent = self
                            self._children_name_map["microloop_avoidance"] = "microloop-avoidance"
                            self._children_yang_names.add("microloop-avoidance")

                            self.mpls = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls()
                            self.mpls.parent = self
                            self._children_name_map["mpls"] = "mpls"
                            self._children_yang_names.add("mpls")

                            self.nsr = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Nsr()
                            self.nsr.parent = self
                            self._children_name_map["nsr"] = "nsr"
                            self._children_yang_names.add("nsr")

                            self.redistribution = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution()
                            self.redistribution.parent = self
                            self._children_name_map["redistribution"] = "redistribution"
                            self._children_yang_names.add("redistribution")

                            self.reload_control = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl()
                            self.reload_control.parent = self
                            self._children_name_map["reload_control"] = "reload-control"
                            self._children_yang_names.add("reload-control")

                            self.spf_control = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl()
                            self.spf_control.parent = self
                            self._children_name_map["spf_control"] = "spf-control"
                            self._children_yang_names.add("spf-control")

                            self.summary_prefixes = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes()
                            self.summary_prefixes.parent = self
                            self._children_name_map["summary_prefixes"] = "summary-prefixes"
                            self._children_yang_names.add("summary-prefixes")

                            self.area = YList(self)
                            self.topology = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af",
                                            "enable",
                                            "router_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance, self).__setattr__(name, value)


                        class Redistribution(Entity):
                            """
                            redistribute other routing protocols inside ospf
                            
                            .. attribute:: applications
                            
                            	Application
                            	**type**\:   :py:class:`Applications <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications>`
                            
                            .. attribute:: bgp
                            
                            	Border Gateway Protocol (BGP)
                            	**type**\:   :py:class:`Bgp <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp>`
                            
                            .. attribute:: connected
                            
                            	Connected routes
                            	**type**\:   :py:class:`Connected <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: eigrp
                            
                            	Enhanced Interior Gateway Routing Protocol (EIGRP)
                            	**type**\:   :py:class:`Eigrp <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp>`
                            
                            .. attribute:: isis
                            
                            	ISO IS\-IS
                            	**type**\:   :py:class:`Isis <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis>`
                            
                            .. attribute:: maximum_prefix
                            
                            	Maximum number of prefixes redistributed to protocol
                            	**type**\:   :py:class:`MaximumPrefix <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.MaximumPrefix>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: ospf
                            
                            	Open Shortest Path First (OSPF)
                            	**type**\:   :py:class:`Ospf <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf>`
                            
                            .. attribute:: rip
                            
                            	rip routes
                            	**type**\:   :py:class:`Rip <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: static
                            
                            	Static routes
                            	**type**\:   :py:class:`Static <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: subscriber
                            
                            	Subscriber routes
                            	**type**\:   :py:class:`Subscriber <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber>`
                            
                            	**presence node**\: True
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution, self).__init__()

                                self.yang_name = "redistribution"
                                self.yang_parent_name = "instance"

                                self.applications = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications()
                                self.applications.parent = self
                                self._children_name_map["applications"] = "applications"
                                self._children_yang_names.add("applications")

                                self.bgp = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp()
                                self.bgp.parent = self
                                self._children_name_map["bgp"] = "bgp"
                                self._children_yang_names.add("bgp")

                                self.connected = None
                                self._children_name_map["connected"] = "connected"
                                self._children_yang_names.add("connected")

                                self.eigrp = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp()
                                self.eigrp.parent = self
                                self._children_name_map["eigrp"] = "eigrp"
                                self._children_yang_names.add("eigrp")

                                self.isis = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis()
                                self.isis.parent = self
                                self._children_name_map["isis"] = "isis"
                                self._children_yang_names.add("isis")

                                self.maximum_prefix = None
                                self._children_name_map["maximum_prefix"] = "maximum-prefix"
                                self._children_yang_names.add("maximum-prefix")

                                self.ospf = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf()
                                self.ospf.parent = self
                                self._children_name_map["ospf"] = "ospf"
                                self._children_yang_names.add("ospf")

                                self.rip = None
                                self._children_name_map["rip"] = "rip"
                                self._children_yang_names.add("rip")

                                self.static = None
                                self._children_name_map["static"] = "static"
                                self._children_yang_names.add("static")

                                self.subscriber = None
                                self._children_name_map["subscriber"] = "subscriber"
                                self._children_yang_names.add("subscriber")


                            class MaximumPrefix(Entity):
                                """
                                Maximum number of prefixes redistributed to protocol
                                
                                .. attribute:: ip_prefixes
                                
                                	Maximum number of IP prefixes redistributed
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: threshold_value
                                
                                	Threshold value (%) at which to generate a warning msg
                                	**type**\:  int
                                
                                	**range:** 1..100
                                
                                .. attribute:: warning_only
                                
                                	Only give warning message when limit is exceeded
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.MaximumPrefix, self).__init__()

                                    self.yang_name = "maximum-prefix"
                                    self.yang_parent_name = "redistribution"
                                    self.is_presence_container = True

                                    self.ip_prefixes = YLeaf(YType.uint32, "IP-prefixes")

                                    self.threshold_value = YLeaf(YType.uint32, "Threshold-value")

                                    self.warning_only = YLeaf(YType.empty, "warning-only")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ip_prefixes",
                                                    "threshold_value",
                                                    "warning_only") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.MaximumPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.MaximumPrefix, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ip_prefixes.is_set or
                                        self.threshold_value.is_set or
                                        self.warning_only.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ip_prefixes.yfilter != YFilter.not_set or
                                        self.threshold_value.yfilter != YFilter.not_set or
                                        self.warning_only.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "maximum-prefix" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ip_prefixes.is_set or self.ip_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip_prefixes.get_name_leafdata())
                                    if (self.threshold_value.is_set or self.threshold_value.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_value.get_name_leafdata())
                                    if (self.warning_only.is_set or self.warning_only.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.warning_only.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "IP-prefixes" or name == "Threshold-value" or name == "warning-only"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "IP-prefixes"):
                                        self.ip_prefixes = value
                                        self.ip_prefixes.value_namespace = name_space
                                        self.ip_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "Threshold-value"):
                                        self.threshold_value = value
                                        self.threshold_value.value_namespace = name_space
                                        self.threshold_value.value_namespace_prefix = name_space_prefix
                                    if(value_path == "warning-only"):
                                        self.warning_only = value
                                        self.warning_only.value_namespace = name_space
                                        self.warning_only.value_namespace_prefix = name_space_prefix


                            class Bgp(Entity):
                                """
                                Border Gateway Protocol (BGP)
                                
                                .. attribute:: bgp_protocol
                                
                                	Border Gateway Protocol (BGP)
                                	**type**\: list of    :py:class:`BgpProtocol <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp, self).__init__()

                                    self.yang_name = "bgp"
                                    self.yang_parent_name = "redistribution"

                                    self.bgp_protocol = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp, self).__setattr__(name, value)


                                class BgpProtocol(Entity):
                                    """
                                    Border Gateway Protocol (BGP)
                                    
                                    .. attribute:: as_number  <key>
                                    
                                    	Autonomous system number
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: redist_option
                                    
                                    	Redist options
                                    	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol.RedistOption>`
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol, self).__init__()

                                        self.yang_name = "bgp-protocol"
                                        self.yang_parent_name = "bgp"

                                        self.as_number = YLeaf(YType.uint32, "as-number")

                                        self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol.RedistOption()
                                        self.redist_option.parent = self
                                        self._children_name_map["redist_option"] = "redist-option"
                                        self._children_yang_names.add("redist-option")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_number") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol, self).__setattr__(name, value)


                                    class RedistOption(Entity):
                                        """
                                        Redist options
                                        
                                        .. attribute:: metric
                                        
                                        	Default metric
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: metric_type
                                        
                                        	Set OSPF External Type metrics
                                        	**type**\:  int
                                        
                                        	**range:** 1..2
                                        
                                        .. attribute:: nssa_only
                                        
                                        	Limit redistributed routes to NSSA areas
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: route_map
                                        
                                        	Routing policy or route\-map  name
                                        	**type**\:  str
                                        
                                        .. attribute:: tag
                                        
                                        	 Set tag for routes redistributed into OSPF
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol.RedistOption, self).__init__()

                                            self.yang_name = "redist-option"
                                            self.yang_parent_name = "bgp-protocol"

                                            self.metric = YLeaf(YType.uint32, "metric")

                                            self.metric_type = YLeaf(YType.uint32, "metric-type")

                                            self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                            self.route_map = YLeaf(YType.str, "route-map")

                                            self.tag = YLeaf(YType.uint32, "tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("metric",
                                                            "metric_type",
                                                            "nssa_only",
                                                            "route_map",
                                                            "tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol.RedistOption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol.RedistOption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.metric.is_set or
                                                self.metric_type.is_set or
                                                self.nssa_only.is_set or
                                                self.route_map.is_set or
                                                self.tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set or
                                                self.metric_type.yfilter != YFilter.not_set or
                                                self.nssa_only.yfilter != YFilter.not_set or
                                                self.route_map.yfilter != YFilter.not_set or
                                                self.tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "redist-option" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                            if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric_type.get_name_leafdata())
                                            if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                            if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_map.get_name_leafdata())
                                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric-type"):
                                                self.metric_type = value
                                                self.metric_type.value_namespace = name_space
                                                self.metric_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "nssa-only"):
                                                self.nssa_only = value
                                                self.nssa_only.value_namespace = name_space
                                                self.nssa_only.value_namespace_prefix = name_space_prefix
                                            if(value_path == "route-map"):
                                                self.route_map = value
                                                self.route_map.value_namespace = name_space
                                                self.route_map.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tag"):
                                                self.tag = value
                                                self.tag.value_namespace = name_space
                                                self.tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.as_number.is_set or
                                            (self.redist_option is not None and self.redist_option.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_number.yfilter != YFilter.not_set or
                                            (self.redist_option is not None and self.redist_option.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "bgp-protocol" + "[as-number='" + self.as_number.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_number.is_set or self.as_number.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_number.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "redist-option"):
                                            if (self.redist_option is None):
                                                self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol.RedistOption()
                                                self.redist_option.parent = self
                                                self._children_name_map["redist_option"] = "redist-option"
                                            return self.redist_option

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "redist-option" or name == "as-number"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-number"):
                                            self.as_number = value
                                            self.as_number.value_namespace = name_space
                                            self.as_number.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.bgp_protocol:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.bgp_protocol:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "bgp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "bgp-protocol"):
                                        for c in self.bgp_protocol:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp.BgpProtocol()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.bgp_protocol.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "bgp-protocol"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Eigrp(Entity):
                                """
                                Enhanced Interior Gateway Routing Protocol
                                (EIGRP)
                                
                                .. attribute:: eigrp_protocol
                                
                                	Enhanced Interior Gateway Routing Protocol (EIGRP)
                                	**type**\: list of    :py:class:`EigrpProtocol <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp, self).__init__()

                                    self.yang_name = "eigrp"
                                    self.yang_parent_name = "redistribution"

                                    self.eigrp_protocol = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp, self).__setattr__(name, value)


                                class EigrpProtocol(Entity):
                                    """
                                    Enhanced Interior Gateway
                                    Routing Protocol (EIGRP)
                                    
                                    .. attribute:: as_number  <key>
                                    
                                    	Autonomous system number
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    .. attribute:: redist_option
                                    
                                    	Redist options
                                    	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol.RedistOption>`
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol, self).__init__()

                                        self.yang_name = "eigrp-protocol"
                                        self.yang_parent_name = "eigrp"

                                        self.as_number = YLeaf(YType.uint16, "as-number")

                                        self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol.RedistOption()
                                        self.redist_option.parent = self
                                        self._children_name_map["redist_option"] = "redist-option"
                                        self._children_yang_names.add("redist-option")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("as_number") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol, self).__setattr__(name, value)


                                    class RedistOption(Entity):
                                        """
                                        Redist options
                                        
                                        .. attribute:: metric
                                        
                                        	Default metric
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: metric_type
                                        
                                        	Set OSPF External Type metrics
                                        	**type**\:  int
                                        
                                        	**range:** 1..2
                                        
                                        .. attribute:: nssa_only
                                        
                                        	Limit redistributed routes to NSSA areas
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: route_map
                                        
                                        	Routing policy or route\-map  name
                                        	**type**\:  str
                                        
                                        .. attribute:: tag
                                        
                                        	 Set tag for routes redistributed into OSPF
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol.RedistOption, self).__init__()

                                            self.yang_name = "redist-option"
                                            self.yang_parent_name = "eigrp-protocol"

                                            self.metric = YLeaf(YType.uint32, "metric")

                                            self.metric_type = YLeaf(YType.uint32, "metric-type")

                                            self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                            self.route_map = YLeaf(YType.str, "route-map")

                                            self.tag = YLeaf(YType.uint32, "tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("metric",
                                                            "metric_type",
                                                            "nssa_only",
                                                            "route_map",
                                                            "tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol.RedistOption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol.RedistOption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.metric.is_set or
                                                self.metric_type.is_set or
                                                self.nssa_only.is_set or
                                                self.route_map.is_set or
                                                self.tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set or
                                                self.metric_type.yfilter != YFilter.not_set or
                                                self.nssa_only.yfilter != YFilter.not_set or
                                                self.route_map.yfilter != YFilter.not_set or
                                                self.tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "redist-option" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                            if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric_type.get_name_leafdata())
                                            if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                            if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_map.get_name_leafdata())
                                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric-type"):
                                                self.metric_type = value
                                                self.metric_type.value_namespace = name_space
                                                self.metric_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "nssa-only"):
                                                self.nssa_only = value
                                                self.nssa_only.value_namespace = name_space
                                                self.nssa_only.value_namespace_prefix = name_space_prefix
                                            if(value_path == "route-map"):
                                                self.route_map = value
                                                self.route_map.value_namespace = name_space
                                                self.route_map.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tag"):
                                                self.tag = value
                                                self.tag.value_namespace = name_space
                                                self.tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.as_number.is_set or
                                            (self.redist_option is not None and self.redist_option.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.as_number.yfilter != YFilter.not_set or
                                            (self.redist_option is not None and self.redist_option.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "eigrp-protocol" + "[as-number='" + self.as_number.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.as_number.is_set or self.as_number.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.as_number.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "redist-option"):
                                            if (self.redist_option is None):
                                                self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol.RedistOption()
                                                self.redist_option.parent = self
                                                self._children_name_map["redist_option"] = "redist-option"
                                            return self.redist_option

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "redist-option" or name == "as-number"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "as-number"):
                                            self.as_number = value
                                            self.as_number.value_namespace = name_space
                                            self.as_number.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.eigrp_protocol:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.eigrp_protocol:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "eigrp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "eigrp-protocol"):
                                        for c in self.eigrp_protocol:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp.EigrpProtocol()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.eigrp_protocol.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "eigrp-protocol"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Isis(Entity):
                                """
                                ISO IS\-IS
                                
                                .. attribute:: isis_protocol
                                
                                	Intermediate system intermediate system (ISIS)
                                	**type**\: list of    :py:class:`IsisProtocol <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis, self).__init__()

                                    self.yang_name = "isis"
                                    self.yang_parent_name = "redistribution"

                                    self.isis_protocol = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis, self).__setattr__(name, value)


                                class IsisProtocol(Entity):
                                    """
                                    Intermediate system intermediate system (ISIS)
                                    
                                    .. attribute:: process_name  <key>
                                    
                                    	instance name
                                    	**type**\:  str
                                    
                                    .. attribute:: level_1
                                    
                                    	IS\-IS level\-1 routes only
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: level_1_2
                                    
                                    	IS\-IS level\-1 and level\-2 routes
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: level_2
                                    
                                    	IS\-IS level\-2 routes only
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: redist_option
                                    
                                    	Redist options
                                    	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol.RedistOption>`
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol, self).__init__()

                                        self.yang_name = "isis-protocol"
                                        self.yang_parent_name = "isis"

                                        self.process_name = YLeaf(YType.str, "process-name")

                                        self.level_1 = YLeaf(YType.empty, "level-1")

                                        self.level_1_2 = YLeaf(YType.empty, "level-1-2")

                                        self.level_2 = YLeaf(YType.empty, "level-2")

                                        self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol.RedistOption()
                                        self.redist_option.parent = self
                                        self._children_name_map["redist_option"] = "redist-option"
                                        self._children_yang_names.add("redist-option")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("process_name",
                                                        "level_1",
                                                        "level_1_2",
                                                        "level_2") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol, self).__setattr__(name, value)


                                    class RedistOption(Entity):
                                        """
                                        Redist options
                                        
                                        .. attribute:: metric
                                        
                                        	Default metric
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: metric_type
                                        
                                        	Set OSPF External Type metrics
                                        	**type**\:  int
                                        
                                        	**range:** 1..2
                                        
                                        .. attribute:: nssa_only
                                        
                                        	Limit redistributed routes to NSSA areas
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: route_map
                                        
                                        	Routing policy or route\-map  name
                                        	**type**\:  str
                                        
                                        .. attribute:: tag
                                        
                                        	 Set tag for routes redistributed into OSPF
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol.RedistOption, self).__init__()

                                            self.yang_name = "redist-option"
                                            self.yang_parent_name = "isis-protocol"

                                            self.metric = YLeaf(YType.uint32, "metric")

                                            self.metric_type = YLeaf(YType.uint32, "metric-type")

                                            self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                            self.route_map = YLeaf(YType.str, "route-map")

                                            self.tag = YLeaf(YType.uint32, "tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("metric",
                                                            "metric_type",
                                                            "nssa_only",
                                                            "route_map",
                                                            "tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol.RedistOption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol.RedistOption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.metric.is_set or
                                                self.metric_type.is_set or
                                                self.nssa_only.is_set or
                                                self.route_map.is_set or
                                                self.tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set or
                                                self.metric_type.yfilter != YFilter.not_set or
                                                self.nssa_only.yfilter != YFilter.not_set or
                                                self.route_map.yfilter != YFilter.not_set or
                                                self.tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "redist-option" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                            if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric_type.get_name_leafdata())
                                            if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                            if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_map.get_name_leafdata())
                                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric-type"):
                                                self.metric_type = value
                                                self.metric_type.value_namespace = name_space
                                                self.metric_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "nssa-only"):
                                                self.nssa_only = value
                                                self.nssa_only.value_namespace = name_space
                                                self.nssa_only.value_namespace_prefix = name_space_prefix
                                            if(value_path == "route-map"):
                                                self.route_map = value
                                                self.route_map.value_namespace = name_space
                                                self.route_map.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tag"):
                                                self.tag = value
                                                self.tag.value_namespace = name_space
                                                self.tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.process_name.is_set or
                                            self.level_1.is_set or
                                            self.level_1_2.is_set or
                                            self.level_2.is_set or
                                            (self.redist_option is not None and self.redist_option.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.process_name.yfilter != YFilter.not_set or
                                            self.level_1.yfilter != YFilter.not_set or
                                            self.level_1_2.yfilter != YFilter.not_set or
                                            self.level_2.yfilter != YFilter.not_set or
                                            (self.redist_option is not None and self.redist_option.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "isis-protocol" + "[process-name='" + self.process_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.process_name.get_name_leafdata())
                                        if (self.level_1.is_set or self.level_1.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level_1.get_name_leafdata())
                                        if (self.level_1_2.is_set or self.level_1_2.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level_1_2.get_name_leafdata())
                                        if (self.level_2.is_set or self.level_2.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level_2.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "redist-option"):
                                            if (self.redist_option is None):
                                                self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol.RedistOption()
                                                self.redist_option.parent = self
                                                self._children_name_map["redist_option"] = "redist-option"
                                            return self.redist_option

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "redist-option" or name == "process-name" or name == "level-1" or name == "level-1-2" or name == "level-2"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "process-name"):
                                            self.process_name = value
                                            self.process_name.value_namespace = name_space
                                            self.process_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "level-1"):
                                            self.level_1 = value
                                            self.level_1.value_namespace = name_space
                                            self.level_1.value_namespace_prefix = name_space_prefix
                                        if(value_path == "level-1-2"):
                                            self.level_1_2 = value
                                            self.level_1_2.value_namespace = name_space
                                            self.level_1_2.value_namespace_prefix = name_space_prefix
                                        if(value_path == "level-2"):
                                            self.level_2 = value
                                            self.level_2.value_namespace = name_space
                                            self.level_2.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.isis_protocol:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.isis_protocol:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "isis" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "isis-protocol"):
                                        for c in self.isis_protocol:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis.IsisProtocol()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.isis_protocol.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "isis-protocol"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Applications(Entity):
                                """
                                Application
                                
                                .. attribute:: application
                                
                                	Application routes
                                	**type**\: list of    :py:class:`Application <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications, self).__init__()

                                    self.yang_name = "applications"
                                    self.yang_parent_name = "redistribution"

                                    self.application = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications, self).__setattr__(name, value)


                                class Application(Entity):
                                    """
                                    Application routes
                                    
                                    .. attribute:: application_name  <key>
                                    
                                    	application name
                                    	**type**\:  str
                                    
                                    .. attribute:: redist_option
                                    
                                    	Redist options
                                    	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application.RedistOption>`
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application, self).__init__()

                                        self.yang_name = "application"
                                        self.yang_parent_name = "applications"

                                        self.application_name = YLeaf(YType.str, "application-name")

                                        self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application.RedistOption()
                                        self.redist_option.parent = self
                                        self._children_name_map["redist_option"] = "redist-option"
                                        self._children_yang_names.add("redist-option")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("application_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application, self).__setattr__(name, value)


                                    class RedistOption(Entity):
                                        """
                                        Redist options
                                        
                                        .. attribute:: metric
                                        
                                        	Default metric
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: metric_type
                                        
                                        	Set OSPF External Type metrics
                                        	**type**\:  int
                                        
                                        	**range:** 1..2
                                        
                                        .. attribute:: nssa_only
                                        
                                        	Limit redistributed routes to NSSA areas
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: route_map
                                        
                                        	Routing policy or route\-map  name
                                        	**type**\:  str
                                        
                                        .. attribute:: tag
                                        
                                        	 Set tag for routes redistributed into OSPF
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application.RedistOption, self).__init__()

                                            self.yang_name = "redist-option"
                                            self.yang_parent_name = "application"

                                            self.metric = YLeaf(YType.uint32, "metric")

                                            self.metric_type = YLeaf(YType.uint32, "metric-type")

                                            self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                            self.route_map = YLeaf(YType.str, "route-map")

                                            self.tag = YLeaf(YType.uint32, "tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("metric",
                                                            "metric_type",
                                                            "nssa_only",
                                                            "route_map",
                                                            "tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application.RedistOption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application.RedistOption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.metric.is_set or
                                                self.metric_type.is_set or
                                                self.nssa_only.is_set or
                                                self.route_map.is_set or
                                                self.tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set or
                                                self.metric_type.yfilter != YFilter.not_set or
                                                self.nssa_only.yfilter != YFilter.not_set or
                                                self.route_map.yfilter != YFilter.not_set or
                                                self.tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "redist-option" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                            if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric_type.get_name_leafdata())
                                            if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                            if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_map.get_name_leafdata())
                                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric-type"):
                                                self.metric_type = value
                                                self.metric_type.value_namespace = name_space
                                                self.metric_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "nssa-only"):
                                                self.nssa_only = value
                                                self.nssa_only.value_namespace = name_space
                                                self.nssa_only.value_namespace_prefix = name_space_prefix
                                            if(value_path == "route-map"):
                                                self.route_map = value
                                                self.route_map.value_namespace = name_space
                                                self.route_map.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tag"):
                                                self.tag = value
                                                self.tag.value_namespace = name_space
                                                self.tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.application_name.is_set or
                                            (self.redist_option is not None and self.redist_option.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.application_name.yfilter != YFilter.not_set or
                                            (self.redist_option is not None and self.redist_option.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "application" + "[application-name='" + self.application_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.application_name.is_set or self.application_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.application_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "redist-option"):
                                            if (self.redist_option is None):
                                                self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application.RedistOption()
                                                self.redist_option.parent = self
                                                self._children_name_map["redist_option"] = "redist-option"
                                            return self.redist_option

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "redist-option" or name == "application-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "application-name"):
                                            self.application_name = value
                                            self.application_name.value_namespace = name_space
                                            self.application_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.application:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.application:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "applications" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "application"):
                                        for c in self.application:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications.Application()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.application.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "application"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Ospf(Entity):
                                """
                                Open Shortest Path First (OSPF)
                                
                                .. attribute:: ospf
                                
                                	Open Shortest Path First (OSPF)
                                	**type**\: list of    :py:class:`Ospf <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf, self).__init__()

                                    self.yang_name = "ospf"
                                    self.yang_parent_name = "redistribution"

                                    self.ospf = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf, self).__setattr__(name, value)


                                class Ospf(Entity):
                                    """
                                    Open Shortest Path First (OSPF)
                                    
                                    .. attribute:: id_or_name  <key>
                                    
                                    	Process id or Name
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  int
                                    
                                    	**range:** 1..65535
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    
                                    ----
                                    .. attribute:: match
                                    
                                    	Redistribution of OSPF routes
                                    	**type**\:   :py:class:`Match <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match>`
                                    
                                    .. attribute:: redist_option
                                    
                                    	Redist options
                                    	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.RedistOption>`
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf, self).__init__()

                                        self.yang_name = "ospf"
                                        self.yang_parent_name = "ospf"

                                        self.id_or_name = YLeaf(YType.str, "id-or-name")

                                        self.match = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match()
                                        self.match.parent = self
                                        self._children_name_map["match"] = "match"
                                        self._children_yang_names.add("match")

                                        self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.RedistOption()
                                        self.redist_option.parent = self
                                        self._children_name_map["redist_option"] = "redist-option"
                                        self._children_yang_names.add("redist-option")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("id_or_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf, self).__setattr__(name, value)


                                    class Match(Entity):
                                        """
                                        Redistribution of OSPF routes
                                        
                                        .. attribute:: external
                                        
                                        	Redistribute OSPF external routes
                                        	**type**\:   :py:class:`External <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.External>`
                                        
                                        	**presence node**\: True
                                        
                                        .. attribute:: internal
                                        
                                        	Redistribute OSPF internal routes
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: nssa_external
                                        
                                        	Redistribute OSPF NSSA external routes
                                        	**type**\:   :py:class:`NssaExternal <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.NssaExternal>`
                                        
                                        	**presence node**\: True
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match, self).__init__()

                                            self.yang_name = "match"
                                            self.yang_parent_name = "ospf"

                                            self.internal = YLeaf(YType.empty, "internal")

                                            self.external = None
                                            self._children_name_map["external"] = "external"
                                            self._children_yang_names.add("external")

                                            self.nssa_external = None
                                            self._children_name_map["nssa_external"] = "nssa-external"
                                            self._children_yang_names.add("nssa-external")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("internal") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match, self).__setattr__(name, value)


                                        class External(Entity):
                                            """
                                            Redistribute OSPF external routes
                                            
                                            .. attribute:: external_routes
                                            
                                            	Redistribute OSPF external routes
                                            	**type**\:   :py:class:`OspfExternalType <ydk.models.cisco_ios_xe.cisco_ospf.OspfExternalType>`
                                            
                                            

                                            This class is a :ref:`presence class<presence-class>`

                                            """

                                            _prefix = 'cisco-ospf'
                                            _revision = '2016-03-30'

                                            def __init__(self):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.External, self).__init__()

                                                self.yang_name = "external"
                                                self.yang_parent_name = "match"
                                                self.is_presence_container = True

                                                self.external_routes = YLeaf(YType.enumeration, "external-routes")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("external_routes") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.External, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.External, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.external_routes.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.external_routes.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "external" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.external_routes.is_set or self.external_routes.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.external_routes.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "external-routes"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "external-routes"):
                                                    self.external_routes = value
                                                    self.external_routes.value_namespace = name_space
                                                    self.external_routes.value_namespace_prefix = name_space_prefix


                                        class NssaExternal(Entity):
                                            """
                                            Redistribute OSPF NSSA external routes
                                            
                                            .. attribute:: nssa_external_routes
                                            
                                            	NSSA external routes
                                            	**type**\:   :py:class:`OspfExternalType <ydk.models.cisco_ios_xe.cisco_ospf.OspfExternalType>`
                                            
                                            

                                            This class is a :ref:`presence class<presence-class>`

                                            """

                                            _prefix = 'cisco-ospf'
                                            _revision = '2016-03-30'

                                            def __init__(self):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.NssaExternal, self).__init__()

                                                self.yang_name = "nssa-external"
                                                self.yang_parent_name = "match"
                                                self.is_presence_container = True

                                                self.nssa_external_routes = YLeaf(YType.enumeration, "nssa-external-routes")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("nssa_external_routes") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.NssaExternal, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.NssaExternal, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.nssa_external_routes.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.nssa_external_routes.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "nssa-external" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.nssa_external_routes.is_set or self.nssa_external_routes.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.nssa_external_routes.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "nssa-external-routes"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "nssa-external-routes"):
                                                    self.nssa_external_routes = value
                                                    self.nssa_external_routes.value_namespace = name_space
                                                    self.nssa_external_routes.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.internal.is_set or
                                                (self.external is not None) or
                                                (self.nssa_external is not None))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.internal.yfilter != YFilter.not_set or
                                                (self.external is not None and self.external.has_operation()) or
                                                (self.nssa_external is not None and self.nssa_external.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "match" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.internal.is_set or self.internal.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.internal.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "external"):
                                                if (self.external is None):
                                                    self.external = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.External()
                                                    self.external.parent = self
                                                    self._children_name_map["external"] = "external"
                                                return self.external

                                            if (child_yang_name == "nssa-external"):
                                                if (self.nssa_external is None):
                                                    self.nssa_external = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match.NssaExternal()
                                                    self.nssa_external.parent = self
                                                    self._children_name_map["nssa_external"] = "nssa-external"
                                                return self.nssa_external

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external" or name == "nssa-external" or name == "internal"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "internal"):
                                                self.internal = value
                                                self.internal.value_namespace = name_space
                                                self.internal.value_namespace_prefix = name_space_prefix


                                    class RedistOption(Entity):
                                        """
                                        Redist options
                                        
                                        .. attribute:: metric
                                        
                                        	Default metric
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: metric_type
                                        
                                        	Set OSPF External Type metrics
                                        	**type**\:  int
                                        
                                        	**range:** 1..2
                                        
                                        .. attribute:: nssa_only
                                        
                                        	Limit redistributed routes to NSSA areas
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: route_map
                                        
                                        	Routing policy or route\-map  name
                                        	**type**\:  str
                                        
                                        .. attribute:: tag
                                        
                                        	 Set tag for routes redistributed into OSPF
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.RedistOption, self).__init__()

                                            self.yang_name = "redist-option"
                                            self.yang_parent_name = "ospf"

                                            self.metric = YLeaf(YType.uint32, "metric")

                                            self.metric_type = YLeaf(YType.uint32, "metric-type")

                                            self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                            self.route_map = YLeaf(YType.str, "route-map")

                                            self.tag = YLeaf(YType.uint32, "tag")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("metric",
                                                            "metric_type",
                                                            "nssa_only",
                                                            "route_map",
                                                            "tag") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.RedistOption, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.RedistOption, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.metric.is_set or
                                                self.metric_type.is_set or
                                                self.nssa_only.is_set or
                                                self.route_map.is_set or
                                                self.tag.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.metric.yfilter != YFilter.not_set or
                                                self.metric_type.yfilter != YFilter.not_set or
                                                self.nssa_only.yfilter != YFilter.not_set or
                                                self.route_map.yfilter != YFilter.not_set or
                                                self.tag.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "redist-option" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric.get_name_leafdata())
                                            if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.metric_type.get_name_leafdata())
                                            if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                            if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_map.get_name_leafdata())
                                            if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tag.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "metric"):
                                                self.metric = value
                                                self.metric.value_namespace = name_space
                                                self.metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "metric-type"):
                                                self.metric_type = value
                                                self.metric_type.value_namespace = name_space
                                                self.metric_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "nssa-only"):
                                                self.nssa_only = value
                                                self.nssa_only.value_namespace = name_space
                                                self.nssa_only.value_namespace_prefix = name_space_prefix
                                            if(value_path == "route-map"):
                                                self.route_map = value
                                                self.route_map.value_namespace = name_space
                                                self.route_map.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tag"):
                                                self.tag = value
                                                self.tag.value_namespace = name_space
                                                self.tag.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.id_or_name.is_set or
                                            (self.match is not None and self.match.has_data()) or
                                            (self.redist_option is not None and self.redist_option.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.id_or_name.yfilter != YFilter.not_set or
                                            (self.match is not None and self.match.has_operation()) or
                                            (self.redist_option is not None and self.redist_option.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ospf" + "[id-or-name='" + self.id_or_name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.id_or_name.is_set or self.id_or_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.id_or_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "match"):
                                            if (self.match is None):
                                                self.match = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.Match()
                                                self.match.parent = self
                                                self._children_name_map["match"] = "match"
                                            return self.match

                                        if (child_yang_name == "redist-option"):
                                            if (self.redist_option is None):
                                                self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf.RedistOption()
                                                self.redist_option.parent = self
                                                self._children_name_map["redist_option"] = "redist-option"
                                            return self.redist_option

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "match" or name == "redist-option" or name == "id-or-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "id-or-name"):
                                            self.id_or_name = value
                                            self.id_or_name.value_namespace = name_space
                                            self.id_or_name.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.ospf:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.ospf:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ospf" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ospf"):
                                        for c in self.ospf:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf.Ospf()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.ospf.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ospf"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Rip(Entity):
                                """
                                rip routes
                                
                                .. attribute:: redist_option
                                
                                	Redist options
                                	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip.RedistOption>`
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip, self).__init__()

                                    self.yang_name = "rip"
                                    self.yang_parent_name = "redistribution"
                                    self.is_presence_container = True

                                    self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip.RedistOption()
                                    self.redist_option.parent = self
                                    self._children_name_map["redist_option"] = "redist-option"
                                    self._children_yang_names.add("redist-option")


                                class RedistOption(Entity):
                                    """
                                    Redist options
                                    
                                    .. attribute:: metric
                                    
                                    	Default metric
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	Set OSPF External Type metrics
                                    	**type**\:  int
                                    
                                    	**range:** 1..2
                                    
                                    .. attribute:: nssa_only
                                    
                                    	Limit redistributed routes to NSSA areas
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: route_map
                                    
                                    	Routing policy or route\-map  name
                                    	**type**\:  str
                                    
                                    .. attribute:: tag
                                    
                                    	 Set tag for routes redistributed into OSPF
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip.RedistOption, self).__init__()

                                        self.yang_name = "redist-option"
                                        self.yang_parent_name = "rip"

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.uint32, "metric-type")

                                        self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                        self.route_map = YLeaf(YType.str, "route-map")

                                        self.tag = YLeaf(YType.uint32, "tag")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("metric",
                                                        "metric_type",
                                                        "nssa_only",
                                                        "route_map",
                                                        "tag") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip.RedistOption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip.RedistOption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.nssa_only.is_set or
                                            self.route_map.is_set or
                                            self.tag.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.nssa_only.yfilter != YFilter.not_set or
                                            self.route_map.yfilter != YFilter.not_set or
                                            self.tag.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "redist-option" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                        if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_map.get_name_leafdata())
                                        if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tag.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nssa-only"):
                                            self.nssa_only = value
                                            self.nssa_only.value_namespace = name_space
                                            self.nssa_only.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-map"):
                                            self.route_map = value
                                            self.route_map.value_namespace = name_space
                                            self.route_map.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tag"):
                                            self.tag = value
                                            self.tag.value_namespace = name_space
                                            self.tag.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.redist_option is not None and self.redist_option.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.redist_option is not None and self.redist_option.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "rip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "redist-option"):
                                        if (self.redist_option is None):
                                            self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip.RedistOption()
                                            self.redist_option.parent = self
                                            self._children_name_map["redist_option"] = "redist-option"
                                        return self.redist_option

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "redist-option"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Static(Entity):
                                """
                                Static routes
                                
                                .. attribute:: redist_option
                                
                                	Redist options
                                	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static.RedistOption>`
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static, self).__init__()

                                    self.yang_name = "static"
                                    self.yang_parent_name = "redistribution"
                                    self.is_presence_container = True

                                    self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static.RedistOption()
                                    self.redist_option.parent = self
                                    self._children_name_map["redist_option"] = "redist-option"
                                    self._children_yang_names.add("redist-option")


                                class RedistOption(Entity):
                                    """
                                    Redist options
                                    
                                    .. attribute:: metric
                                    
                                    	Default metric
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	Set OSPF External Type metrics
                                    	**type**\:  int
                                    
                                    	**range:** 1..2
                                    
                                    .. attribute:: nssa_only
                                    
                                    	Limit redistributed routes to NSSA areas
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: route_map
                                    
                                    	Routing policy or route\-map  name
                                    	**type**\:  str
                                    
                                    .. attribute:: tag
                                    
                                    	 Set tag for routes redistributed into OSPF
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static.RedistOption, self).__init__()

                                        self.yang_name = "redist-option"
                                        self.yang_parent_name = "static"

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.uint32, "metric-type")

                                        self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                        self.route_map = YLeaf(YType.str, "route-map")

                                        self.tag = YLeaf(YType.uint32, "tag")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("metric",
                                                        "metric_type",
                                                        "nssa_only",
                                                        "route_map",
                                                        "tag") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static.RedistOption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static.RedistOption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.nssa_only.is_set or
                                            self.route_map.is_set or
                                            self.tag.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.nssa_only.yfilter != YFilter.not_set or
                                            self.route_map.yfilter != YFilter.not_set or
                                            self.tag.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "redist-option" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                        if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_map.get_name_leafdata())
                                        if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tag.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nssa-only"):
                                            self.nssa_only = value
                                            self.nssa_only.value_namespace = name_space
                                            self.nssa_only.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-map"):
                                            self.route_map = value
                                            self.route_map.value_namespace = name_space
                                            self.route_map.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tag"):
                                            self.tag = value
                                            self.tag.value_namespace = name_space
                                            self.tag.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.redist_option is not None and self.redist_option.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.redist_option is not None and self.redist_option.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "static" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "redist-option"):
                                        if (self.redist_option is None):
                                            self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static.RedistOption()
                                            self.redist_option.parent = self
                                            self._children_name_map["redist_option"] = "redist-option"
                                        return self.redist_option

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "redist-option"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Subscriber(Entity):
                                """
                                Subscriber routes
                                
                                .. attribute:: redist_option
                                
                                	Redist options
                                	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber.RedistOption>`
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber, self).__init__()

                                    self.yang_name = "subscriber"
                                    self.yang_parent_name = "redistribution"
                                    self.is_presence_container = True

                                    self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber.RedistOption()
                                    self.redist_option.parent = self
                                    self._children_name_map["redist_option"] = "redist-option"
                                    self._children_yang_names.add("redist-option")


                                class RedistOption(Entity):
                                    """
                                    Redist options
                                    
                                    .. attribute:: metric
                                    
                                    	Default metric
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	Set OSPF External Type metrics
                                    	**type**\:  int
                                    
                                    	**range:** 1..2
                                    
                                    .. attribute:: nssa_only
                                    
                                    	Limit redistributed routes to NSSA areas
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: route_map
                                    
                                    	Routing policy or route\-map  name
                                    	**type**\:  str
                                    
                                    .. attribute:: tag
                                    
                                    	 Set tag for routes redistributed into OSPF
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber.RedistOption, self).__init__()

                                        self.yang_name = "redist-option"
                                        self.yang_parent_name = "subscriber"

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.uint32, "metric-type")

                                        self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                        self.route_map = YLeaf(YType.str, "route-map")

                                        self.tag = YLeaf(YType.uint32, "tag")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("metric",
                                                        "metric_type",
                                                        "nssa_only",
                                                        "route_map",
                                                        "tag") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber.RedistOption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber.RedistOption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.nssa_only.is_set or
                                            self.route_map.is_set or
                                            self.tag.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.nssa_only.yfilter != YFilter.not_set or
                                            self.route_map.yfilter != YFilter.not_set or
                                            self.tag.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "redist-option" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                        if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_map.get_name_leafdata())
                                        if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tag.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nssa-only"):
                                            self.nssa_only = value
                                            self.nssa_only.value_namespace = name_space
                                            self.nssa_only.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-map"):
                                            self.route_map = value
                                            self.route_map.value_namespace = name_space
                                            self.route_map.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tag"):
                                            self.tag = value
                                            self.tag.value_namespace = name_space
                                            self.tag.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.redist_option is not None and self.redist_option.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.redist_option is not None and self.redist_option.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "subscriber" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "redist-option"):
                                        if (self.redist_option is None):
                                            self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber.RedistOption()
                                            self.redist_option.parent = self
                                            self._children_name_map["redist_option"] = "redist-option"
                                        return self.redist_option

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "redist-option"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Connected(Entity):
                                """
                                Connected routes
                                
                                .. attribute:: redist_option
                                
                                	Redist options
                                	**type**\:   :py:class:`RedistOption <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected.RedistOption>`
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected, self).__init__()

                                    self.yang_name = "connected"
                                    self.yang_parent_name = "redistribution"
                                    self.is_presence_container = True

                                    self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected.RedistOption()
                                    self.redist_option.parent = self
                                    self._children_name_map["redist_option"] = "redist-option"
                                    self._children_yang_names.add("redist-option")


                                class RedistOption(Entity):
                                    """
                                    Redist options
                                    
                                    .. attribute:: metric
                                    
                                    	Default metric
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777215
                                    
                                    .. attribute:: metric_type
                                    
                                    	Set OSPF External Type metrics
                                    	**type**\:  int
                                    
                                    	**range:** 1..2
                                    
                                    .. attribute:: nssa_only
                                    
                                    	Limit redistributed routes to NSSA areas
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: route_map
                                    
                                    	Routing policy or route\-map  name
                                    	**type**\:  str
                                    
                                    .. attribute:: tag
                                    
                                    	 Set tag for routes redistributed into OSPF
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected.RedistOption, self).__init__()

                                        self.yang_name = "redist-option"
                                        self.yang_parent_name = "connected"

                                        self.metric = YLeaf(YType.uint32, "metric")

                                        self.metric_type = YLeaf(YType.uint32, "metric-type")

                                        self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                        self.route_map = YLeaf(YType.str, "route-map")

                                        self.tag = YLeaf(YType.uint32, "tag")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("metric",
                                                        "metric_type",
                                                        "nssa_only",
                                                        "route_map",
                                                        "tag") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected.RedistOption, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected.RedistOption, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.metric.is_set or
                                            self.metric_type.is_set or
                                            self.nssa_only.is_set or
                                            self.route_map.is_set or
                                            self.tag.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.metric.yfilter != YFilter.not_set or
                                            self.metric_type.yfilter != YFilter.not_set or
                                            self.nssa_only.yfilter != YFilter.not_set or
                                            self.route_map.yfilter != YFilter.not_set or
                                            self.tag.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "redist-option" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric.get_name_leafdata())
                                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.metric_type.get_name_leafdata())
                                        if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                        if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_map.get_name_leafdata())
                                        if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tag.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "metric" or name == "metric-type" or name == "nssa-only" or name == "route-map" or name == "tag"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "metric"):
                                            self.metric = value
                                            self.metric.value_namespace = name_space
                                            self.metric.value_namespace_prefix = name_space_prefix
                                        if(value_path == "metric-type"):
                                            self.metric_type = value
                                            self.metric_type.value_namespace = name_space
                                            self.metric_type.value_namespace_prefix = name_space_prefix
                                        if(value_path == "nssa-only"):
                                            self.nssa_only = value
                                            self.nssa_only.value_namespace = name_space
                                            self.nssa_only.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-map"):
                                            self.route_map = value
                                            self.route_map.value_namespace = name_space
                                            self.route_map.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tag"):
                                            self.tag = value
                                            self.tag.value_namespace = name_space
                                            self.tag.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (self.redist_option is not None and self.redist_option.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.redist_option is not None and self.redist_option.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "connected" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "redist-option"):
                                        if (self.redist_option is None):
                                            self.redist_option = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected.RedistOption()
                                            self.redist_option.parent = self
                                            self._children_name_map["redist_option"] = "redist-option"
                                        return self.redist_option

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "redist-option"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    (self.applications is not None and self.applications.has_data()) or
                                    (self.bgp is not None and self.bgp.has_data()) or
                                    (self.eigrp is not None and self.eigrp.has_data()) or
                                    (self.isis is not None and self.isis.has_data()) or
                                    (self.ospf is not None and self.ospf.has_data()) or
                                    (self.connected is not None) or
                                    (self.maximum_prefix is not None) or
                                    (self.rip is not None) or
                                    (self.static is not None) or
                                    (self.subscriber is not None))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.applications is not None and self.applications.has_operation()) or
                                    (self.bgp is not None and self.bgp.has_operation()) or
                                    (self.connected is not None and self.connected.has_operation()) or
                                    (self.eigrp is not None and self.eigrp.has_operation()) or
                                    (self.isis is not None and self.isis.has_operation()) or
                                    (self.maximum_prefix is not None and self.maximum_prefix.has_operation()) or
                                    (self.ospf is not None and self.ospf.has_operation()) or
                                    (self.rip is not None and self.rip.has_operation()) or
                                    (self.static is not None and self.static.has_operation()) or
                                    (self.subscriber is not None and self.subscriber.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:redistribution" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "applications"):
                                    if (self.applications is None):
                                        self.applications = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Applications()
                                        self.applications.parent = self
                                        self._children_name_map["applications"] = "applications"
                                    return self.applications

                                if (child_yang_name == "bgp"):
                                    if (self.bgp is None):
                                        self.bgp = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Bgp()
                                        self.bgp.parent = self
                                        self._children_name_map["bgp"] = "bgp"
                                    return self.bgp

                                if (child_yang_name == "connected"):
                                    if (self.connected is None):
                                        self.connected = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Connected()
                                        self.connected.parent = self
                                        self._children_name_map["connected"] = "connected"
                                    return self.connected

                                if (child_yang_name == "eigrp"):
                                    if (self.eigrp is None):
                                        self.eigrp = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Eigrp()
                                        self.eigrp.parent = self
                                        self._children_name_map["eigrp"] = "eigrp"
                                    return self.eigrp

                                if (child_yang_name == "isis"):
                                    if (self.isis is None):
                                        self.isis = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Isis()
                                        self.isis.parent = self
                                        self._children_name_map["isis"] = "isis"
                                    return self.isis

                                if (child_yang_name == "maximum-prefix"):
                                    if (self.maximum_prefix is None):
                                        self.maximum_prefix = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.MaximumPrefix()
                                        self.maximum_prefix.parent = self
                                        self._children_name_map["maximum_prefix"] = "maximum-prefix"
                                    return self.maximum_prefix

                                if (child_yang_name == "ospf"):
                                    if (self.ospf is None):
                                        self.ospf = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Ospf()
                                        self.ospf.parent = self
                                        self._children_name_map["ospf"] = "ospf"
                                    return self.ospf

                                if (child_yang_name == "rip"):
                                    if (self.rip is None):
                                        self.rip = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Rip()
                                        self.rip.parent = self
                                        self._children_name_map["rip"] = "rip"
                                    return self.rip

                                if (child_yang_name == "static"):
                                    if (self.static is None):
                                        self.static = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Static()
                                        self.static.parent = self
                                        self._children_name_map["static"] = "static"
                                    return self.static

                                if (child_yang_name == "subscriber"):
                                    if (self.subscriber is None):
                                        self.subscriber = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution.Subscriber()
                                        self.subscriber.parent = self
                                        self._children_name_map["subscriber"] = "subscriber"
                                    return self.subscriber

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "applications" or name == "bgp" or name == "connected" or name == "eigrp" or name == "isis" or name == "maximum-prefix" or name == "ospf" or name == "rip" or name == "static" or name == "subscriber"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class ReloadControl(Entity):
                            """
                            Protocol reload control.
                            
                            .. attribute:: max_metric
                            
                            	Set maximum metric configuration
                            	**type**\:   :py:class:`MaxMetric <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl, self).__init__()

                                self.yang_name = "reload-control"
                                self.yang_parent_name = "instance"

                                self.max_metric = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric()
                                self.max_metric.parent = self
                                self._children_name_map["max_metric"] = "max-metric"
                                self._children_yang_names.add("max-metric")


                            class MaxMetric(Entity):
                                """
                                Set maximum metric configuration
                                
                                .. attribute:: always
                                
                                	Set maximum metric always configuration
                                	**type**\:   :py:class:`Always <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always>`
                                
                                .. attribute:: on_proc_migration
                                
                                	Set maximum metric on\-proc\-migration configuration
                                	**type**\:   :py:class:`OnProcMigration <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration>`
                                
                                .. attribute:: on_proc_restart
                                
                                	Set maximum metric on\-proc\-restart configuration
                                	**type**\:   :py:class:`OnProcRestart <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart>`
                                
                                .. attribute:: on_startup
                                
                                	Set maximum metric on\-startup configuration
                                	**type**\:   :py:class:`OnStartup <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup>`
                                
                                .. attribute:: on_switchover
                                
                                	Set maximum metric on\-switchover configuration
                                	**type**\:   :py:class:`OnSwitchover <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric, self).__init__()

                                    self.yang_name = "max-metric"
                                    self.yang_parent_name = "reload-control"

                                    self.always = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always()
                                    self.always.parent = self
                                    self._children_name_map["always"] = "always"
                                    self._children_yang_names.add("always")

                                    self.on_proc_migration = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration()
                                    self.on_proc_migration.parent = self
                                    self._children_name_map["on_proc_migration"] = "on-proc-migration"
                                    self._children_yang_names.add("on-proc-migration")

                                    self.on_proc_restart = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart()
                                    self.on_proc_restart.parent = self
                                    self._children_name_map["on_proc_restart"] = "on-proc-restart"
                                    self._children_yang_names.add("on-proc-restart")

                                    self.on_startup = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup()
                                    self.on_startup.parent = self
                                    self._children_name_map["on_startup"] = "on-startup"
                                    self._children_yang_names.add("on-startup")

                                    self.on_switchover = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover()
                                    self.on_switchover.parent = self
                                    self._children_name_map["on_switchover"] = "on-switchover"
                                    self._children_yang_names.add("on-switchover")


                                class OnProcRestart(Entity):
                                    """
                                    Set maximum metric on\-proc\-restart configuration
                                    
                                    .. attribute:: max_metric_options
                                    
                                    	max metric options
                                    	**type**\:   :py:class:`MaxMetricOptions <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart.MaxMetricOptions>`
                                    
                                    .. attribute:: time
                                    
                                    	Till how much time originate router\-LSA with max\-metric
                                    	**type**\:  int
                                    
                                    	**range:** 5..86400
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: wait_for_bgp
                                    
                                    	Till BGP converge originate router\-LSA with max metric
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart, self).__init__()

                                        self.yang_name = "on-proc-restart"
                                        self.yang_parent_name = "max-metric"

                                        self.time = YLeaf(YType.uint32, "time")

                                        self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                        self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart.MaxMetricOptions()
                                        self.max_metric_options.parent = self
                                        self._children_name_map["max_metric_options"] = "max-metric-options"
                                        self._children_yang_names.add("max-metric-options")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("time",
                                                        "wait_for_bgp") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart, self).__setattr__(name, value)


                                    class MaxMetricOptions(Entity):
                                        """
                                        max metric options
                                        
                                        .. attribute:: external_lsa
                                        
                                        	Override external\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: external_lsa_metric
                                        
                                        	Overriding metric in external\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: include_stub
                                        
                                        	Set maximum metric for stub links in router\-LSAs
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa
                                        
                                        	Override summary\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa_metric
                                        
                                        	Overriding metric in summary\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart.MaxMetricOptions, self).__init__()

                                            self.yang_name = "max-metric-options"
                                            self.yang_parent_name = "on-proc-restart"

                                            self.external_lsa = YLeaf(YType.boolean, "external-lsa")

                                            self.external_lsa_metric = YLeaf(YType.uint32, "external-lsa-metric")

                                            self.include_stub = YLeaf(YType.boolean, "include-stub")

                                            self.summary_lsa = YLeaf(YType.boolean, "summary-lsa")

                                            self.summary_lsa_metric = YLeaf(YType.uint32, "summary-lsa-metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("external_lsa",
                                                            "external_lsa_metric",
                                                            "include_stub",
                                                            "summary_lsa",
                                                            "summary_lsa_metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart.MaxMetricOptions, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart.MaxMetricOptions, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.external_lsa.is_set or
                                                self.external_lsa_metric.is_set or
                                                self.include_stub.is_set or
                                                self.summary_lsa.is_set or
                                                self.summary_lsa_metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.external_lsa.yfilter != YFilter.not_set or
                                                self.external_lsa_metric.yfilter != YFilter.not_set or
                                                self.include_stub.yfilter != YFilter.not_set or
                                                self.summary_lsa.yfilter != YFilter.not_set or
                                                self.summary_lsa_metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "max-metric-options" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                            if (self.external_lsa_metric.is_set or self.external_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa_metric.get_name_leafdata())
                                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())
                                            if (self.summary_lsa_metric.is_set or self.summary_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa_metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external-lsa" or name == "external-lsa-metric" or name == "include-stub" or name == "summary-lsa" or name == "summary-lsa-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "external-lsa"):
                                                self.external_lsa = value
                                                self.external_lsa.value_namespace = name_space
                                                self.external_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "external-lsa-metric"):
                                                self.external_lsa_metric = value
                                                self.external_lsa_metric.value_namespace = name_space
                                                self.external_lsa_metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "include-stub"):
                                                self.include_stub = value
                                                self.include_stub.value_namespace = name_space
                                                self.include_stub.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa"):
                                                self.summary_lsa = value
                                                self.summary_lsa.value_namespace = name_space
                                                self.summary_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa-metric"):
                                                self.summary_lsa_metric = value
                                                self.summary_lsa_metric.value_namespace = name_space
                                                self.summary_lsa_metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.time.is_set or
                                            self.wait_for_bgp.is_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.time.yfilter != YFilter.not_set or
                                            self.wait_for_bgp.yfilter != YFilter.not_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "on-proc-restart" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.time.is_set or self.time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.time.get_name_leafdata())
                                        if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "max-metric-options"):
                                            if (self.max_metric_options is None):
                                                self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart.MaxMetricOptions()
                                                self.max_metric_options.parent = self
                                                self._children_name_map["max_metric_options"] = "max-metric-options"
                                            return self.max_metric_options

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "max-metric-options" or name == "time" or name == "wait-for-bgp"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "time"):
                                            self.time = value
                                            self.time.value_namespace = name_space
                                            self.time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wait-for-bgp"):
                                            self.wait_for_bgp = value
                                            self.wait_for_bgp.value_namespace = name_space
                                            self.wait_for_bgp.value_namespace_prefix = name_space_prefix


                                class OnStartup(Entity):
                                    """
                                    Set maximum metric on\-startup configuration
                                    
                                    .. attribute:: max_metric_options
                                    
                                    	max metric options
                                    	**type**\:   :py:class:`MaxMetricOptions <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup.MaxMetricOptions>`
                                    
                                    .. attribute:: time
                                    
                                    	Till how much time originate router\-LSA with max\-metric
                                    	**type**\:  int
                                    
                                    	**range:** 5..86400
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: wait_for_bgp
                                    
                                    	Till BGP converge originate router\-LSA with max metric
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup, self).__init__()

                                        self.yang_name = "on-startup"
                                        self.yang_parent_name = "max-metric"

                                        self.time = YLeaf(YType.uint32, "time")

                                        self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                        self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup.MaxMetricOptions()
                                        self.max_metric_options.parent = self
                                        self._children_name_map["max_metric_options"] = "max-metric-options"
                                        self._children_yang_names.add("max-metric-options")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("time",
                                                        "wait_for_bgp") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup, self).__setattr__(name, value)


                                    class MaxMetricOptions(Entity):
                                        """
                                        max metric options
                                        
                                        .. attribute:: external_lsa
                                        
                                        	Override external\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: external_lsa_metric
                                        
                                        	Overriding metric in external\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: include_stub
                                        
                                        	Set maximum metric for stub links in router\-LSAs
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa
                                        
                                        	Override summary\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa_metric
                                        
                                        	Overriding metric in summary\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup.MaxMetricOptions, self).__init__()

                                            self.yang_name = "max-metric-options"
                                            self.yang_parent_name = "on-startup"

                                            self.external_lsa = YLeaf(YType.boolean, "external-lsa")

                                            self.external_lsa_metric = YLeaf(YType.uint32, "external-lsa-metric")

                                            self.include_stub = YLeaf(YType.boolean, "include-stub")

                                            self.summary_lsa = YLeaf(YType.boolean, "summary-lsa")

                                            self.summary_lsa_metric = YLeaf(YType.uint32, "summary-lsa-metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("external_lsa",
                                                            "external_lsa_metric",
                                                            "include_stub",
                                                            "summary_lsa",
                                                            "summary_lsa_metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup.MaxMetricOptions, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup.MaxMetricOptions, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.external_lsa.is_set or
                                                self.external_lsa_metric.is_set or
                                                self.include_stub.is_set or
                                                self.summary_lsa.is_set or
                                                self.summary_lsa_metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.external_lsa.yfilter != YFilter.not_set or
                                                self.external_lsa_metric.yfilter != YFilter.not_set or
                                                self.include_stub.yfilter != YFilter.not_set or
                                                self.summary_lsa.yfilter != YFilter.not_set or
                                                self.summary_lsa_metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "max-metric-options" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                            if (self.external_lsa_metric.is_set or self.external_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa_metric.get_name_leafdata())
                                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())
                                            if (self.summary_lsa_metric.is_set or self.summary_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa_metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external-lsa" or name == "external-lsa-metric" or name == "include-stub" or name == "summary-lsa" or name == "summary-lsa-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "external-lsa"):
                                                self.external_lsa = value
                                                self.external_lsa.value_namespace = name_space
                                                self.external_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "external-lsa-metric"):
                                                self.external_lsa_metric = value
                                                self.external_lsa_metric.value_namespace = name_space
                                                self.external_lsa_metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "include-stub"):
                                                self.include_stub = value
                                                self.include_stub.value_namespace = name_space
                                                self.include_stub.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa"):
                                                self.summary_lsa = value
                                                self.summary_lsa.value_namespace = name_space
                                                self.summary_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa-metric"):
                                                self.summary_lsa_metric = value
                                                self.summary_lsa_metric.value_namespace = name_space
                                                self.summary_lsa_metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.time.is_set or
                                            self.wait_for_bgp.is_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.time.yfilter != YFilter.not_set or
                                            self.wait_for_bgp.yfilter != YFilter.not_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "on-startup" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.time.is_set or self.time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.time.get_name_leafdata())
                                        if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "max-metric-options"):
                                            if (self.max_metric_options is None):
                                                self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup.MaxMetricOptions()
                                                self.max_metric_options.parent = self
                                                self._children_name_map["max_metric_options"] = "max-metric-options"
                                            return self.max_metric_options

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "max-metric-options" or name == "time" or name == "wait-for-bgp"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "time"):
                                            self.time = value
                                            self.time.value_namespace = name_space
                                            self.time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wait-for-bgp"):
                                            self.wait_for_bgp = value
                                            self.wait_for_bgp.value_namespace = name_space
                                            self.wait_for_bgp.value_namespace_prefix = name_space_prefix


                                class OnProcMigration(Entity):
                                    """
                                    Set maximum metric on\-proc\-migration configuration
                                    
                                    .. attribute:: max_metric_options
                                    
                                    	max metric options
                                    	**type**\:   :py:class:`MaxMetricOptions <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration.MaxMetricOptions>`
                                    
                                    .. attribute:: time
                                    
                                    	Till how much time originate router\-LSA with max\-metric
                                    	**type**\:  int
                                    
                                    	**range:** 5..86400
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: wait_for_bgp
                                    
                                    	Till BGP converge originate router\-LSA with max metric
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration, self).__init__()

                                        self.yang_name = "on-proc-migration"
                                        self.yang_parent_name = "max-metric"

                                        self.time = YLeaf(YType.uint32, "time")

                                        self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                        self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration.MaxMetricOptions()
                                        self.max_metric_options.parent = self
                                        self._children_name_map["max_metric_options"] = "max-metric-options"
                                        self._children_yang_names.add("max-metric-options")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("time",
                                                        "wait_for_bgp") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration, self).__setattr__(name, value)


                                    class MaxMetricOptions(Entity):
                                        """
                                        max metric options
                                        
                                        .. attribute:: external_lsa
                                        
                                        	Override external\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: external_lsa_metric
                                        
                                        	Overriding metric in external\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: include_stub
                                        
                                        	Set maximum metric for stub links in router\-LSAs
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa
                                        
                                        	Override summary\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa_metric
                                        
                                        	Overriding metric in summary\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration.MaxMetricOptions, self).__init__()

                                            self.yang_name = "max-metric-options"
                                            self.yang_parent_name = "on-proc-migration"

                                            self.external_lsa = YLeaf(YType.boolean, "external-lsa")

                                            self.external_lsa_metric = YLeaf(YType.uint32, "external-lsa-metric")

                                            self.include_stub = YLeaf(YType.boolean, "include-stub")

                                            self.summary_lsa = YLeaf(YType.boolean, "summary-lsa")

                                            self.summary_lsa_metric = YLeaf(YType.uint32, "summary-lsa-metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("external_lsa",
                                                            "external_lsa_metric",
                                                            "include_stub",
                                                            "summary_lsa",
                                                            "summary_lsa_metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration.MaxMetricOptions, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration.MaxMetricOptions, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.external_lsa.is_set or
                                                self.external_lsa_metric.is_set or
                                                self.include_stub.is_set or
                                                self.summary_lsa.is_set or
                                                self.summary_lsa_metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.external_lsa.yfilter != YFilter.not_set or
                                                self.external_lsa_metric.yfilter != YFilter.not_set or
                                                self.include_stub.yfilter != YFilter.not_set or
                                                self.summary_lsa.yfilter != YFilter.not_set or
                                                self.summary_lsa_metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "max-metric-options" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                            if (self.external_lsa_metric.is_set or self.external_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa_metric.get_name_leafdata())
                                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())
                                            if (self.summary_lsa_metric.is_set or self.summary_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa_metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external-lsa" or name == "external-lsa-metric" or name == "include-stub" or name == "summary-lsa" or name == "summary-lsa-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "external-lsa"):
                                                self.external_lsa = value
                                                self.external_lsa.value_namespace = name_space
                                                self.external_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "external-lsa-metric"):
                                                self.external_lsa_metric = value
                                                self.external_lsa_metric.value_namespace = name_space
                                                self.external_lsa_metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "include-stub"):
                                                self.include_stub = value
                                                self.include_stub.value_namespace = name_space
                                                self.include_stub.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa"):
                                                self.summary_lsa = value
                                                self.summary_lsa.value_namespace = name_space
                                                self.summary_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa-metric"):
                                                self.summary_lsa_metric = value
                                                self.summary_lsa_metric.value_namespace = name_space
                                                self.summary_lsa_metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.time.is_set or
                                            self.wait_for_bgp.is_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.time.yfilter != YFilter.not_set or
                                            self.wait_for_bgp.yfilter != YFilter.not_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "on-proc-migration" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.time.is_set or self.time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.time.get_name_leafdata())
                                        if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "max-metric-options"):
                                            if (self.max_metric_options is None):
                                                self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration.MaxMetricOptions()
                                                self.max_metric_options.parent = self
                                                self._children_name_map["max_metric_options"] = "max-metric-options"
                                            return self.max_metric_options

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "max-metric-options" or name == "time" or name == "wait-for-bgp"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "time"):
                                            self.time = value
                                            self.time.value_namespace = name_space
                                            self.time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wait-for-bgp"):
                                            self.wait_for_bgp = value
                                            self.wait_for_bgp.value_namespace = name_space
                                            self.wait_for_bgp.value_namespace_prefix = name_space_prefix


                                class Always(Entity):
                                    """
                                    Set maximum metric always configuration
                                    
                                    .. attribute:: max_metric_options
                                    
                                    	max metric options
                                    	**type**\:   :py:class:`MaxMetricOptions <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always.MaxMetricOptions>`
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always, self).__init__()

                                        self.yang_name = "always"
                                        self.yang_parent_name = "max-metric"

                                        self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always.MaxMetricOptions()
                                        self.max_metric_options.parent = self
                                        self._children_name_map["max_metric_options"] = "max-metric-options"
                                        self._children_yang_names.add("max-metric-options")


                                    class MaxMetricOptions(Entity):
                                        """
                                        max metric options
                                        
                                        .. attribute:: external_lsa
                                        
                                        	Override external\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: external_lsa_metric
                                        
                                        	Overriding metric in external\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: include_stub
                                        
                                        	Set maximum metric for stub links in router\-LSAs
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa
                                        
                                        	Override summary\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa_metric
                                        
                                        	Overriding metric in summary\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always.MaxMetricOptions, self).__init__()

                                            self.yang_name = "max-metric-options"
                                            self.yang_parent_name = "always"

                                            self.external_lsa = YLeaf(YType.boolean, "external-lsa")

                                            self.external_lsa_metric = YLeaf(YType.uint32, "external-lsa-metric")

                                            self.include_stub = YLeaf(YType.boolean, "include-stub")

                                            self.summary_lsa = YLeaf(YType.boolean, "summary-lsa")

                                            self.summary_lsa_metric = YLeaf(YType.uint32, "summary-lsa-metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("external_lsa",
                                                            "external_lsa_metric",
                                                            "include_stub",
                                                            "summary_lsa",
                                                            "summary_lsa_metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always.MaxMetricOptions, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always.MaxMetricOptions, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.external_lsa.is_set or
                                                self.external_lsa_metric.is_set or
                                                self.include_stub.is_set or
                                                self.summary_lsa.is_set or
                                                self.summary_lsa_metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.external_lsa.yfilter != YFilter.not_set or
                                                self.external_lsa_metric.yfilter != YFilter.not_set or
                                                self.include_stub.yfilter != YFilter.not_set or
                                                self.summary_lsa.yfilter != YFilter.not_set or
                                                self.summary_lsa_metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "max-metric-options" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                            if (self.external_lsa_metric.is_set or self.external_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa_metric.get_name_leafdata())
                                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())
                                            if (self.summary_lsa_metric.is_set or self.summary_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa_metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external-lsa" or name == "external-lsa-metric" or name == "include-stub" or name == "summary-lsa" or name == "summary-lsa-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "external-lsa"):
                                                self.external_lsa = value
                                                self.external_lsa.value_namespace = name_space
                                                self.external_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "external-lsa-metric"):
                                                self.external_lsa_metric = value
                                                self.external_lsa_metric.value_namespace = name_space
                                                self.external_lsa_metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "include-stub"):
                                                self.include_stub = value
                                                self.include_stub.value_namespace = name_space
                                                self.include_stub.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa"):
                                                self.summary_lsa = value
                                                self.summary_lsa.value_namespace = name_space
                                                self.summary_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa-metric"):
                                                self.summary_lsa_metric = value
                                                self.summary_lsa_metric.value_namespace = name_space
                                                self.summary_lsa_metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.max_metric_options is not None and self.max_metric_options.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "always" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "max-metric-options"):
                                            if (self.max_metric_options is None):
                                                self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always.MaxMetricOptions()
                                                self.max_metric_options.parent = self
                                                self._children_name_map["max_metric_options"] = "max-metric-options"
                                            return self.max_metric_options

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "max-metric-options"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class OnSwitchover(Entity):
                                    """
                                    Set maximum metric on\-switchover configuration
                                    
                                    .. attribute:: max_metric_options
                                    
                                    	max metric options
                                    	**type**\:   :py:class:`MaxMetricOptions <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover.MaxMetricOptions>`
                                    
                                    .. attribute:: time
                                    
                                    	Till how much time originate router\-LSA with max\-metric
                                    	**type**\:  int
                                    
                                    	**range:** 5..86400
                                    
                                    	**units**\: second
                                    
                                    .. attribute:: wait_for_bgp
                                    
                                    	Till BGP converge originate router\-LSA with max metric
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover, self).__init__()

                                        self.yang_name = "on-switchover"
                                        self.yang_parent_name = "max-metric"

                                        self.time = YLeaf(YType.uint32, "time")

                                        self.wait_for_bgp = YLeaf(YType.boolean, "wait-for-bgp")

                                        self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover.MaxMetricOptions()
                                        self.max_metric_options.parent = self
                                        self._children_name_map["max_metric_options"] = "max-metric-options"
                                        self._children_yang_names.add("max-metric-options")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("time",
                                                        "wait_for_bgp") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover, self).__setattr__(name, value)


                                    class MaxMetricOptions(Entity):
                                        """
                                        max metric options
                                        
                                        .. attribute:: external_lsa
                                        
                                        	Override external\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: external_lsa_metric
                                        
                                        	Overriding metric in external\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        .. attribute:: include_stub
                                        
                                        	Set maximum metric for stub links in router\-LSAs
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa
                                        
                                        	Override summary\-lsa metric with max\-metric value
                                        	**type**\:  bool
                                        
                                        .. attribute:: summary_lsa_metric
                                        
                                        	Overriding metric in summary\-LSAs (default 16711680)
                                        	**type**\:  int
                                        
                                        	**range:** 0..16777215
                                        
                                        

                                        """

                                        _prefix = 'cisco-ospf'
                                        _revision = '2016-03-30'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover.MaxMetricOptions, self).__init__()

                                            self.yang_name = "max-metric-options"
                                            self.yang_parent_name = "on-switchover"

                                            self.external_lsa = YLeaf(YType.boolean, "external-lsa")

                                            self.external_lsa_metric = YLeaf(YType.uint32, "external-lsa-metric")

                                            self.include_stub = YLeaf(YType.boolean, "include-stub")

                                            self.summary_lsa = YLeaf(YType.boolean, "summary-lsa")

                                            self.summary_lsa_metric = YLeaf(YType.uint32, "summary-lsa-metric")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("external_lsa",
                                                            "external_lsa_metric",
                                                            "include_stub",
                                                            "summary_lsa",
                                                            "summary_lsa_metric") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover.MaxMetricOptions, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover.MaxMetricOptions, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.external_lsa.is_set or
                                                self.external_lsa_metric.is_set or
                                                self.include_stub.is_set or
                                                self.summary_lsa.is_set or
                                                self.summary_lsa_metric.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.external_lsa.yfilter != YFilter.not_set or
                                                self.external_lsa_metric.yfilter != YFilter.not_set or
                                                self.include_stub.yfilter != YFilter.not_set or
                                                self.summary_lsa.yfilter != YFilter.not_set or
                                                self.summary_lsa_metric.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "max-metric-options" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.external_lsa.is_set or self.external_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa.get_name_leafdata())
                                            if (self.external_lsa_metric.is_set or self.external_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.external_lsa_metric.get_name_leafdata())
                                            if (self.include_stub.is_set or self.include_stub.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.include_stub.get_name_leafdata())
                                            if (self.summary_lsa.is_set or self.summary_lsa.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa.get_name_leafdata())
                                            if (self.summary_lsa_metric.is_set or self.summary_lsa_metric.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.summary_lsa_metric.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "external-lsa" or name == "external-lsa-metric" or name == "include-stub" or name == "summary-lsa" or name == "summary-lsa-metric"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "external-lsa"):
                                                self.external_lsa = value
                                                self.external_lsa.value_namespace = name_space
                                                self.external_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "external-lsa-metric"):
                                                self.external_lsa_metric = value
                                                self.external_lsa_metric.value_namespace = name_space
                                                self.external_lsa_metric.value_namespace_prefix = name_space_prefix
                                            if(value_path == "include-stub"):
                                                self.include_stub = value
                                                self.include_stub.value_namespace = name_space
                                                self.include_stub.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa"):
                                                self.summary_lsa = value
                                                self.summary_lsa.value_namespace = name_space
                                                self.summary_lsa.value_namespace_prefix = name_space_prefix
                                            if(value_path == "summary-lsa-metric"):
                                                self.summary_lsa_metric = value
                                                self.summary_lsa_metric.value_namespace = name_space
                                                self.summary_lsa_metric.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.time.is_set or
                                            self.wait_for_bgp.is_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.time.yfilter != YFilter.not_set or
                                            self.wait_for_bgp.yfilter != YFilter.not_set or
                                            (self.max_metric_options is not None and self.max_metric_options.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "on-switchover" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.time.is_set or self.time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.time.get_name_leafdata())
                                        if (self.wait_for_bgp.is_set or self.wait_for_bgp.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.wait_for_bgp.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "max-metric-options"):
                                            if (self.max_metric_options is None):
                                                self.max_metric_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover.MaxMetricOptions()
                                                self.max_metric_options.parent = self
                                                self._children_name_map["max_metric_options"] = "max-metric-options"
                                            return self.max_metric_options

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "max-metric-options" or name == "time" or name == "wait-for-bgp"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "time"):
                                            self.time = value
                                            self.time.value_namespace = name_space
                                            self.time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "wait-for-bgp"):
                                            self.wait_for_bgp = value
                                            self.wait_for_bgp.value_namespace = name_space
                                            self.wait_for_bgp.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        (self.always is not None and self.always.has_data()) or
                                        (self.on_proc_migration is not None and self.on_proc_migration.has_data()) or
                                        (self.on_proc_restart is not None and self.on_proc_restart.has_data()) or
                                        (self.on_startup is not None and self.on_startup.has_data()) or
                                        (self.on_switchover is not None and self.on_switchover.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.always is not None and self.always.has_operation()) or
                                        (self.on_proc_migration is not None and self.on_proc_migration.has_operation()) or
                                        (self.on_proc_restart is not None and self.on_proc_restart.has_operation()) or
                                        (self.on_startup is not None and self.on_startup.has_operation()) or
                                        (self.on_switchover is not None and self.on_switchover.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:max-metric" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "always"):
                                        if (self.always is None):
                                            self.always = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.Always()
                                            self.always.parent = self
                                            self._children_name_map["always"] = "always"
                                        return self.always

                                    if (child_yang_name == "on-proc-migration"):
                                        if (self.on_proc_migration is None):
                                            self.on_proc_migration = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcMigration()
                                            self.on_proc_migration.parent = self
                                            self._children_name_map["on_proc_migration"] = "on-proc-migration"
                                        return self.on_proc_migration

                                    if (child_yang_name == "on-proc-restart"):
                                        if (self.on_proc_restart is None):
                                            self.on_proc_restart = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnProcRestart()
                                            self.on_proc_restart.parent = self
                                            self._children_name_map["on_proc_restart"] = "on-proc-restart"
                                        return self.on_proc_restart

                                    if (child_yang_name == "on-startup"):
                                        if (self.on_startup is None):
                                            self.on_startup = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnStartup()
                                            self.on_startup.parent = self
                                            self._children_name_map["on_startup"] = "on-startup"
                                        return self.on_startup

                                    if (child_yang_name == "on-switchover"):
                                        if (self.on_switchover is None):
                                            self.on_switchover = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric.OnSwitchover()
                                            self.on_switchover.parent = self
                                            self._children_name_map["on_switchover"] = "on-switchover"
                                        return self.on_switchover

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "always" or name == "on-proc-migration" or name == "on-proc-restart" or name == "on-startup" or name == "on-switchover"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (self.max_metric is not None and self.max_metric.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.max_metric is not None and self.max_metric.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "reload-control" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "max-metric"):
                                    if (self.max_metric is None):
                                        self.max_metric = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl.MaxMetric()
                                        self.max_metric.parent = self
                                        self._children_name_map["max_metric"] = "max-metric"
                                    return self.max_metric

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "max-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class LogAdjacencyChanges(Entity):
                            """
                            Log adjacency changes
                            
                            .. attribute:: adjacency_changes
                            
                            	Log adjacecny state changes
                            	**type**\:   :py:class:`OspfLogAdj <ydk.models.cisco_ios_xe.cisco_ospf.OspfLogAdj>`
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.LogAdjacencyChanges, self).__init__()

                                self.yang_name = "log-adjacency-changes"
                                self.yang_parent_name = "instance"

                                self.adjacency_changes = YLeaf(YType.enumeration, "adjacency-changes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("adjacency_changes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.LogAdjacencyChanges, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.LogAdjacencyChanges, self).__setattr__(name, value)

                            def has_data(self):
                                return self.adjacency_changes.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.adjacency_changes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:log-adjacency-changes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.adjacency_changes.is_set or self.adjacency_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjacency_changes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "adjacency-changes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "adjacency-changes"):
                                    self.adjacency_changes = value
                                    self.adjacency_changes.value_namespace = name_space
                                    self.adjacency_changes.value_namespace_prefix = name_space_prefix


                        class GracefulRestart(Entity):
                            """
                            Graceful restart config state.
                            
                            .. attribute:: enable
                            
                            	Enable/Disable graceful restart as defined in RFC 3623
                            	**type**\:  bool
                            
                            .. attribute:: helper_enable
                            
                            	Enable RestartHelperSupport in RFC 3623 Section B.2
                            	**type**\:  bool
                            
                            .. attribute:: helper_strict_lsa_checking
                            
                            	RestartHelperStrictLSAChecking option in RFC 3623 Section B.2
                            	**type**\:  bool
                            
                            .. attribute:: restart_interval
                            
                            	RestartInterval option in RFC 3623 Section B.1
                            	**type**\:  int
                            
                            	**range:** 1..1800
                            
                            	**units**\: seconds
                            
                            	**default value**\: 120
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulRestart, self).__init__()

                                self.yang_name = "graceful-restart"
                                self.yang_parent_name = "instance"

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.helper_enable = YLeaf(YType.boolean, "helper-enable")

                                self.helper_strict_lsa_checking = YLeaf(YType.boolean, "helper-strict-lsa-checking")

                                self.restart_interval = YLeaf(YType.uint16, "restart-interval")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "helper_enable",
                                                "helper_strict_lsa_checking",
                                                "restart_interval") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulRestart, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulRestart, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.helper_enable.is_set or
                                    self.helper_strict_lsa_checking.is_set or
                                    self.restart_interval.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.helper_enable.yfilter != YFilter.not_set or
                                    self.helper_strict_lsa_checking.yfilter != YFilter.not_set or
                                    self.restart_interval.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "graceful-restart" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.helper_enable.is_set or self.helper_enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.helper_enable.get_name_leafdata())
                                if (self.helper_strict_lsa_checking.is_set or self.helper_strict_lsa_checking.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.helper_strict_lsa_checking.get_name_leafdata())
                                if (self.restart_interval.is_set or self.restart_interval.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.restart_interval.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "helper-enable" or name == "helper-strict-lsa-checking" or name == "restart-interval"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "helper-enable"):
                                    self.helper_enable = value
                                    self.helper_enable.value_namespace = name_space
                                    self.helper_enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "helper-strict-lsa-checking"):
                                    self.helper_strict_lsa_checking = value
                                    self.helper_strict_lsa_checking.value_namespace = name_space
                                    self.helper_strict_lsa_checking.value_namespace_prefix = name_space_prefix
                                if(value_path == "restart-interval"):
                                    self.restart_interval = value
                                    self.restart_interval.value_namespace = name_space
                                    self.restart_interval.value_namespace_prefix = name_space_prefix


                        class MicroloopAvoidance(Entity):
                            """
                            Microloop avoidance configuration
                            
                            .. attribute:: disable
                            
                            	disable microloop avoidance
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: enable
                            
                            	Type of prefixes for which to avoid microloops
                            	**type**\:   :py:class:`PrefixApplicability <ydk.models.cisco_ios_xe.cisco_ospf.PrefixApplicability>`
                            
                            	**default value**\: all
                            
                            .. attribute:: rib_update_delay
                            
                            	Delay to introduce between SPF and RIB update in msecs
                            	**type**\:  int
                            
                            	**range:** 0..16777215
                            
                            	**units**\: millisecond
                            
                            	**default value**\: 5000
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.MicroloopAvoidance, self).__init__()

                                self.yang_name = "microloop-avoidance"
                                self.yang_parent_name = "instance"

                                self.disable = YLeaf(YType.empty, "disable")

                                self.enable = YLeaf(YType.enumeration, "enable")

                                self.rib_update_delay = YLeaf(YType.uint32, "rib-update-delay")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("disable",
                                                "enable",
                                                "rib_update_delay") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.MicroloopAvoidance, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.MicroloopAvoidance, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.disable.is_set or
                                    self.enable.is_set or
                                    self.rib_update_delay.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.disable.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.rib_update_delay.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:microloop-avoidance" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.disable.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.rib_update_delay.is_set or self.rib_update_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rib_update_delay.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "disable" or name == "enable" or name == "rib-update-delay"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "disable"):
                                    self.disable = value
                                    self.disable.value_namespace = name_space
                                    self.disable.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "rib-update-delay"):
                                    self.rib_update_delay = value
                                    self.rib_update_delay.value_namespace = name_space
                                    self.rib_update_delay.value_namespace_prefix = name_space_prefix


                        class DiscardRoute(Entity):
                            """
                            Enable or disable discard\-route installation
                            
                            .. attribute:: external
                            
                            	Discard route for redistributed summarised routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: external_admin_distance
                            
                            	admin distance value for external routes
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            	**default value**\: 254
                            
                            .. attribute:: internal
                            
                            	Discard route for summarised internal routes
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: internal_admin_distance
                            
                            	admin distance value for internal routes
                            	**type**\:  int
                            
                            	**range:** 1..255
                            
                            	**default value**\: 110
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DiscardRoute, self).__init__()

                                self.yang_name = "discard-route"
                                self.yang_parent_name = "instance"
                                self.is_presence_container = True

                                self.external = YLeaf(YType.empty, "external")

                                self.external_admin_distance = YLeaf(YType.uint8, "external-admin-distance")

                                self.internal = YLeaf(YType.empty, "internal")

                                self.internal_admin_distance = YLeaf(YType.uint8, "internal-admin-distance")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("external",
                                                "external_admin_distance",
                                                "internal",
                                                "internal_admin_distance") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DiscardRoute, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DiscardRoute, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.external.is_set or
                                    self.external_admin_distance.is_set or
                                    self.internal.is_set or
                                    self.internal_admin_distance.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.external.yfilter != YFilter.not_set or
                                    self.external_admin_distance.yfilter != YFilter.not_set or
                                    self.internal.yfilter != YFilter.not_set or
                                    self.internal_admin_distance.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:discard-route" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.external.is_set or self.external.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external.get_name_leafdata())
                                if (self.external_admin_distance.is_set or self.external_admin_distance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external_admin_distance.get_name_leafdata())
                                if (self.internal.is_set or self.internal.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal.get_name_leafdata())
                                if (self.internal_admin_distance.is_set or self.internal_admin_distance.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal_admin_distance.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "external" or name == "external-admin-distance" or name == "internal" or name == "internal-admin-distance"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "external"):
                                    self.external = value
                                    self.external.value_namespace = name_space
                                    self.external.value_namespace_prefix = name_space_prefix
                                if(value_path == "external-admin-distance"):
                                    self.external_admin_distance = value
                                    self.external_admin_distance.value_namespace = name_space
                                    self.external_admin_distance.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal"):
                                    self.internal = value
                                    self.internal.value_namespace = name_space
                                    self.internal.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal-admin-distance"):
                                    self.internal_admin_distance = value
                                    self.internal_admin_distance.value_namespace = name_space
                                    self.internal_admin_distance.value_namespace_prefix = name_space_prefix


                        class AutoCost(Entity):
                            """
                            Auto cost config state.
                            
                            .. attribute:: enable
                            
                            	Enable/Disable auto cost
                            	**type**\:  bool
                            
                            .. attribute:: reference_bandwidth
                            
                            	Configure reference bandwidth in term of Mbits
                            	**type**\:  int
                            
                            	**range:** 1..4294967
                            
                            	**units**\: Mbits
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AutoCost, self).__init__()

                                self.yang_name = "auto-cost"
                                self.yang_parent_name = "instance"

                                self.enable = YLeaf(YType.boolean, "enable")

                                self.reference_bandwidth = YLeaf(YType.uint32, "reference-bandwidth")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "reference_bandwidth") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AutoCost, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AutoCost, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.reference_bandwidth.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.reference_bandwidth.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "auto-cost" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.reference_bandwidth.is_set or self.reference_bandwidth.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reference_bandwidth.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable" or name == "reference-bandwidth"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "reference-bandwidth"):
                                    self.reference_bandwidth = value
                                    self.reference_bandwidth.value_namespace = name_space
                                    self.reference_bandwidth.value_namespace_prefix = name_space_prefix


                        class Mpls(Entity):
                            """
                            OSPF MPLS config state.
                            
                            .. attribute:: ldp
                            
                            	OSPF MPLS LDP config state
                            	**type**\:   :py:class:`Ldp <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.Ldp>`
                            
                            .. attribute:: te_rid
                            
                            	Traffic Engineering stable IP address for system
                            	**type**\:   :py:class:`TeRid <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.TeRid>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls, self).__init__()

                                self.yang_name = "mpls"
                                self.yang_parent_name = "instance"

                                self.ldp = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.Ldp()
                                self.ldp.parent = self
                                self._children_name_map["ldp"] = "ldp"
                                self._children_yang_names.add("ldp")

                                self.te_rid = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.TeRid()
                                self.te_rid.parent = self
                                self._children_name_map["te_rid"] = "te-rid"
                                self._children_yang_names.add("te-rid")


                            class Ldp(Entity):
                                """
                                OSPF MPLS LDP config state.
                                
                                .. attribute:: autoconfig
                                
                                	Enable LDP IGP interface auto\-configuration
                                	**type**\:  bool
                                
                                .. attribute:: igp_sync
                                
                                	Enable LDP IGP synchronization
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.Ldp, self).__init__()

                                    self.yang_name = "ldp"
                                    self.yang_parent_name = "mpls"

                                    self.autoconfig = YLeaf(YType.boolean, "autoconfig")

                                    self.igp_sync = YLeaf(YType.boolean, "igp-sync")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("autoconfig",
                                                    "igp_sync") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.Ldp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.Ldp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.autoconfig.is_set or
                                        self.igp_sync.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.autoconfig.yfilter != YFilter.not_set or
                                        self.igp_sync.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ldp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.autoconfig.is_set or self.autoconfig.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.autoconfig.get_name_leafdata())
                                    if (self.igp_sync.is_set or self.igp_sync.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.igp_sync.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "autoconfig" or name == "igp-sync"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "autoconfig"):
                                        self.autoconfig = value
                                        self.autoconfig.value_namespace = name_space
                                        self.autoconfig.value_namespace_prefix = name_space_prefix
                                    if(value_path == "igp-sync"):
                                        self.igp_sync = value
                                        self.igp_sync.value_namespace = name_space
                                        self.igp_sync.value_namespace_prefix = name_space_prefix


                            class TeRid(Entity):
                                """
                                Traffic Engineering stable IP address for system.
                                
                                .. attribute:: interface
                                
                                	Take the interface's IPv4 address as TE router ID
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: router_id
                                
                                	Explicitly configure the TE router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.TeRid, self).__init__()

                                    self.yang_name = "te-rid"
                                    self.yang_parent_name = "mpls"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.router_id = YLeaf(YType.str, "router-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "router_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.TeRid, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.TeRid, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface.is_set or
                                        self.router_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "te-rid" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface" or name == "router-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    (self.ldp is not None and self.ldp.has_data()) or
                                    (self.te_rid is not None and self.te_rid.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.ldp is not None and self.ldp.has_operation()) or
                                    (self.te_rid is not None and self.te_rid.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "ldp"):
                                    if (self.ldp is None):
                                        self.ldp = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.Ldp()
                                        self.ldp.parent = self
                                        self._children_name_map["ldp"] = "ldp"
                                    return self.ldp

                                if (child_yang_name == "te-rid"):
                                    if (self.te_rid is None):
                                        self.te_rid = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls.TeRid()
                                        self.te_rid.parent = self
                                        self._children_name_map["te_rid"] = "te-rid"
                                    return self.te_rid

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ldp" or name == "te-rid"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class SummaryPrefixes(Entity):
                            """
                            Configure IP address summaries
                            
                            .. attribute:: summary_prefix
                            
                            	Summarize redistributed routes matching prefix/length
                            	**type**\: list of    :py:class:`SummaryPrefix <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes.SummaryPrefix>`
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes, self).__init__()

                                self.yang_name = "summary-prefixes"
                                self.yang_parent_name = "instance"

                                self.summary_prefix = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes, self).__setattr__(name, value)


                            class SummaryPrefix(Entity):
                                """
                                Summarize redistributed routes
                                matching prefix/length
                                
                                .. attribute:: prefix  <key>
                                
                                	IPv4 or IPv6 prefix
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                                
                                
                                ----
                                .. attribute:: not_advertise
                                
                                	Do not advertise when translating OSPF type\-7 LSA
                                	**type**\:  bool
                                
                                .. attribute:: nssa_only
                                
                                	Limit summary to NSSA areas
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: tag
                                
                                	32\-bit tag value
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes.SummaryPrefix, self).__init__()

                                    self.yang_name = "summary-prefix"
                                    self.yang_parent_name = "summary-prefixes"

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.not_advertise = YLeaf(YType.boolean, "not-advertise")

                                    self.nssa_only = YLeaf(YType.empty, "nssa-only")

                                    self.tag = YLeaf(YType.uint32, "tag")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix",
                                                    "not_advertise",
                                                    "nssa_only",
                                                    "tag") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes.SummaryPrefix, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.prefix.is_set or
                                        self.not_advertise.is_set or
                                        self.nssa_only.is_set or
                                        self.tag.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.not_advertise.yfilter != YFilter.not_set or
                                        self.nssa_only.yfilter != YFilter.not_set or
                                        self.tag.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "summary-prefix" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.not_advertise.is_set or self.not_advertise.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.not_advertise.get_name_leafdata())
                                    if (self.nssa_only.is_set or self.nssa_only.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.nssa_only.get_name_leafdata())
                                    if (self.tag.is_set or self.tag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tag.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix" or name == "not-advertise" or name == "nssa-only" or name == "tag"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "not-advertise"):
                                        self.not_advertise = value
                                        self.not_advertise.value_namespace = name_space
                                        self.not_advertise.value_namespace_prefix = name_space_prefix
                                    if(value_path == "nssa-only"):
                                        self.nssa_only = value
                                        self.nssa_only.value_namespace = name_space
                                        self.nssa_only.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tag"):
                                        self.tag = value
                                        self.tag.value_namespace = name_space
                                        self.tag.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.summary_prefix:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.summary_prefix:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:summary-prefixes" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "summary-prefix"):
                                    for c in self.summary_prefix:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes.SummaryPrefix()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.summary_prefix.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "summary-prefix"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Nsr(Entity):
                            """
                            NSR config state.
                            
                            .. attribute:: enable
                            
                            	Enable/Disable NSR
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Nsr, self).__init__()

                                self.yang_name = "nsr"
                                self.yang_parent_name = "instance"

                                self.enable = YLeaf(YType.boolean, "enable")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Nsr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Nsr, self).__setattr__(name, value)

                            def has_data(self):
                                return self.enable.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "nsr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix


                        class SpfControl(Entity):
                            """
                            SPF calculation control.
                            
                            .. attribute:: paths
                            
                            	Maximum number of ECMP paths
                            	**type**\:  int
                            
                            	**range:** 1..32
                            
                            .. attribute:: throttle_timers
                            
                            	timers value
                            	**type**\:   :py:class:`ThrottleTimers <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl.ThrottleTimers>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl, self).__init__()

                                self.yang_name = "spf-control"
                                self.yang_parent_name = "instance"

                                self.paths = YLeaf(YType.uint16, "paths")

                                self.throttle_timers = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl.ThrottleTimers()
                                self.throttle_timers.parent = self
                                self._children_name_map["throttle_timers"] = "throttle-timers"
                                self._children_yang_names.add("throttle-timers")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("paths") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl, self).__setattr__(name, value)


                            class ThrottleTimers(Entity):
                                """
                                timers value
                                
                                .. attribute:: init_delay
                                
                                	Delay between receiving a change to SPF or LSA  calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..600000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: max_delay
                                
                                	Maximum wait time in milliseconds  for SPF or LSA calculations
                                	**type**\:  int
                                
                                	**range:** 0..600000
                                
                                	**units**\: millisecond
                                
                                .. attribute:: min_delay
                                
                                	Delay between first and second SPF or LSA  calculation in milliseconds
                                	**type**\:  int
                                
                                	**range:** 0..600000
                                
                                	**units**\: millisecond
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl.ThrottleTimers, self).__init__()

                                    self.yang_name = "throttle-timers"
                                    self.yang_parent_name = "spf-control"

                                    self.init_delay = YLeaf(YType.uint32, "init-delay")

                                    self.max_delay = YLeaf(YType.uint32, "max-delay")

                                    self.min_delay = YLeaf(YType.uint32, "min-delay")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("init_delay",
                                                    "max_delay",
                                                    "min_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl.ThrottleTimers, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl.ThrottleTimers, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.init_delay.is_set or
                                        self.max_delay.is_set or
                                        self.min_delay.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.init_delay.yfilter != YFilter.not_set or
                                        self.max_delay.yfilter != YFilter.not_set or
                                        self.min_delay.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:throttle-timers" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.init_delay.is_set or self.init_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.init_delay.get_name_leafdata())
                                    if (self.max_delay.is_set or self.max_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_delay.get_name_leafdata())
                                    if (self.min_delay.is_set or self.min_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.min_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "init-delay" or name == "max-delay" or name == "min-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "init-delay"):
                                        self.init_delay = value
                                        self.init_delay.value_namespace = name_space
                                        self.init_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "max-delay"):
                                        self.max_delay = value
                                        self.max_delay.value_namespace = name_space
                                        self.max_delay.value_namespace_prefix = name_space_prefix
                                    if(value_path == "min-delay"):
                                        self.min_delay = value
                                        self.min_delay.value_namespace = name_space
                                        self.min_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.paths.is_set or
                                    (self.throttle_timers is not None and self.throttle_timers.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.paths.yfilter != YFilter.not_set or
                                    (self.throttle_timers is not None and self.throttle_timers.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-control" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.paths.is_set or self.paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.paths.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "throttle-timers"):
                                    if (self.throttle_timers is None):
                                        self.throttle_timers = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl.ThrottleTimers()
                                        self.throttle_timers.parent = self
                                        self._children_name_map["throttle_timers"] = "throttle-timers"
                                    return self.throttle_timers

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "throttle-timers" or name == "paths"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "paths"):
                                    self.paths = value
                                    self.paths.value_namespace = name_space
                                    self.paths.value_namespace_prefix = name_space_prefix


                        class FastReroute(Entity):
                            """
                            This container may be augmented with global
                            parameters for IPFRR.
                            
                            .. attribute:: lfa
                            
                            	This container may be augmented with global parameters for LFA. Creating the container has no effect on LFA activation
                            	**type**\:   :py:class:`Lfa <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute.Lfa>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute, self).__init__()

                                self.yang_name = "fast-reroute"
                                self.yang_parent_name = "instance"

                                self.lfa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute.Lfa()
                                self.lfa.parent = self
                                self._children_name_map["lfa"] = "lfa"
                                self._children_yang_names.add("lfa")


                            class Lfa(Entity):
                                """
                                This container may be augmented with
                                global parameters for LFA.
                                Creating the container has no effect on
                                LFA activation.
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute.Lfa, self).__init__()

                                    self.yang_name = "lfa"
                                    self.yang_parent_name = "fast-reroute"

                                def has_data(self):
                                    return False

                                def has_operation(self):
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (self.lfa is not None and self.lfa.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.lfa is not None and self.lfa.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "fast-reroute" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa"):
                                    if (self.lfa is None):
                                        self.lfa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute.Lfa()
                                        self.lfa.parent = self
                                        self._children_name_map["lfa"] = "lfa"
                                    return self.lfa

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class AllAreasInherit(Entity):
                            """
                            Inheritance for all areas.
                            
                            .. attribute:: area
                            
                            	Area config to be inherited by all areas
                            	**type**\:   :py:class:`Area <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Area>`
                            
                            .. attribute:: interface
                            
                            	Interface config to be inherited by all interfaces in all areas
                            	**type**\:   :py:class:`Interface <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Interface>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit, self).__init__()

                                self.yang_name = "all-areas-inherit"
                                self.yang_parent_name = "instance"

                                self.area = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Area()
                                self.area.parent = self
                                self._children_name_map["area"] = "area"
                                self._children_yang_names.add("area")

                                self.interface = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Interface()
                                self.interface.parent = self
                                self._children_name_map["interface"] = "interface"
                                self._children_yang_names.add("interface")


                            class Area(Entity):
                                """
                                Area config to be inherited by all areas.
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Area, self).__init__()

                                    self.yang_name = "area"
                                    self.yang_parent_name = "all-areas-inherit"

                                def has_data(self):
                                    return False

                                def has_operation(self):
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "area" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Interface(Entity):
                                """
                                Interface config to be inherited by all interfaces
                                in all areas.
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Interface, self).__init__()

                                    self.yang_name = "interface"
                                    self.yang_parent_name = "all-areas-inherit"

                                def has_data(self):
                                    return False

                                def has_operation(self):
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interface" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    (self.area is not None and self.area.has_data()) or
                                    (self.interface is not None and self.interface.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.area is not None and self.area.has_operation()) or
                                    (self.interface is not None and self.interface.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "all-areas-inherit" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "area"):
                                    if (self.area is None):
                                        self.area = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Area()
                                        self.area.parent = self
                                        self._children_name_map["area"] = "area"
                                    return self.area

                                if (child_yang_name == "interface"):
                                    if (self.interface is None):
                                        self.interface = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit.Interface()
                                        self.interface.parent = self
                                        self._children_name_map["interface"] = "interface"
                                    return self.interface

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "interface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class DefaultMetric(Entity):
                            """
                            OSPF default metric
                            
                            .. attribute:: default_metric
                            
                            	Default metric of redistributed routes
                            	**type**\:  int
                            
                            	**range:** 0..16777215
                            
                            	**default value**\: 1
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultMetric, self).__init__()

                                self.yang_name = "default-metric"
                                self.yang_parent_name = "instance"

                                self.default_metric = YLeaf(YType.uint32, "default-metric")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("default_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultMetric, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultMetric, self).__setattr__(name, value)

                            def has_data(self):
                                return self.default_metric.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.default_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:default-metric" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.default_metric.is_set or self.default_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "default-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "default-metric"):
                                    self.default_metric = value
                                    self.default_metric.value_namespace = name_space
                                    self.default_metric.value_namespace_prefix = name_space_prefix


                        class GracefulShutdown(Entity):
                            """
                            Timers for graceful shutdown
                            
                            .. attribute:: initial_delay
                            
                            	OSPF Delay before starting graceful shutdown
                            	**type**\:  int
                            
                            	**range:** 0..90
                            
                            	**units**\: seconds
                            
                            	**default value**\: 5
                            
                            .. attribute:: retain_routes
                            
                            	Time to keep routes active after graceful shutdown
                            	**type**\:  int
                            
                            	**range:** 0..90
                            
                            	**units**\: seconds
                            
                            	**default value**\: 5
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulShutdown, self).__init__()

                                self.yang_name = "graceful-shutdown"
                                self.yang_parent_name = "instance"

                                self.initial_delay = YLeaf(YType.uint32, "initial-delay")

                                self.retain_routes = YLeaf(YType.uint32, "retain-routes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("initial_delay",
                                                "retain_routes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulShutdown, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulShutdown, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.initial_delay.is_set or
                                    self.retain_routes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.initial_delay.yfilter != YFilter.not_set or
                                    self.retain_routes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:graceful-shutdown" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.initial_delay.is_set or self.initial_delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.initial_delay.get_name_leafdata())
                                if (self.retain_routes.is_set or self.retain_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.retain_routes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "initial-delay" or name == "retain-routes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "initial-delay"):
                                    self.initial_delay = value
                                    self.initial_delay.value_namespace = name_space
                                    self.initial_delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "retain-routes"):
                                    self.retain_routes = value
                                    self.retain_routes.value_namespace = name_space
                                    self.retain_routes.value_namespace_prefix = name_space_prefix


                        class DefaultInformation(Entity):
                            """
                            Control distribution of default information
                            
                            .. attribute:: originate
                            
                            	Distribute a default route
                            	**type**\:   :py:class:`Originate <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation.Originate>`
                            
                            	**presence node**\: True
                            
                            

                            """

                            _prefix = 'cisco-ospf'
                            _revision = '2016-03-30'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation, self).__init__()

                                self.yang_name = "default-information"
                                self.yang_parent_name = "instance"

                                self.originate = None
                                self._children_name_map["originate"] = "originate"
                                self._children_yang_names.add("originate")


                            class Originate(Entity):
                                """
                                Distribute a default route
                                
                                .. attribute:: always_advertise
                                
                                	Always advertise default route
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: metric
                                
                                	OSPF metric
                                	**type**\:  int
                                
                                	**range:** 0..16777215
                                
                                	**default value**\: 1
                                
                                .. attribute:: metric_type
                                
                                	OSPF External metric type
                                	**type**\:   :py:class:`OspfExternalType <ydk.models.cisco_ios_xe.cisco_ospf.OspfExternalType>`
                                
                                	**default value**\: 2
                                
                                .. attribute:: route_map
                                
                                	Routing policy or route\-map  name
                                	**type**\:  str
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation.Originate, self).__init__()

                                    self.yang_name = "originate"
                                    self.yang_parent_name = "default-information"
                                    self.is_presence_container = True

                                    self.always_advertise = YLeaf(YType.boolean, "always-advertise")

                                    self.metric = YLeaf(YType.uint32, "metric")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.route_map = YLeaf(YType.str, "route-map")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("always_advertise",
                                                    "metric",
                                                    "metric_type",
                                                    "route_map") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation.Originate, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation.Originate, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.always_advertise.is_set or
                                        self.metric.is_set or
                                        self.metric_type.is_set or
                                        self.route_map.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.always_advertise.yfilter != YFilter.not_set or
                                        self.metric.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.route_map.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "originate" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.always_advertise.is_set or self.always_advertise.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.always_advertise.get_name_leafdata())
                                    if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.route_map.is_set or self.route_map.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.route_map.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "always-advertise" or name == "metric" or name == "metric-type" or name == "route-map"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "always-advertise"):
                                        self.always_advertise = value
                                        self.always_advertise.value_namespace = name_space
                                        self.always_advertise.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric"):
                                        self.metric = value
                                        self.metric.value_namespace = name_space
                                        self.metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "route-map"):
                                        self.route_map = value
                                        self.route_map.value_namespace = name_space
                                        self.route_map.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (self.originate is not None)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.originate is not None and self.originate.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "cisco-ospf:default-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "originate"):
                                    if (self.originate is None):
                                        self.originate = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation.Originate()
                                        self.originate.parent = self
                                        self._children_name_map["originate"] = "originate"
                                    return self.originate

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "originate"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class DatabaseControl(Entity):
                            """
                            Database maintenance control.
                            
                            .. attribute:: database_filter
                            
                            	Filter OSPF LSA during synchronization and flooding
                            	**type**\:   :py:class:`DatabaseFilter <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.DatabaseFilter>`
                            
                            .. attribute:: flood_reduction
                            
                            	OSPF Flood Reduction
                            	**type**\:   :py:class:`FloodReduction <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.FloodReduction>`
                            
                            .. attribute:: ignore_lsa
                            
                            	Do not complain upon receiving LSA of the specified type
                            	**type**\:   :py:class:`IgnoreLsa <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.IgnoreLsa>`
                            
                            .. attribute:: lsa
                            
                            	OSPF LSA timers
                            	**type**\:   :py:class:`Lsa <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa>`
                            
                            .. attribute:: max_lsa
                            
                            	Maximum number of LSAs OSPF will receive
                            	**type**\:  int
                            
                            	**range:** 1..4294967294
                            
                            .. attribute:: max_lsa_options
                            
                            	Option of Max\-LSA
                            	**type**\:   :py:class:`MaxLsaOptions <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.MaxLsaOptions>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl, self).__init__()

                                self.yang_name = "database-control"
                                self.yang_parent_name = "instance"

                                self.max_lsa = YLeaf(YType.uint32, "max-lsa")

                                self.database_filter = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.DatabaseFilter()
                                self.database_filter.parent = self
                                self._children_name_map["database_filter"] = "database-filter"
                                self._children_yang_names.add("database-filter")

                                self.flood_reduction = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.FloodReduction()
                                self.flood_reduction.parent = self
                                self._children_name_map["flood_reduction"] = "flood-reduction"
                                self._children_yang_names.add("flood-reduction")

                                self.ignore_lsa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.IgnoreLsa()
                                self.ignore_lsa.parent = self
                                self._children_name_map["ignore_lsa"] = "ignore-lsa"
                                self._children_yang_names.add("ignore-lsa")

                                self.lsa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa()
                                self.lsa.parent = self
                                self._children_name_map["lsa"] = "lsa"
                                self._children_yang_names.add("lsa")

                                self.max_lsa_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.MaxLsaOptions()
                                self.max_lsa_options.parent = self
                                self._children_name_map["max_lsa_options"] = "max-lsa-options"
                                self._children_yang_names.add("max-lsa-options")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("max_lsa") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl, self).__setattr__(name, value)


                            class MaxLsaOptions(Entity):
                                """
                                Option of Max\-LSA
                                
                                .. attribute:: ignore_count
                                
                                	<1\-65534> count on how many times  adjacencies can be suppressed
                                	**type**\:  int
                                
                                	**range:** 1..65534
                                
                                .. attribute:: ignore_time
                                
                                	<1\-17895> number of minutes during which  all adjacencies are suppressed
                                	**type**\:  int
                                
                                	**range:** 1..17895
                                
                                .. attribute:: reset_time
                                
                                	<2\-35791> number of minutes after which  ignore\-count is reset to zero
                                	**type**\:  int
                                
                                	**range:** 2..35791
                                
                                .. attribute:: threshold_value
                                
                                	<1\-100> Threshold value (%) at which  to generate a warning msg
                                	**type**\:  int
                                
                                	**range:** 1..100
                                
                                .. attribute:: warning_only
                                
                                	Only give warning message when limit is exceeded
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.MaxLsaOptions, self).__init__()

                                    self.yang_name = "max-lsa-options"
                                    self.yang_parent_name = "database-control"

                                    self.ignore_count = YLeaf(YType.uint32, "ignore-count")

                                    self.ignore_time = YLeaf(YType.uint32, "ignore-time")

                                    self.reset_time = YLeaf(YType.uint32, "reset-time")

                                    self.threshold_value = YLeaf(YType.uint32, "threshold-value")

                                    self.warning_only = YLeaf(YType.empty, "warning-only")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ignore_count",
                                                    "ignore_time",
                                                    "reset_time",
                                                    "threshold_value",
                                                    "warning_only") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.MaxLsaOptions, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.MaxLsaOptions, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.ignore_count.is_set or
                                        self.ignore_time.is_set or
                                        self.reset_time.is_set or
                                        self.threshold_value.is_set or
                                        self.warning_only.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ignore_count.yfilter != YFilter.not_set or
                                        self.ignore_time.yfilter != YFilter.not_set or
                                        self.reset_time.yfilter != YFilter.not_set or
                                        self.threshold_value.yfilter != YFilter.not_set or
                                        self.warning_only.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:max-lsa-options" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ignore_count.is_set or self.ignore_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ignore_count.get_name_leafdata())
                                    if (self.ignore_time.is_set or self.ignore_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ignore_time.get_name_leafdata())
                                    if (self.reset_time.is_set or self.reset_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reset_time.get_name_leafdata())
                                    if (self.threshold_value.is_set or self.threshold_value.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_value.get_name_leafdata())
                                    if (self.warning_only.is_set or self.warning_only.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.warning_only.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ignore-count" or name == "ignore-time" or name == "reset-time" or name == "threshold-value" or name == "warning-only"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ignore-count"):
                                        self.ignore_count = value
                                        self.ignore_count.value_namespace = name_space
                                        self.ignore_count.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ignore-time"):
                                        self.ignore_time = value
                                        self.ignore_time.value_namespace = name_space
                                        self.ignore_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "reset-time"):
                                        self.reset_time = value
                                        self.reset_time.value_namespace = name_space
                                        self.reset_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-value"):
                                        self.threshold_value = value
                                        self.threshold_value.value_namespace = name_space
                                        self.threshold_value.value_namespace_prefix = name_space_prefix
                                    if(value_path == "warning-only"):
                                        self.warning_only = value
                                        self.warning_only.value_namespace = name_space
                                        self.warning_only.value_namespace_prefix = name_space_prefix


                            class DatabaseFilter(Entity):
                                """
                                Filter OSPF LSA during synchronization and flooding
                                
                                .. attribute:: all_out
                                
                                	Filter all Outgoing LSA
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.DatabaseFilter, self).__init__()

                                    self.yang_name = "database-filter"
                                    self.yang_parent_name = "database-control"

                                    self.all_out = YLeaf(YType.boolean, "all-out")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("all_out") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.DatabaseFilter, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.DatabaseFilter, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.all_out.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.all_out.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:database-filter" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.all_out.is_set or self.all_out.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.all_out.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "all-out"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "all-out"):
                                        self.all_out = value
                                        self.all_out.value_namespace = name_space
                                        self.all_out.value_namespace_prefix = name_space_prefix


                            class FloodReduction(Entity):
                                """
                                OSPF Flood Reduction
                                
                                .. attribute:: flood_reduction
                                
                                	Enable OSPF flood reduction
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.FloodReduction, self).__init__()

                                    self.yang_name = "flood-reduction"
                                    self.yang_parent_name = "database-control"

                                    self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("flood_reduction") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.FloodReduction, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.FloodReduction, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.flood_reduction.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.flood_reduction.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:flood-reduction" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.flood_reduction.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "flood-reduction"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "flood-reduction"):
                                        self.flood_reduction = value
                                        self.flood_reduction.value_namespace = name_space
                                        self.flood_reduction.value_namespace_prefix = name_space_prefix


                            class IgnoreLsa(Entity):
                                """
                                Do not complain upon receiving LSA of the
                                specified type
                                
                                .. attribute:: mospf
                                
                                	Ignore Type 6 LSAs
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.IgnoreLsa, self).__init__()

                                    self.yang_name = "ignore-lsa"
                                    self.yang_parent_name = "database-control"

                                    self.mospf = YLeaf(YType.empty, "mospf")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("mospf") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.IgnoreLsa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.IgnoreLsa, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.mospf.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.mospf.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:ignore-lsa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.mospf.is_set or self.mospf.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mospf.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "mospf"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "mospf"):
                                        self.mospf = value
                                        self.mospf.value_namespace = name_space
                                        self.mospf.value_namespace_prefix = name_space_prefix


                            class Lsa(Entity):
                                """
                                OSPF LSA timers
                                
                                .. attribute:: arrival
                                
                                	The minimum interval in milliseconds  between accepting the same LSA arrival timer
                                	**type**\:  int
                                
                                	**range:** 0..600000
                                
                                	**units**\: millisecond
                                
                                	**default value**\: 1000
                                
                                .. attribute:: flood
                                
                                	OSPF flood pacing timer
                                	**type**\:  int
                                
                                	**range:** 5..100
                                
                                	**units**\: millisecond
                                
                                	**default value**\: 33
                                
                                .. attribute:: group_pacing
                                
                                	OSPF LSA group pacing timer
                                	**type**\:  int
                                
                                	**range:** 10..1800
                                
                                	**units**\: seconds
                                
                                	**default value**\: 240
                                
                                .. attribute:: refresh
                                
                                	How often self\-originated LSAs should be refreshed, in seconds
                                	**type**\:  int
                                
                                	**range:** 1800..2700
                                
                                	**units**\: seconds
                                
                                	**default value**\: 1800
                                
                                .. attribute:: retransmission
                                
                                	OSPF retransmission pacing timer
                                	**type**\:  int
                                
                                	**range:** 5..200
                                
                                	**units**\: millisecond
                                
                                	**default value**\: 66
                                
                                .. attribute:: throttle_timers
                                
                                	timers value
                                	**type**\:   :py:class:`ThrottleTimers <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa.ThrottleTimers>`
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa, self).__init__()

                                    self.yang_name = "lsa"
                                    self.yang_parent_name = "database-control"

                                    self.arrival = YLeaf(YType.uint32, "arrival")

                                    self.flood = YLeaf(YType.uint32, "flood")

                                    self.group_pacing = YLeaf(YType.uint32, "group-pacing")

                                    self.refresh = YLeaf(YType.uint32, "refresh")

                                    self.retransmission = YLeaf(YType.uint32, "retransmission")

                                    self.throttle_timers = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa.ThrottleTimers()
                                    self.throttle_timers.parent = self
                                    self._children_name_map["throttle_timers"] = "throttle-timers"
                                    self._children_yang_names.add("throttle-timers")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("arrival",
                                                    "flood",
                                                    "group_pacing",
                                                    "refresh",
                                                    "retransmission") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa, self).__setattr__(name, value)


                                class ThrottleTimers(Entity):
                                    """
                                    timers value
                                    
                                    .. attribute:: init_delay
                                    
                                    	Delay between receiving a change to SPF or LSA  calculation in milliseconds
                                    	**type**\:  int
                                    
                                    	**range:** 0..600000
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: max_delay
                                    
                                    	Maximum wait time in milliseconds  for SPF or LSA calculations
                                    	**type**\:  int
                                    
                                    	**range:** 0..600000
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: min_delay
                                    
                                    	Delay between first and second SPF or LSA  calculation in milliseconds
                                    	**type**\:  int
                                    
                                    	**range:** 0..600000
                                    
                                    	**units**\: millisecond
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa.ThrottleTimers, self).__init__()

                                        self.yang_name = "throttle-timers"
                                        self.yang_parent_name = "lsa"

                                        self.init_delay = YLeaf(YType.uint32, "init-delay")

                                        self.max_delay = YLeaf(YType.uint32, "max-delay")

                                        self.min_delay = YLeaf(YType.uint32, "min-delay")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("init_delay",
                                                        "max_delay",
                                                        "min_delay") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa.ThrottleTimers, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa.ThrottleTimers, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.init_delay.is_set or
                                            self.max_delay.is_set or
                                            self.min_delay.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.init_delay.yfilter != YFilter.not_set or
                                            self.max_delay.yfilter != YFilter.not_set or
                                            self.min_delay.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "throttle-timers" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.init_delay.is_set or self.init_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.init_delay.get_name_leafdata())
                                        if (self.max_delay.is_set or self.max_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.max_delay.get_name_leafdata())
                                        if (self.min_delay.is_set or self.min_delay.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.min_delay.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "init-delay" or name == "max-delay" or name == "min-delay"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "init-delay"):
                                            self.init_delay = value
                                            self.init_delay.value_namespace = name_space
                                            self.init_delay.value_namespace_prefix = name_space_prefix
                                        if(value_path == "max-delay"):
                                            self.max_delay = value
                                            self.max_delay.value_namespace = name_space
                                            self.max_delay.value_namespace_prefix = name_space_prefix
                                        if(value_path == "min-delay"):
                                            self.min_delay = value
                                            self.min_delay.value_namespace = name_space
                                            self.min_delay.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.arrival.is_set or
                                        self.flood.is_set or
                                        self.group_pacing.is_set or
                                        self.refresh.is_set or
                                        self.retransmission.is_set or
                                        (self.throttle_timers is not None and self.throttle_timers.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.arrival.yfilter != YFilter.not_set or
                                        self.flood.yfilter != YFilter.not_set or
                                        self.group_pacing.yfilter != YFilter.not_set or
                                        self.refresh.yfilter != YFilter.not_set or
                                        self.retransmission.yfilter != YFilter.not_set or
                                        (self.throttle_timers is not None and self.throttle_timers.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:lsa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.arrival.is_set or self.arrival.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.arrival.get_name_leafdata())
                                    if (self.flood.is_set or self.flood.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.flood.get_name_leafdata())
                                    if (self.group_pacing.is_set or self.group_pacing.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.group_pacing.get_name_leafdata())
                                    if (self.refresh.is_set or self.refresh.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.refresh.get_name_leafdata())
                                    if (self.retransmission.is_set or self.retransmission.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmission.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "throttle-timers"):
                                        if (self.throttle_timers is None):
                                            self.throttle_timers = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa.ThrottleTimers()
                                            self.throttle_timers.parent = self
                                            self._children_name_map["throttle_timers"] = "throttle-timers"
                                        return self.throttle_timers

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "throttle-timers" or name == "arrival" or name == "flood" or name == "group-pacing" or name == "refresh" or name == "retransmission"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "arrival"):
                                        self.arrival = value
                                        self.arrival.value_namespace = name_space
                                        self.arrival.value_namespace_prefix = name_space_prefix
                                    if(value_path == "flood"):
                                        self.flood = value
                                        self.flood.value_namespace = name_space
                                        self.flood.value_namespace_prefix = name_space_prefix
                                    if(value_path == "group-pacing"):
                                        self.group_pacing = value
                                        self.group_pacing.value_namespace = name_space
                                        self.group_pacing.value_namespace_prefix = name_space_prefix
                                    if(value_path == "refresh"):
                                        self.refresh = value
                                        self.refresh.value_namespace = name_space
                                        self.refresh.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmission"):
                                        self.retransmission = value
                                        self.retransmission.value_namespace = name_space
                                        self.retransmission.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.max_lsa.is_set or
                                    (self.database_filter is not None and self.database_filter.has_data()) or
                                    (self.flood_reduction is not None and self.flood_reduction.has_data()) or
                                    (self.ignore_lsa is not None and self.ignore_lsa.has_data()) or
                                    (self.lsa is not None and self.lsa.has_data()) or
                                    (self.max_lsa_options is not None and self.max_lsa_options.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.max_lsa.yfilter != YFilter.not_set or
                                    (self.database_filter is not None and self.database_filter.has_operation()) or
                                    (self.flood_reduction is not None and self.flood_reduction.has_operation()) or
                                    (self.ignore_lsa is not None and self.ignore_lsa.has_operation()) or
                                    (self.lsa is not None and self.lsa.has_operation()) or
                                    (self.max_lsa_options is not None and self.max_lsa_options.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "database-control" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.max_lsa.is_set or self.max_lsa.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_lsa.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "database-filter"):
                                    if (self.database_filter is None):
                                        self.database_filter = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.DatabaseFilter()
                                        self.database_filter.parent = self
                                        self._children_name_map["database_filter"] = "database-filter"
                                    return self.database_filter

                                if (child_yang_name == "flood-reduction"):
                                    if (self.flood_reduction is None):
                                        self.flood_reduction = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.FloodReduction()
                                        self.flood_reduction.parent = self
                                        self._children_name_map["flood_reduction"] = "flood-reduction"
                                    return self.flood_reduction

                                if (child_yang_name == "ignore-lsa"):
                                    if (self.ignore_lsa is None):
                                        self.ignore_lsa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.IgnoreLsa()
                                        self.ignore_lsa.parent = self
                                        self._children_name_map["ignore_lsa"] = "ignore-lsa"
                                    return self.ignore_lsa

                                if (child_yang_name == "lsa"):
                                    if (self.lsa is None):
                                        self.lsa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.Lsa()
                                        self.lsa.parent = self
                                        self._children_name_map["lsa"] = "lsa"
                                    return self.lsa

                                if (child_yang_name == "max-lsa-options"):
                                    if (self.max_lsa_options is None):
                                        self.max_lsa_options = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl.MaxLsaOptions()
                                        self.max_lsa_options.parent = self
                                        self._children_name_map["max_lsa_options"] = "max-lsa-options"
                                    return self.max_lsa_options

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "database-filter" or name == "flood-reduction" or name == "ignore-lsa" or name == "lsa" or name == "max-lsa-options" or name == "max-lsa"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "max-lsa"):
                                    self.max_lsa = value
                                    self.max_lsa.value_namespace = name_space
                                    self.max_lsa.value_namespace_prefix = name_space_prefix


                        class Topology(Entity):
                            """
                            OSPF topology.
                            
                            .. attribute:: name  <key>
                            
                            	RIB
                            	**type**\:  str
                            
                            	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Ribs.Rib>`
                            
                            .. attribute:: area
                            
                            	List of ospf areas
                            	**type**\: list of    :py:class:`Area <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology, self).__init__()

                                self.yang_name = "topology"
                                self.yang_parent_name = "instance"

                                self.name = YLeaf(YType.str, "name")

                                self.area = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology, self).__setattr__(name, value)


                            class Area(Entity):
                                """
                                List of ospf areas
                                
                                .. attribute:: area_id  <key>
                                
                                	Area ID
                                	**type**\: one of the below types:
                                
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                
                                
                                ----
                                .. attribute:: area_type
                                
                                	Area type
                                	**type**\:   :py:class:`AreaType <ydk.models.ietf.ietf_ospf.AreaType>`
                                
                                	**default value**\: normal
                                
                                .. attribute:: default_cost
                                
                                	Set the summary default\-cost for a stub or NSSA area
                                	**type**\:  int
                                
                                	**range:** 1..16777215
                                
                                .. attribute:: range
                                
                                	Summarize routes matching address/mask (border routers only)
                                	**type**\: list of    :py:class:`Range <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area.Range>`
                                
                                .. attribute:: summary
                                
                                	Enable/Disable summary generation to the stub or NSSA area
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area, self).__init__()

                                    self.yang_name = "area"
                                    self.yang_parent_name = "topology"

                                    self.area_id = YLeaf(YType.str, "area-id")

                                    self.area_type = YLeaf(YType.identityref, "area-type")

                                    self.default_cost = YLeaf(YType.uint32, "default-cost")

                                    self.summary = YLeaf(YType.boolean, "summary")

                                    self.range = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("area_id",
                                                    "area_type",
                                                    "default_cost",
                                                    "summary") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area, self).__setattr__(name, value)


                                class Range(Entity):
                                    """
                                    Summarize routes matching address/mask (border
                                    routers only)
                                    
                                    .. attribute:: prefix  <key>
                                    
                                    	IPv4 or IPv6 prefix
                                    	**type**\:  str
                                    
                                    .. attribute:: advertise
                                    
                                    	Advertise or hide
                                    	**type**\:  bool
                                    
                                    .. attribute:: cost
                                    
                                    	Cost of summary route
                                    	**type**\:  int
                                    
                                    	**range:** 0..16777214
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area.Range, self).__init__()

                                        self.yang_name = "range"
                                        self.yang_parent_name = "area"

                                        self.prefix = YLeaf(YType.str, "prefix")

                                        self.advertise = YLeaf(YType.boolean, "advertise")

                                        self.cost = YLeaf(YType.uint32, "cost")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("prefix",
                                                        "advertise",
                                                        "cost") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area.Range, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area.Range, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.prefix.is_set or
                                            self.advertise.is_set or
                                            self.cost.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.prefix.yfilter != YFilter.not_set or
                                            self.advertise.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "range" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                        if (self.advertise.is_set or self.advertise.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.advertise.get_name_leafdata())
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "prefix" or name == "advertise" or name == "cost"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "prefix"):
                                            self.prefix = value
                                            self.prefix.value_namespace = name_space
                                            self.prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "advertise"):
                                            self.advertise = value
                                            self.advertise.value_namespace = name_space
                                            self.advertise.value_namespace_prefix = name_space_prefix
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.range:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.area_id.is_set or
                                        self.area_type.is_set or
                                        self.default_cost.is_set or
                                        self.summary.is_set)

                                def has_operation(self):
                                    for c in self.range:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.area_id.yfilter != YFilter.not_set or
                                        self.area_type.yfilter != YFilter.not_set or
                                        self.default_cost.yfilter != YFilter.not_set or
                                        self.summary.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "area" + "[area-id='" + self.area_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area_id.get_name_leafdata())
                                    if (self.area_type.is_set or self.area_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.area_type.get_name_leafdata())
                                    if (self.default_cost.is_set or self.default_cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.default_cost.get_name_leafdata())
                                    if (self.summary.is_set or self.summary.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.summary.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "range"):
                                        for c in self.range:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area.Range()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.range.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "range" or name == "area-id" or name == "area-type" or name == "default-cost" or name == "summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "area-id"):
                                        self.area_id = value
                                        self.area_id.value_namespace = name_space
                                        self.area_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "area-type"):
                                        self.area_type = value
                                        self.area_type.value_namespace = name_space
                                        self.area_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "default-cost"):
                                        self.default_cost = value
                                        self.default_cost.value_namespace = name_space
                                        self.default_cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "summary"):
                                        self.summary = value
                                        self.summary.value_namespace = name_space
                                        self.summary.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.area:
                                    if (c.has_data()):
                                        return True
                                return self.name.is_set

                            def has_operation(self):
                                for c in self.area:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "topology" + "[name='" + self.name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "area"):
                                    for c in self.area:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology.Area()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.area.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "area" or name == "name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "name"):
                                    self.name = value
                                    self.name.value_namespace = name_space
                                    self.name.value_namespace_prefix = name_space_prefix


                        class AdminDistance(Entity):
                            """
                            Admin distance config state.
                            
                            .. attribute:: external
                            
                            	Admin distance for both external route
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: inter_area
                            
                            	Admin distance for inter\-area route
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: internal
                            
                            	Admin distance for both intra\-area and inter\-area route
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: intra_area
                            
                            	Admin distance for intra\-area route
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: ospf_distance
                            
                            	configuration of Admin Distance
                            	**type**\:   :py:class:`OspfDistance <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance.OspfDistance>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance, self).__init__()

                                self.yang_name = "admin-distance"
                                self.yang_parent_name = "instance"

                                self.external = YLeaf(YType.uint8, "external")

                                self.inter_area = YLeaf(YType.uint8, "inter-area")

                                self.internal = YLeaf(YType.uint8, "internal")

                                self.intra_area = YLeaf(YType.uint8, "intra-area")

                                self.ospf_distance = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance.OspfDistance()
                                self.ospf_distance.parent = self
                                self._children_name_map["ospf_distance"] = "ospf-distance"
                                self._children_yang_names.add("ospf-distance")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("external",
                                                "inter_area",
                                                "internal",
                                                "intra_area") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance, self).__setattr__(name, value)


                            class OspfDistance(Entity):
                                """
                                configuration of Admin Distance
                                
                                .. attribute:: acl_name
                                
                                	standard acl
                                	**type**\: one of the below types:
                                
                                	**type**\:  int
                                
                                	**range:** 1..99
                                
                                
                                ----
                                	**type**\:  int
                                
                                	**range:** 1300..1999
                                
                                
                                ----
                                
                                ----
                                	**type**\:  str
                                
                                
                                ----
                                .. attribute:: distance
                                
                                	<1\-255>;;OSPF Administrative distance
                                	**type**\:  int
                                
                                	**range:** 1..255
                                
                                .. attribute:: ip
                                
                                	A.B.C.D;;IP source address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: wildcard
                                
                                	A.B.C.D;;Wildcard bits
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'cisco-ospf'
                                _revision = '2016-03-30'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance.OspfDistance, self).__init__()

                                    self.yang_name = "ospf-distance"
                                    self.yang_parent_name = "admin-distance"

                                    self.acl_name = YLeaf(YType.str, "acl-name")

                                    self.distance = YLeaf(YType.uint32, "distance")

                                    self.ip = YLeaf(YType.str, "ip")

                                    self.wildcard = YLeaf(YType.str, "wildcard")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("acl_name",
                                                    "distance",
                                                    "ip",
                                                    "wildcard") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance.OspfDistance, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance.OspfDistance, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.acl_name.is_set or
                                        self.distance.is_set or
                                        self.ip.is_set or
                                        self.wildcard.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.acl_name.yfilter != YFilter.not_set or
                                        self.distance.yfilter != YFilter.not_set or
                                        self.ip.yfilter != YFilter.not_set or
                                        self.wildcard.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cisco-ospf:ospf-distance" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.acl_name.is_set or self.acl_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.acl_name.get_name_leafdata())
                                    if (self.distance.is_set or self.distance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.distance.get_name_leafdata())
                                    if (self.ip.is_set or self.ip.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ip.get_name_leafdata())
                                    if (self.wildcard.is_set or self.wildcard.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.wildcard.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "acl-name" or name == "distance" or name == "ip" or name == "wildcard"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "acl-name"):
                                        self.acl_name = value
                                        self.acl_name.value_namespace = name_space
                                        self.acl_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "distance"):
                                        self.distance = value
                                        self.distance.value_namespace = name_space
                                        self.distance.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ip"):
                                        self.ip = value
                                        self.ip.value_namespace = name_space
                                        self.ip.value_namespace_prefix = name_space_prefix
                                    if(value_path == "wildcard"):
                                        self.wildcard = value
                                        self.wildcard.value_namespace = name_space
                                        self.wildcard.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.external.is_set or
                                    self.inter_area.is_set or
                                    self.internal.is_set or
                                    self.intra_area.is_set or
                                    (self.ospf_distance is not None and self.ospf_distance.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.external.yfilter != YFilter.not_set or
                                    self.inter_area.yfilter != YFilter.not_set or
                                    self.internal.yfilter != YFilter.not_set or
                                    self.intra_area.yfilter != YFilter.not_set or
                                    (self.ospf_distance is not None and self.ospf_distance.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "admin-distance" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.external.is_set or self.external.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.external.get_name_leafdata())
                                if (self.inter_area.is_set or self.inter_area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.inter_area.get_name_leafdata())
                                if (self.internal.is_set or self.internal.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.internal.get_name_leafdata())
                                if (self.intra_area.is_set or self.intra_area.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.intra_area.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "ospf-distance"):
                                    if (self.ospf_distance is None):
                                        self.ospf_distance = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance.OspfDistance()
                                        self.ospf_distance.parent = self
                                        self._children_name_map["ospf_distance"] = "ospf-distance"
                                    return self.ospf_distance

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ospf-distance" or name == "external" or name == "inter-area" or name == "internal" or name == "intra-area"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "external"):
                                    self.external = value
                                    self.external.value_namespace = name_space
                                    self.external.value_namespace_prefix = name_space_prefix
                                if(value_path == "inter-area"):
                                    self.inter_area = value
                                    self.inter_area.value_namespace = name_space
                                    self.inter_area.value_namespace_prefix = name_space_prefix
                                if(value_path == "internal"):
                                    self.internal = value
                                    self.internal.value_namespace = name_space
                                    self.internal.value_namespace_prefix = name_space_prefix
                                if(value_path == "intra-area"):
                                    self.intra_area = value
                                    self.intra_area.value_namespace = name_space
                                    self.intra_area.value_namespace_prefix = name_space_prefix


                        class Area(Entity):
                            """
                            List of ospf areas
                            
                            .. attribute:: area_id  <key>
                            
                            	Area ID
                            	**type**\: one of the below types:
                            
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                            
                            
                            ----
                            .. attribute:: all_interfaces_inherit
                            
                            	Inheritance for all interfaces
                            	**type**\:   :py:class:`AllInterfacesInherit <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit>`
                            
                            .. attribute:: area_type
                            
                            	Area type
                            	**type**\:   :py:class:`AreaType <ydk.models.ietf.ietf_ospf.AreaType>`
                            
                            	**default value**\: normal
                            
                            .. attribute:: default_cost
                            
                            	Set the summary default\-cost for a stub or NSSA area
                            	**type**\:  int
                            
                            	**range:** 1..16777215
                            
                            .. attribute:: interface
                            
                            	List of OSPF interfaces
                            	**type**\: list of    :py:class:`Interface <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface>`
                            
                            .. attribute:: range
                            
                            	Summarize routes matching address/mask (border routers only)
                            	**type**\: list of    :py:class:`Range <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Range>`
                            
                            .. attribute:: sham_link
                            
                            	OSPF sham link
                            	**type**\: list of    :py:class:`ShamLink <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink>`
                            
                            .. attribute:: summary
                            
                            	Enable/Disable summary generation to the stub or NSSA area
                            	**type**\:  bool
                            
                            .. attribute:: virtual_link
                            
                            	OSPF virtual link
                            	**type**\: list of    :py:class:`VirtualLink <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink>`
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area, self).__init__()

                                self.yang_name = "area"
                                self.yang_parent_name = "instance"

                                self.area_id = YLeaf(YType.str, "area-id")

                                self.area_type = YLeaf(YType.identityref, "area-type")

                                self.default_cost = YLeaf(YType.uint32, "default-cost")

                                self.summary = YLeaf(YType.boolean, "summary")

                                self.all_interfaces_inherit = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit()
                                self.all_interfaces_inherit.parent = self
                                self._children_name_map["all_interfaces_inherit"] = "all-interfaces-inherit"
                                self._children_yang_names.add("all-interfaces-inherit")

                                self.interface = YList(self)
                                self.range = YList(self)
                                self.sham_link = YList(self)
                                self.virtual_link = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area_id",
                                                "area_type",
                                                "default_cost",
                                                "summary") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area, self).__setattr__(name, value)


                            class Range(Entity):
                                """
                                Summarize routes matching address/mask (border
                                routers only)
                                
                                .. attribute:: prefix  <key>
                                
                                	IPv4 or IPv6 prefix
                                	**type**\:  str
                                
                                .. attribute:: advertise
                                
                                	Advertise or hide
                                	**type**\:  bool
                                
                                .. attribute:: cost
                                
                                	Cost of summary route
                                	**type**\:  int
                                
                                	**range:** 0..16777214
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Range, self).__init__()

                                    self.yang_name = "range"
                                    self.yang_parent_name = "area"

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.advertise = YLeaf(YType.boolean, "advertise")

                                    self.cost = YLeaf(YType.uint32, "cost")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("prefix",
                                                    "advertise",
                                                    "cost") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Range, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Range, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.prefix.is_set or
                                        self.advertise.is_set or
                                        self.cost.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.advertise.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "range" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.advertise.is_set or self.advertise.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.advertise.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "prefix" or name == "advertise" or name == "cost"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "advertise"):
                                        self.advertise = value
                                        self.advertise.value_namespace = name_space
                                        self.advertise.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix


                            class AllInterfacesInherit(Entity):
                                """
                                Inheritance for all interfaces
                                
                                .. attribute:: interface
                                
                                	Interface config to be inherited by all interfaces
                                	**type**\:   :py:class:`Interface <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit.Interface>`
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit, self).__init__()

                                    self.yang_name = "all-interfaces-inherit"
                                    self.yang_parent_name = "area"

                                    self.interface = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit.Interface()
                                    self.interface.parent = self
                                    self._children_name_map["interface"] = "interface"
                                    self._children_yang_names.add("interface")


                                class Interface(Entity):
                                    """
                                    Interface config to be inherited by all
                                    interfaces.
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit.Interface, self).__init__()

                                        self.yang_name = "interface"
                                        self.yang_parent_name = "all-interfaces-inherit"

                                    def has_data(self):
                                        return False

                                    def has_operation(self):
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (self.interface is not None and self.interface.has_data())

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.interface is not None and self.interface.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "all-interfaces-inherit" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "interface"):
                                        if (self.interface is None):
                                            self.interface = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit.Interface()
                                            self.interface.parent = self
                                            self._children_name_map["interface"] = "interface"
                                        return self.interface

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class VirtualLink(Entity):
                                """
                                OSPF virtual link
                                
                                .. attribute:: router_id  <key>
                                
                                	Virtual link router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                
                                .. attribute:: authentication
                                
                                	Authentication configuration
                                	**type**\:   :py:class:`Authentication <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication>`
                                
                                .. attribute:: bfd
                                
                                	Enable/disable bfd
                                	**type**\:  bool
                                
                                .. attribute:: cost
                                
                                	Interface cost
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: enable
                                
                                	Enable/disable protocol on the interface
                                	**type**\:  bool
                                
                                	**default value**\: true
                                
                                .. attribute:: hello_interval
                                
                                	Time between hello packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: lls
                                
                                	Enable/Disable link\-local signaling (LLS) support
                                	**type**\:  bool
                                
                                .. attribute:: mtu_ignore
                                
                                	Enable/Disable ignoring of MTU in DBD packets
                                	**type**\:  bool
                                
                                .. attribute:: prefix_suppression
                                
                                	Suppress advertisement of the prefixes
                                	**type**\:  bool
                                
                                .. attribute:: retransmit_interval
                                
                                	Time between retransmitting unacknowledged Link State Advertisements (LSAs)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: transmit_delay
                                
                                	Estimated time needed to send link\-state update
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: ttl_security
                                
                                	TTL security check
                                	**type**\:   :py:class:`TtlSecurity <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.TtlSecurity>`
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink, self).__init__()

                                    self.yang_name = "virtual-link"
                                    self.yang_parent_name = "area"

                                    self.router_id = YLeaf(YType.str, "router-id")

                                    self.bfd = YLeaf(YType.boolean, "bfd")

                                    self.cost = YLeaf(YType.uint16, "cost")

                                    self.dead_interval = YLeaf(YType.uint16, "dead-interval")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                                    self.lls = YLeaf(YType.boolean, "lls")

                                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                    self.retransmit_interval = YLeaf(YType.uint16, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint16, "transmit-delay")

                                    self.authentication = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.ttl_security = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.TtlSecurity()
                                    self.ttl_security.parent = self
                                    self._children_name_map["ttl_security"] = "ttl-security"
                                    self._children_yang_names.add("ttl-security")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("router_id",
                                                    "bfd",
                                                    "cost",
                                                    "dead_interval",
                                                    "enable",
                                                    "hello_interval",
                                                    "lls",
                                                    "mtu_ignore",
                                                    "prefix_suppression",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink, self).__setattr__(name, value)


                                class Authentication(Entity):
                                    """
                                    Authentication configuration.
                                    
                                    .. attribute:: crypto_algorithm
                                    
                                    	Cryptographic algorithm associated with key
                                    	**type**\:   :py:class:`CryptoAlgorithm <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication.CryptoAlgorithm>`
                                    
                                    .. attribute:: key
                                    
                                    	Key string in ASCII format
                                    	**type**\:  str
                                    
                                    .. attribute:: key_chain
                                    
                                    	key\-chain name
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_key_chain.KeyChains>`
                                    
                                    .. attribute:: sa
                                    
                                    	SA name
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "virtual-link"

                                        self.key = YLeaf(YType.str, "key")

                                        self.key_chain = YLeaf(YType.str, "key-chain")

                                        self.sa = YLeaf(YType.str, "sa")

                                        self.crypto_algorithm = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication.CryptoAlgorithm()
                                        self.crypto_algorithm.parent = self
                                        self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                        self._children_yang_names.add("crypto-algorithm")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("key",
                                                        "key_chain",
                                                        "sa") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication, self).__setattr__(name, value)


                                    class CryptoAlgorithm(Entity):
                                        """
                                        Cryptographic algorithm associated with key.
                                        
                                        .. attribute:: hmac_sha1_12
                                        
                                        	The HMAC\-SHA1\-12 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha1_20
                                        
                                        	The HMAC\-SHA1\-20 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_1
                                        
                                        	HMAC\-SHA\-1 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_256
                                        
                                        	HMAC\-SHA\-256 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_384
                                        
                                        	HMAC\-SHA\-384 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_512
                                        
                                        	HMAC\-SHA\-512 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: md5
                                        
                                        	The MD5 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: sha_1
                                        
                                        	The SHA\-1 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication.CryptoAlgorithm, self).__init__()

                                            self.yang_name = "crypto-algorithm"
                                            self.yang_parent_name = "authentication"

                                            self.hmac_sha1_12 = YLeaf(YType.empty, "hmac-sha1-12")

                                            self.hmac_sha1_20 = YLeaf(YType.empty, "hmac-sha1-20")

                                            self.hmac_sha_1 = YLeaf(YType.empty, "hmac-sha-1")

                                            self.hmac_sha_256 = YLeaf(YType.empty, "hmac-sha-256")

                                            self.hmac_sha_384 = YLeaf(YType.empty, "hmac-sha-384")

                                            self.hmac_sha_512 = YLeaf(YType.empty, "hmac-sha-512")

                                            self.md5 = YLeaf(YType.empty, "md5")

                                            self.sha_1 = YLeaf(YType.empty, "sha-1")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("hmac_sha1_12",
                                                            "hmac_sha1_20",
                                                            "hmac_sha_1",
                                                            "hmac_sha_256",
                                                            "hmac_sha_384",
                                                            "hmac_sha_512",
                                                            "md5",
                                                            "sha_1") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication.CryptoAlgorithm, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication.CryptoAlgorithm, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.hmac_sha1_12.is_set or
                                                self.hmac_sha1_20.is_set or
                                                self.hmac_sha_1.is_set or
                                                self.hmac_sha_256.is_set or
                                                self.hmac_sha_384.is_set or
                                                self.hmac_sha_512.is_set or
                                                self.md5.is_set or
                                                self.sha_1.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.hmac_sha1_12.yfilter != YFilter.not_set or
                                                self.hmac_sha1_20.yfilter != YFilter.not_set or
                                                self.hmac_sha_1.yfilter != YFilter.not_set or
                                                self.hmac_sha_256.yfilter != YFilter.not_set or
                                                self.hmac_sha_384.yfilter != YFilter.not_set or
                                                self.hmac_sha_512.yfilter != YFilter.not_set or
                                                self.md5.yfilter != YFilter.not_set or
                                                self.sha_1.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "crypto-algorithm" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.hmac_sha1_12.is_set or self.hmac_sha1_12.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_12.get_name_leafdata())
                                            if (self.hmac_sha1_20.is_set or self.hmac_sha1_20.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_20.get_name_leafdata())
                                            if (self.hmac_sha_1.is_set or self.hmac_sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_1.get_name_leafdata())
                                            if (self.hmac_sha_256.is_set or self.hmac_sha_256.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_256.get_name_leafdata())
                                            if (self.hmac_sha_384.is_set or self.hmac_sha_384.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_384.get_name_leafdata())
                                            if (self.hmac_sha_512.is_set or self.hmac_sha_512.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_512.get_name_leafdata())
                                            if (self.md5.is_set or self.md5.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.md5.get_name_leafdata())
                                            if (self.sha_1.is_set or self.sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sha_1.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "hmac-sha1-12" or name == "hmac-sha1-20" or name == "hmac-sha-1" or name == "hmac-sha-256" or name == "hmac-sha-384" or name == "hmac-sha-512" or name == "md5" or name == "sha-1"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "hmac-sha1-12"):
                                                self.hmac_sha1_12 = value
                                                self.hmac_sha1_12.value_namespace = name_space
                                                self.hmac_sha1_12.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha1-20"):
                                                self.hmac_sha1_20 = value
                                                self.hmac_sha1_20.value_namespace = name_space
                                                self.hmac_sha1_20.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-1"):
                                                self.hmac_sha_1 = value
                                                self.hmac_sha_1.value_namespace = name_space
                                                self.hmac_sha_1.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-256"):
                                                self.hmac_sha_256 = value
                                                self.hmac_sha_256.value_namespace = name_space
                                                self.hmac_sha_256.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-384"):
                                                self.hmac_sha_384 = value
                                                self.hmac_sha_384.value_namespace = name_space
                                                self.hmac_sha_384.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-512"):
                                                self.hmac_sha_512 = value
                                                self.hmac_sha_512.value_namespace = name_space
                                                self.hmac_sha_512.value_namespace_prefix = name_space_prefix
                                            if(value_path == "md5"):
                                                self.md5 = value
                                                self.md5.value_namespace = name_space
                                                self.md5.value_namespace_prefix = name_space_prefix
                                            if(value_path == "sha-1"):
                                                self.sha_1 = value
                                                self.sha_1.value_namespace = name_space
                                                self.sha_1.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.key.is_set or
                                            self.key_chain.is_set or
                                            self.sa.is_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.key.yfilter != YFilter.not_set or
                                            self.key_chain.yfilter != YFilter.not_set or
                                            self.sa.yfilter != YFilter.not_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key.get_name_leafdata())
                                        if (self.key_chain.is_set or self.key_chain.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key_chain.get_name_leafdata())
                                        if (self.sa.is_set or self.sa.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.sa.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "crypto-algorithm"):
                                            if (self.crypto_algorithm is None):
                                                self.crypto_algorithm = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication.CryptoAlgorithm()
                                                self.crypto_algorithm.parent = self
                                                self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                            return self.crypto_algorithm

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "crypto-algorithm" or name == "key" or name == "key-chain" or name == "sa"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "key"):
                                            self.key = value
                                            self.key.value_namespace = name_space
                                            self.key.value_namespace_prefix = name_space_prefix
                                        if(value_path == "key-chain"):
                                            self.key_chain = value
                                            self.key_chain.value_namespace = name_space
                                            self.key_chain.value_namespace_prefix = name_space_prefix
                                        if(value_path == "sa"):
                                            self.sa = value
                                            self.sa.value_namespace = name_space
                                            self.sa.value_namespace_prefix = name_space_prefix


                                class TtlSecurity(Entity):
                                    """
                                    TTL security check.
                                    
                                    .. attribute:: enable
                                    
                                    	Enable/Disable TTL security check
                                    	**type**\:  bool
                                    
                                    .. attribute:: hops
                                    
                                    	Maximum number of hops that a OSPF packet may have traveled
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.TtlSecurity, self).__init__()

                                        self.yang_name = "ttl-security"
                                        self.yang_parent_name = "virtual-link"

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.hops = YLeaf(YType.uint8, "hops")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("enable",
                                                        "hops") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.TtlSecurity, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.TtlSecurity, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.enable.is_set or
                                            self.hops.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hops.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ttl-security" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hops.is_set or self.hops.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hops.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "enable" or name == "hops"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hops"):
                                            self.hops = value
                                            self.hops.value_namespace = name_space
                                            self.hops.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.router_id.is_set or
                                        self.bfd.is_set or
                                        self.cost.is_set or
                                        self.dead_interval.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.lls.is_set or
                                        self.mtu_ignore.is_set or
                                        self.prefix_suppression.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.ttl_security is not None and self.ttl_security.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.router_id.yfilter != YFilter.not_set or
                                        self.bfd.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.lls.yfilter != YFilter.not_set or
                                        self.mtu_ignore.yfilter != YFilter.not_set or
                                        self.prefix_suppression.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.ttl_security is not None and self.ttl_security.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "virtual-link" + "[router-id='" + self.router_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.router_id.get_name_leafdata())
                                    if (self.bfd.is_set or self.bfd.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bfd.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.lls.is_set or self.lls.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lls.get_name_leafdata())
                                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "ttl-security"):
                                        if (self.ttl_security is None):
                                            self.ttl_security = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink.TtlSecurity()
                                            self.ttl_security.parent = self
                                            self._children_name_map["ttl_security"] = "ttl-security"
                                        return self.ttl_security

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "ttl-security" or name == "router-id" or name == "bfd" or name == "cost" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "lls" or name == "mtu-ignore" or name == "prefix-suppression" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "router-id"):
                                        self.router_id = value
                                        self.router_id.value_namespace = name_space
                                        self.router_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bfd"):
                                        self.bfd = value
                                        self.bfd.value_namespace = name_space
                                        self.bfd.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lls"):
                                        self.lls = value
                                        self.lls.value_namespace = name_space
                                        self.lls.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mtu-ignore"):
                                        self.mtu_ignore = value
                                        self.mtu_ignore.value_namespace = name_space
                                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-suppression"):
                                        self.prefix_suppression = value
                                        self.prefix_suppression.value_namespace = name_space
                                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix


                            class ShamLink(Entity):
                                """
                                OSPF sham link
                                
                                .. attribute:: local_id  <key>
                                
                                	Address of the local end\-point
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                .. attribute:: remote_id  <key>
                                
                                	Address of the remote end\-point
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                .. attribute:: authentication
                                
                                	Authentication configuration
                                	**type**\:   :py:class:`Authentication <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication>`
                                
                                .. attribute:: bfd
                                
                                	Enable/disable bfd
                                	**type**\:  bool
                                
                                .. attribute:: cost
                                
                                	Interface cost
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: enable
                                
                                	Enable/disable protocol on the interface
                                	**type**\:  bool
                                
                                	**default value**\: true
                                
                                .. attribute:: hello_interval
                                
                                	Time between hello packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: lls
                                
                                	Enable/Disable link\-local signaling (LLS) support
                                	**type**\:  bool
                                
                                .. attribute:: mtu_ignore
                                
                                	Enable/Disable ignoring of MTU in DBD packets
                                	**type**\:  bool
                                
                                .. attribute:: prefix_suppression
                                
                                	Suppress advertisement of the prefixes
                                	**type**\:  bool
                                
                                .. attribute:: retransmit_interval
                                
                                	Time between retransmitting unacknowledged Link State Advertisements (LSAs)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: transmit_delay
                                
                                	Estimated time needed to send link\-state update
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: ttl_security
                                
                                	TTL security check
                                	**type**\:   :py:class:`TtlSecurity <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.TtlSecurity>`
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink, self).__init__()

                                    self.yang_name = "sham-link"
                                    self.yang_parent_name = "area"

                                    self.local_id = YLeaf(YType.str, "local-id")

                                    self.remote_id = YLeaf(YType.str, "remote-id")

                                    self.bfd = YLeaf(YType.boolean, "bfd")

                                    self.cost = YLeaf(YType.uint16, "cost")

                                    self.dead_interval = YLeaf(YType.uint16, "dead-interval")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                                    self.lls = YLeaf(YType.boolean, "lls")

                                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                    self.retransmit_interval = YLeaf(YType.uint16, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint16, "transmit-delay")

                                    self.authentication = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.ttl_security = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.TtlSecurity()
                                    self.ttl_security.parent = self
                                    self._children_name_map["ttl_security"] = "ttl-security"
                                    self._children_yang_names.add("ttl-security")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("local_id",
                                                    "remote_id",
                                                    "bfd",
                                                    "cost",
                                                    "dead_interval",
                                                    "enable",
                                                    "hello_interval",
                                                    "lls",
                                                    "mtu_ignore",
                                                    "prefix_suppression",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink, self).__setattr__(name, value)


                                class TtlSecurity(Entity):
                                    """
                                    TTL security check.
                                    
                                    .. attribute:: enable
                                    
                                    	Enable/Disable TTL security check
                                    	**type**\:  bool
                                    
                                    .. attribute:: hops
                                    
                                    	Maximum number of hops that a OSPF packet may have traveled
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.TtlSecurity, self).__init__()

                                        self.yang_name = "ttl-security"
                                        self.yang_parent_name = "sham-link"

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.hops = YLeaf(YType.uint8, "hops")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("enable",
                                                        "hops") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.TtlSecurity, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.TtlSecurity, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.enable.is_set or
                                            self.hops.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hops.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ttl-security" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hops.is_set or self.hops.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hops.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "enable" or name == "hops"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hops"):
                                            self.hops = value
                                            self.hops.value_namespace = name_space
                                            self.hops.value_namespace_prefix = name_space_prefix


                                class Authentication(Entity):
                                    """
                                    Authentication configuration.
                                    
                                    .. attribute:: crypto_algorithm
                                    
                                    	Cryptographic algorithm associated with key
                                    	**type**\:   :py:class:`CryptoAlgorithm <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication.CryptoAlgorithm>`
                                    
                                    .. attribute:: key
                                    
                                    	Key string in ASCII format
                                    	**type**\:  str
                                    
                                    .. attribute:: key_chain
                                    
                                    	key\-chain name
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_key_chain.KeyChains>`
                                    
                                    .. attribute:: sa
                                    
                                    	SA name
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "sham-link"

                                        self.key = YLeaf(YType.str, "key")

                                        self.key_chain = YLeaf(YType.str, "key-chain")

                                        self.sa = YLeaf(YType.str, "sa")

                                        self.crypto_algorithm = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication.CryptoAlgorithm()
                                        self.crypto_algorithm.parent = self
                                        self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                        self._children_yang_names.add("crypto-algorithm")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("key",
                                                        "key_chain",
                                                        "sa") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication, self).__setattr__(name, value)


                                    class CryptoAlgorithm(Entity):
                                        """
                                        Cryptographic algorithm associated with key.
                                        
                                        .. attribute:: hmac_sha1_12
                                        
                                        	The HMAC\-SHA1\-12 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha1_20
                                        
                                        	The HMAC\-SHA1\-20 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_1
                                        
                                        	HMAC\-SHA\-1 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_256
                                        
                                        	HMAC\-SHA\-256 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_384
                                        
                                        	HMAC\-SHA\-384 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_512
                                        
                                        	HMAC\-SHA\-512 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: md5
                                        
                                        	The MD5 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: sha_1
                                        
                                        	The SHA\-1 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication.CryptoAlgorithm, self).__init__()

                                            self.yang_name = "crypto-algorithm"
                                            self.yang_parent_name = "authentication"

                                            self.hmac_sha1_12 = YLeaf(YType.empty, "hmac-sha1-12")

                                            self.hmac_sha1_20 = YLeaf(YType.empty, "hmac-sha1-20")

                                            self.hmac_sha_1 = YLeaf(YType.empty, "hmac-sha-1")

                                            self.hmac_sha_256 = YLeaf(YType.empty, "hmac-sha-256")

                                            self.hmac_sha_384 = YLeaf(YType.empty, "hmac-sha-384")

                                            self.hmac_sha_512 = YLeaf(YType.empty, "hmac-sha-512")

                                            self.md5 = YLeaf(YType.empty, "md5")

                                            self.sha_1 = YLeaf(YType.empty, "sha-1")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("hmac_sha1_12",
                                                            "hmac_sha1_20",
                                                            "hmac_sha_1",
                                                            "hmac_sha_256",
                                                            "hmac_sha_384",
                                                            "hmac_sha_512",
                                                            "md5",
                                                            "sha_1") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication.CryptoAlgorithm, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication.CryptoAlgorithm, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.hmac_sha1_12.is_set or
                                                self.hmac_sha1_20.is_set or
                                                self.hmac_sha_1.is_set or
                                                self.hmac_sha_256.is_set or
                                                self.hmac_sha_384.is_set or
                                                self.hmac_sha_512.is_set or
                                                self.md5.is_set or
                                                self.sha_1.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.hmac_sha1_12.yfilter != YFilter.not_set or
                                                self.hmac_sha1_20.yfilter != YFilter.not_set or
                                                self.hmac_sha_1.yfilter != YFilter.not_set or
                                                self.hmac_sha_256.yfilter != YFilter.not_set or
                                                self.hmac_sha_384.yfilter != YFilter.not_set or
                                                self.hmac_sha_512.yfilter != YFilter.not_set or
                                                self.md5.yfilter != YFilter.not_set or
                                                self.sha_1.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "crypto-algorithm" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.hmac_sha1_12.is_set or self.hmac_sha1_12.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_12.get_name_leafdata())
                                            if (self.hmac_sha1_20.is_set or self.hmac_sha1_20.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_20.get_name_leafdata())
                                            if (self.hmac_sha_1.is_set or self.hmac_sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_1.get_name_leafdata())
                                            if (self.hmac_sha_256.is_set or self.hmac_sha_256.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_256.get_name_leafdata())
                                            if (self.hmac_sha_384.is_set or self.hmac_sha_384.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_384.get_name_leafdata())
                                            if (self.hmac_sha_512.is_set or self.hmac_sha_512.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_512.get_name_leafdata())
                                            if (self.md5.is_set or self.md5.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.md5.get_name_leafdata())
                                            if (self.sha_1.is_set or self.sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sha_1.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "hmac-sha1-12" or name == "hmac-sha1-20" or name == "hmac-sha-1" or name == "hmac-sha-256" or name == "hmac-sha-384" or name == "hmac-sha-512" or name == "md5" or name == "sha-1"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "hmac-sha1-12"):
                                                self.hmac_sha1_12 = value
                                                self.hmac_sha1_12.value_namespace = name_space
                                                self.hmac_sha1_12.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha1-20"):
                                                self.hmac_sha1_20 = value
                                                self.hmac_sha1_20.value_namespace = name_space
                                                self.hmac_sha1_20.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-1"):
                                                self.hmac_sha_1 = value
                                                self.hmac_sha_1.value_namespace = name_space
                                                self.hmac_sha_1.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-256"):
                                                self.hmac_sha_256 = value
                                                self.hmac_sha_256.value_namespace = name_space
                                                self.hmac_sha_256.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-384"):
                                                self.hmac_sha_384 = value
                                                self.hmac_sha_384.value_namespace = name_space
                                                self.hmac_sha_384.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-512"):
                                                self.hmac_sha_512 = value
                                                self.hmac_sha_512.value_namespace = name_space
                                                self.hmac_sha_512.value_namespace_prefix = name_space_prefix
                                            if(value_path == "md5"):
                                                self.md5 = value
                                                self.md5.value_namespace = name_space
                                                self.md5.value_namespace_prefix = name_space_prefix
                                            if(value_path == "sha-1"):
                                                self.sha_1 = value
                                                self.sha_1.value_namespace = name_space
                                                self.sha_1.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.key.is_set or
                                            self.key_chain.is_set or
                                            self.sa.is_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.key.yfilter != YFilter.not_set or
                                            self.key_chain.yfilter != YFilter.not_set or
                                            self.sa.yfilter != YFilter.not_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key.get_name_leafdata())
                                        if (self.key_chain.is_set or self.key_chain.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key_chain.get_name_leafdata())
                                        if (self.sa.is_set or self.sa.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.sa.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "crypto-algorithm"):
                                            if (self.crypto_algorithm is None):
                                                self.crypto_algorithm = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication.CryptoAlgorithm()
                                                self.crypto_algorithm.parent = self
                                                self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                            return self.crypto_algorithm

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "crypto-algorithm" or name == "key" or name == "key-chain" or name == "sa"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "key"):
                                            self.key = value
                                            self.key.value_namespace = name_space
                                            self.key.value_namespace_prefix = name_space_prefix
                                        if(value_path == "key-chain"):
                                            self.key_chain = value
                                            self.key_chain.value_namespace = name_space
                                            self.key_chain.value_namespace_prefix = name_space_prefix
                                        if(value_path == "sa"):
                                            self.sa = value
                                            self.sa.value_namespace = name_space
                                            self.sa.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.local_id.is_set or
                                        self.remote_id.is_set or
                                        self.bfd.is_set or
                                        self.cost.is_set or
                                        self.dead_interval.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.lls.is_set or
                                        self.mtu_ignore.is_set or
                                        self.prefix_suppression.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.ttl_security is not None and self.ttl_security.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.local_id.yfilter != YFilter.not_set or
                                        self.remote_id.yfilter != YFilter.not_set or
                                        self.bfd.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.lls.yfilter != YFilter.not_set or
                                        self.mtu_ignore.yfilter != YFilter.not_set or
                                        self.prefix_suppression.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.ttl_security is not None and self.ttl_security.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sham-link" + "[local-id='" + self.local_id.get() + "']" + "[remote-id='" + self.remote_id.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.local_id.is_set or self.local_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.local_id.get_name_leafdata())
                                    if (self.remote_id.is_set or self.remote_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_id.get_name_leafdata())
                                    if (self.bfd.is_set or self.bfd.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bfd.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.lls.is_set or self.lls.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lls.get_name_leafdata())
                                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "ttl-security"):
                                        if (self.ttl_security is None):
                                            self.ttl_security = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink.TtlSecurity()
                                            self.ttl_security.parent = self
                                            self._children_name_map["ttl_security"] = "ttl-security"
                                        return self.ttl_security

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "ttl-security" or name == "local-id" or name == "remote-id" or name == "bfd" or name == "cost" or name == "dead-interval" or name == "enable" or name == "hello-interval" or name == "lls" or name == "mtu-ignore" or name == "prefix-suppression" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "local-id"):
                                        self.local_id = value
                                        self.local_id.value_namespace = name_space
                                        self.local_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-id"):
                                        self.remote_id = value
                                        self.remote_id.value_namespace = name_space
                                        self.remote_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bfd"):
                                        self.bfd = value
                                        self.bfd.value_namespace = name_space
                                        self.bfd.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lls"):
                                        self.lls = value
                                        self.lls.value_namespace = name_space
                                        self.lls.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mtu-ignore"):
                                        self.mtu_ignore = value
                                        self.mtu_ignore.value_namespace = name_space
                                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-suppression"):
                                        self.prefix_suppression = value
                                        self.prefix_suppression.value_namespace = name_space
                                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix


                            class Interface(Entity):
                                """
                                List of OSPF interfaces.
                                
                                .. attribute:: interface  <key>
                                
                                	Interface
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: authentication
                                
                                	Authentication configuration
                                	**type**\:   :py:class:`Authentication <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication>`
                                
                                .. attribute:: bfd
                                
                                	Enable/disable bfd
                                	**type**\:  bool
                                
                                .. attribute:: cost
                                
                                	Interface cost
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                .. attribute:: database_filter
                                
                                	Filter OSPF LSA during synchronization and flooding
                                	**type**\:   :py:class:`DatabaseFilter <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.DatabaseFilter>`
                                
                                .. attribute:: dead_interval
                                
                                	Interval after which a neighbor is declared dead
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: demand_circuit
                                
                                	Enable/Disable demand circuit
                                	**type**\:  bool
                                
                                .. attribute:: enable
                                
                                	Enable/disable protocol on the interface
                                	**type**\:  bool
                                
                                	**default value**\: true
                                
                                .. attribute:: fast_reroute
                                
                                	Fast\-reroute configuration
                                	**type**\:   :py:class:`FastReroute <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute>`
                                
                                .. attribute:: flood_reduction
                                
                                	OSPF Flood Reduction
                                	**type**\:   :py:class:`FloodReduction <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FloodReduction>`
                                
                                .. attribute:: hello_interval
                                
                                	Time between hello packets
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: lls
                                
                                	Enable/Disable link\-local signaling (LLS) support
                                	**type**\:  bool
                                
                                .. attribute:: mtu_ignore
                                
                                	Enable/Disable ignoring of MTU in DBD packets
                                	**type**\:  bool
                                
                                .. attribute:: multi_area
                                
                                	Configure ospf multi\-area
                                	**type**\:   :py:class:`MultiArea <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.MultiArea>`
                                
                                .. attribute:: network_type
                                
                                	Network type
                                	**type**\:   :py:class:`NetworkType <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.NetworkType>`
                                
                                .. attribute:: node_flag
                                
                                	Set prefix as a node representative prefix
                                	**type**\:  bool
                                
                                	**default value**\: false
                                
                                .. attribute:: passive
                                
                                	Enable/Disable passive
                                	**type**\:  bool
                                
                                .. attribute:: prefix_suppression
                                
                                	Suppress advertisement of the prefixes
                                	**type**\:  bool
                                
                                .. attribute:: retransmit_interval
                                
                                	Time between retransmitting unacknowledged Link State Advertisements (LSAs)
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: static_neighbors
                                
                                	Static configured neighbors
                                	**type**\:   :py:class:`StaticNeighbors <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors>`
                                
                                .. attribute:: topology
                                
                                	OSPF interface topology
                                	**type**\: list of    :py:class:`Topology <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Topology>`
                                
                                .. attribute:: transmit_delay
                                
                                	Estimated time needed to send link\-state update
                                	**type**\:  int
                                
                                	**range:** 1..65535
                                
                                	**units**\: seconds
                                
                                .. attribute:: ttl_security
                                
                                	TTL security check
                                	**type**\:   :py:class:`TtlSecurity <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.TtlSecurity>`
                                
                                

                                """

                                _prefix = 'ospf'
                                _revision = '2015-03-09'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface, self).__init__()

                                    self.yang_name = "interface"
                                    self.yang_parent_name = "area"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.bfd = YLeaf(YType.boolean, "bfd")

                                    self.cost = YLeaf(YType.uint16, "cost")

                                    self.dead_interval = YLeaf(YType.uint16, "dead-interval")

                                    self.demand_circuit = YLeaf(YType.boolean, "demand-circuit")

                                    self.enable = YLeaf(YType.boolean, "enable")

                                    self.hello_interval = YLeaf(YType.uint16, "hello-interval")

                                    self.lls = YLeaf(YType.boolean, "lls")

                                    self.mtu_ignore = YLeaf(YType.boolean, "mtu-ignore")

                                    self.network_type = YLeaf(YType.enumeration, "network-type")

                                    self.node_flag = YLeaf(YType.boolean, "node-flag")

                                    self.passive = YLeaf(YType.boolean, "passive")

                                    self.prefix_suppression = YLeaf(YType.boolean, "prefix-suppression")

                                    self.retransmit_interval = YLeaf(YType.uint16, "retransmit-interval")

                                    self.transmit_delay = YLeaf(YType.uint16, "transmit-delay")

                                    self.authentication = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication()
                                    self.authentication.parent = self
                                    self._children_name_map["authentication"] = "authentication"
                                    self._children_yang_names.add("authentication")

                                    self.database_filter = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.DatabaseFilter()
                                    self.database_filter.parent = self
                                    self._children_name_map["database_filter"] = "database-filter"
                                    self._children_yang_names.add("database-filter")

                                    self.fast_reroute = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                    self._children_yang_names.add("fast-reroute")

                                    self.flood_reduction = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FloodReduction()
                                    self.flood_reduction.parent = self
                                    self._children_name_map["flood_reduction"] = "flood-reduction"
                                    self._children_yang_names.add("flood-reduction")

                                    self.multi_area = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.MultiArea()
                                    self.multi_area.parent = self
                                    self._children_name_map["multi_area"] = "multi-area"
                                    self._children_yang_names.add("multi-area")

                                    self.static_neighbors = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors()
                                    self.static_neighbors.parent = self
                                    self._children_name_map["static_neighbors"] = "static-neighbors"
                                    self._children_yang_names.add("static-neighbors")

                                    self.ttl_security = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.TtlSecurity()
                                    self.ttl_security.parent = self
                                    self._children_name_map["ttl_security"] = "ttl-security"
                                    self._children_yang_names.add("ttl-security")

                                    self.topology = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "bfd",
                                                    "cost",
                                                    "dead_interval",
                                                    "demand_circuit",
                                                    "enable",
                                                    "hello_interval",
                                                    "lls",
                                                    "mtu_ignore",
                                                    "network_type",
                                                    "node_flag",
                                                    "passive",
                                                    "prefix_suppression",
                                                    "retransmit_interval",
                                                    "transmit_delay") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface, self).__setattr__(name, value)

                                class NetworkType(Enum):
                                    """
                                    NetworkType

                                    Network type.

                                    .. data:: broadcast = 0

                                    	Specify OSPF broadcast multi-access network.

                                    .. data:: non_broadcast = 1

                                    	Specify OSPF Non-Broadcast Multi-Access

                                    	(NBMA) network.

                                    .. data:: point_to_multipoint = 2

                                    	Specify OSPF point-to-multipoint network.

                                    .. data:: point_to_point = 3

                                    	Specify OSPF point-to-point network.

                                    """

                                    broadcast = Enum.YLeaf(0, "broadcast")

                                    non_broadcast = Enum.YLeaf(1, "non-broadcast")

                                    point_to_multipoint = Enum.YLeaf(2, "point-to-multipoint")

                                    point_to_point = Enum.YLeaf(3, "point-to-point")



                                class FloodReduction(Entity):
                                    """
                                    OSPF Flood Reduction
                                    
                                    .. attribute:: flood_reduction
                                    
                                    	Enable OSPF flood reduction
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FloodReduction, self).__init__()

                                        self.yang_name = "flood-reduction"
                                        self.yang_parent_name = "interface"

                                        self.flood_reduction = YLeaf(YType.boolean, "flood-reduction")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("flood_reduction") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FloodReduction, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FloodReduction, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.flood_reduction.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.flood_reduction.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "cisco-ospf:flood-reduction" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.flood_reduction.is_set or self.flood_reduction.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flood_reduction.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "flood-reduction"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "flood-reduction"):
                                            self.flood_reduction = value
                                            self.flood_reduction.value_namespace = name_space
                                            self.flood_reduction.value_namespace_prefix = name_space_prefix


                                class Topology(Entity):
                                    """
                                    OSPF interface topology.
                                    
                                    .. attribute:: name  <key>
                                    
                                    	One of the topology enabled on this interface
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Ribs.Rib>`
                                    
                                    .. attribute:: cost
                                    
                                    	Interface cost for this topology
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Topology, self).__init__()

                                        self.yang_name = "topology"
                                        self.yang_parent_name = "interface"

                                        self.name = YLeaf(YType.str, "name")

                                        self.cost = YLeaf(YType.uint32, "cost")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("name",
                                                        "cost") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Topology, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Topology, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.name.is_set or
                                            self.cost.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.name.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "topology" + "[name='" + self.name.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.name.get_name_leafdata())
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "name" or name == "cost"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "name"):
                                            self.name = value
                                            self.name.value_namespace = name_space
                                            self.name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix


                                class TtlSecurity(Entity):
                                    """
                                    TTL security check.
                                    
                                    .. attribute:: enable
                                    
                                    	Enable/Disable TTL security check
                                    	**type**\:  bool
                                    
                                    .. attribute:: hops
                                    
                                    	Maximum number of hops that a OSPF packet may have traveled
                                    	**type**\:  int
                                    
                                    	**range:** 1..254
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.TtlSecurity, self).__init__()

                                        self.yang_name = "ttl-security"
                                        self.yang_parent_name = "interface"

                                        self.enable = YLeaf(YType.boolean, "enable")

                                        self.hops = YLeaf(YType.uint8, "hops")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("enable",
                                                        "hops") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.TtlSecurity, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.TtlSecurity, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.enable.is_set or
                                            self.hops.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.enable.yfilter != YFilter.not_set or
                                            self.hops.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ttl-security" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.enable.get_name_leafdata())
                                        if (self.hops.is_set or self.hops.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hops.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "enable" or name == "hops"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "enable"):
                                            self.enable = value
                                            self.enable.value_namespace = name_space
                                            self.enable.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hops"):
                                            self.hops = value
                                            self.hops.value_namespace = name_space
                                            self.hops.value_namespace_prefix = name_space_prefix


                                class MultiArea(Entity):
                                    """
                                    Configure ospf multi\-area.
                                    
                                    .. attribute:: cost
                                    
                                    	Interface cost for multi\-area
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: multi_area_id
                                    
                                    	Multi\-area ID
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])
                                    
                                    
                                    ----
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.MultiArea, self).__init__()

                                        self.yang_name = "multi-area"
                                        self.yang_parent_name = "interface"

                                        self.cost = YLeaf(YType.uint16, "cost")

                                        self.multi_area_id = YLeaf(YType.str, "multi-area-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("cost",
                                                        "multi_area_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.MultiArea, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.MultiArea, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.cost.is_set or
                                            self.multi_area_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.cost.yfilter != YFilter.not_set or
                                            self.multi_area_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "multi-area" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.cost.get_name_leafdata())
                                        if (self.multi_area_id.is_set or self.multi_area_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.multi_area_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "cost" or name == "multi-area-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "cost"):
                                            self.cost = value
                                            self.cost.value_namespace = name_space
                                            self.cost.value_namespace_prefix = name_space_prefix
                                        if(value_path == "multi-area-id"):
                                            self.multi_area_id = value
                                            self.multi_area_id.value_namespace = name_space
                                            self.multi_area_id.value_namespace_prefix = name_space_prefix


                                class DatabaseFilter(Entity):
                                    """
                                    Filter OSPF LSA during synchronization and flooding
                                    
                                    .. attribute:: all_out
                                    
                                    	Filter all Outgoing LSA
                                    	**type**\:  bool
                                    
                                    	**default value**\: false
                                    
                                    

                                    """

                                    _prefix = 'cisco-ospf'
                                    _revision = '2016-03-30'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.DatabaseFilter, self).__init__()

                                        self.yang_name = "database-filter"
                                        self.yang_parent_name = "interface"

                                        self.all_out = YLeaf(YType.boolean, "all-out")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("all_out") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.DatabaseFilter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.DatabaseFilter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.all_out.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.all_out.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "cisco-ospf:database-filter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.all_out.is_set or self.all_out.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.all_out.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "all-out"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "all-out"):
                                            self.all_out = value
                                            self.all_out.value_namespace = name_space
                                            self.all_out.value_namespace_prefix = name_space_prefix


                                class StaticNeighbors(Entity):
                                    """
                                    Static configured neighbors.
                                    
                                    .. attribute:: neighbor
                                    
                                    	Specify a neighbor router
                                    	**type**\: list of    :py:class:`Neighbor <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors.Neighbor>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors, self).__init__()

                                        self.yang_name = "static-neighbors"
                                        self.yang_parent_name = "interface"

                                        self.neighbor = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors, self).__setattr__(name, value)


                                    class Neighbor(Entity):
                                        """
                                        Specify a neighbor router.
                                        
                                        .. attribute:: address  <key>
                                        
                                        	Neighbor IP address
                                        	**type**\: one of the below types:
                                        
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        	**type**\:  str
                                        
                                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                        
                                        
                                        ----
                                        .. attribute:: cost
                                        
                                        	Neighbor cost
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        .. attribute:: poll_interval
                                        
                                        	Neighbor poll interval
                                        	**type**\:  int
                                        
                                        	**range:** 1..65535
                                        
                                        	**units**\: seconds
                                        
                                        .. attribute:: priority
                                        
                                        	Neighbor priority for DR election
                                        	**type**\:  int
                                        
                                        	**range:** 1..255
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors.Neighbor, self).__init__()

                                            self.yang_name = "neighbor"
                                            self.yang_parent_name = "static-neighbors"

                                            self.address = YLeaf(YType.str, "address")

                                            self.cost = YLeaf(YType.uint16, "cost")

                                            self.poll_interval = YLeaf(YType.uint16, "poll-interval")

                                            self.priority = YLeaf(YType.uint8, "priority")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("address",
                                                            "cost",
                                                            "poll_interval",
                                                            "priority") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors.Neighbor, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors.Neighbor, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.address.is_set or
                                                self.cost.is_set or
                                                self.poll_interval.is_set or
                                                self.priority.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.address.yfilter != YFilter.not_set or
                                                self.cost.yfilter != YFilter.not_set or
                                                self.poll_interval.yfilter != YFilter.not_set or
                                                self.priority.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "neighbor" + "[address='" + self.address.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.address.get_name_leafdata())
                                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.cost.get_name_leafdata())
                                            if (self.poll_interval.is_set or self.poll_interval.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.poll_interval.get_name_leafdata())
                                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.priority.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "address" or name == "cost" or name == "poll-interval" or name == "priority"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "address"):
                                                self.address = value
                                                self.address.value_namespace = name_space
                                                self.address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "cost"):
                                                self.cost = value
                                                self.cost.value_namespace = name_space
                                                self.cost.value_namespace_prefix = name_space_prefix
                                            if(value_path == "poll-interval"):
                                                self.poll_interval = value
                                                self.poll_interval.value_namespace = name_space
                                                self.poll_interval.value_namespace_prefix = name_space_prefix
                                            if(value_path == "priority"):
                                                self.priority = value
                                                self.priority.value_namespace = name_space
                                                self.priority.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.neighbor:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.neighbor:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "static-neighbors" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "neighbor"):
                                            for c in self.neighbor:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors.Neighbor()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.neighbor.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "neighbor"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class FastReroute(Entity):
                                    """
                                    Fast\-reroute configuration.
                                    
                                    .. attribute:: lfa
                                    
                                    	LFA configuration
                                    	**type**\:   :py:class:`Lfa <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa>`
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute, self).__init__()

                                        self.yang_name = "fast-reroute"
                                        self.yang_parent_name = "interface"

                                        self.lfa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa()
                                        self.lfa.parent = self
                                        self._children_name_map["lfa"] = "lfa"
                                        self._children_yang_names.add("lfa")


                                    class Lfa(Entity):
                                        """
                                        LFA configuration.
                                        
                                        .. attribute:: candidate_disabled
                                        
                                        	Prevent the interface to be used as backup
                                        	**type**\:  bool
                                        
                                        .. attribute:: enabled
                                        
                                        	Activates LFA. This model assumes activation of per\-prefix LFA
                                        	**type**\:  bool
                                        
                                        .. attribute:: remote_lfa
                                        
                                        	Remote LFA configuration
                                        	**type**\:   :py:class:`RemoteLfa <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa.RemoteLfa>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa, self).__init__()

                                            self.yang_name = "lfa"
                                            self.yang_parent_name = "fast-reroute"

                                            self.candidate_disabled = YLeaf(YType.boolean, "candidate-disabled")

                                            self.enabled = YLeaf(YType.boolean, "enabled")

                                            self.remote_lfa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa.RemoteLfa()
                                            self.remote_lfa.parent = self
                                            self._children_name_map["remote_lfa"] = "remote-lfa"
                                            self._children_yang_names.add("remote-lfa")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("candidate_disabled",
                                                            "enabled") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa, self).__setattr__(name, value)


                                        class RemoteLfa(Entity):
                                            """
                                            Remote LFA configuration.
                                            
                                            .. attribute:: enabled
                                            
                                            	Activates remote LFA
                                            	**type**\:  bool
                                            
                                            

                                            """

                                            _prefix = 'ospf'
                                            _revision = '2015-03-09'

                                            def __init__(self):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa.RemoteLfa, self).__init__()

                                                self.yang_name = "remote-lfa"
                                                self.yang_parent_name = "lfa"

                                                self.enabled = YLeaf(YType.boolean, "enabled")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("enabled") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa.RemoteLfa, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa.RemoteLfa, self).__setattr__(name, value)

                                            def has_data(self):
                                                return self.enabled.is_set

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.enabled.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "remote-lfa" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.enabled.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "enabled"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "enabled"):
                                                    self.enabled = value
                                                    self.enabled.value_namespace = name_space
                                                    self.enabled.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.candidate_disabled.is_set or
                                                self.enabled.is_set or
                                                (self.remote_lfa is not None and self.remote_lfa.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.candidate_disabled.yfilter != YFilter.not_set or
                                                self.enabled.yfilter != YFilter.not_set or
                                                (self.remote_lfa is not None and self.remote_lfa.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lfa" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.candidate_disabled.is_set or self.candidate_disabled.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.candidate_disabled.get_name_leafdata())
                                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.enabled.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "remote-lfa"):
                                                if (self.remote_lfa is None):
                                                    self.remote_lfa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa.RemoteLfa()
                                                    self.remote_lfa.parent = self
                                                    self._children_name_map["remote_lfa"] = "remote-lfa"
                                                return self.remote_lfa

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "remote-lfa" or name == "candidate-disabled" or name == "enabled"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "candidate-disabled"):
                                                self.candidate_disabled = value
                                                self.candidate_disabled.value_namespace = name_space
                                                self.candidate_disabled.value_namespace_prefix = name_space_prefix
                                            if(value_path == "enabled"):
                                                self.enabled = value
                                                self.enabled.value_namespace = name_space
                                                self.enabled.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (self.lfa is not None and self.lfa.has_data())

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.lfa is not None and self.lfa.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fast-reroute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lfa"):
                                            if (self.lfa is None):
                                                self.lfa = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute.Lfa()
                                                self.lfa.parent = self
                                                self._children_name_map["lfa"] = "lfa"
                                            return self.lfa

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lfa"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class Authentication(Entity):
                                    """
                                    Authentication configuration.
                                    
                                    .. attribute:: crypto_algorithm
                                    
                                    	Cryptographic algorithm associated with key
                                    	**type**\:   :py:class:`CryptoAlgorithm <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication.CryptoAlgorithm>`
                                    
                                    .. attribute:: key
                                    
                                    	Key string in ASCII format
                                    	**type**\:  str
                                    
                                    .. attribute:: key_chain
                                    
                                    	key\-chain name
                                    	**type**\:  str
                                    
                                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_key_chain.KeyChains>`
                                    
                                    .. attribute:: sa
                                    
                                    	SA name
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'ospf'
                                    _revision = '2015-03-09'

                                    def __init__(self):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication, self).__init__()

                                        self.yang_name = "authentication"
                                        self.yang_parent_name = "interface"

                                        self.key = YLeaf(YType.str, "key")

                                        self.key_chain = YLeaf(YType.str, "key-chain")

                                        self.sa = YLeaf(YType.str, "sa")

                                        self.crypto_algorithm = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication.CryptoAlgorithm()
                                        self.crypto_algorithm.parent = self
                                        self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                        self._children_yang_names.add("crypto-algorithm")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("key",
                                                        "key_chain",
                                                        "sa") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication, self).__setattr__(name, value)


                                    class CryptoAlgorithm(Entity):
                                        """
                                        Cryptographic algorithm associated with key.
                                        
                                        .. attribute:: hmac_sha1_12
                                        
                                        	The HMAC\-SHA1\-12 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha1_20
                                        
                                        	The HMAC\-SHA1\-20 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_1
                                        
                                        	HMAC\-SHA\-1 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_256
                                        
                                        	HMAC\-SHA\-256 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_384
                                        
                                        	HMAC\-SHA\-384 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: hmac_sha_512
                                        
                                        	HMAC\-SHA\-512 authentication algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: md5
                                        
                                        	The MD5 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        .. attribute:: sha_1
                                        
                                        	The SHA\-1 algorithm
                                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                        
                                        

                                        """

                                        _prefix = 'ospf'
                                        _revision = '2015-03-09'

                                        def __init__(self):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication.CryptoAlgorithm, self).__init__()

                                            self.yang_name = "crypto-algorithm"
                                            self.yang_parent_name = "authentication"

                                            self.hmac_sha1_12 = YLeaf(YType.empty, "hmac-sha1-12")

                                            self.hmac_sha1_20 = YLeaf(YType.empty, "hmac-sha1-20")

                                            self.hmac_sha_1 = YLeaf(YType.empty, "hmac-sha-1")

                                            self.hmac_sha_256 = YLeaf(YType.empty, "hmac-sha-256")

                                            self.hmac_sha_384 = YLeaf(YType.empty, "hmac-sha-384")

                                            self.hmac_sha_512 = YLeaf(YType.empty, "hmac-sha-512")

                                            self.md5 = YLeaf(YType.empty, "md5")

                                            self.sha_1 = YLeaf(YType.empty, "sha-1")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("hmac_sha1_12",
                                                            "hmac_sha1_20",
                                                            "hmac_sha_1",
                                                            "hmac_sha_256",
                                                            "hmac_sha_384",
                                                            "hmac_sha_512",
                                                            "md5",
                                                            "sha_1") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication.CryptoAlgorithm, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication.CryptoAlgorithm, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.hmac_sha1_12.is_set or
                                                self.hmac_sha1_20.is_set or
                                                self.hmac_sha_1.is_set or
                                                self.hmac_sha_256.is_set or
                                                self.hmac_sha_384.is_set or
                                                self.hmac_sha_512.is_set or
                                                self.md5.is_set or
                                                self.sha_1.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.hmac_sha1_12.yfilter != YFilter.not_set or
                                                self.hmac_sha1_20.yfilter != YFilter.not_set or
                                                self.hmac_sha_1.yfilter != YFilter.not_set or
                                                self.hmac_sha_256.yfilter != YFilter.not_set or
                                                self.hmac_sha_384.yfilter != YFilter.not_set or
                                                self.hmac_sha_512.yfilter != YFilter.not_set or
                                                self.md5.yfilter != YFilter.not_set or
                                                self.sha_1.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "crypto-algorithm" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.hmac_sha1_12.is_set or self.hmac_sha1_12.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_12.get_name_leafdata())
                                            if (self.hmac_sha1_20.is_set or self.hmac_sha1_20.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha1_20.get_name_leafdata())
                                            if (self.hmac_sha_1.is_set or self.hmac_sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_1.get_name_leafdata())
                                            if (self.hmac_sha_256.is_set or self.hmac_sha_256.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_256.get_name_leafdata())
                                            if (self.hmac_sha_384.is_set or self.hmac_sha_384.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_384.get_name_leafdata())
                                            if (self.hmac_sha_512.is_set or self.hmac_sha_512.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.hmac_sha_512.get_name_leafdata())
                                            if (self.md5.is_set or self.md5.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.md5.get_name_leafdata())
                                            if (self.sha_1.is_set or self.sha_1.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sha_1.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "hmac-sha1-12" or name == "hmac-sha1-20" or name == "hmac-sha-1" or name == "hmac-sha-256" or name == "hmac-sha-384" or name == "hmac-sha-512" or name == "md5" or name == "sha-1"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "hmac-sha1-12"):
                                                self.hmac_sha1_12 = value
                                                self.hmac_sha1_12.value_namespace = name_space
                                                self.hmac_sha1_12.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha1-20"):
                                                self.hmac_sha1_20 = value
                                                self.hmac_sha1_20.value_namespace = name_space
                                                self.hmac_sha1_20.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-1"):
                                                self.hmac_sha_1 = value
                                                self.hmac_sha_1.value_namespace = name_space
                                                self.hmac_sha_1.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-256"):
                                                self.hmac_sha_256 = value
                                                self.hmac_sha_256.value_namespace = name_space
                                                self.hmac_sha_256.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-384"):
                                                self.hmac_sha_384 = value
                                                self.hmac_sha_384.value_namespace = name_space
                                                self.hmac_sha_384.value_namespace_prefix = name_space_prefix
                                            if(value_path == "hmac-sha-512"):
                                                self.hmac_sha_512 = value
                                                self.hmac_sha_512.value_namespace = name_space
                                                self.hmac_sha_512.value_namespace_prefix = name_space_prefix
                                            if(value_path == "md5"):
                                                self.md5 = value
                                                self.md5.value_namespace = name_space
                                                self.md5.value_namespace_prefix = name_space_prefix
                                            if(value_path == "sha-1"):
                                                self.sha_1 = value
                                                self.sha_1.value_namespace = name_space
                                                self.sha_1.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.key.is_set or
                                            self.key_chain.is_set or
                                            self.sa.is_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.key.yfilter != YFilter.not_set or
                                            self.key_chain.yfilter != YFilter.not_set or
                                            self.sa.yfilter != YFilter.not_set or
                                            (self.crypto_algorithm is not None and self.crypto_algorithm.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "authentication" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.key.is_set or self.key.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key.get_name_leafdata())
                                        if (self.key_chain.is_set or self.key_chain.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.key_chain.get_name_leafdata())
                                        if (self.sa.is_set or self.sa.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.sa.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "crypto-algorithm"):
                                            if (self.crypto_algorithm is None):
                                                self.crypto_algorithm = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication.CryptoAlgorithm()
                                                self.crypto_algorithm.parent = self
                                                self._children_name_map["crypto_algorithm"] = "crypto-algorithm"
                                            return self.crypto_algorithm

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "crypto-algorithm" or name == "key" or name == "key-chain" or name == "sa"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "key"):
                                            self.key = value
                                            self.key.value_namespace = name_space
                                            self.key.value_namespace_prefix = name_space_prefix
                                        if(value_path == "key-chain"):
                                            self.key_chain = value
                                            self.key_chain.value_namespace = name_space
                                            self.key_chain.value_namespace_prefix = name_space_prefix
                                        if(value_path == "sa"):
                                            self.sa = value
                                            self.sa.value_namespace = name_space
                                            self.sa.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.topology:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.interface.is_set or
                                        self.bfd.is_set or
                                        self.cost.is_set or
                                        self.dead_interval.is_set or
                                        self.demand_circuit.is_set or
                                        self.enable.is_set or
                                        self.hello_interval.is_set or
                                        self.lls.is_set or
                                        self.mtu_ignore.is_set or
                                        self.network_type.is_set or
                                        self.node_flag.is_set or
                                        self.passive.is_set or
                                        self.prefix_suppression.is_set or
                                        self.retransmit_interval.is_set or
                                        self.transmit_delay.is_set or
                                        (self.authentication is not None and self.authentication.has_data()) or
                                        (self.database_filter is not None and self.database_filter.has_data()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                        (self.flood_reduction is not None and self.flood_reduction.has_data()) or
                                        (self.multi_area is not None and self.multi_area.has_data()) or
                                        (self.static_neighbors is not None and self.static_neighbors.has_data()) or
                                        (self.ttl_security is not None and self.ttl_security.has_data()))

                                def has_operation(self):
                                    for c in self.topology:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.bfd.yfilter != YFilter.not_set or
                                        self.cost.yfilter != YFilter.not_set or
                                        self.dead_interval.yfilter != YFilter.not_set or
                                        self.demand_circuit.yfilter != YFilter.not_set or
                                        self.enable.yfilter != YFilter.not_set or
                                        self.hello_interval.yfilter != YFilter.not_set or
                                        self.lls.yfilter != YFilter.not_set or
                                        self.mtu_ignore.yfilter != YFilter.not_set or
                                        self.network_type.yfilter != YFilter.not_set or
                                        self.node_flag.yfilter != YFilter.not_set or
                                        self.passive.yfilter != YFilter.not_set or
                                        self.prefix_suppression.yfilter != YFilter.not_set or
                                        self.retransmit_interval.yfilter != YFilter.not_set or
                                        self.transmit_delay.yfilter != YFilter.not_set or
                                        (self.authentication is not None and self.authentication.has_operation()) or
                                        (self.database_filter is not None and self.database_filter.has_operation()) or
                                        (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                        (self.flood_reduction is not None and self.flood_reduction.has_operation()) or
                                        (self.multi_area is not None and self.multi_area.has_operation()) or
                                        (self.static_neighbors is not None and self.static_neighbors.has_operation()) or
                                        (self.ttl_security is not None and self.ttl_security.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interface" + "[interface='" + self.interface.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.bfd.is_set or self.bfd.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bfd.get_name_leafdata())
                                    if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cost.get_name_leafdata())
                                    if (self.dead_interval.is_set or self.dead_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.dead_interval.get_name_leafdata())
                                    if (self.demand_circuit.is_set or self.demand_circuit.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.demand_circuit.get_name_leafdata())
                                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.enable.get_name_leafdata())
                                    if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hello_interval.get_name_leafdata())
                                    if (self.lls.is_set or self.lls.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lls.get_name_leafdata())
                                    if (self.mtu_ignore.is_set or self.mtu_ignore.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mtu_ignore.get_name_leafdata())
                                    if (self.network_type.is_set or self.network_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.network_type.get_name_leafdata())
                                    if (self.node_flag.is_set or self.node_flag.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_flag.get_name_leafdata())
                                    if (self.passive.is_set or self.passive.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.passive.get_name_leafdata())
                                    if (self.prefix_suppression.is_set or self.prefix_suppression.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_suppression.get_name_leafdata())
                                    if (self.retransmit_interval.is_set or self.retransmit_interval.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retransmit_interval.get_name_leafdata())
                                    if (self.transmit_delay.is_set or self.transmit_delay.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_delay.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "authentication"):
                                        if (self.authentication is None):
                                            self.authentication = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Authentication()
                                            self.authentication.parent = self
                                            self._children_name_map["authentication"] = "authentication"
                                        return self.authentication

                                    if (child_yang_name == "database-filter"):
                                        if (self.database_filter is None):
                                            self.database_filter = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.DatabaseFilter()
                                            self.database_filter.parent = self
                                            self._children_name_map["database_filter"] = "database-filter"
                                        return self.database_filter

                                    if (child_yang_name == "fast-reroute"):
                                        if (self.fast_reroute is None):
                                            self.fast_reroute = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FastReroute()
                                            self.fast_reroute.parent = self
                                            self._children_name_map["fast_reroute"] = "fast-reroute"
                                        return self.fast_reroute

                                    if (child_yang_name == "flood-reduction"):
                                        if (self.flood_reduction is None):
                                            self.flood_reduction = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.FloodReduction()
                                            self.flood_reduction.parent = self
                                            self._children_name_map["flood_reduction"] = "flood-reduction"
                                        return self.flood_reduction

                                    if (child_yang_name == "multi-area"):
                                        if (self.multi_area is None):
                                            self.multi_area = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.MultiArea()
                                            self.multi_area.parent = self
                                            self._children_name_map["multi_area"] = "multi-area"
                                        return self.multi_area

                                    if (child_yang_name == "static-neighbors"):
                                        if (self.static_neighbors is None):
                                            self.static_neighbors = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.StaticNeighbors()
                                            self.static_neighbors.parent = self
                                            self._children_name_map["static_neighbors"] = "static-neighbors"
                                        return self.static_neighbors

                                    if (child_yang_name == "topology"):
                                        for c in self.topology:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.Topology()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.topology.append(c)
                                        return c

                                    if (child_yang_name == "ttl-security"):
                                        if (self.ttl_security is None):
                                            self.ttl_security = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface.TtlSecurity()
                                            self.ttl_security.parent = self
                                            self._children_name_map["ttl_security"] = "ttl-security"
                                        return self.ttl_security

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "authentication" or name == "database-filter" or name == "fast-reroute" or name == "flood-reduction" or name == "multi-area" or name == "static-neighbors" or name == "topology" or name == "ttl-security" or name == "interface" or name == "bfd" or name == "cost" or name == "dead-interval" or name == "demand-circuit" or name == "enable" or name == "hello-interval" or name == "lls" or name == "mtu-ignore" or name == "network-type" or name == "node-flag" or name == "passive" or name == "prefix-suppression" or name == "retransmit-interval" or name == "transmit-delay"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bfd"):
                                        self.bfd = value
                                        self.bfd.value_namespace = name_space
                                        self.bfd.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cost"):
                                        self.cost = value
                                        self.cost.value_namespace = name_space
                                        self.cost.value_namespace_prefix = name_space_prefix
                                    if(value_path == "dead-interval"):
                                        self.dead_interval = value
                                        self.dead_interval.value_namespace = name_space
                                        self.dead_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "demand-circuit"):
                                        self.demand_circuit = value
                                        self.demand_circuit.value_namespace = name_space
                                        self.demand_circuit.value_namespace_prefix = name_space_prefix
                                    if(value_path == "enable"):
                                        self.enable = value
                                        self.enable.value_namespace = name_space
                                        self.enable.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hello-interval"):
                                        self.hello_interval = value
                                        self.hello_interval.value_namespace = name_space
                                        self.hello_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lls"):
                                        self.lls = value
                                        self.lls.value_namespace = name_space
                                        self.lls.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mtu-ignore"):
                                        self.mtu_ignore = value
                                        self.mtu_ignore.value_namespace = name_space
                                        self.mtu_ignore.value_namespace_prefix = name_space_prefix
                                    if(value_path == "network-type"):
                                        self.network_type = value
                                        self.network_type.value_namespace = name_space
                                        self.network_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-flag"):
                                        self.node_flag = value
                                        self.node_flag.value_namespace = name_space
                                        self.node_flag.value_namespace_prefix = name_space_prefix
                                    if(value_path == "passive"):
                                        self.passive = value
                                        self.passive.value_namespace = name_space
                                        self.passive.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-suppression"):
                                        self.prefix_suppression = value
                                        self.prefix_suppression.value_namespace = name_space
                                        self.prefix_suppression.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retransmit-interval"):
                                        self.retransmit_interval = value
                                        self.retransmit_interval.value_namespace = name_space
                                        self.retransmit_interval.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-delay"):
                                        self.transmit_delay = value
                                        self.transmit_delay.value_namespace = name_space
                                        self.transmit_delay.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.interface:
                                    if (c.has_data()):
                                        return True
                                for c in self.range:
                                    if (c.has_data()):
                                        return True
                                for c in self.sham_link:
                                    if (c.has_data()):
                                        return True
                                for c in self.virtual_link:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.area_id.is_set or
                                    self.area_type.is_set or
                                    self.default_cost.is_set or
                                    self.summary.is_set or
                                    (self.all_interfaces_inherit is not None and self.all_interfaces_inherit.has_data()))

                            def has_operation(self):
                                for c in self.interface:
                                    if (c.has_operation()):
                                        return True
                                for c in self.range:
                                    if (c.has_operation()):
                                        return True
                                for c in self.sham_link:
                                    if (c.has_operation()):
                                        return True
                                for c in self.virtual_link:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area_id.yfilter != YFilter.not_set or
                                    self.area_type.yfilter != YFilter.not_set or
                                    self.default_cost.yfilter != YFilter.not_set or
                                    self.summary.yfilter != YFilter.not_set or
                                    (self.all_interfaces_inherit is not None and self.all_interfaces_inherit.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area" + "[area-id='" + self.area_id.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area_id.get_name_leafdata())
                                if (self.area_type.is_set or self.area_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area_type.get_name_leafdata())
                                if (self.default_cost.is_set or self.default_cost.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.default_cost.get_name_leafdata())
                                if (self.summary.is_set or self.summary.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.summary.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "all-interfaces-inherit"):
                                    if (self.all_interfaces_inherit is None):
                                        self.all_interfaces_inherit = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.AllInterfacesInherit()
                                        self.all_interfaces_inherit.parent = self
                                        self._children_name_map["all_interfaces_inherit"] = "all-interfaces-inherit"
                                    return self.all_interfaces_inherit

                                if (child_yang_name == "interface"):
                                    for c in self.interface:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Interface()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.interface.append(c)
                                    return c

                                if (child_yang_name == "range"):
                                    for c in self.range:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.Range()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.range.append(c)
                                    return c

                                if (child_yang_name == "sham-link"):
                                    for c in self.sham_link:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.ShamLink()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sham_link.append(c)
                                    return c

                                if (child_yang_name == "virtual-link"):
                                    for c in self.virtual_link:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area.VirtualLink()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.virtual_link.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "all-interfaces-inherit" or name == "interface" or name == "range" or name == "sham-link" or name == "virtual-link" or name == "area-id" or name == "area-type" or name == "default-cost" or name == "summary"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area-id"):
                                    self.area_id = value
                                    self.area_id.value_namespace = name_space
                                    self.area_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "area-type"):
                                    self.area_type = value
                                    self.area_type.value_namespace = name_space
                                    self.area_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "default-cost"):
                                    self.default_cost = value
                                    self.default_cost.value_namespace = name_space
                                    self.default_cost.value_namespace_prefix = name_space_prefix
                                if(value_path == "summary"):
                                    self.summary = value
                                    self.summary.value_namespace = name_space
                                    self.summary.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.area:
                                if (c.has_data()):
                                    return True
                            for c in self.topology:
                                if (c.has_data()):
                                    return True
                            return (
                                self.af.is_set or
                                self.enable.is_set or
                                self.router_id.is_set or
                                (self.admin_distance is not None and self.admin_distance.has_data()) or
                                (self.all_areas_inherit is not None and self.all_areas_inherit.has_data()) or
                                (self.auto_cost is not None and self.auto_cost.has_data()) or
                                (self.database_control is not None and self.database_control.has_data()) or
                                (self.default_information is not None and self.default_information.has_data()) or
                                (self.default_metric is not None and self.default_metric.has_data()) or
                                (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                                (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                                (self.graceful_shutdown is not None and self.graceful_shutdown.has_data()) or
                                (self.log_adjacency_changes is not None and self.log_adjacency_changes.has_data()) or
                                (self.microloop_avoidance is not None and self.microloop_avoidance.has_data()) or
                                (self.mpls is not None and self.mpls.has_data()) or
                                (self.nsr is not None and self.nsr.has_data()) or
                                (self.redistribution is not None and self.redistribution.has_data()) or
                                (self.reload_control is not None and self.reload_control.has_data()) or
                                (self.spf_control is not None and self.spf_control.has_data()) or
                                (self.summary_prefixes is not None and self.summary_prefixes.has_data()) or
                                (self.discard_route is not None))

                        def has_operation(self):
                            for c in self.area:
                                if (c.has_operation()):
                                    return True
                            for c in self.topology:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.router_id.yfilter != YFilter.not_set or
                                (self.admin_distance is not None and self.admin_distance.has_operation()) or
                                (self.all_areas_inherit is not None and self.all_areas_inherit.has_operation()) or
                                (self.auto_cost is not None and self.auto_cost.has_operation()) or
                                (self.database_control is not None and self.database_control.has_operation()) or
                                (self.default_information is not None and self.default_information.has_operation()) or
                                (self.default_metric is not None and self.default_metric.has_operation()) or
                                (self.discard_route is not None and self.discard_route.has_operation()) or
                                (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                                (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                                (self.graceful_shutdown is not None and self.graceful_shutdown.has_operation()) or
                                (self.log_adjacency_changes is not None and self.log_adjacency_changes.has_operation()) or
                                (self.microloop_avoidance is not None and self.microloop_avoidance.has_operation()) or
                                (self.mpls is not None and self.mpls.has_operation()) or
                                (self.nsr is not None and self.nsr.has_operation()) or
                                (self.redistribution is not None and self.redistribution.has_operation()) or
                                (self.reload_control is not None and self.reload_control.has_operation()) or
                                (self.spf_control is not None and self.spf_control.has_operation()) or
                                (self.summary_prefixes is not None and self.summary_prefixes.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "instance" + "[af='" + self.af.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af.is_set or self.af.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.router_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "admin-distance"):
                                if (self.admin_distance is None):
                                    self.admin_distance = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AdminDistance()
                                    self.admin_distance.parent = self
                                    self._children_name_map["admin_distance"] = "admin-distance"
                                return self.admin_distance

                            if (child_yang_name == "all-areas-inherit"):
                                if (self.all_areas_inherit is None):
                                    self.all_areas_inherit = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AllAreasInherit()
                                    self.all_areas_inherit.parent = self
                                    self._children_name_map["all_areas_inherit"] = "all-areas-inherit"
                                return self.all_areas_inherit

                            if (child_yang_name == "area"):
                                for c in self.area:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Area()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.area.append(c)
                                return c

                            if (child_yang_name == "auto-cost"):
                                if (self.auto_cost is None):
                                    self.auto_cost = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.AutoCost()
                                    self.auto_cost.parent = self
                                    self._children_name_map["auto_cost"] = "auto-cost"
                                return self.auto_cost

                            if (child_yang_name == "database-control"):
                                if (self.database_control is None):
                                    self.database_control = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DatabaseControl()
                                    self.database_control.parent = self
                                    self._children_name_map["database_control"] = "database-control"
                                return self.database_control

                            if (child_yang_name == "default-information"):
                                if (self.default_information is None):
                                    self.default_information = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultInformation()
                                    self.default_information.parent = self
                                    self._children_name_map["default_information"] = "default-information"
                                return self.default_information

                            if (child_yang_name == "default-metric"):
                                if (self.default_metric is None):
                                    self.default_metric = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DefaultMetric()
                                    self.default_metric.parent = self
                                    self._children_name_map["default_metric"] = "default-metric"
                                return self.default_metric

                            if (child_yang_name == "discard-route"):
                                if (self.discard_route is None):
                                    self.discard_route = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.DiscardRoute()
                                    self.discard_route.parent = self
                                    self._children_name_map["discard_route"] = "discard-route"
                                return self.discard_route

                            if (child_yang_name == "fast-reroute"):
                                if (self.fast_reroute is None):
                                    self.fast_reroute = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.FastReroute()
                                    self.fast_reroute.parent = self
                                    self._children_name_map["fast_reroute"] = "fast-reroute"
                                return self.fast_reroute

                            if (child_yang_name == "graceful-restart"):
                                if (self.graceful_restart is None):
                                    self.graceful_restart = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulRestart()
                                    self.graceful_restart.parent = self
                                    self._children_name_map["graceful_restart"] = "graceful-restart"
                                return self.graceful_restart

                            if (child_yang_name == "graceful-shutdown"):
                                if (self.graceful_shutdown is None):
                                    self.graceful_shutdown = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.GracefulShutdown()
                                    self.graceful_shutdown.parent = self
                                    self._children_name_map["graceful_shutdown"] = "graceful-shutdown"
                                return self.graceful_shutdown

                            if (child_yang_name == "log-adjacency-changes"):
                                if (self.log_adjacency_changes is None):
                                    self.log_adjacency_changes = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.LogAdjacencyChanges()
                                    self.log_adjacency_changes.parent = self
                                    self._children_name_map["log_adjacency_changes"] = "log-adjacency-changes"
                                return self.log_adjacency_changes

                            if (child_yang_name == "microloop-avoidance"):
                                if (self.microloop_avoidance is None):
                                    self.microloop_avoidance = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.MicroloopAvoidance()
                                    self.microloop_avoidance.parent = self
                                    self._children_name_map["microloop_avoidance"] = "microloop-avoidance"
                                return self.microloop_avoidance

                            if (child_yang_name == "mpls"):
                                if (self.mpls is None):
                                    self.mpls = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Mpls()
                                    self.mpls.parent = self
                                    self._children_name_map["mpls"] = "mpls"
                                return self.mpls

                            if (child_yang_name == "nsr"):
                                if (self.nsr is None):
                                    self.nsr = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Nsr()
                                    self.nsr.parent = self
                                    self._children_name_map["nsr"] = "nsr"
                                return self.nsr

                            if (child_yang_name == "redistribution"):
                                if (self.redistribution is None):
                                    self.redistribution = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Redistribution()
                                    self.redistribution.parent = self
                                    self._children_name_map["redistribution"] = "redistribution"
                                return self.redistribution

                            if (child_yang_name == "reload-control"):
                                if (self.reload_control is None):
                                    self.reload_control = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.ReloadControl()
                                    self.reload_control.parent = self
                                    self._children_name_map["reload_control"] = "reload-control"
                                return self.reload_control

                            if (child_yang_name == "spf-control"):
                                if (self.spf_control is None):
                                    self.spf_control = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SpfControl()
                                    self.spf_control.parent = self
                                    self._children_name_map["spf_control"] = "spf-control"
                                return self.spf_control

                            if (child_yang_name == "summary-prefixes"):
                                if (self.summary_prefixes is None):
                                    self.summary_prefixes = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.SummaryPrefixes()
                                    self.summary_prefixes.parent = self
                                    self._children_name_map["summary_prefixes"] = "summary-prefixes"
                                return self.summary_prefixes

                            if (child_yang_name == "topology"):
                                for c in self.topology:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance.Topology()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.topology.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "admin-distance" or name == "all-areas-inherit" or name == "area" or name == "auto-cost" or name == "database-control" or name == "default-information" or name == "default-metric" or name == "discard-route" or name == "fast-reroute" or name == "graceful-restart" or name == "graceful-shutdown" or name == "log-adjacency-changes" or name == "microloop-avoidance" or name == "mpls" or name == "nsr" or name == "redistribution" or name == "reload-control" or name == "spf-control" or name == "summary-prefixes" or name == "topology" or name == "af" or name == "enable" or name == "router-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af"):
                                self.af = value
                                self.af.value_namespace = name_space
                                self.af.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "router-id"):
                                self.router_id = value
                                self.router_id.value_namespace = name_space
                                self.router_id.value_namespace_prefix = name_space_prefix


                    class AllInstancesInherit(Entity):
                        """
                        Inheritance support to all instances.
                        
                        .. attribute:: area
                        
                        	Area config to be inherited by all areas in all instances
                        	**type**\:   :py:class:`Area <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Area>`
                        
                        .. attribute:: interface
                        
                        	Interface config to be inherited by all interfaces in all instances
                        	**type**\:   :py:class:`Interface <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Interface>`
                        
                        

                        """

                        _prefix = 'ospf'
                        _revision = '2015-03-09'

                        def __init__(self):
                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit, self).__init__()

                            self.yang_name = "all-instances-inherit"
                            self.yang_parent_name = "ospf"

                            self.area = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Area()
                            self.area.parent = self
                            self._children_name_map["area"] = "area"
                            self._children_yang_names.add("area")

                            self.interface = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Interface()
                            self.interface.parent = self
                            self._children_name_map["interface"] = "interface"
                            self._children_yang_names.add("interface")


                        class Area(Entity):
                            """
                            Area config to be inherited by all areas in
                            all instances.
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Area, self).__init__()

                                self.yang_name = "area"
                                self.yang_parent_name = "all-instances-inherit"

                            def has_data(self):
                                return False

                            def has_operation(self):
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "area" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Interface(Entity):
                            """
                            Interface config to be inherited by all interfaces
                            in all instances.
                            
                            

                            """

                            _prefix = 'ospf'
                            _revision = '2015-03-09'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Interface, self).__init__()

                                self.yang_name = "interface"
                                self.yang_parent_name = "all-instances-inherit"

                            def has_data(self):
                                return False

                            def has_operation(self):
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.area is not None and self.area.has_data()) or
                                (self.interface is not None and self.interface.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.area is not None and self.area.has_operation()) or
                                (self.interface is not None and self.interface.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "all-instances-inherit" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "area"):
                                if (self.area is None):
                                    self.area = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Area()
                                    self.area.parent = self
                                    self._children_name_map["area"] = "area"
                                return self.area

                            if (child_yang_name == "interface"):
                                if (self.interface is None):
                                    self.interface = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit.Interface()
                                    self.interface.parent = self
                                    self._children_name_map["interface"] = "interface"
                                return self.interface

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "area" or name == "interface"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        for c in self.instance:
                            if (c.has_data()):
                                return True
                        return (
                            self.operation_mode.is_set or
                            (self.all_instances_inherit is not None and self.all_instances_inherit.has_data()))

                    def has_operation(self):
                        for c in self.instance:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.operation_mode.yfilter != YFilter.not_set or
                            (self.all_instances_inherit is not None and self.all_instances_inherit.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ietf-ospf:ospf" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.operation_mode.is_set or self.operation_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.operation_mode.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "all-instances-inherit"):
                            if (self.all_instances_inherit is None):
                                self.all_instances_inherit = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.AllInstancesInherit()
                                self.all_instances_inherit.parent = self
                                self._children_name_map["all_instances_inherit"] = "all-instances-inherit"
                            return self.all_instances_inherit

                        if (child_yang_name == "instance"):
                            for c in self.instance:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf.Instance()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.instance.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "all-instances-inherit" or name == "instance" or name == "operation-mode"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "operation-mode"):
                            self.operation_mode = value
                            self.operation_mode.value_namespace = name_space
                            self.operation_mode.value_namespace_prefix = name_space_prefix


                class StaticRoutes(Entity):
                    """
                    Configuration of the 'static' pseudo\-protocol.
                    
                    Address\-family\-specific modules augment this node with
                    their lists of routes.
                    
                    .. attribute:: ipv4
                    
                    	Configuration of a 'static' pseudo\-protocol instance consists of a list of routes
                    	**type**\:   :py:class:`Ipv4 <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4>`
                    
                    .. attribute:: ipv6
                    
                    	Configuration of a 'static' pseudo\-protocol instance consists of a list of routes
                    	**type**\:   :py:class:`Ipv6 <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6>`
                    
                    

                    """

                    _prefix = 'rt'
                    _revision = '2015-05-25'

                    def __init__(self):
                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes, self).__init__()

                        self.yang_name = "static-routes"
                        self.yang_parent_name = "routing-protocol"

                        self.ipv4 = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4()
                        self.ipv4.parent = self
                        self._children_name_map["ipv4"] = "ipv4"
                        self._children_yang_names.add("ipv4")

                        self.ipv6 = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6()
                        self.ipv6.parent = self
                        self._children_name_map["ipv6"] = "ipv6"
                        self._children_yang_names.add("ipv6")


                    class Ipv4(Entity):
                        """
                        Configuration of a 'static' pseudo\-protocol instance
                        consists of a list of routes.
                        
                        .. attribute:: route
                        
                        	A user\-ordered list of static routes
                        	**type**\: list of    :py:class:`Route <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route>`
                        
                        

                        """

                        _prefix = 'v4ur'
                        _revision = '2015-05-25'

                        def __init__(self):
                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4, self).__init__()

                            self.yang_name = "ipv4"
                            self.yang_parent_name = "static-routes"

                            self.route = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4, self).__setattr__(name, value)


                        class Route(Entity):
                            """
                            A user\-ordered list of static routes.
                            
                            .. attribute:: destination_prefix  <key>
                            
                            	IPv4 destination prefix
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                            
                            	**mandatory**\: True
                            
                            .. attribute:: description
                            
                            	Textual description of the route
                            	**type**\:  str
                            
                            .. attribute:: next_hop
                            
                            	Configuration of next\-hop
                            	**type**\:   :py:class:`NextHop <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop>`
                            
                            

                            """

                            _prefix = 'v4ur'
                            _revision = '2015-05-25'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route, self).__init__()

                                self.yang_name = "route"
                                self.yang_parent_name = "ipv4"

                                self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                                self.description = YLeaf(YType.str, "description")

                                self.next_hop = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop()
                                self.next_hop.parent = self
                                self._children_name_map["next_hop"] = "next-hop"
                                self._children_yang_names.add("next-hop")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("destination_prefix",
                                                "description") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route, self).__setattr__(name, value)


                            class NextHop(Entity):
                                """
                                Configuration of next\-hop.
                                
                                .. attribute:: next_hop_address
                                
                                	IPv4 address of the next\-hop
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: outgoing_interface
                                
                                	Name of the outgoing interface
                                	**type**\:  str
                                
                                .. attribute:: special_next_hop
                                
                                	Special next\-hop options
                                	**type**\:   :py:class:`SpecialNextHop <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop.SpecialNextHop>`
                                
                                

                                """

                                _prefix = 'v4ur'
                                _revision = '2015-05-25'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop, self).__init__()

                                    self.yang_name = "next-hop"
                                    self.yang_parent_name = "route"

                                    self.next_hop_address = YLeaf(YType.str, "next-hop-address")

                                    self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                    self.special_next_hop = YLeaf(YType.enumeration, "special-next-hop")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("next_hop_address",
                                                    "outgoing_interface",
                                                    "special_next_hop") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop, self).__setattr__(name, value)

                                class SpecialNextHop(Enum):
                                    """
                                    SpecialNextHop

                                    Special next\-hop options.

                                    .. data:: blackhole = 0

                                    	Silently discard the packet.

                                    .. data:: unreachable = 1

                                    	Discard the packet and notify the sender with an error

                                    	message indicating that the destination host is

                                    	unreachable.

                                    .. data:: prohibit = 2

                                    	Discard the packet and notify the sender with an error

                                    	message indicating that the communication is

                                    	administratively prohibited.

                                    .. data:: receive = 3

                                    	The packet will be received by the local system.

                                    """

                                    blackhole = Enum.YLeaf(0, "blackhole")

                                    unreachable = Enum.YLeaf(1, "unreachable")

                                    prohibit = Enum.YLeaf(2, "prohibit")

                                    receive = Enum.YLeaf(3, "receive")


                                def has_data(self):
                                    return (
                                        self.next_hop_address.is_set or
                                        self.outgoing_interface.is_set or
                                        self.special_next_hop.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.next_hop_address.yfilter != YFilter.not_set or
                                        self.outgoing_interface.yfilter != YFilter.not_set or
                                        self.special_next_hop.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "next-hop" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.next_hop_address.is_set or self.next_hop_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_address.get_name_leafdata())
                                    if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                    if (self.special_next_hop.is_set or self.special_next_hop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.special_next_hop.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "next-hop-address" or name == "outgoing-interface" or name == "special-next-hop"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "next-hop-address"):
                                        self.next_hop_address = value
                                        self.next_hop_address.value_namespace = name_space
                                        self.next_hop_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-interface"):
                                        self.outgoing_interface = value
                                        self.outgoing_interface.value_namespace = name_space
                                        self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "special-next-hop"):
                                        self.special_next_hop = value
                                        self.special_next_hop.value_namespace = name_space
                                        self.special_next_hop.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.destination_prefix.is_set or
                                    self.description.is_set or
                                    (self.next_hop is not None and self.next_hop.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.destination_prefix.yfilter != YFilter.not_set or
                                    self.description.yfilter != YFilter.not_set or
                                    (self.next_hop is not None and self.next_hop.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "route" + "[destination-prefix='" + self.destination_prefix.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                                if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.description.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "next-hop"):
                                    if (self.next_hop is None):
                                        self.next_hop = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route.NextHop()
                                        self.next_hop.parent = self
                                        self._children_name_map["next_hop"] = "next-hop"
                                    return self.next_hop

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop" or name == "destination-prefix" or name == "description"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "destination-prefix"):
                                    self.destination_prefix = value
                                    self.destination_prefix.value_namespace = name_space
                                    self.destination_prefix.value_namespace_prefix = name_space_prefix
                                if(value_path == "description"):
                                    self.description = value
                                    self.description.value_namespace = name_space
                                    self.description.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.route:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.route:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ietf-ipv4-unicast-routing:ipv4" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "route"):
                                for c in self.route:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4.Route()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.route.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "route"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Ipv6(Entity):
                        """
                        Configuration of a 'static' pseudo\-protocol instance
                        consists of a list of routes.
                        
                        .. attribute:: route
                        
                        	A user\-ordered list of static routes
                        	**type**\: list of    :py:class:`Route <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route>`
                        
                        

                        """

                        _prefix = 'v6ur'
                        _revision = '2015-05-25'

                        def __init__(self):
                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6, self).__init__()

                            self.yang_name = "ipv6"
                            self.yang_parent_name = "static-routes"

                            self.route = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6, self).__setattr__(name, value)


                        class Route(Entity):
                            """
                            A user\-ordered list of static routes.
                            
                            .. attribute:: destination_prefix  <key>
                            
                            	IPv6 destination prefix
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                            
                            	**mandatory**\: True
                            
                            .. attribute:: description
                            
                            	Textual description of the route
                            	**type**\:  str
                            
                            .. attribute:: next_hop
                            
                            	Configuration of next\-hop
                            	**type**\:   :py:class:`NextHop <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop>`
                            
                            

                            """

                            _prefix = 'v6ur'
                            _revision = '2015-05-25'

                            def __init__(self):
                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route, self).__init__()

                                self.yang_name = "route"
                                self.yang_parent_name = "ipv6"

                                self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                                self.description = YLeaf(YType.str, "description")

                                self.next_hop = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop()
                                self.next_hop.parent = self
                                self._children_name_map["next_hop"] = "next-hop"
                                self._children_yang_names.add("next-hop")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("destination_prefix",
                                                "description") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route, self).__setattr__(name, value)


                            class NextHop(Entity):
                                """
                                Configuration of next\-hop.
                                
                                .. attribute:: next_hop_address
                                
                                	IPv6 address of the next\-hop
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: outgoing_interface
                                
                                	Name of the outgoing interface
                                	**type**\:  str
                                
                                .. attribute:: special_next_hop
                                
                                	Special next\-hop options
                                	**type**\:   :py:class:`SpecialNextHop <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop.SpecialNextHop>`
                                
                                

                                """

                                _prefix = 'v6ur'
                                _revision = '2015-05-25'

                                def __init__(self):
                                    super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop, self).__init__()

                                    self.yang_name = "next-hop"
                                    self.yang_parent_name = "route"

                                    self.next_hop_address = YLeaf(YType.str, "next-hop-address")

                                    self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                    self.special_next_hop = YLeaf(YType.enumeration, "special-next-hop")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("next_hop_address",
                                                    "outgoing_interface",
                                                    "special_next_hop") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop, self).__setattr__(name, value)

                                class SpecialNextHop(Enum):
                                    """
                                    SpecialNextHop

                                    Special next\-hop options.

                                    .. data:: blackhole = 0

                                    	Silently discard the packet.

                                    .. data:: unreachable = 1

                                    	Discard the packet and notify the sender with an error

                                    	message indicating that the destination host is

                                    	unreachable.

                                    .. data:: prohibit = 2

                                    	Discard the packet and notify the sender with an error

                                    	message indicating that the communication is

                                    	administratively prohibited.

                                    .. data:: receive = 3

                                    	The packet will be received by the local system.

                                    """

                                    blackhole = Enum.YLeaf(0, "blackhole")

                                    unreachable = Enum.YLeaf(1, "unreachable")

                                    prohibit = Enum.YLeaf(2, "prohibit")

                                    receive = Enum.YLeaf(3, "receive")


                                def has_data(self):
                                    return (
                                        self.next_hop_address.is_set or
                                        self.outgoing_interface.is_set or
                                        self.special_next_hop.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.next_hop_address.yfilter != YFilter.not_set or
                                        self.outgoing_interface.yfilter != YFilter.not_set or
                                        self.special_next_hop.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "next-hop" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.next_hop_address.is_set or self.next_hop_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_address.get_name_leafdata())
                                    if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                    if (self.special_next_hop.is_set or self.special_next_hop.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.special_next_hop.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "next-hop-address" or name == "outgoing-interface" or name == "special-next-hop"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "next-hop-address"):
                                        self.next_hop_address = value
                                        self.next_hop_address.value_namespace = name_space
                                        self.next_hop_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-interface"):
                                        self.outgoing_interface = value
                                        self.outgoing_interface.value_namespace = name_space
                                        self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "special-next-hop"):
                                        self.special_next_hop = value
                                        self.special_next_hop.value_namespace = name_space
                                        self.special_next_hop.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.destination_prefix.is_set or
                                    self.description.is_set or
                                    (self.next_hop is not None and self.next_hop.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.destination_prefix.yfilter != YFilter.not_set or
                                    self.description.yfilter != YFilter.not_set or
                                    (self.next_hop is not None and self.next_hop.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "route" + "[destination-prefix='" + self.destination_prefix.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                                if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.description.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "next-hop"):
                                    if (self.next_hop is None):
                                        self.next_hop = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route.NextHop()
                                        self.next_hop.parent = self
                                        self._children_name_map["next_hop"] = "next-hop"
                                    return self.next_hop

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "next-hop" or name == "destination-prefix" or name == "description"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "destination-prefix"):
                                    self.destination_prefix = value
                                    self.destination_prefix.value_namespace = name_space
                                    self.destination_prefix.value_namespace_prefix = name_space_prefix
                                if(value_path == "description"):
                                    self.description = value
                                    self.description.value_namespace = name_space
                                    self.description.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.route:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.route:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ietf-ipv6-unicast-routing:ipv6" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "route"):
                                for c in self.route:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6.Route()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.route.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "route"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.ipv4 is not None and self.ipv4.has_data()) or
                            (self.ipv6 is not None and self.ipv6.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.ipv4 is not None and self.ipv4.has_operation()) or
                            (self.ipv6 is not None and self.ipv6.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "static-routes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ipv4"):
                            if (self.ipv4 is None):
                                self.ipv4 = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv4()
                                self.ipv4.parent = self
                                self._children_name_map["ipv4"] = "ipv4"
                            return self.ipv4

                        if (child_yang_name == "ipv6"):
                            if (self.ipv6 is None):
                                self.ipv6 = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes.Ipv6()
                                self.ipv6.parent = self
                                self._children_name_map["ipv6"] = "ipv6"
                            return self.ipv6

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.type.is_set or
                        self.name.is_set or
                        self.description.is_set or
                        (self.ospf is not None and self.ospf.has_data()) or
                        (self.static_routes is not None and self.static_routes.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.type.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.description.yfilter != YFilter.not_set or
                        (self.ospf is not None and self.ospf.has_operation()) or
                        (self.static_routes is not None and self.static_routes.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "routing-protocol" + "[type='" + self.type.get() + "']" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.type.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.description.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ospf"):
                        if (self.ospf is None):
                            self.ospf = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.Ospf()
                            self.ospf.parent = self
                            self._children_name_map["ospf"] = "ospf"
                        return self.ospf

                    if (child_yang_name == "static-routes"):
                        if (self.static_routes is None):
                            self.static_routes = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol.StaticRoutes()
                            self.static_routes.parent = self
                            self._children_name_map["static_routes"] = "static-routes"
                        return self.static_routes

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ospf" or name == "static-routes" or name == "type" or name == "name" or name == "description"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "type"):
                        self.type = value
                        self.type.value_namespace = name_space
                        self.type.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "description"):
                        self.description = value
                        self.description.value_namespace = name_space
                        self.description.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.routing_protocol:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.routing_protocol:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "routing-protocols" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "routing-protocol"):
                    for c in self.routing_protocol:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Routing.RoutingInstance.RoutingProtocols.RoutingProtocol()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.routing_protocol.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "routing-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Ribs(Entity):
            """
            Configuration of RIBs.
            
            .. attribute:: rib
            
            	Each entry contains configuration for a RIB identified by the 'name' key.  Entries having the same key as a system\-controlled entry of the list /routing\-state/routing\-instance/ribs/rib are used for configuring parameters of that entry. Other entries define additional user\-controlled RIBs
            	**type**\: list of    :py:class:`Rib <ydk.models.ietf.ietf_routing.Routing.RoutingInstance.Ribs.Rib>`
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(Routing.RoutingInstance.Ribs, self).__init__()

                self.yang_name = "ribs"
                self.yang_parent_name = "routing-instance"

                self.rib = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Routing.RoutingInstance.Ribs, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Routing.RoutingInstance.Ribs, self).__setattr__(name, value)


            class Rib(Entity):
                """
                Each entry contains configuration for a RIB identified
                by the 'name' key.
                
                Entries having the same key as a system\-controlled entry
                of the list /routing\-state/routing\-instance/ribs/rib are
                used for configuring parameters of that entry. Other
                entries define additional user\-controlled RIBs.
                
                .. attribute:: name  <key>
                
                	The name of the RIB.  For system\-controlled entries, the value of this leaf must be the same as the name of the corresponding entry in state data.  For user\-controlled entries, an arbitrary name can be used
                	**type**\:  str
                
                .. attribute:: address_family
                
                	Address family
                	**type**\:   :py:class:`AddressFamily <ydk.models.ietf.ietf_routing.AddressFamily>`
                
                .. attribute:: description
                
                	Textual description of the RIB
                	**type**\:  str
                
                

                """

                _prefix = 'rt'
                _revision = '2015-05-25'

                def __init__(self):
                    super(Routing.RoutingInstance.Ribs.Rib, self).__init__()

                    self.yang_name = "rib"
                    self.yang_parent_name = "ribs"

                    self.name = YLeaf(YType.str, "name")

                    self.address_family = YLeaf(YType.identityref, "address-family")

                    self.description = YLeaf(YType.str, "description")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name",
                                    "address_family",
                                    "description") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Routing.RoutingInstance.Ribs.Rib, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Routing.RoutingInstance.Ribs.Rib, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.name.is_set or
                        self.address_family.is_set or
                        self.description.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set or
                        self.address_family.yfilter != YFilter.not_set or
                        self.description.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "rib" + "[name='" + self.name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())
                    if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address_family.get_name_leafdata())
                    if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.description.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "name" or name == "address-family" or name == "description"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix
                    if(value_path == "address-family"):
                        self.address_family = value
                        self.address_family.value_namespace = name_space
                        self.address_family.value_namespace_prefix = name_space_prefix
                    if(value_path == "description"):
                        self.description = value
                        self.description.value_namespace = name_space
                        self.description.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.rib:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.rib:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ribs" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "rib"):
                    for c in self.rib:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Routing.RoutingInstance.Ribs.Rib()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.rib.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "rib"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.name.is_set or
                self.description.is_set or
                self.enabled.is_set or
                self.router_id.is_set or
                self.type.is_set or
                (self.interfaces is not None and self.interfaces.has_data()) or
                (self.ribs is not None and self.ribs.has_data()) or
                (self.routing_protocols is not None and self.routing_protocols.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.name.yfilter != YFilter.not_set or
                self.description.yfilter != YFilter.not_set or
                self.enabled.yfilter != YFilter.not_set or
                self.router_id.yfilter != YFilter.not_set or
                self.type.yfilter != YFilter.not_set or
                (self.interfaces is not None and self.interfaces.has_operation()) or
                (self.ribs is not None and self.ribs.has_operation()) or
                (self.routing_protocols is not None and self.routing_protocols.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "routing-instance" + "[name='" + self.name.get() + "']" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "ietf-routing:routing/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.name.get_name_leafdata())
            if (self.description.is_set or self.description.yfilter != YFilter.not_set):
                leaf_name_data.append(self.description.get_name_leafdata())
            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                leaf_name_data.append(self.enabled.get_name_leafdata())
            if (self.router_id.is_set or self.router_id.yfilter != YFilter.not_set):
                leaf_name_data.append(self.router_id.get_name_leafdata())
            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                leaf_name_data.append(self.type.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interfaces"):
                if (self.interfaces is None):
                    self.interfaces = Routing.RoutingInstance.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                return self.interfaces

            if (child_yang_name == "ribs"):
                if (self.ribs is None):
                    self.ribs = Routing.RoutingInstance.Ribs()
                    self.ribs.parent = self
                    self._children_name_map["ribs"] = "ribs"
                return self.ribs

            if (child_yang_name == "routing-protocols"):
                if (self.routing_protocols is None):
                    self.routing_protocols = Routing.RoutingInstance.RoutingProtocols()
                    self.routing_protocols.parent = self
                    self._children_name_map["routing_protocols"] = "routing-protocols"
                return self.routing_protocols

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interfaces" or name == "ribs" or name == "routing-protocols" or name == "name" or name == "description" or name == "enabled" or name == "router-id" or name == "type"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "name"):
                self.name = value
                self.name.value_namespace = name_space
                self.name.value_namespace_prefix = name_space_prefix
            if(value_path == "description"):
                self.description = value
                self.description.value_namespace = name_space
                self.description.value_namespace_prefix = name_space_prefix
            if(value_path == "enabled"):
                self.enabled = value
                self.enabled.value_namespace = name_space
                self.enabled.value_namespace_prefix = name_space_prefix
            if(value_path == "router-id"):
                self.router_id = value
                self.router_id.value_namespace = name_space
                self.router_id.value_namespace_prefix = name_space_prefix
            if(value_path == "type"):
                self.type = value
                self.type.value_namespace = name_space
                self.type.value_namespace_prefix = name_space_prefix

    def has_data(self):
        for c in self.routing_instance:
            if (c.has_data()):
                return True
        return False

    def has_operation(self):
        for c in self.routing_instance:
            if (c.has_operation()):
                return True
        return self.yfilter != YFilter.not_set

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "ietf-routing:routing" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "routing-instance"):
            for c in self.routing_instance:
                segment = c.get_segment_path()
                if (segment_path == segment):
                    return c
            c = Routing.RoutingInstance()
            c.parent = self
            local_reference_key = "ydk::seg::%s" % segment_path
            self._local_refs[local_reference_key] = c
            self.routing_instance.append(c)
            return c

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "routing-instance"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Routing()
        return self._top_entity

class FibRoute(Entity):
    """
    Return the active FIB route that a routing\-instance uses for
    sending packets to a destination address.
    
    .. attribute:: input
    
    	
    	**type**\:   :py:class:`Input <ydk.models.ietf.ietf_routing.FibRoute.Input>`
    
    .. attribute:: output
    
    	
    	**type**\:   :py:class:`Output <ydk.models.ietf.ietf_routing.FibRoute.Output>`
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(FibRoute, self).__init__()
        self._top_entity = None

        self.yang_name = "fib-route"
        self.yang_parent_name = "ietf-routing"

        self.input = FibRoute.Input()
        self.input.parent = self
        self._children_name_map["input"] = "input"
        self._children_yang_names.add("input")

        self.output = FibRoute.Output()
        self.output.parent = self
        self._children_name_map["output"] = "output"
        self._children_yang_names.add("output")


    class Input(Entity):
        """
        
        
        .. attribute:: destination_address
        
        	Network layer destination address.  Address family specific modules MUST augment this container with a leaf named 'address'
        	**type**\:   :py:class:`DestinationAddress <ydk.models.ietf.ietf_routing.FibRoute.Input.DestinationAddress>`
        
        .. attribute:: routing_instance_name
        
        	Name of the routing instance whose forwarding information base is being queried.  If the routing instance with name equal to the value of this parameter doesn't exist, then this operation SHALL fail with error\-tag 'data\-missing' and error\-app\-tag 'routing\-instance\-not\-found'
        	**type**\:  str
        
        	**mandatory**\: True
        
        

        """

        _prefix = 'rt'
        _revision = '2015-05-25'

        def __init__(self):
            super(FibRoute.Input, self).__init__()

            self.yang_name = "input"
            self.yang_parent_name = "fib-route"

            self.routing_instance_name = YLeaf(YType.str, "routing-instance-name")

            self.destination_address = FibRoute.Input.DestinationAddress()
            self.destination_address.parent = self
            self._children_name_map["destination_address"] = "destination-address"
            self._children_yang_names.add("destination-address")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("routing_instance_name") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(FibRoute.Input, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(FibRoute.Input, self).__setattr__(name, value)


        class DestinationAddress(Entity):
            """
            Network layer destination address.
            
            Address family specific modules MUST augment this
            container with a leaf named 'address'.
            
            .. attribute:: address_family
            
            	Address family
            	**type**\:   :py:class:`AddressFamily <ydk.models.ietf.ietf_routing.AddressFamily>`
            
            	**mandatory**\: True
            
            .. attribute:: ietf_ipv4_unicast_routing_address
            
            	IPv4 destination address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: ietf_ipv6_unicast_routing_address
            
            	IPv6 destination address
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(FibRoute.Input.DestinationAddress, self).__init__()

                self.yang_name = "destination-address"
                self.yang_parent_name = "input"

                self.address_family = YLeaf(YType.identityref, "address-family")

                self.ietf_ipv4_unicast_routing_address = YLeaf(YType.str, "ietf-ipv4-unicast-routing:ietf-ipv4-unicast-routing_address")

                self.ietf_ipv6_unicast_routing_address = YLeaf(YType.str, "ietf-ipv6-unicast-routing:ietf-ipv6-unicast-routing_address")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("address_family",
                                "ietf_ipv4_unicast_routing_address",
                                "ietf_ipv6_unicast_routing_address") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(FibRoute.Input.DestinationAddress, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(FibRoute.Input.DestinationAddress, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.address_family.is_set or
                    self.ietf_ipv4_unicast_routing_address.is_set or
                    self.ietf_ipv6_unicast_routing_address.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.address_family.yfilter != YFilter.not_set or
                    self.ietf_ipv4_unicast_routing_address.yfilter != YFilter.not_set or
                    self.ietf_ipv6_unicast_routing_address.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "destination-address" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "ietf-routing:fib-route/input/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.address_family.get_name_leafdata())
                if (self.ietf_ipv4_unicast_routing_address.is_set or self.ietf_ipv4_unicast_routing_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ietf_ipv4_unicast_routing_address.get_name_leafdata())
                if (self.ietf_ipv6_unicast_routing_address.is_set or self.ietf_ipv6_unicast_routing_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ietf_ipv6_unicast_routing_address.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "address-family" or name == "ietf-ipv4-unicast-routing_address" or name == "ietf-ipv6-unicast-routing_address"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "address-family"):
                    self.address_family = value
                    self.address_family.value_namespace = name_space
                    self.address_family.value_namespace_prefix = name_space_prefix
                if(value_path == "ietf-ipv4-unicast-routing_address"):
                    self.ietf_ipv4_unicast_routing_address = value
                    self.ietf_ipv4_unicast_routing_address.value_namespace = name_space
                    self.ietf_ipv4_unicast_routing_address.value_namespace_prefix = name_space_prefix
                if(value_path == "ietf-ipv6-unicast-routing_address"):
                    self.ietf_ipv6_unicast_routing_address = value
                    self.ietf_ipv6_unicast_routing_address.value_namespace = name_space
                    self.ietf_ipv6_unicast_routing_address.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.routing_instance_name.is_set or
                (self.destination_address is not None and self.destination_address.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.routing_instance_name.yfilter != YFilter.not_set or
                (self.destination_address is not None and self.destination_address.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "input" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "ietf-routing:fib-route/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.routing_instance_name.is_set or self.routing_instance_name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.routing_instance_name.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "destination-address"):
                if (self.destination_address is None):
                    self.destination_address = FibRoute.Input.DestinationAddress()
                    self.destination_address.parent = self
                    self._children_name_map["destination_address"] = "destination-address"
                return self.destination_address

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "destination-address" or name == "routing-instance-name"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "routing-instance-name"):
                self.routing_instance_name = value
                self.routing_instance_name.value_namespace = name_space
                self.routing_instance_name.value_namespace_prefix = name_space_prefix


    class Output(Entity):
        """
        
        
        .. attribute:: route
        
        	The active FIB route for the specified destination.  If the routing instance has no active FIB route for the destination address, no output is returned \- the server SHALL send an <rpc\-reply> containing a single element <ok>.  Address family specific modules MUST augment this list with appropriate route contents
        	**type**\:   :py:class:`Route <ydk.models.ietf.ietf_routing.FibRoute.Output.Route>`
        
        

        """

        _prefix = 'rt'
        _revision = '2015-05-25'

        def __init__(self):
            super(FibRoute.Output, self).__init__()

            self.yang_name = "output"
            self.yang_parent_name = "fib-route"

            self.route = FibRoute.Output.Route()
            self.route.parent = self
            self._children_name_map["route"] = "route"
            self._children_yang_names.add("route")


        class Route(Entity):
            """
            The active FIB route for the specified destination.
            
            If the routing instance has no active FIB route for the
            destination address, no output is returned \- the server
            SHALL send an <rpc\-reply> containing a single element
            <ok>.
            
            Address family specific modules MUST augment this list
            with appropriate route contents.
            
            .. attribute:: active
            
            	Presence of this leaf indicates that the route is preferred among all routes in the same RIB that have the same destination prefix
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: address_family
            
            	Address family
            	**type**\:   :py:class:`AddressFamily <ydk.models.ietf.ietf_routing.AddressFamily>`
            
            	**mandatory**\: True
            
            .. attribute:: ietf_ipv4_unicast_routing_destination_prefix
            
            	IPv4 destination prefix
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
            
            .. attribute:: ietf_ipv6_unicast_routing_destination_prefix
            
            	IPv6 destination prefix
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
            
            .. attribute:: last_updated
            
            	Time stamp of the last modification of the route. If the route was never modified, it is the time when the route was inserted into the RIB
            	**type**\:  str
            
            	**pattern:** \\d{4}\-\\d{2}\-\\d{2}T\\d{2}\:\\d{2}\:\\d{2}(\\.\\d+)?(Z\|[\\+\\\-]\\d{2}\:\\d{2})
            
            .. attribute:: next_hop
            
            	Route's next\-hop attribute
            	**type**\:   :py:class:`NextHop <ydk.models.ietf.ietf_routing.FibRoute.Output.Route.NextHop>`
            
            .. attribute:: source_protocol
            
            	Type of the routing protocol from which the route originated
            	**type**\:   :py:class:`RoutingProtocol <ydk.models.ietf.ietf_routing.RoutingProtocol>`
            
            	**mandatory**\: True
            
            

            """

            _prefix = 'rt'
            _revision = '2015-05-25'

            def __init__(self):
                super(FibRoute.Output.Route, self).__init__()

                self.yang_name = "route"
                self.yang_parent_name = "output"

                self.active = YLeaf(YType.empty, "active")

                self.address_family = YLeaf(YType.identityref, "address-family")

                self.ietf_ipv4_unicast_routing_destination_prefix = YLeaf(YType.str, "ietf-ipv4-unicast-routing:ietf-ipv4-unicast-routing_destination-prefix")

                self.ietf_ipv6_unicast_routing_destination_prefix = YLeaf(YType.str, "ietf-ipv6-unicast-routing:ietf-ipv6-unicast-routing_destination-prefix")

                self.last_updated = YLeaf(YType.str, "last-updated")

                self.source_protocol = YLeaf(YType.identityref, "source-protocol")

                self.next_hop = FibRoute.Output.Route.NextHop()
                self.next_hop.parent = self
                self._children_name_map["next_hop"] = "next-hop"
                self._children_yang_names.add("next-hop")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("active",
                                "address_family",
                                "ietf_ipv4_unicast_routing_destination_prefix",
                                "ietf_ipv6_unicast_routing_destination_prefix",
                                "last_updated",
                                "source_protocol") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(FibRoute.Output.Route, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(FibRoute.Output.Route, self).__setattr__(name, value)


            class NextHop(Entity):
                """
                Route's next\-hop attribute.
                
                .. attribute:: ietf_ipv4_unicast_routing_next_hop_address
                
                	IPv4 address of the next\-hop
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ietf_ipv6_unicast_routing_next_hop_address
                
                	IPv6 address of the next\-hop
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ietf_routing_next_hop_address
                
                	IP address
                	**type**\:  str
                
                .. attribute:: outgoing_interface
                
                	Name of the outgoing interface
                	**type**\:  str
                
                .. attribute:: special_next_hop
                
                	Special next\-hop options
                	**type**\:   :py:class:`SpecialNextHop <ydk.models.ietf.ietf_routing.FibRoute.Output.Route.NextHop.SpecialNextHop>`
                
                

                """

                _prefix = 'rt'
                _revision = '2015-05-25'

                def __init__(self):
                    super(FibRoute.Output.Route.NextHop, self).__init__()

                    self.yang_name = "next-hop"
                    self.yang_parent_name = "route"

                    self.ietf_ipv4_unicast_routing_next_hop_address = YLeaf(YType.str, "ietf-ipv4-unicast-routing:ietf-ipv4-unicast-routing_next-hop-address")

                    self.ietf_ipv6_unicast_routing_next_hop_address = YLeaf(YType.str, "ietf-ipv6-unicast-routing:ietf-ipv6-unicast-routing_next-hop-address")

                    self.ietf_routing_next_hop_address = YLeaf(YType.str, "ietf-routing_next-hop-address")

                    self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                    self.special_next_hop = YLeaf(YType.enumeration, "special-next-hop")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ietf_ipv4_unicast_routing_next_hop_address",
                                    "ietf_ipv6_unicast_routing_next_hop_address",
                                    "ietf_routing_next_hop_address",
                                    "outgoing_interface",
                                    "special_next_hop") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(FibRoute.Output.Route.NextHop, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(FibRoute.Output.Route.NextHop, self).__setattr__(name, value)

                class SpecialNextHop(Enum):
                    """
                    SpecialNextHop

                    Special next\-hop options.

                    .. data:: blackhole = 0

                    	Silently discard the packet.

                    .. data:: unreachable = 1

                    	Discard the packet and notify the sender with an error

                    	message indicating that the destination host is

                    	unreachable.

                    .. data:: prohibit = 2

                    	Discard the packet and notify the sender with an error

                    	message indicating that the communication is

                    	administratively prohibited.

                    .. data:: receive = 3

                    	The packet will be received by the local system.

                    """

                    blackhole = Enum.YLeaf(0, "blackhole")

                    unreachable = Enum.YLeaf(1, "unreachable")

                    prohibit = Enum.YLeaf(2, "prohibit")

                    receive = Enum.YLeaf(3, "receive")


                def has_data(self):
                    return (
                        self.ietf_ipv4_unicast_routing_next_hop_address.is_set or
                        self.ietf_ipv6_unicast_routing_next_hop_address.is_set or
                        self.ietf_routing_next_hop_address.is_set or
                        self.outgoing_interface.is_set or
                        self.special_next_hop.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ietf_ipv4_unicast_routing_next_hop_address.yfilter != YFilter.not_set or
                        self.ietf_ipv6_unicast_routing_next_hop_address.yfilter != YFilter.not_set or
                        self.ietf_routing_next_hop_address.yfilter != YFilter.not_set or
                        self.outgoing_interface.yfilter != YFilter.not_set or
                        self.special_next_hop.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "next-hop" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "ietf-routing:fib-route/output/route/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ietf_ipv4_unicast_routing_next_hop_address.is_set or self.ietf_ipv4_unicast_routing_next_hop_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ietf_ipv4_unicast_routing_next_hop_address.get_name_leafdata())
                    if (self.ietf_ipv6_unicast_routing_next_hop_address.is_set or self.ietf_ipv6_unicast_routing_next_hop_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ietf_ipv6_unicast_routing_next_hop_address.get_name_leafdata())
                    if (self.ietf_routing_next_hop_address.is_set or self.ietf_routing_next_hop_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ietf_routing_next_hop_address.get_name_leafdata())
                    if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                    if (self.special_next_hop.is_set or self.special_next_hop.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.special_next_hop.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ietf-ipv4-unicast-routing_next-hop-address" or name == "ietf-ipv6-unicast-routing_next-hop-address" or name == "ietf-routing_next-hop-address" or name == "outgoing-interface" or name == "special-next-hop"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ietf-ipv4-unicast-routing_next-hop-address"):
                        self.ietf_ipv4_unicast_routing_next_hop_address = value
                        self.ietf_ipv4_unicast_routing_next_hop_address.value_namespace = name_space
                        self.ietf_ipv4_unicast_routing_next_hop_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "ietf-ipv6-unicast-routing_next-hop-address"):
                        self.ietf_ipv6_unicast_routing_next_hop_address = value
                        self.ietf_ipv6_unicast_routing_next_hop_address.value_namespace = name_space
                        self.ietf_ipv6_unicast_routing_next_hop_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "ietf-routing_next-hop-address"):
                        self.ietf_routing_next_hop_address = value
                        self.ietf_routing_next_hop_address.value_namespace = name_space
                        self.ietf_routing_next_hop_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "outgoing-interface"):
                        self.outgoing_interface = value
                        self.outgoing_interface.value_namespace = name_space
                        self.outgoing_interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "special-next-hop"):
                        self.special_next_hop = value
                        self.special_next_hop.value_namespace = name_space
                        self.special_next_hop.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.active.is_set or
                    self.address_family.is_set or
                    self.ietf_ipv4_unicast_routing_destination_prefix.is_set or
                    self.ietf_ipv6_unicast_routing_destination_prefix.is_set or
                    self.last_updated.is_set or
                    self.source_protocol.is_set or
                    (self.next_hop is not None and self.next_hop.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.active.yfilter != YFilter.not_set or
                    self.address_family.yfilter != YFilter.not_set or
                    self.ietf_ipv4_unicast_routing_destination_prefix.yfilter != YFilter.not_set or
                    self.ietf_ipv6_unicast_routing_destination_prefix.yfilter != YFilter.not_set or
                    self.last_updated.yfilter != YFilter.not_set or
                    self.source_protocol.yfilter != YFilter.not_set or
                    (self.next_hop is not None and self.next_hop.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "route" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "ietf-routing:fib-route/output/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.active.get_name_leafdata())
                if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.address_family.get_name_leafdata())
                if (self.ietf_ipv4_unicast_routing_destination_prefix.is_set or self.ietf_ipv4_unicast_routing_destination_prefix.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ietf_ipv4_unicast_routing_destination_prefix.get_name_leafdata())
                if (self.ietf_ipv6_unicast_routing_destination_prefix.is_set or self.ietf_ipv6_unicast_routing_destination_prefix.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ietf_ipv6_unicast_routing_destination_prefix.get_name_leafdata())
                if (self.last_updated.is_set or self.last_updated.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_updated.get_name_leafdata())
                if (self.source_protocol.is_set or self.source_protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_protocol.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "next-hop"):
                    if (self.next_hop is None):
                        self.next_hop = FibRoute.Output.Route.NextHop()
                        self.next_hop.parent = self
                        self._children_name_map["next_hop"] = "next-hop"
                    return self.next_hop

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "next-hop" or name == "active" or name == "address-family" or name == "ietf-ipv4-unicast-routing_destination-prefix" or name == "ietf-ipv6-unicast-routing_destination-prefix" or name == "last-updated" or name == "source-protocol"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "active"):
                    self.active = value
                    self.active.value_namespace = name_space
                    self.active.value_namespace_prefix = name_space_prefix
                if(value_path == "address-family"):
                    self.address_family = value
                    self.address_family.value_namespace = name_space
                    self.address_family.value_namespace_prefix = name_space_prefix
                if(value_path == "ietf-ipv4-unicast-routing_destination-prefix"):
                    self.ietf_ipv4_unicast_routing_destination_prefix = value
                    self.ietf_ipv4_unicast_routing_destination_prefix.value_namespace = name_space
                    self.ietf_ipv4_unicast_routing_destination_prefix.value_namespace_prefix = name_space_prefix
                if(value_path == "ietf-ipv6-unicast-routing_destination-prefix"):
                    self.ietf_ipv6_unicast_routing_destination_prefix = value
                    self.ietf_ipv6_unicast_routing_destination_prefix.value_namespace = name_space
                    self.ietf_ipv6_unicast_routing_destination_prefix.value_namespace_prefix = name_space_prefix
                if(value_path == "last-updated"):
                    self.last_updated = value
                    self.last_updated.value_namespace = name_space
                    self.last_updated.value_namespace_prefix = name_space_prefix
                if(value_path == "source-protocol"):
                    self.source_protocol = value
                    self.source_protocol.value_namespace = name_space
                    self.source_protocol.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.route is not None and self.route.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.route is not None and self.route.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "output" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "ietf-routing:fib-route/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "route"):
                if (self.route is None):
                    self.route = FibRoute.Output.Route()
                    self.route.parent = self
                    self._children_name_map["route"] = "route"
                return self.route

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "route"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.input is not None and self.input.has_data()) or
            (self.output is not None and self.output.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.input is not None and self.input.has_operation()) or
            (self.output is not None and self.output.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "ietf-routing:fib-route" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "input"):
            if (self.input is None):
                self.input = FibRoute.Input()
                self.input.parent = self
                self._children_name_map["input"] = "input"
            return self.input

        if (child_yang_name == "output"):
            if (self.output is None):
                self.output = FibRoute.Output()
                self.output.parent = self
                self._children_name_map["output"] = "output"
            return self.output

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "input" or name == "output"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = FibRoute()
        return self._top_entity

class Static(Identity):
    """
    Static routing pseudo\-protocol.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(Static, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:static")


class Ipv6(Identity):
    """
    This identity represents IPv6 address family.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(Ipv6, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:ipv6")


class Direct(Identity):
    """
    Routing pseudo\-protocol that provides routes to directly
    connected networks.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(Direct, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:direct")


class VrfRoutingInstance(Identity):
    """
    This identity represents a VRF routing instance. The type is
    distinct from the default\-routing\-instance. There may be
    multiple vrf\-routing\-interfaces.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(VrfRoutingInstance, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:vrf-routing-instance")


class DefaultRoutingInstance(Identity):
    """
    This identity represents either a default routing instance, or
    the only routing instance on systems that do not support
    multiple instances.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(DefaultRoutingInstance, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:default-routing-instance")


class Ipv4(Identity):
    """
    This identity represents IPv4 address family.
    
    

    """

    _prefix = 'rt'
    _revision = '2015-05-25'

    def __init__(self):
        super(Ipv4, self).__init__("urn:ietf:params:xml:ns:yang:ietf-routing", "ietf-routing", "ietf-routing:ipv4")


