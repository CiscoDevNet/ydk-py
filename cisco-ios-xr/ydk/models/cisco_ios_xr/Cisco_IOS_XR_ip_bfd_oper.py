""" Cisco_IOS_XR_ip_bfd_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR ip\-bfd package operational data.

This module contains definitions
for the following management objects\:
  bfd\: Bidirectional Forwarding Detection(BFD) operational data

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class BfdAfId(Enum):
    """
    BfdAfId

    Bfd af id

    .. data:: bfd_af_id_none = 0

    	No Address

    .. data:: bfd_af_id_ipv4 = 2

    	IPv4 AFI

    .. data:: bfd_af_id_ipv6 = 10

    	IPv6 AFI

    """

    bfd_af_id_none = Enum.YLeaf(0, "bfd-af-id-none")

    bfd_af_id_ipv4 = Enum.YLeaf(2, "bfd-af-id-ipv4")

    bfd_af_id_ipv6 = Enum.YLeaf(10, "bfd-af-id-ipv6")


class BfdApiFec(Enum):
    """
    BfdApiFec

    Bfd api fec

    .. data:: bfd_api_fec_type_none = 0

    	bfd api fec type none

    .. data:: bfd_api_fec_type_p2p_te = 1

    	bfd api fec type p2p te

    """

    bfd_api_fec_type_none = Enum.YLeaf(0, "bfd-api-fec-type-none")

    bfd_api_fec_type_p2p_te = Enum.YLeaf(1, "bfd-api-fec-type-p2p-te")


class BfdMgmtPktDisplay(Enum):
    """
    BfdMgmtPktDisplay

    BFD session type

    .. data:: bfd_mgmt_pkt_display_type_none = 0

    	None

    .. data:: bfd_mgmt_pkt_display_type_bob_mbr = 1

    	Display Type Bundle RTR Member

    .. data:: bfd_mgmt_pkt_display_type_max = 2

    	Display Type Enum Max Value

    """

    bfd_mgmt_pkt_display_type_none = Enum.YLeaf(0, "bfd-mgmt-pkt-display-type-none")

    bfd_mgmt_pkt_display_type_bob_mbr = Enum.YLeaf(1, "bfd-mgmt-pkt-display-type-bob-mbr")

    bfd_mgmt_pkt_display_type_max = Enum.YLeaf(2, "bfd-mgmt-pkt-display-type-max")


class BfdMgmtSessionDiag(Enum):
    """
    BfdMgmtSessionDiag

    BFD session diagnostic

    .. data:: bfd_mgmt_session_diag_none = 0

    	No diagnostic

    .. data:: bfd_mgmt_session_diag_control_detect_expired = 1

    	Control Detection Time Expired

    .. data:: bfd_mgmt_session_diag_echo_function_failed = 2

    	Echo Function Failed

    .. data:: bfd_mgmt_session_diag_nb_or_signaled_down = 3

    	Neighbor Signaled Session Down

    .. data:: bfd_mgmt_session_diag_fwding_plane_reset = 4

    	Forwarding Plane Reset

    .. data:: bfd_mgmt_session_diag_path_down = 5

    	Path Down

    .. data:: bfd_mgmt_session_diag_conc_path_down = 6

    	Concatenated Path Down

    .. data:: bfd_mgmt_session_diag_admin_down = 7

    	Administratively Down

    .. data:: bfd_mgmt_session_diag_rev_conc_path_down = 8

    	Reverse Concatenated Path Down

    .. data:: bfd_mgmt_session_diag_num = 10

    	Unknown diagnostic state

    """

    bfd_mgmt_session_diag_none = Enum.YLeaf(0, "bfd-mgmt-session-diag-none")

    bfd_mgmt_session_diag_control_detect_expired = Enum.YLeaf(1, "bfd-mgmt-session-diag-control-detect-expired")

    bfd_mgmt_session_diag_echo_function_failed = Enum.YLeaf(2, "bfd-mgmt-session-diag-echo-function-failed")

    bfd_mgmt_session_diag_nb_or_signaled_down = Enum.YLeaf(3, "bfd-mgmt-session-diag-nb-or-signaled-down")

    bfd_mgmt_session_diag_fwding_plane_reset = Enum.YLeaf(4, "bfd-mgmt-session-diag-fwding-plane-reset")

    bfd_mgmt_session_diag_path_down = Enum.YLeaf(5, "bfd-mgmt-session-diag-path-down")

    bfd_mgmt_session_diag_conc_path_down = Enum.YLeaf(6, "bfd-mgmt-session-diag-conc-path-down")

    bfd_mgmt_session_diag_admin_down = Enum.YLeaf(7, "bfd-mgmt-session-diag-admin-down")

    bfd_mgmt_session_diag_rev_conc_path_down = Enum.YLeaf(8, "bfd-mgmt-session-diag-rev-conc-path-down")

    bfd_mgmt_session_diag_num = Enum.YLeaf(10, "bfd-mgmt-session-diag-num")


class BfdMgmtSessionState(Enum):
    """
    BfdMgmtSessionState

    BFD session states

    .. data:: bfd_mgmt_session_state_admin_down = 0

    	Session in Administratively Shutdown State

    .. data:: bfd_mgmt_session_state_down = 1

    	Session in Down State

    .. data:: bfd_mgmt_session_state_init = 2

    	Session in Initializing State

    .. data:: bfd_mgmt_session_state_up = 3

    	Session in Up State

    .. data:: bfd_mgmt_session_state_failing = 4

    	Session in Failing State

    .. data:: bfd_mgmt_session_state_unknown = 6

    	Session in Unknown State

    """

    bfd_mgmt_session_state_admin_down = Enum.YLeaf(0, "bfd-mgmt-session-state-admin-down")

    bfd_mgmt_session_state_down = Enum.YLeaf(1, "bfd-mgmt-session-state-down")

    bfd_mgmt_session_state_init = Enum.YLeaf(2, "bfd-mgmt-session-state-init")

    bfd_mgmt_session_state_up = Enum.YLeaf(3, "bfd-mgmt-session-state-up")

    bfd_mgmt_session_state_failing = Enum.YLeaf(4, "bfd-mgmt-session-state-failing")

    bfd_mgmt_session_state_unknown = Enum.YLeaf(6, "bfd-mgmt-session-state-unknown")


class BfdMpDownloadState(Enum):
    """
    BfdMpDownloadState

    Bfd mp download state

    .. data:: bfd_mp_download_none = 0

    	bfd mp download none

    .. data:: bfd_mp_download_no_lc = 1

    	bfd mp download no lc

    .. data:: bfd_mp_download_downloaded = 2

    	bfd mp download downloaded

    .. data:: bfd_mp_download_ack = 3

    	bfd mp download ack

    .. data:: bfd_mp_download_nack = 4

    	bfd mp download nack

    .. data:: bfd_mp_download_delete = 5

    	bfd mp download delete

    """

    bfd_mp_download_none = Enum.YLeaf(0, "bfd-mp-download-none")

    bfd_mp_download_no_lc = Enum.YLeaf(1, "bfd-mp-download-no-lc")

    bfd_mp_download_downloaded = Enum.YLeaf(2, "bfd-mp-download-downloaded")

    bfd_mp_download_ack = Enum.YLeaf(3, "bfd-mp-download-ack")

    bfd_mp_download_nack = Enum.YLeaf(4, "bfd-mp-download-nack")

    bfd_mp_download_delete = Enum.YLeaf(5, "bfd-mp-download-delete")


class BfdSession(Enum):
    """
    BfdSession

    BFD session type

    .. data:: undefined = 0

    	Session type is undefined

    .. data:: bundle_member = 1

    	Session type is bundle member

    .. data:: bundle_interface = 2

    	Session type is bundle interface

    .. data:: state_inheriting = 3

    	Session type is state inheriting

    .. data:: bundle_vlan = 4

    	Session type is bundle vlan

    .. data:: mpls_tp = 5

    	Session type is MPLS-TP

    .. data:: gre = 6

    	Session type is GRE tunnel

    .. data:: pseudowire_headend = 7

    	Session type is PW-HE

    .. data:: ip_single_hop = 8

    	Session type is IP single hop

    """

    undefined = Enum.YLeaf(0, "undefined")

    bundle_member = Enum.YLeaf(1, "bundle-member")

    bundle_interface = Enum.YLeaf(2, "bundle-interface")

    state_inheriting = Enum.YLeaf(3, "state-inheriting")

    bundle_vlan = Enum.YLeaf(4, "bundle-vlan")

    mpls_tp = Enum.YLeaf(5, "mpls-tp")

    gre = Enum.YLeaf(6, "gre")

    pseudowire_headend = Enum.YLeaf(7, "pseudowire-headend")

    ip_single_hop = Enum.YLeaf(8, "ip-single-hop")


class MplsLibC(Enum):
    """
    MplsLibC

    Mpls lib c

    .. data:: mpls_lib_c_type_null = 0

    	NULL Ctype

    .. data:: mpls_lib_c_type_ipv4 = 1

    	IPv4 UDP

    .. data:: mpls_lib_c_type_ipv4_p2p_tunnel = 7

    	IPv4 point-to-point TE tunnel

    .. data:: mpls_lib_c_type_ipv6_p2p_tunnel = 8

    	IPv6 point-to-point TE tunnel

    .. data:: mpls_lib_c_type_ipv4_uni = 9

    	IPv4 unicast

    .. data:: mpls_lib_c_type_ipv4_p2mp_tunnel = 13

    	IPv4 point-to-point TE tunnel

    .. data:: mpls_lib_c_type_ipv6_p2mp_tunnel = 14

    	IPv6 point-to-point TE tunnel

    .. data:: mpls_lib_c_type_ipv4_tp_tunnel = 15

    	IPv4 transport protocol tunnel

    .. data:: mpls_lib_c_type_ipv6_tp_tunnel = 16

    	IPv6 transport protocol tunnel

    .. data:: mpls_lib_c_type_p2p_binding_label = 17

    	P2P transport tunnel binding label

    """

    mpls_lib_c_type_null = Enum.YLeaf(0, "mpls-lib-c-type-null")

    mpls_lib_c_type_ipv4 = Enum.YLeaf(1, "mpls-lib-c-type-ipv4")

    mpls_lib_c_type_ipv4_p2p_tunnel = Enum.YLeaf(7, "mpls-lib-c-type-ipv4-p2p-tunnel")

    mpls_lib_c_type_ipv6_p2p_tunnel = Enum.YLeaf(8, "mpls-lib-c-type-ipv6-p2p-tunnel")

    mpls_lib_c_type_ipv4_uni = Enum.YLeaf(9, "mpls-lib-c-type-ipv4-uni")

    mpls_lib_c_type_ipv4_p2mp_tunnel = Enum.YLeaf(13, "mpls-lib-c-type-ipv4-p2mp-tunnel")

    mpls_lib_c_type_ipv6_p2mp_tunnel = Enum.YLeaf(14, "mpls-lib-c-type-ipv6-p2mp-tunnel")

    mpls_lib_c_type_ipv4_tp_tunnel = Enum.YLeaf(15, "mpls-lib-c-type-ipv4-tp-tunnel")

    mpls_lib_c_type_ipv6_tp_tunnel = Enum.YLeaf(16, "mpls-lib-c-type-ipv6-tp-tunnel")

    mpls_lib_c_type_p2p_binding_label = Enum.YLeaf(17, "mpls-lib-c-type-p2p-binding-label")



class Bfd(Entity):
    """
    Bidirectional Forwarding Detection(BFD)
    operational data
    
    .. attribute:: client_briefs
    
    	Table of Brief information about BFD clients
    	**type**\:   :py:class:`ClientBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.ClientBriefs>`
    
    .. attribute:: client_details
    
    	Table of detailed information about BFD clients
    	**type**\:   :py:class:`ClientDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.ClientDetails>`
    
    .. attribute:: counters
    
    	Counters
    	**type**\:   :py:class:`Counters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Counters>`
    
    .. attribute:: generic_summaries
    
    	Generic summary information about BFD location
    	**type**\:   :py:class:`GenericSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.GenericSummaries>`
    
    .. attribute:: ipv4_multi_hop_counters
    
    	IPv4 multiple hop Counters
    	**type**\:   :py:class:`Ipv4MultiHopCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopCounters>`
    
    .. attribute:: ipv4_multi_hop_multi_paths
    
    	IPv4 multi\-hop multipath
    	**type**\:   :py:class:`Ipv4MultiHopMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopMultiPaths>`
    
    .. attribute:: ipv4_multi_hop_node_location_summaries
    
    	Table of summary information about BFD IPv4 multihop sessions per location
    	**type**\:   :py:class:`Ipv4MultiHopNodeLocationSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopNodeLocationSummaries>`
    
    .. attribute:: ipv4_multi_hop_session_briefs
    
    	Table of brief information about all IPv4 multihop BFD sessions in the System
    	**type**\:   :py:class:`Ipv4MultiHopSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionBriefs>`
    
    .. attribute:: ipv4_multi_hop_session_details
    
    	Table of detailed information about all IPv4 multihop BFD sessions in the System 
    	**type**\:   :py:class:`Ipv4MultiHopSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails>`
    
    .. attribute:: ipv4_multi_hop_summary
    
    	Summary information of BFD IPv4 multihop sessions
    	**type**\:   :py:class:`Ipv4MultiHopSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSummary>`
    
    .. attribute:: ipv4_single_hop_counters
    
    	IPv4 single hop Counters
    	**type**\:   :py:class:`Ipv4SingleHopCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopCounters>`
    
    .. attribute:: ipv4_single_hop_location_summaries
    
    	Table of summary information about IPv4 singlehop BFD sessions for location
    	**type**\:   :py:class:`Ipv4SingleHopLocationSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopLocationSummaries>`
    
    .. attribute:: ipv4_single_hop_multi_paths
    
    	IPv4 single hop multipath
    	**type**\:   :py:class:`Ipv4SingleHopMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopMultiPaths>`
    
    .. attribute:: ipv4_single_hop_node_location_summaries
    
    	Table of summary information about BFD IPv4 singlehop sessions per location
    	**type**\:   :py:class:`Ipv4SingleHopNodeLocationSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopNodeLocationSummaries>`
    
    .. attribute:: ipv4_single_hop_session_briefs
    
    	Table of brief information about all IPv4 singlehop BFD sessions in the System
    	**type**\:   :py:class:`Ipv4SingleHopSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionBriefs>`
    
    .. attribute:: ipv4_single_hop_session_details
    
    	Table of detailed information about all IPv4 singlehop BFD sessions in the System 
    	**type**\:   :py:class:`Ipv4SingleHopSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails>`
    
    .. attribute:: ipv4_single_hop_summary
    
    	Summary information of BFD IPv4 singlehop sessions
    	**type**\:   :py:class:`Ipv4SingleHopSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSummary>`
    
    .. attribute:: ipv4bf_do_mplste_head_counters
    
    	IPv4 BFD over MPLS\-TE Counters
    	**type**\:   :py:class:`Ipv4BfDoMplsteHeadCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadCounters>`
    
    .. attribute:: ipv4bf_do_mplste_head_multi_paths
    
    	IPv4 BFD over MPLS\-TE Head multipath
    	**type**\:   :py:class:`Ipv4BfDoMplsteHeadMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadMultiPaths>`
    
    .. attribute:: ipv4bf_do_mplste_head_session_briefs
    
    	Table of brief information about all IPv4 BFD over MPLS\-TE Head sessions in the System
    	**type**\:   :py:class:`Ipv4BfDoMplsteHeadSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionBriefs>`
    
    .. attribute:: ipv4bf_do_mplste_head_session_details
    
    	Table of detailed information about all IPv4 BFD over MPLS\-TE Head sessions in the System
    	**type**\:   :py:class:`Ipv4BfDoMplsteHeadSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails>`
    
    .. attribute:: ipv4bf_do_mplste_head_summary
    
    	Summary information of IPv4 BFD over MPLS\-TE Head
    	**type**\:   :py:class:`Ipv4BfDoMplsteHeadSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSummary>`
    
    .. attribute:: ipv4bf_do_mplste_tail_counters
    
    	IPv4 BFD over MPLS\-TE Counters
    	**type**\:   :py:class:`Ipv4BfDoMplsteTailCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailCounters>`
    
    .. attribute:: ipv4bf_do_mplste_tail_multi_paths
    
    	IPv4 BFD over MPLS\-TE Tail multipath
    	**type**\:   :py:class:`Ipv4BfDoMplsteTailMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailMultiPaths>`
    
    .. attribute:: ipv4bf_do_mplste_tail_session_briefs
    
    	Table of brief information about all IPv4 BFD over MPLS\-TE Tail sessions in the System
    	**type**\:   :py:class:`Ipv4BfDoMplsteTailSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionBriefs>`
    
    .. attribute:: ipv4bf_do_mplste_tail_session_details
    
    	Table of detailed information about all IPv4 BFD over MPLS\-TE Tail sessions in the System
    	**type**\:   :py:class:`Ipv4BfDoMplsteTailSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails>`
    
    .. attribute:: ipv4bf_do_mplste_tail_summary
    
    	Summary information of IPv4 BFD over MPLS\-TE Tail
    	**type**\:   :py:class:`Ipv4BfDoMplsteTailSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSummary>`
    
    .. attribute:: ipv4bfd_mplste_head_summary_nodes
    
    	Table of summary about IPv4 TE head BFD sessions for location
    	**type**\:   :py:class:`Ipv4BfdMplsteHeadSummaryNodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfdMplsteHeadSummaryNodes>`
    
    .. attribute:: ipv4bfd_mplste_tail_node_summaries
    
    	Table of summary about IPv4 TE tail BFD sessions for location
    	**type**\:   :py:class:`Ipv4BfdMplsteTailNodeSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfdMplsteTailNodeSummaries>`
    
    .. attribute:: ipv6_multi_hop_counters
    
    	IPv6 multiple hop Counters
    	**type**\:   :py:class:`Ipv6MultiHopCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopCounters>`
    
    .. attribute:: ipv6_multi_hop_multi_paths
    
    	IPv6 multi hop multipath
    	**type**\:   :py:class:`Ipv6MultiHopMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopMultiPaths>`
    
    .. attribute:: ipv6_multi_hop_node_location_summaries
    
    	Table of summary information about BFD IPv6 multihop sessions per location
    	**type**\:   :py:class:`Ipv6MultiHopNodeLocationSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopNodeLocationSummaries>`
    
    .. attribute:: ipv6_multi_hop_session_briefs
    
    	Table of brief information about all IPv6 multihop BFD sessions in the System
    	**type**\:   :py:class:`Ipv6MultiHopSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionBriefs>`
    
    .. attribute:: ipv6_multi_hop_session_details
    
    	Table of detailed information about all IPv6 multihop BFD sessions in the System 
    	**type**\:   :py:class:`Ipv6MultiHopSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails>`
    
    .. attribute:: ipv6_multi_hop_summary
    
    	Summary information of BFD IPv6 multihop sessions
    	**type**\:   :py:class:`Ipv6MultiHopSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSummary>`
    
    .. attribute:: ipv6_single_hop_counters
    
    	IPv6 single hop Counters
    	**type**\:   :py:class:`Ipv6SingleHopCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopCounters>`
    
    .. attribute:: ipv6_single_hop_location_summaries
    
    	Table of summary information about BFD IPv6 singlehop sessions per location
    	**type**\:   :py:class:`Ipv6SingleHopLocationSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopLocationSummaries>`
    
    .. attribute:: ipv6_single_hop_multi_paths
    
    	IPv6 single hop multipath
    	**type**\:   :py:class:`Ipv6SingleHopMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopMultiPaths>`
    
    .. attribute:: ipv6_single_hop_node_location_summaries
    
    	Table of summary information about BFD IPv6 singlehop sessions per location
    	**type**\:   :py:class:`Ipv6SingleHopNodeLocationSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopNodeLocationSummaries>`
    
    .. attribute:: ipv6_single_hop_session_briefs
    
    	Table of brief information about all IPv6 singlehop BFD sessions in the System
    	**type**\:   :py:class:`Ipv6SingleHopSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionBriefs>`
    
    .. attribute:: ipv6_single_hop_session_details
    
    	Table of detailed information about all IPv6 singlehop BFD sessions in the System 
    	**type**\:   :py:class:`Ipv6SingleHopSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails>`
    
    .. attribute:: ipv6_single_hop_summary
    
    	Summary information of BFD IPv6 singlehop sessions
    	**type**\:   :py:class:`Ipv6SingleHopSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSummary>`
    
    .. attribute:: label_counters
    
    	Label Counters
    	**type**\:   :py:class:`LabelCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelCounters>`
    
    .. attribute:: label_multi_paths
    
    	Label multipath
    	**type**\:   :py:class:`LabelMultiPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelMultiPaths>`
    
    .. attribute:: label_session_briefs
    
    	Table of brief information about all Label BFD sessions in the System
    	**type**\:   :py:class:`LabelSessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionBriefs>`
    
    .. attribute:: label_session_details
    
    	Table of detailed information about all Label BFD sessions in the System 
    	**type**\:   :py:class:`LabelSessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails>`
    
    .. attribute:: label_summary
    
    	Summary information of Label BFD
    	**type**\:   :py:class:`LabelSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSummary>`
    
    .. attribute:: label_summary_nodes
    
    	Table of summary about Label BFD sessions for location
    	**type**\:   :py:class:`LabelSummaryNodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSummaryNodes>`
    
    .. attribute:: relation_briefs
    
    	Table of brief information about all BFD relations in the System
    	**type**\:   :py:class:`RelationBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationBriefs>`
    
    .. attribute:: relation_details
    
    	Table of detail information about all BFD relations in the System
    	**type**\:   :py:class:`RelationDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails>`
    
    .. attribute:: session_briefs
    
    	Table of brief information about singlehop IPv4 BFD sessions in the System
    	**type**\:   :py:class:`SessionBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionBriefs>`
    
    .. attribute:: session_details
    
    	Table of detailed information about IPv4 singlehop BFD sessions in the System 
    	**type**\:   :py:class:`SessionDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails>`
    
    .. attribute:: session_mibs
    
    	BFD session MIB database
    	**type**\:   :py:class:`SessionMibs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionMibs>`
    
    .. attribute:: summary
    
    	Summary information of BFD IPv4 singlehop sessions
    	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Summary>`
    
    

    """

    _prefix = 'ip-bfd-oper'
    _revision = '2015-11-09'

    def __init__(self):
        super(Bfd, self).__init__()
        self._top_entity = None

        self.yang_name = "bfd"
        self.yang_parent_name = "Cisco-IOS-XR-ip-bfd-oper"

        self.client_briefs = Bfd.ClientBriefs()
        self.client_briefs.parent = self
        self._children_name_map["client_briefs"] = "client-briefs"
        self._children_yang_names.add("client-briefs")

        self.client_details = Bfd.ClientDetails()
        self.client_details.parent = self
        self._children_name_map["client_details"] = "client-details"
        self._children_yang_names.add("client-details")

        self.counters = Bfd.Counters()
        self.counters.parent = self
        self._children_name_map["counters"] = "counters"
        self._children_yang_names.add("counters")

        self.generic_summaries = Bfd.GenericSummaries()
        self.generic_summaries.parent = self
        self._children_name_map["generic_summaries"] = "generic-summaries"
        self._children_yang_names.add("generic-summaries")

        self.ipv4_multi_hop_counters = Bfd.Ipv4MultiHopCounters()
        self.ipv4_multi_hop_counters.parent = self
        self._children_name_map["ipv4_multi_hop_counters"] = "ipv4-multi-hop-counters"
        self._children_yang_names.add("ipv4-multi-hop-counters")

        self.ipv4_multi_hop_multi_paths = Bfd.Ipv4MultiHopMultiPaths()
        self.ipv4_multi_hop_multi_paths.parent = self
        self._children_name_map["ipv4_multi_hop_multi_paths"] = "ipv4-multi-hop-multi-paths"
        self._children_yang_names.add("ipv4-multi-hop-multi-paths")

        self.ipv4_multi_hop_node_location_summaries = Bfd.Ipv4MultiHopNodeLocationSummaries()
        self.ipv4_multi_hop_node_location_summaries.parent = self
        self._children_name_map["ipv4_multi_hop_node_location_summaries"] = "ipv4-multi-hop-node-location-summaries"
        self._children_yang_names.add("ipv4-multi-hop-node-location-summaries")

        self.ipv4_multi_hop_session_briefs = Bfd.Ipv4MultiHopSessionBriefs()
        self.ipv4_multi_hop_session_briefs.parent = self
        self._children_name_map["ipv4_multi_hop_session_briefs"] = "ipv4-multi-hop-session-briefs"
        self._children_yang_names.add("ipv4-multi-hop-session-briefs")

        self.ipv4_multi_hop_session_details = Bfd.Ipv4MultiHopSessionDetails()
        self.ipv4_multi_hop_session_details.parent = self
        self._children_name_map["ipv4_multi_hop_session_details"] = "ipv4-multi-hop-session-details"
        self._children_yang_names.add("ipv4-multi-hop-session-details")

        self.ipv4_multi_hop_summary = Bfd.Ipv4MultiHopSummary()
        self.ipv4_multi_hop_summary.parent = self
        self._children_name_map["ipv4_multi_hop_summary"] = "ipv4-multi-hop-summary"
        self._children_yang_names.add("ipv4-multi-hop-summary")

        self.ipv4_single_hop_counters = Bfd.Ipv4SingleHopCounters()
        self.ipv4_single_hop_counters.parent = self
        self._children_name_map["ipv4_single_hop_counters"] = "ipv4-single-hop-counters"
        self._children_yang_names.add("ipv4-single-hop-counters")

        self.ipv4_single_hop_location_summaries = Bfd.Ipv4SingleHopLocationSummaries()
        self.ipv4_single_hop_location_summaries.parent = self
        self._children_name_map["ipv4_single_hop_location_summaries"] = "ipv4-single-hop-location-summaries"
        self._children_yang_names.add("ipv4-single-hop-location-summaries")

        self.ipv4_single_hop_multi_paths = Bfd.Ipv4SingleHopMultiPaths()
        self.ipv4_single_hop_multi_paths.parent = self
        self._children_name_map["ipv4_single_hop_multi_paths"] = "ipv4-single-hop-multi-paths"
        self._children_yang_names.add("ipv4-single-hop-multi-paths")

        self.ipv4_single_hop_node_location_summaries = Bfd.Ipv4SingleHopNodeLocationSummaries()
        self.ipv4_single_hop_node_location_summaries.parent = self
        self._children_name_map["ipv4_single_hop_node_location_summaries"] = "ipv4-single-hop-node-location-summaries"
        self._children_yang_names.add("ipv4-single-hop-node-location-summaries")

        self.ipv4_single_hop_session_briefs = Bfd.Ipv4SingleHopSessionBriefs()
        self.ipv4_single_hop_session_briefs.parent = self
        self._children_name_map["ipv4_single_hop_session_briefs"] = "ipv4-single-hop-session-briefs"
        self._children_yang_names.add("ipv4-single-hop-session-briefs")

        self.ipv4_single_hop_session_details = Bfd.Ipv4SingleHopSessionDetails()
        self.ipv4_single_hop_session_details.parent = self
        self._children_name_map["ipv4_single_hop_session_details"] = "ipv4-single-hop-session-details"
        self._children_yang_names.add("ipv4-single-hop-session-details")

        self.ipv4_single_hop_summary = Bfd.Ipv4SingleHopSummary()
        self.ipv4_single_hop_summary.parent = self
        self._children_name_map["ipv4_single_hop_summary"] = "ipv4-single-hop-summary"
        self._children_yang_names.add("ipv4-single-hop-summary")

        self.ipv4bf_do_mplste_head_counters = Bfd.Ipv4BfDoMplsteHeadCounters()
        self.ipv4bf_do_mplste_head_counters.parent = self
        self._children_name_map["ipv4bf_do_mplste_head_counters"] = "ipv4bf-do-mplste-head-counters"
        self._children_yang_names.add("ipv4bf-do-mplste-head-counters")

        self.ipv4bf_do_mplste_head_multi_paths = Bfd.Ipv4BfDoMplsteHeadMultiPaths()
        self.ipv4bf_do_mplste_head_multi_paths.parent = self
        self._children_name_map["ipv4bf_do_mplste_head_multi_paths"] = "ipv4bf-do-mplste-head-multi-paths"
        self._children_yang_names.add("ipv4bf-do-mplste-head-multi-paths")

        self.ipv4bf_do_mplste_head_session_briefs = Bfd.Ipv4BfDoMplsteHeadSessionBriefs()
        self.ipv4bf_do_mplste_head_session_briefs.parent = self
        self._children_name_map["ipv4bf_do_mplste_head_session_briefs"] = "ipv4bf-do-mplste-head-session-briefs"
        self._children_yang_names.add("ipv4bf-do-mplste-head-session-briefs")

        self.ipv4bf_do_mplste_head_session_details = Bfd.Ipv4BfDoMplsteHeadSessionDetails()
        self.ipv4bf_do_mplste_head_session_details.parent = self
        self._children_name_map["ipv4bf_do_mplste_head_session_details"] = "ipv4bf-do-mplste-head-session-details"
        self._children_yang_names.add("ipv4bf-do-mplste-head-session-details")

        self.ipv4bf_do_mplste_head_summary = Bfd.Ipv4BfDoMplsteHeadSummary()
        self.ipv4bf_do_mplste_head_summary.parent = self
        self._children_name_map["ipv4bf_do_mplste_head_summary"] = "ipv4bf-do-mplste-head-summary"
        self._children_yang_names.add("ipv4bf-do-mplste-head-summary")

        self.ipv4bf_do_mplste_tail_counters = Bfd.Ipv4BfDoMplsteTailCounters()
        self.ipv4bf_do_mplste_tail_counters.parent = self
        self._children_name_map["ipv4bf_do_mplste_tail_counters"] = "ipv4bf-do-mplste-tail-counters"
        self._children_yang_names.add("ipv4bf-do-mplste-tail-counters")

        self.ipv4bf_do_mplste_tail_multi_paths = Bfd.Ipv4BfDoMplsteTailMultiPaths()
        self.ipv4bf_do_mplste_tail_multi_paths.parent = self
        self._children_name_map["ipv4bf_do_mplste_tail_multi_paths"] = "ipv4bf-do-mplste-tail-multi-paths"
        self._children_yang_names.add("ipv4bf-do-mplste-tail-multi-paths")

        self.ipv4bf_do_mplste_tail_session_briefs = Bfd.Ipv4BfDoMplsteTailSessionBriefs()
        self.ipv4bf_do_mplste_tail_session_briefs.parent = self
        self._children_name_map["ipv4bf_do_mplste_tail_session_briefs"] = "ipv4bf-do-mplste-tail-session-briefs"
        self._children_yang_names.add("ipv4bf-do-mplste-tail-session-briefs")

        self.ipv4bf_do_mplste_tail_session_details = Bfd.Ipv4BfDoMplsteTailSessionDetails()
        self.ipv4bf_do_mplste_tail_session_details.parent = self
        self._children_name_map["ipv4bf_do_mplste_tail_session_details"] = "ipv4bf-do-mplste-tail-session-details"
        self._children_yang_names.add("ipv4bf-do-mplste-tail-session-details")

        self.ipv4bf_do_mplste_tail_summary = Bfd.Ipv4BfDoMplsteTailSummary()
        self.ipv4bf_do_mplste_tail_summary.parent = self
        self._children_name_map["ipv4bf_do_mplste_tail_summary"] = "ipv4bf-do-mplste-tail-summary"
        self._children_yang_names.add("ipv4bf-do-mplste-tail-summary")

        self.ipv4bfd_mplste_head_summary_nodes = Bfd.Ipv4BfdMplsteHeadSummaryNodes()
        self.ipv4bfd_mplste_head_summary_nodes.parent = self
        self._children_name_map["ipv4bfd_mplste_head_summary_nodes"] = "ipv4bfd-mplste-head-summary-nodes"
        self._children_yang_names.add("ipv4bfd-mplste-head-summary-nodes")

        self.ipv4bfd_mplste_tail_node_summaries = Bfd.Ipv4BfdMplsteTailNodeSummaries()
        self.ipv4bfd_mplste_tail_node_summaries.parent = self
        self._children_name_map["ipv4bfd_mplste_tail_node_summaries"] = "ipv4bfd-mplste-tail-node-summaries"
        self._children_yang_names.add("ipv4bfd-mplste-tail-node-summaries")

        self.ipv6_multi_hop_counters = Bfd.Ipv6MultiHopCounters()
        self.ipv6_multi_hop_counters.parent = self
        self._children_name_map["ipv6_multi_hop_counters"] = "ipv6-multi-hop-counters"
        self._children_yang_names.add("ipv6-multi-hop-counters")

        self.ipv6_multi_hop_multi_paths = Bfd.Ipv6MultiHopMultiPaths()
        self.ipv6_multi_hop_multi_paths.parent = self
        self._children_name_map["ipv6_multi_hop_multi_paths"] = "ipv6-multi-hop-multi-paths"
        self._children_yang_names.add("ipv6-multi-hop-multi-paths")

        self.ipv6_multi_hop_node_location_summaries = Bfd.Ipv6MultiHopNodeLocationSummaries()
        self.ipv6_multi_hop_node_location_summaries.parent = self
        self._children_name_map["ipv6_multi_hop_node_location_summaries"] = "ipv6-multi-hop-node-location-summaries"
        self._children_yang_names.add("ipv6-multi-hop-node-location-summaries")

        self.ipv6_multi_hop_session_briefs = Bfd.Ipv6MultiHopSessionBriefs()
        self.ipv6_multi_hop_session_briefs.parent = self
        self._children_name_map["ipv6_multi_hop_session_briefs"] = "ipv6-multi-hop-session-briefs"
        self._children_yang_names.add("ipv6-multi-hop-session-briefs")

        self.ipv6_multi_hop_session_details = Bfd.Ipv6MultiHopSessionDetails()
        self.ipv6_multi_hop_session_details.parent = self
        self._children_name_map["ipv6_multi_hop_session_details"] = "ipv6-multi-hop-session-details"
        self._children_yang_names.add("ipv6-multi-hop-session-details")

        self.ipv6_multi_hop_summary = Bfd.Ipv6MultiHopSummary()
        self.ipv6_multi_hop_summary.parent = self
        self._children_name_map["ipv6_multi_hop_summary"] = "ipv6-multi-hop-summary"
        self._children_yang_names.add("ipv6-multi-hop-summary")

        self.ipv6_single_hop_counters = Bfd.Ipv6SingleHopCounters()
        self.ipv6_single_hop_counters.parent = self
        self._children_name_map["ipv6_single_hop_counters"] = "ipv6-single-hop-counters"
        self._children_yang_names.add("ipv6-single-hop-counters")

        self.ipv6_single_hop_location_summaries = Bfd.Ipv6SingleHopLocationSummaries()
        self.ipv6_single_hop_location_summaries.parent = self
        self._children_name_map["ipv6_single_hop_location_summaries"] = "ipv6-single-hop-location-summaries"
        self._children_yang_names.add("ipv6-single-hop-location-summaries")

        self.ipv6_single_hop_multi_paths = Bfd.Ipv6SingleHopMultiPaths()
        self.ipv6_single_hop_multi_paths.parent = self
        self._children_name_map["ipv6_single_hop_multi_paths"] = "ipv6-single-hop-multi-paths"
        self._children_yang_names.add("ipv6-single-hop-multi-paths")

        self.ipv6_single_hop_node_location_summaries = Bfd.Ipv6SingleHopNodeLocationSummaries()
        self.ipv6_single_hop_node_location_summaries.parent = self
        self._children_name_map["ipv6_single_hop_node_location_summaries"] = "ipv6-single-hop-node-location-summaries"
        self._children_yang_names.add("ipv6-single-hop-node-location-summaries")

        self.ipv6_single_hop_session_briefs = Bfd.Ipv6SingleHopSessionBriefs()
        self.ipv6_single_hop_session_briefs.parent = self
        self._children_name_map["ipv6_single_hop_session_briefs"] = "ipv6-single-hop-session-briefs"
        self._children_yang_names.add("ipv6-single-hop-session-briefs")

        self.ipv6_single_hop_session_details = Bfd.Ipv6SingleHopSessionDetails()
        self.ipv6_single_hop_session_details.parent = self
        self._children_name_map["ipv6_single_hop_session_details"] = "ipv6-single-hop-session-details"
        self._children_yang_names.add("ipv6-single-hop-session-details")

        self.ipv6_single_hop_summary = Bfd.Ipv6SingleHopSummary()
        self.ipv6_single_hop_summary.parent = self
        self._children_name_map["ipv6_single_hop_summary"] = "ipv6-single-hop-summary"
        self._children_yang_names.add("ipv6-single-hop-summary")

        self.label_counters = Bfd.LabelCounters()
        self.label_counters.parent = self
        self._children_name_map["label_counters"] = "label-counters"
        self._children_yang_names.add("label-counters")

        self.label_multi_paths = Bfd.LabelMultiPaths()
        self.label_multi_paths.parent = self
        self._children_name_map["label_multi_paths"] = "label-multi-paths"
        self._children_yang_names.add("label-multi-paths")

        self.label_session_briefs = Bfd.LabelSessionBriefs()
        self.label_session_briefs.parent = self
        self._children_name_map["label_session_briefs"] = "label-session-briefs"
        self._children_yang_names.add("label-session-briefs")

        self.label_session_details = Bfd.LabelSessionDetails()
        self.label_session_details.parent = self
        self._children_name_map["label_session_details"] = "label-session-details"
        self._children_yang_names.add("label-session-details")

        self.label_summary = Bfd.LabelSummary()
        self.label_summary.parent = self
        self._children_name_map["label_summary"] = "label-summary"
        self._children_yang_names.add("label-summary")

        self.label_summary_nodes = Bfd.LabelSummaryNodes()
        self.label_summary_nodes.parent = self
        self._children_name_map["label_summary_nodes"] = "label-summary-nodes"
        self._children_yang_names.add("label-summary-nodes")

        self.relation_briefs = Bfd.RelationBriefs()
        self.relation_briefs.parent = self
        self._children_name_map["relation_briefs"] = "relation-briefs"
        self._children_yang_names.add("relation-briefs")

        self.relation_details = Bfd.RelationDetails()
        self.relation_details.parent = self
        self._children_name_map["relation_details"] = "relation-details"
        self._children_yang_names.add("relation-details")

        self.session_briefs = Bfd.SessionBriefs()
        self.session_briefs.parent = self
        self._children_name_map["session_briefs"] = "session-briefs"
        self._children_yang_names.add("session-briefs")

        self.session_details = Bfd.SessionDetails()
        self.session_details.parent = self
        self._children_name_map["session_details"] = "session-details"
        self._children_yang_names.add("session-details")

        self.session_mibs = Bfd.SessionMibs()
        self.session_mibs.parent = self
        self._children_name_map["session_mibs"] = "session-mibs"
        self._children_yang_names.add("session-mibs")

        self.summary = Bfd.Summary()
        self.summary.parent = self
        self._children_name_map["summary"] = "summary"
        self._children_yang_names.add("summary")


    class LabelSessionBriefs(Entity):
        """
        Table of brief information about all Label BFD
        sessions in the System
        
        .. attribute:: label_session_brief
        
        	Brief information for a single Label BFD session
        	**type**\: list of    :py:class:`LabelSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionBriefs.LabelSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.LabelSessionBriefs, self).__init__()

            self.yang_name = "label-session-briefs"
            self.yang_parent_name = "bfd"

            self.label_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.LabelSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.LabelSessionBriefs, self).__setattr__(name, value)


        class LabelSessionBrief(Entity):
            """
            Brief information for a single Label BFD
            session
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.LabelSessionBriefs.LabelSessionBrief, self).__init__()

                self.yang_name = "label-session-brief"
                self.yang_parent_name = "label-session-briefs"

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.state = YLeaf(YType.enumeration, "state")

                self.status_brief_information = Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("incoming_label",
                                "interface_name",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.LabelSessionBriefs.LabelSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.LabelSessionBriefs.LabelSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "label-session-brief"

                    self.async_interval_multiplier = Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/label-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/label-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/label-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.incoming_label.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.state.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.LabelSessionBriefs.LabelSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "incoming-label" or name == "interface-name" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.label_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.label_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "label-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "label-session-brief"):
                for c in self.label_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.LabelSessionBriefs.LabelSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.label_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "label-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteTailSummary(Entity):
        """
        Summary information of IPv4 BFD over MPLS\-TE
        Tail
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteTailSummary, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-tail-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Ipv4BfDoMplsteTailSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteTailSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "ipv4bf-do-mplste-tail-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteTailSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteTailSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-tail-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Ipv4BfDoMplsteTailSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopCounters(Entity):
        """
        IPv6 single hop Counters
        
        .. attribute:: ipv6_single_hop_packet_counters
        
        	Table of IPv6 single hop Packet counters
        	**type**\:   :py:class:`Ipv6SingleHopPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopCounters, self).__init__()

            self.yang_name = "ipv6-single-hop-counters"
            self.yang_parent_name = "bfd"

            self.ipv6_single_hop_packet_counters = Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters()
            self.ipv6_single_hop_packet_counters.parent = self
            self._children_name_map["ipv6_single_hop_packet_counters"] = "ipv6-single-hop-packet-counters"
            self._children_yang_names.add("ipv6-single-hop-packet-counters")


        class Ipv6SingleHopPacketCounters(Entity):
            """
            Table of IPv6 single hop Packet counters
            
            .. attribute:: ipv6_single_hop_packet_counter
            
            	Interface IPv6 single hop Packet counters
            	**type**\: list of    :py:class:`Ipv6SingleHopPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters.Ipv6SingleHopPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters, self).__init__()

                self.yang_name = "ipv6-single-hop-packet-counters"
                self.yang_parent_name = "ipv6-single-hop-counters"

                self.ipv6_single_hop_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters, self).__setattr__(name, value)


            class Ipv6SingleHopPacketCounter(Entity):
                """
                Interface IPv6 single hop Packet counters
                
                .. attribute:: interface_name  <key>
                
                	Interface Name
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters.Ipv6SingleHopPacketCounter, self).__init__()

                    self.yang_name = "ipv6-single-hop-packet-counter"
                    self.yang_parent_name = "ipv6-single-hop-packet-counters"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters.Ipv6SingleHopPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters.Ipv6SingleHopPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv6-single-hop-packet-counter" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-counters/ipv6-single-hop-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv6_single_hop_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ipv6_single_hop_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-single-hop-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv6-single-hop-packet-counter"):
                    for c in self.ipv6_single_hop_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters.Ipv6SingleHopPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv6_single_hop_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv6-single-hop-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.ipv6_single_hop_packet_counters is not None and self.ipv6_single_hop_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv6_single_hop_packet_counters is not None and self.ipv6_single_hop_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-single-hop-packet-counters"):
                if (self.ipv6_single_hop_packet_counters is None):
                    self.ipv6_single_hop_packet_counters = Bfd.Ipv6SingleHopCounters.Ipv6SingleHopPacketCounters()
                    self.ipv6_single_hop_packet_counters.parent = self
                    self._children_name_map["ipv6_single_hop_packet_counters"] = "ipv6-single-hop-packet-counters"
                return self.ipv6_single_hop_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-single-hop-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Counters(Entity):
        """
        Counters
        
        .. attribute:: packet_counters
        
        	Table of Packet counters
        	**type**\:   :py:class:`PacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Counters.PacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Counters, self).__init__()

            self.yang_name = "counters"
            self.yang_parent_name = "bfd"

            self.packet_counters = Bfd.Counters.PacketCounters()
            self.packet_counters.parent = self
            self._children_name_map["packet_counters"] = "packet-counters"
            self._children_yang_names.add("packet-counters")


        class PacketCounters(Entity):
            """
            Table of Packet counters
            
            .. attribute:: packet_counter
            
            	Interface Packet counters
            	**type**\: list of    :py:class:`PacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Counters.PacketCounters.PacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Counters.PacketCounters, self).__init__()

                self.yang_name = "packet-counters"
                self.yang_parent_name = "counters"

                self.packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Counters.PacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Counters.PacketCounters, self).__setattr__(name, value)


            class PacketCounter(Entity):
                """
                Interface Packet counters
                
                .. attribute:: interface_name  <key>
                
                	Interface Name
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Counters.PacketCounters.PacketCounter, self).__init__()

                    self.yang_name = "packet-counter"
                    self.yang_parent_name = "packet-counters"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Counters.PacketCounters.PacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Counters.PacketCounters.PacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "packet-counter" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/counters/packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "packet-counter"):
                    for c in self.packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Counters.PacketCounters.PacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.packet_counters is not None and self.packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.packet_counters is not None and self.packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "packet-counters"):
                if (self.packet_counters is None):
                    self.packet_counters = Bfd.Counters.PacketCounters()
                    self.packet_counters.parent = self
                    self._children_name_map["packet_counters"] = "packet-counters"
                return self.packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class ClientDetails(Entity):
        """
        Table of detailed information about BFD clients
        
        .. attribute:: client_detail
        
        	Detailed information of client
        	**type**\: list of    :py:class:`ClientDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.ClientDetails.ClientDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.ClientDetails, self).__init__()

            self.yang_name = "client-details"
            self.yang_parent_name = "bfd"

            self.client_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.ClientDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.ClientDetails, self).__setattr__(name, value)


        class ClientDetail(Entity):
            """
            Detailed information of client
            
            .. attribute:: client_name  <key>
            
            	Client Name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: brief
            
            	Brief client information
            	**type**\:   :py:class:`Brief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.ClientDetails.ClientDetail.Brief>`
            
            .. attribute:: flags
            
            	The BFD Client Flags
            	**type**\:   :py:class:`Flags <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.ClientDetails.ClientDetail.Flags>`
            
            .. attribute:: recreate_time
            
            	Recreate Time in Seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: second
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.ClientDetails.ClientDetail, self).__init__()

                self.yang_name = "client-detail"
                self.yang_parent_name = "client-details"

                self.client_name = YLeaf(YType.str, "client-name")

                self.recreate_time = YLeaf(YType.uint32, "recreate-time")

                self.brief = Bfd.ClientDetails.ClientDetail.Brief()
                self.brief.parent = self
                self._children_name_map["brief"] = "brief"
                self._children_yang_names.add("brief")

                self.flags = Bfd.ClientDetails.ClientDetail.Flags()
                self.flags.parent = self
                self._children_name_map["flags"] = "flags"
                self._children_yang_names.add("flags")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("client_name",
                                "recreate_time") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.ClientDetails.ClientDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.ClientDetails.ClientDetail, self).__setattr__(name, value)


            class Brief(Entity):
                """
                Brief client information
                
                .. attribute:: name_xr
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                .. attribute:: node_id
                
                	Location where client resides
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: session_count
                
                	Number of sessions created by this client
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.ClientDetails.ClientDetail.Brief, self).__init__()

                    self.yang_name = "brief"
                    self.yang_parent_name = "client-detail"

                    self.name_xr = YLeaf(YType.str, "name-xr")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.session_count = YLeaf(YType.uint32, "session-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("name_xr",
                                    "node_id",
                                    "session_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.ClientDetails.ClientDetail.Brief, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.ClientDetails.ClientDetail.Brief, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.name_xr.is_set or
                        self.node_id.is_set or
                        self.session_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.name_xr.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.session_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "brief" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.name_xr.is_set or self.name_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name_xr.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.session_count.is_set or self.session_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "name-xr" or name == "node-id" or name == "session-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "name-xr"):
                        self.name_xr = value
                        self.name_xr.value_namespace = name_space
                        self.name_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-count"):
                        self.session_count = value
                        self.session_count.value_namespace = name_space
                        self.session_count.value_namespace_prefix = name_space_prefix


            class Flags(Entity):
                """
                The BFD Client Flags
                
                .. attribute:: is_recreate_state
                
                	Client is in Recreate State
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: is_zombie_state
                
                	Client is in Zombie State
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.ClientDetails.ClientDetail.Flags, self).__init__()

                    self.yang_name = "flags"
                    self.yang_parent_name = "client-detail"

                    self.is_recreate_state = YLeaf(YType.int32, "is-recreate-state")

                    self.is_zombie_state = YLeaf(YType.int32, "is-zombie-state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("is_recreate_state",
                                    "is_zombie_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.ClientDetails.ClientDetail.Flags, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.ClientDetails.ClientDetail.Flags, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.is_recreate_state.is_set or
                        self.is_zombie_state.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.is_recreate_state.yfilter != YFilter.not_set or
                        self.is_zombie_state.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "flags" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.is_recreate_state.is_set or self.is_recreate_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_recreate_state.get_name_leafdata())
                    if (self.is_zombie_state.is_set or self.is_zombie_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_zombie_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "is-recreate-state" or name == "is-zombie-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "is-recreate-state"):
                        self.is_recreate_state = value
                        self.is_recreate_state.value_namespace = name_space
                        self.is_recreate_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-zombie-state"):
                        self.is_zombie_state = value
                        self.is_zombie_state.value_namespace = name_space
                        self.is_zombie_state.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.client_name.is_set or
                    self.recreate_time.is_set or
                    (self.brief is not None and self.brief.has_data()) or
                    (self.flags is not None and self.flags.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.client_name.yfilter != YFilter.not_set or
                    self.recreate_time.yfilter != YFilter.not_set or
                    (self.brief is not None and self.brief.has_operation()) or
                    (self.flags is not None and self.flags.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "client-detail" + "[client-name='" + self.client_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/client-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.client_name.is_set or self.client_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.client_name.get_name_leafdata())
                if (self.recreate_time.is_set or self.recreate_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.recreate_time.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "brief"):
                    if (self.brief is None):
                        self.brief = Bfd.ClientDetails.ClientDetail.Brief()
                        self.brief.parent = self
                        self._children_name_map["brief"] = "brief"
                    return self.brief

                if (child_yang_name == "flags"):
                    if (self.flags is None):
                        self.flags = Bfd.ClientDetails.ClientDetail.Flags()
                        self.flags.parent = self
                        self._children_name_map["flags"] = "flags"
                    return self.flags

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "brief" or name == "flags" or name == "client-name" or name == "recreate-time"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "client-name"):
                    self.client_name = value
                    self.client_name.value_namespace = name_space
                    self.client_name.value_namespace_prefix = name_space_prefix
                if(value_path == "recreate-time"):
                    self.recreate_time = value
                    self.recreate_time.value_namespace = name_space
                    self.recreate_time.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.client_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.client_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "client-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "client-detail"):
                for c in self.client_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.ClientDetails.ClientDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.client_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "client-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopSummary(Entity):
        """
        Summary information of BFD IPv4 singlehop
        sessions
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopSummary, self).__init__()

            self.yang_name = "ipv4-single-hop-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Ipv4SingleHopSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "ipv4-single-hop-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Ipv4SingleHopSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopSummary(Entity):
        """
        Summary information of BFD IPv6 singlehop
        sessions
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopSummary, self).__init__()

            self.yang_name = "ipv6-single-hop-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Ipv6SingleHopSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "ipv6-single-hop-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Ipv6SingleHopSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LabelMultiPaths(Entity):
        """
        Label multipath
        
        .. attribute:: label_multi_path
        
        	Label multipath table
        	**type**\: list of    :py:class:`LabelMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelMultiPaths.LabelMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.LabelMultiPaths, self).__init__()

            self.yang_name = "label-multi-paths"
            self.yang_parent_name = "bfd"

            self.label_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.LabelMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.LabelMultiPaths, self).__setattr__(name, value)


        class LabelMultiPath(Entity):
            """
            Label multipath table
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.LabelMultiPaths.LabelMultiPath, self).__init__()

                self.yang_name = "label-multi-path"
                self.yang_parent_name = "label-multi-paths"

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.state = YLeaf(YType.enumeration, "state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("incoming_label",
                                "incoming_label_xr",
                                "interface_name",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.LabelMultiPaths.LabelMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.LabelMultiPaths.LabelMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.incoming_label.is_set or
                    self.incoming_label_xr.is_set or
                    self.interface_name.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.state.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "incoming-label" or name == "incoming-label-xr" or name == "interface-name" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.label_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.label_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "label-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "label-multi-path"):
                for c in self.label_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.LabelMultiPaths.LabelMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.label_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "label-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4MultiHopSessionDetails(Entity):
        """
        Table of detailed information about all IPv4
        multihop BFD sessions in the System 
        
        .. attribute:: ipv4_multi_hop_session_detail
        
        	Detailed information for a single IPv4 multihop BFD session
        	**type**\: list of    :py:class:`Ipv4MultiHopSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4MultiHopSessionDetails, self).__init__()

            self.yang_name = "ipv4-multi-hop-session-details"
            self.yang_parent_name = "bfd"

            self.ipv4_multi_hop_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4MultiHopSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4MultiHopSessionDetails, self).__setattr__(name, value)


        class Ipv4MultiHopSessionDetail(Entity):
            """
            Detailed information for a single IPv4 multihop
            BFD session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation>`
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.OwnerInformation>`
            
            .. attribute:: source_address
            
            	Source Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail, self).__init__()

                self.yang_name = "ipv4-multi-hop-session-detail"
                self.yang_parent_name = "ipv4-multi-hop-session-details"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.location = YLeaf(YType.str, "location")

                self.source_address = YLeaf(YType.str, "source-address")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.lsp_ping_info = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "location",
                                "source_address",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "ipv4-multi-hop-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "ipv4-multi-hop-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "ipv4-multi-hop-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "ipv4-multi-hop-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "ipv4-multi-hop-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.location.is_set or
                    self.source_address.is_set or
                    self.vrf_name.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.source_address.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-multi-hop-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_address.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "destination-address" or name == "location" or name == "source-address" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "source-address"):
                    self.source_address = value
                    self.source_address.value_namespace = name_space
                    self.source_address.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_multi_hop_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_multi_hop_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-multi-hop-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-multi-hop-session-detail"):
                for c in self.ipv4_multi_hop_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4MultiHopSessionDetails.Ipv4MultiHopSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_multi_hop_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-multi-hop-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopSessionDetails(Entity):
        """
        Table of detailed information about all IPv4
        singlehop BFD sessions in the System 
        
        .. attribute:: ipv4_single_hop_session_detail
        
        	Detailed information for a single IPv4 singlehop BFD session
        	**type**\: list of    :py:class:`Ipv4SingleHopSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopSessionDetails, self).__init__()

            self.yang_name = "ipv4-single-hop-session-details"
            self.yang_parent_name = "bfd"

            self.ipv4_single_hop_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4SingleHopSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4SingleHopSessionDetails, self).__setattr__(name, value)


        class Ipv4SingleHopSessionDetail(Entity):
            """
            Detailed information for a single IPv4
            singlehop BFD session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation>`
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.OwnerInformation>`
            
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail, self).__init__()

                self.yang_name = "ipv4-single-hop-session-detail"
                self.yang_parent_name = "ipv4-single-hop-session-details"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.lsp_ping_info = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "ipv4-single-hop-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "ipv4-single-hop-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "ipv4-single-hop-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "ipv4-single-hop-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "ipv4-single-hop-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-single-hop-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "destination-address" or name == "interface-name" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_single_hop_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_single_hop_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-single-hop-session-detail"):
                for c in self.ipv4_single_hop_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4SingleHopSessionDetails.Ipv4SingleHopSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_single_hop_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-single-hop-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4MultiHopSessionBriefs(Entity):
        """
        Table of brief information about all IPv4
        multihop BFD sessions in the System
        
        .. attribute:: ipv4_multi_hop_session_brief
        
        	Brief information for a single IPv4 multihop BFD session
        	**type**\: list of    :py:class:`Ipv4MultiHopSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4MultiHopSessionBriefs, self).__init__()

            self.yang_name = "ipv4-multi-hop-session-briefs"
            self.yang_parent_name = "bfd"

            self.ipv4_multi_hop_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4MultiHopSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4MultiHopSessionBriefs, self).__setattr__(name, value)


        class Ipv4MultiHopSessionBrief(Entity):
            """
            Brief information for a single IPv4 multihop
            BFD session
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: source_address
            
            	Source Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief, self).__init__()

                self.yang_name = "ipv4-multi-hop-session-brief"
                self.yang_parent_name = "ipv4-multi-hop-session-briefs"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.source_address = YLeaf(YType.str, "source-address")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.status_brief_information = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "source_address",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "ipv4-multi-hop-session-brief"

                    self.async_interval_multiplier = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/ipv4-multi-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/ipv4-multi-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/ipv4-multi-hop-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.source_address.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.source_address.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-multi-hop-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_address.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "destination-address" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "source-address" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "source-address"):
                    self.source_address = value
                    self.source_address.value_namespace = name_space
                    self.source_address.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_multi_hop_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_multi_hop_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-multi-hop-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-multi-hop-session-brief"):
                for c in self.ipv4_multi_hop_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4MultiHopSessionBriefs.Ipv4MultiHopSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_multi_hop_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-multi-hop-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class GenericSummaries(Entity):
        """
        Generic summary information about BFD location
        
        .. attribute:: generic_summary
        
        	Generic summary information for bfd location table
        	**type**\: list of    :py:class:`GenericSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.GenericSummaries.GenericSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.GenericSummaries, self).__init__()

            self.yang_name = "generic-summaries"
            self.yang_parent_name = "bfd"

            self.generic_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.GenericSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.GenericSummaries, self).__setattr__(name, value)


        class GenericSummary(Entity):
            """
            Generic summary information for bfd location
            table
            
            .. attribute:: location  <key>
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: max_session_number
            
            	Max Session Number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: mp_session_number
            
            	MP Session Number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_id
            
            	Node ID
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: pps_allocated_value
            
            	Allocated PPS value
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: pps_max_value
            
            	Max PPS value
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ppsmp_allocated_value
            
            	Allocated MP PPS value
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ppsmp_max_value
            
            	Max MP PPS value
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_session_number
            
            	Total Session Number
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.GenericSummaries.GenericSummary, self).__init__()

                self.yang_name = "generic-summary"
                self.yang_parent_name = "generic-summaries"

                self.location = YLeaf(YType.str, "location")

                self.max_session_number = YLeaf(YType.uint32, "max-session-number")

                self.mp_session_number = YLeaf(YType.uint32, "mp-session-number")

                self.node_id = YLeaf(YType.str, "node-id")

                self.pps_allocated_value = YLeaf(YType.uint32, "pps-allocated-value")

                self.pps_max_value = YLeaf(YType.uint32, "pps-max-value")

                self.ppsmp_allocated_value = YLeaf(YType.uint32, "ppsmp-allocated-value")

                self.ppsmp_max_value = YLeaf(YType.uint32, "ppsmp-max-value")

                self.total_session_number = YLeaf(YType.uint32, "total-session-number")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location",
                                "max_session_number",
                                "mp_session_number",
                                "node_id",
                                "pps_allocated_value",
                                "pps_max_value",
                                "ppsmp_allocated_value",
                                "ppsmp_max_value",
                                "total_session_number") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.GenericSummaries.GenericSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.GenericSummaries.GenericSummary, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.location.is_set or
                    self.max_session_number.is_set or
                    self.mp_session_number.is_set or
                    self.node_id.is_set or
                    self.pps_allocated_value.is_set or
                    self.pps_max_value.is_set or
                    self.ppsmp_allocated_value.is_set or
                    self.ppsmp_max_value.is_set or
                    self.total_session_number.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.max_session_number.yfilter != YFilter.not_set or
                    self.mp_session_number.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.pps_allocated_value.yfilter != YFilter.not_set or
                    self.pps_max_value.yfilter != YFilter.not_set or
                    self.ppsmp_allocated_value.yfilter != YFilter.not_set or
                    self.ppsmp_max_value.yfilter != YFilter.not_set or
                    self.total_session_number.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "generic-summary" + "[location='" + self.location.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/generic-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.max_session_number.is_set or self.max_session_number.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_session_number.get_name_leafdata())
                if (self.mp_session_number.is_set or self.mp_session_number.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.mp_session_number.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.pps_allocated_value.is_set or self.pps_allocated_value.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pps_allocated_value.get_name_leafdata())
                if (self.pps_max_value.is_set or self.pps_max_value.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pps_max_value.get_name_leafdata())
                if (self.ppsmp_allocated_value.is_set or self.ppsmp_allocated_value.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ppsmp_allocated_value.get_name_leafdata())
                if (self.ppsmp_max_value.is_set or self.ppsmp_max_value.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ppsmp_max_value.get_name_leafdata())
                if (self.total_session_number.is_set or self.total_session_number.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_session_number.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "location" or name == "max-session-number" or name == "mp-session-number" or name == "node-id" or name == "pps-allocated-value" or name == "pps-max-value" or name == "ppsmp-allocated-value" or name == "ppsmp-max-value" or name == "total-session-number"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "max-session-number"):
                    self.max_session_number = value
                    self.max_session_number.value_namespace = name_space
                    self.max_session_number.value_namespace_prefix = name_space_prefix
                if(value_path == "mp-session-number"):
                    self.mp_session_number = value
                    self.mp_session_number.value_namespace = name_space
                    self.mp_session_number.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "pps-allocated-value"):
                    self.pps_allocated_value = value
                    self.pps_allocated_value.value_namespace = name_space
                    self.pps_allocated_value.value_namespace_prefix = name_space_prefix
                if(value_path == "pps-max-value"):
                    self.pps_max_value = value
                    self.pps_max_value.value_namespace = name_space
                    self.pps_max_value.value_namespace_prefix = name_space_prefix
                if(value_path == "ppsmp-allocated-value"):
                    self.ppsmp_allocated_value = value
                    self.ppsmp_allocated_value.value_namespace = name_space
                    self.ppsmp_allocated_value.value_namespace_prefix = name_space_prefix
                if(value_path == "ppsmp-max-value"):
                    self.ppsmp_max_value = value
                    self.ppsmp_max_value.value_namespace = name_space
                    self.ppsmp_max_value.value_namespace_prefix = name_space_prefix
                if(value_path == "total-session-number"):
                    self.total_session_number = value
                    self.total_session_number.value_namespace = name_space
                    self.total_session_number.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.generic_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.generic_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "generic-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "generic-summary"):
                for c in self.generic_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.GenericSummaries.GenericSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.generic_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "generic-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopMultiPaths(Entity):
        """
        IPv6 single hop multipath
        
        .. attribute:: ipv6_single_hop_multi_path
        
        	IPv6 single hop multipath table
        	**type**\: list of    :py:class:`Ipv6SingleHopMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopMultiPaths.Ipv6SingleHopMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopMultiPaths, self).__init__()

            self.yang_name = "ipv6-single-hop-multi-paths"
            self.yang_parent_name = "bfd"

            self.ipv6_single_hop_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6SingleHopMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6SingleHopMultiPaths, self).__setattr__(name, value)


        class Ipv6SingleHopMultiPath(Entity):
            """
            IPv6 single hop multipath table
            
            .. attribute:: destination_address
            
            	Destination address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopMultiPaths.Ipv6SingleHopMultiPath, self).__init__()

                self.yang_name = "ipv6-single-hop-multi-path"
                self.yang_parent_name = "ipv6-single-hop-multi-paths"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.state = YLeaf(YType.enumeration, "state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "incoming_label_xr",
                                "interface_name",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopMultiPaths.Ipv6SingleHopMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopMultiPaths.Ipv6SingleHopMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.incoming_label_xr.is_set or
                    self.interface_name.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.state.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-single-hop-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "destination-address" or name == "incoming-label-xr" or name == "interface-name" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_single_hop_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_single_hop_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-single-hop-multi-path"):
                for c in self.ipv6_single_hop_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6SingleHopMultiPaths.Ipv6SingleHopMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_single_hop_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-single-hop-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopNodeLocationSummaries(Entity):
        """
        Table of summary information about BFD IPv4
        singlehop sessions per location
        
        .. attribute:: ipv4_single_hop_node_location_summary
        
        	Summary information for BFD IPv4 singlehop sessions for location
        	**type**\: list of    :py:class:`Ipv4SingleHopNodeLocationSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopNodeLocationSummaries, self).__init__()

            self.yang_name = "ipv4-single-hop-node-location-summaries"
            self.yang_parent_name = "bfd"

            self.ipv4_single_hop_node_location_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4SingleHopNodeLocationSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4SingleHopNodeLocationSummaries, self).__setattr__(name, value)


        class Ipv4SingleHopNodeLocationSummary(Entity):
            """
            Summary information for BFD IPv4 singlehop
            sessions for location
            
            .. attribute:: location  <key>
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary, self).__init__()

                self.yang_name = "ipv4-single-hop-node-location-summary"
                self.yang_parent_name = "ipv4-single-hop-node-location-summaries"

                self.location = YLeaf(YType.str, "location")

                self.session_state = Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv4-single-hop-node-location-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-single-hop-node-location-summary" + "[location='" + self.location.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-node-location-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_single_hop_node_location_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_single_hop_node_location_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-node-location-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-single-hop-node-location-summary"):
                for c in self.ipv4_single_hop_node_location_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4SingleHopNodeLocationSummaries.Ipv4SingleHopNodeLocationSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_single_hop_node_location_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-single-hop-node-location-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LabelSummary(Entity):
        """
        Summary information of Label BFD
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.LabelSummary, self).__init__()

            self.yang_name = "label-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.LabelSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.LabelSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "label-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.LabelSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.LabelSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "label-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.LabelSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteHeadSessionBriefs(Entity):
        """
        Table of brief information about all IPv4 BFD
        over MPLS\-TE Head sessions in the System
        
        .. attribute:: ipv4bf_do_mplste_head_session_brief
        
        	Brief information for a single IPv4 BFD over MPLS\-TE Head session
        	**type**\: list of    :py:class:`Ipv4BfDoMplsteHeadSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-head-session-briefs"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_head_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs, self).__setattr__(name, value)


        class Ipv4BfDoMplsteHeadSessionBrief(Entity):
            """
            Brief information for a single IPv4 BFD over
            MPLS\-TE Head session
            
            .. attribute:: fe_ctype
            
            	FEC Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_ctype
            
            	FEC C Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_destination
            
            	FEC Destination
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_extended_tunnel_id
            
            	FEC Extended Tunnel ID
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_source
            
            	FEC Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_subgroup_id
            
            	FEC Subgroup ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_subgroup_originator
            
            	FEC Subgroup originator
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_tunnel_id
            
            	FEC Tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: feclspid
            
            	FEC LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fecp2mpid
            
            	FEC P2MP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-head-session-brief"
                self.yang_parent_name = "ipv4bf-do-mplste-head-session-briefs"

                self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                self.fec_destination = YLeaf(YType.str, "fec-destination")

                self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                self.fec_source = YLeaf(YType.str, "fec-source")

                self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                self.feclspid = YLeaf(YType.int32, "feclspid")

                self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.status_brief_information = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("fe_ctype",
                                "fec_ctype",
                                "fec_destination",
                                "fec_extended_tunnel_id",
                                "fec_source",
                                "fec_subgroup_id",
                                "fec_subgroup_originator",
                                "fec_tunnel_id",
                                "feclspid",
                                "fecp2mpid",
                                "incoming_label",
                                "interface_name",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-session-brief"

                    self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/ipv4bf-do-mplste-head-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/ipv4bf-do-mplste-head-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/ipv4bf-do-mplste-head-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.fe_ctype.is_set or
                    self.fec_ctype.is_set or
                    self.fec_destination.is_set or
                    self.fec_extended_tunnel_id.is_set or
                    self.fec_source.is_set or
                    self.fec_subgroup_id.is_set or
                    self.fec_subgroup_originator.is_set or
                    self.fec_tunnel_id.is_set or
                    self.feclspid.is_set or
                    self.fecp2mpid.is_set or
                    self.incoming_label.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.fe_ctype.yfilter != YFilter.not_set or
                    self.fec_ctype.yfilter != YFilter.not_set or
                    self.fec_destination.yfilter != YFilter.not_set or
                    self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                    self.fec_source.yfilter != YFilter.not_set or
                    self.fec_subgroup_id.yfilter != YFilter.not_set or
                    self.fec_subgroup_originator.yfilter != YFilter.not_set or
                    self.fec_tunnel_id.yfilter != YFilter.not_set or
                    self.feclspid.yfilter != YFilter.not_set or
                    self.fecp2mpid.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-head-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_destination.get_name_leafdata())
                if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_source.get_name_leafdata())
                if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.feclspid.get_name_leafdata())
                if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "incoming-label" or name == "interface-name" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "fe-ctype"):
                    self.fe_ctype = value
                    self.fe_ctype.value_namespace = name_space
                    self.fe_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-ctype"):
                    self.fec_ctype = value
                    self.fec_ctype.value_namespace = name_space
                    self.fec_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-destination"):
                    self.fec_destination = value
                    self.fec_destination.value_namespace = name_space
                    self.fec_destination.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-extended-tunnel-id"):
                    self.fec_extended_tunnel_id = value
                    self.fec_extended_tunnel_id.value_namespace = name_space
                    self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-source"):
                    self.fec_source = value
                    self.fec_source.value_namespace = name_space
                    self.fec_source.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-id"):
                    self.fec_subgroup_id = value
                    self.fec_subgroup_id.value_namespace = name_space
                    self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-originator"):
                    self.fec_subgroup_originator = value
                    self.fec_subgroup_originator.value_namespace = name_space
                    self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-tunnel-id"):
                    self.fec_tunnel_id = value
                    self.fec_tunnel_id.value_namespace = name_space
                    self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "feclspid"):
                    self.feclspid = value
                    self.feclspid.value_namespace = name_space
                    self.feclspid.value_namespace_prefix = name_space_prefix
                if(value_path == "fecp2mpid"):
                    self.fecp2mpid = value
                    self.fecp2mpid.value_namespace = name_space
                    self.fecp2mpid.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bf_do_mplste_head_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bf_do_mplste_head_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-head-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-head-session-brief"):
                for c in self.ipv4bf_do_mplste_head_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfDoMplsteHeadSessionBriefs.Ipv4BfDoMplsteHeadSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bf_do_mplste_head_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-head-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteTailSessionDetails(Entity):
        """
        Table of detailed information about all IPv4 BFD
        over MPLS\-TE Tail sessions in the System
        
        .. attribute:: ipv4bf_do_mplste_tail_session_detail
        
        	Detailed information for a single IPv4 BFD over MPLS\-TE Tail session
        	**type**\: list of    :py:class:`Ipv4BfDoMplsteTailSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteTailSessionDetails, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-tail-session-details"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_tail_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails, self).__setattr__(name, value)


        class Ipv4BfDoMplsteTailSessionDetail(Entity):
            """
            Detailed information for a single IPv4 BFD over
            MPLS\-TE Tail session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation>`
            
            .. attribute:: fe_ctype
            
            	FEC Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_ctype
            
            	FEC C Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_destination
            
            	FEC Destination
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_extended_tunnel_id
            
            	FEC Extended Tunnel ID
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_source
            
            	FEC Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_subgroup_id
            
            	FEC Subgroup ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_subgroup_originator
            
            	FEC Subgroup originator
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_tunnel_id
            
            	FEC Tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: feclspid
            
            	FEC LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fecp2mpid
            
            	FEC P2MP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.OwnerInformation>`
            
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-tail-session-detail"
                self.yang_parent_name = "ipv4bf-do-mplste-tail-session-details"

                self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                self.fec_destination = YLeaf(YType.str, "fec-destination")

                self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                self.fec_source = YLeaf(YType.str, "fec-source")

                self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                self.feclspid = YLeaf(YType.int32, "feclspid")

                self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.location = YLeaf(YType.str, "location")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.lsp_ping_info = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("fe_ctype",
                                "fec_ctype",
                                "fec_destination",
                                "fec_extended_tunnel_id",
                                "fec_source",
                                "fec_subgroup_id",
                                "fec_subgroup_originator",
                                "fec_tunnel_id",
                                "feclspid",
                                "fecp2mpid",
                                "incoming_label",
                                "location",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.fe_ctype.is_set or
                    self.fec_ctype.is_set or
                    self.fec_destination.is_set or
                    self.fec_extended_tunnel_id.is_set or
                    self.fec_source.is_set or
                    self.fec_subgroup_id.is_set or
                    self.fec_subgroup_originator.is_set or
                    self.fec_tunnel_id.is_set or
                    self.feclspid.is_set or
                    self.fecp2mpid.is_set or
                    self.incoming_label.is_set or
                    self.location.is_set or
                    self.vrf_name.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.fe_ctype.yfilter != YFilter.not_set or
                    self.fec_ctype.yfilter != YFilter.not_set or
                    self.fec_destination.yfilter != YFilter.not_set or
                    self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                    self.fec_source.yfilter != YFilter.not_set or
                    self.fec_subgroup_id.yfilter != YFilter.not_set or
                    self.fec_subgroup_originator.yfilter != YFilter.not_set or
                    self.fec_tunnel_id.yfilter != YFilter.not_set or
                    self.feclspid.yfilter != YFilter.not_set or
                    self.fecp2mpid.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-tail-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_destination.get_name_leafdata())
                if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_source.get_name_leafdata())
                if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.feclspid.get_name_leafdata())
                if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "incoming-label" or name == "location" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "fe-ctype"):
                    self.fe_ctype = value
                    self.fe_ctype.value_namespace = name_space
                    self.fe_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-ctype"):
                    self.fec_ctype = value
                    self.fec_ctype.value_namespace = name_space
                    self.fec_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-destination"):
                    self.fec_destination = value
                    self.fec_destination.value_namespace = name_space
                    self.fec_destination.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-extended-tunnel-id"):
                    self.fec_extended_tunnel_id = value
                    self.fec_extended_tunnel_id.value_namespace = name_space
                    self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-source"):
                    self.fec_source = value
                    self.fec_source.value_namespace = name_space
                    self.fec_source.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-id"):
                    self.fec_subgroup_id = value
                    self.fec_subgroup_id.value_namespace = name_space
                    self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-originator"):
                    self.fec_subgroup_originator = value
                    self.fec_subgroup_originator.value_namespace = name_space
                    self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-tunnel-id"):
                    self.fec_tunnel_id = value
                    self.fec_tunnel_id.value_namespace = name_space
                    self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "feclspid"):
                    self.feclspid = value
                    self.feclspid.value_namespace = name_space
                    self.feclspid.value_namespace_prefix = name_space_prefix
                if(value_path == "fecp2mpid"):
                    self.fecp2mpid = value
                    self.fecp2mpid.value_namespace = name_space
                    self.fecp2mpid.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bf_do_mplste_tail_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bf_do_mplste_tail_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-tail-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-tail-session-detail"):
                for c in self.ipv4bf_do_mplste_tail_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfDoMplsteTailSessionDetails.Ipv4BfDoMplsteTailSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bf_do_mplste_tail_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-tail-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4MultiHopNodeLocationSummaries(Entity):
        """
        Table of summary information about BFD IPv4
        multihop sessions per location
        
        .. attribute:: ipv4_multi_hop_node_location_summary
        
        	Summary information for BFD IPv4 multihop sessions for location
        	**type**\: list of    :py:class:`Ipv4MultiHopNodeLocationSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4MultiHopNodeLocationSummaries, self).__init__()

            self.yang_name = "ipv4-multi-hop-node-location-summaries"
            self.yang_parent_name = "bfd"

            self.ipv4_multi_hop_node_location_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4MultiHopNodeLocationSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4MultiHopNodeLocationSummaries, self).__setattr__(name, value)


        class Ipv4MultiHopNodeLocationSummary(Entity):
            """
            Summary information for BFD IPv4 multihop
            sessions for location
            
            .. attribute:: location  <key>
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary, self).__init__()

                self.yang_name = "ipv4-multi-hop-node-location-summary"
                self.yang_parent_name = "ipv4-multi-hop-node-location-summaries"

                self.location = YLeaf(YType.str, "location")

                self.session_state = Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv4-multi-hop-node-location-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-multi-hop-node-location-summary" + "[location='" + self.location.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-node-location-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_multi_hop_node_location_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_multi_hop_node_location_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-multi-hop-node-location-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-multi-hop-node-location-summary"):
                for c in self.ipv4_multi_hop_node_location_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4MultiHopNodeLocationSummaries.Ipv4MultiHopNodeLocationSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_multi_hop_node_location_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-multi-hop-node-location-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteTailSessionBriefs(Entity):
        """
        Table of brief information about all IPv4 BFD
        over MPLS\-TE Tail sessions in the System
        
        .. attribute:: ipv4bf_do_mplste_tail_session_brief
        
        	Brief information for a single IPv4 BFD over MPLS\-TE session
        	**type**\: list of    :py:class:`Ipv4BfDoMplsteTailSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteTailSessionBriefs, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-tail-session-briefs"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_tail_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfDoMplsteTailSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfDoMplsteTailSessionBriefs, self).__setattr__(name, value)


        class Ipv4BfDoMplsteTailSessionBrief(Entity):
            """
            Brief information for a single IPv4 BFD over
            MPLS\-TE session
            
            .. attribute:: fe_ctype
            
            	FEC Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_ctype
            
            	FEC C Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_destination
            
            	FEC Destination
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_extended_tunnel_id
            
            	FEC Extended Tunnel ID
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_source
            
            	FEC Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_subgroup_id
            
            	FEC Subgroup ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_subgroup_originator
            
            	FEC Subgroup originator
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_tunnel_id
            
            	FEC Tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: feclspid
            
            	FEC LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fecp2mpid
            
            	FEC P2MP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-tail-session-brief"
                self.yang_parent_name = "ipv4bf-do-mplste-tail-session-briefs"

                self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                self.fec_destination = YLeaf(YType.str, "fec-destination")

                self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                self.fec_source = YLeaf(YType.str, "fec-source")

                self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                self.feclspid = YLeaf(YType.int32, "feclspid")

                self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.status_brief_information = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("fe_ctype",
                                "fec_ctype",
                                "fec_destination",
                                "fec_extended_tunnel_id",
                                "fec_source",
                                "fec_subgroup_id",
                                "fec_subgroup_originator",
                                "fec_tunnel_id",
                                "feclspid",
                                "fecp2mpid",
                                "incoming_label",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-session-brief"

                    self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/ipv4bf-do-mplste-tail-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/ipv4bf-do-mplste-tail-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/ipv4bf-do-mplste-tail-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.fe_ctype.is_set or
                    self.fec_ctype.is_set or
                    self.fec_destination.is_set or
                    self.fec_extended_tunnel_id.is_set or
                    self.fec_source.is_set or
                    self.fec_subgroup_id.is_set or
                    self.fec_subgroup_originator.is_set or
                    self.fec_tunnel_id.is_set or
                    self.feclspid.is_set or
                    self.fecp2mpid.is_set or
                    self.incoming_label.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.fe_ctype.yfilter != YFilter.not_set or
                    self.fec_ctype.yfilter != YFilter.not_set or
                    self.fec_destination.yfilter != YFilter.not_set or
                    self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                    self.fec_source.yfilter != YFilter.not_set or
                    self.fec_subgroup_id.yfilter != YFilter.not_set or
                    self.fec_subgroup_originator.yfilter != YFilter.not_set or
                    self.fec_tunnel_id.yfilter != YFilter.not_set or
                    self.feclspid.yfilter != YFilter.not_set or
                    self.fecp2mpid.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-tail-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_destination.get_name_leafdata())
                if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_source.get_name_leafdata())
                if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.feclspid.get_name_leafdata())
                if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "incoming-label" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "fe-ctype"):
                    self.fe_ctype = value
                    self.fe_ctype.value_namespace = name_space
                    self.fe_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-ctype"):
                    self.fec_ctype = value
                    self.fec_ctype.value_namespace = name_space
                    self.fec_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-destination"):
                    self.fec_destination = value
                    self.fec_destination.value_namespace = name_space
                    self.fec_destination.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-extended-tunnel-id"):
                    self.fec_extended_tunnel_id = value
                    self.fec_extended_tunnel_id.value_namespace = name_space
                    self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-source"):
                    self.fec_source = value
                    self.fec_source.value_namespace = name_space
                    self.fec_source.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-id"):
                    self.fec_subgroup_id = value
                    self.fec_subgroup_id.value_namespace = name_space
                    self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-originator"):
                    self.fec_subgroup_originator = value
                    self.fec_subgroup_originator.value_namespace = name_space
                    self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-tunnel-id"):
                    self.fec_tunnel_id = value
                    self.fec_tunnel_id.value_namespace = name_space
                    self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "feclspid"):
                    self.feclspid = value
                    self.feclspid.value_namespace = name_space
                    self.feclspid.value_namespace_prefix = name_space_prefix
                if(value_path == "fecp2mpid"):
                    self.fecp2mpid = value
                    self.fecp2mpid.value_namespace = name_space
                    self.fecp2mpid.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bf_do_mplste_tail_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bf_do_mplste_tail_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-tail-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-tail-session-brief"):
                for c in self.ipv4bf_do_mplste_tail_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfDoMplsteTailSessionBriefs.Ipv4BfDoMplsteTailSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bf_do_mplste_tail_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-tail-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6MultiHopNodeLocationSummaries(Entity):
        """
        Table of summary information about BFD IPv6
        multihop sessions per location
        
        .. attribute:: ipv6_multi_hop_node_location_summary
        
        	Summary information for BFD IPv6 multihop sessions for location
        	**type**\: list of    :py:class:`Ipv6MultiHopNodeLocationSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6MultiHopNodeLocationSummaries, self).__init__()

            self.yang_name = "ipv6-multi-hop-node-location-summaries"
            self.yang_parent_name = "bfd"

            self.ipv6_multi_hop_node_location_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6MultiHopNodeLocationSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6MultiHopNodeLocationSummaries, self).__setattr__(name, value)


        class Ipv6MultiHopNodeLocationSummary(Entity):
            """
            Summary information for BFD IPv6 multihop
            sessions for location
            
            .. attribute:: location  <key>
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary, self).__init__()

                self.yang_name = "ipv6-multi-hop-node-location-summary"
                self.yang_parent_name = "ipv6-multi-hop-node-location-summaries"

                self.location = YLeaf(YType.str, "location")

                self.session_state = Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv6-multi-hop-node-location-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-multi-hop-node-location-summary" + "[location='" + self.location.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-node-location-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_multi_hop_node_location_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_multi_hop_node_location_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-multi-hop-node-location-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-multi-hop-node-location-summary"):
                for c in self.ipv6_multi_hop_node_location_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6MultiHopNodeLocationSummaries.Ipv6MultiHopNodeLocationSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_multi_hop_node_location_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-multi-hop-node-location-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4MultiHopSummary(Entity):
        """
        Summary information of BFD IPv4 multihop
        sessions
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4MultiHopSummary, self).__init__()

            self.yang_name = "ipv4-multi-hop-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Ipv4MultiHopSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4MultiHopSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "ipv4-multi-hop-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4MultiHopSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4MultiHopSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-multi-hop-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Ipv4MultiHopSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopCounters(Entity):
        """
        IPv4 single hop Counters
        
        .. attribute:: ipv4_single_hop_packet_counters
        
        	Table of IPv4 single hop Packet counters
        	**type**\:   :py:class:`Ipv4SingleHopPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopCounters, self).__init__()

            self.yang_name = "ipv4-single-hop-counters"
            self.yang_parent_name = "bfd"

            self.ipv4_single_hop_packet_counters = Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters()
            self.ipv4_single_hop_packet_counters.parent = self
            self._children_name_map["ipv4_single_hop_packet_counters"] = "ipv4-single-hop-packet-counters"
            self._children_yang_names.add("ipv4-single-hop-packet-counters")


        class Ipv4SingleHopPacketCounters(Entity):
            """
            Table of IPv4 single hop Packet counters
            
            .. attribute:: ipv4_single_hop_packet_counter
            
            	Interface IPv4 single hop Packet counters
            	**type**\: list of    :py:class:`Ipv4SingleHopPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters.Ipv4SingleHopPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters, self).__init__()

                self.yang_name = "ipv4-single-hop-packet-counters"
                self.yang_parent_name = "ipv4-single-hop-counters"

                self.ipv4_single_hop_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters, self).__setattr__(name, value)


            class Ipv4SingleHopPacketCounter(Entity):
                """
                Interface IPv4 single hop Packet counters
                
                .. attribute:: interface_name  <key>
                
                	Interface Name
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters.Ipv4SingleHopPacketCounter, self).__init__()

                    self.yang_name = "ipv4-single-hop-packet-counter"
                    self.yang_parent_name = "ipv4-single-hop-packet-counters"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters.Ipv4SingleHopPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters.Ipv4SingleHopPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4-single-hop-packet-counter" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-counters/ipv4-single-hop-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv4_single_hop_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ipv4_single_hop_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-single-hop-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4-single-hop-packet-counter"):
                    for c in self.ipv4_single_hop_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters.Ipv4SingleHopPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv4_single_hop_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4-single-hop-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.ipv4_single_hop_packet_counters is not None and self.ipv4_single_hop_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv4_single_hop_packet_counters is not None and self.ipv4_single_hop_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-single-hop-packet-counters"):
                if (self.ipv4_single_hop_packet_counters is None):
                    self.ipv4_single_hop_packet_counters = Bfd.Ipv4SingleHopCounters.Ipv4SingleHopPacketCounters()
                    self.ipv4_single_hop_packet_counters.parent = self
                    self._children_name_map["ipv4_single_hop_packet_counters"] = "ipv4-single-hop-packet-counters"
                return self.ipv4_single_hop_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-single-hop-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6MultiHopSessionDetails(Entity):
        """
        Table of detailed information about all IPv6
        multihop BFD sessions in the System 
        
        .. attribute:: ipv6_multi_hop_session_detail
        
        	Detailed information for a single IPv6 multihop BFD session
        	**type**\: list of    :py:class:`Ipv6MultiHopSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6MultiHopSessionDetails, self).__init__()

            self.yang_name = "ipv6-multi-hop-session-details"
            self.yang_parent_name = "bfd"

            self.ipv6_multi_hop_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6MultiHopSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6MultiHopSessionDetails, self).__setattr__(name, value)


        class Ipv6MultiHopSessionDetail(Entity):
            """
            Detailed information for a single IPv6 multihop
            BFD session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation>`
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.OwnerInformation>`
            
            .. attribute:: source_address
            
            	Source Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail, self).__init__()

                self.yang_name = "ipv6-multi-hop-session-detail"
                self.yang_parent_name = "ipv6-multi-hop-session-details"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.location = YLeaf(YType.str, "location")

                self.source_address = YLeaf(YType.str, "source-address")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.lsp_ping_info = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "location",
                                "source_address",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "ipv6-multi-hop-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "ipv6-multi-hop-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "ipv6-multi-hop-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "ipv6-multi-hop-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "ipv6-multi-hop-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.location.is_set or
                    self.source_address.is_set or
                    self.vrf_name.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.source_address.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-multi-hop-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_address.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "destination-address" or name == "location" or name == "source-address" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "source-address"):
                    self.source_address = value
                    self.source_address.value_namespace = name_space
                    self.source_address.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_multi_hop_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_multi_hop_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-multi-hop-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-multi-hop-session-detail"):
                for c in self.ipv6_multi_hop_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6MultiHopSessionDetails.Ipv6MultiHopSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_multi_hop_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-multi-hop-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6MultiHopMultiPaths(Entity):
        """
        IPv6 multi hop multipath
        
        .. attribute:: ipv6_multi_hop_multi_path
        
        	IPv6 multihop multipath table
        	**type**\: list of    :py:class:`Ipv6MultiHopMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopMultiPaths.Ipv6MultiHopMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6MultiHopMultiPaths, self).__init__()

            self.yang_name = "ipv6-multi-hop-multi-paths"
            self.yang_parent_name = "bfd"

            self.ipv6_multi_hop_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6MultiHopMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6MultiHopMultiPaths, self).__setattr__(name, value)


        class Ipv6MultiHopMultiPath(Entity):
            """
            IPv6 multihop multipath table
            
            .. attribute:: destination_address
            
            	Destination address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: source_address
            
            	Source address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6MultiHopMultiPaths.Ipv6MultiHopMultiPath, self).__init__()

                self.yang_name = "ipv6-multi-hop-multi-path"
                self.yang_parent_name = "ipv6-multi-hop-multi-paths"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.source_address = YLeaf(YType.str, "source-address")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "incoming_label_xr",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "source_address",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6MultiHopMultiPaths.Ipv6MultiHopMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6MultiHopMultiPaths.Ipv6MultiHopMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.incoming_label_xr.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.source_address.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.source_address.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-multi-hop-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_address.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "destination-address" or name == "incoming-label-xr" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "source-address" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "source-address"):
                    self.source_address = value
                    self.source_address.value_namespace = name_space
                    self.source_address.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_multi_hop_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_multi_hop_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-multi-hop-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-multi-hop-multi-path"):
                for c in self.ipv6_multi_hop_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6MultiHopMultiPaths.Ipv6MultiHopMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_multi_hop_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-multi-hop-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteHeadCounters(Entity):
        """
        IPv4 BFD over MPLS\-TE Counters
        
        .. attribute:: ipv4bf_do_mplste_head_packet_counters
        
        	Table of IPv4 BFD over MPLS\-TE Packet counters
        	**type**\:   :py:class:`Ipv4BfDoMplsteHeadPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteHeadCounters, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-head-counters"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_head_packet_counters = Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters()
            self.ipv4bf_do_mplste_head_packet_counters.parent = self
            self._children_name_map["ipv4bf_do_mplste_head_packet_counters"] = "ipv4bf-do-mplste-head-packet-counters"
            self._children_yang_names.add("ipv4bf-do-mplste-head-packet-counters")


        class Ipv4BfDoMplsteHeadPacketCounters(Entity):
            """
            Table of IPv4 BFD over MPLS\-TE Packet counters
            
            .. attribute:: ipv4bf_do_mplste_head_packet_counter
            
            	Interface  IPv4 BFD over MPLS\-TE Packet counters
            	**type**\: list of    :py:class:`Ipv4BfDoMplsteHeadPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters.Ipv4BfDoMplsteHeadPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-head-packet-counters"
                self.yang_parent_name = "ipv4bf-do-mplste-head-counters"

                self.ipv4bf_do_mplste_head_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters, self).__setattr__(name, value)


            class Ipv4BfDoMplsteHeadPacketCounter(Entity):
                """
                Interface  IPv4 BFD over MPLS\-TE Packet
                counters
                
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interface_name
                
                	Interface Name
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: location
                
                	Location
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters.Ipv4BfDoMplsteHeadPacketCounter, self).__init__()

                    self.yang_name = "ipv4bf-do-mplste-head-packet-counter"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-packet-counters"

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.location = YLeaf(YType.str, "location")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count",
                                    "interface_name",
                                    "location") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters.Ipv4BfDoMplsteHeadPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters.Ipv4BfDoMplsteHeadPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set or
                        self.interface_name.is_set or
                        self.location.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.location.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4bf-do-mplste-head-packet-counter" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-counters/ipv4bf-do-mplste-head-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.location.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count" or name == "interface-name" or name == "location"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "location"):
                        self.location = value
                        self.location.value_namespace = name_space
                        self.location.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv4bf_do_mplste_head_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ipv4bf_do_mplste_head_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-head-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4bf-do-mplste-head-packet-counter"):
                    for c in self.ipv4bf_do_mplste_head_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters.Ipv4BfDoMplsteHeadPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv4bf_do_mplste_head_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4bf-do-mplste-head-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.ipv4bf_do_mplste_head_packet_counters is not None and self.ipv4bf_do_mplste_head_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv4bf_do_mplste_head_packet_counters is not None and self.ipv4bf_do_mplste_head_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-head-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-head-packet-counters"):
                if (self.ipv4bf_do_mplste_head_packet_counters is None):
                    self.ipv4bf_do_mplste_head_packet_counters = Bfd.Ipv4BfDoMplsteHeadCounters.Ipv4BfDoMplsteHeadPacketCounters()
                    self.ipv4bf_do_mplste_head_packet_counters.parent = self
                    self._children_name_map["ipv4bf_do_mplste_head_packet_counters"] = "ipv4bf-do-mplste-head-packet-counters"
                return self.ipv4bf_do_mplste_head_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-head-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class SessionMibs(Entity):
        """
        BFD session MIB database
        
        .. attribute:: session_mib
        
        	Brief information for BFD session MIB
        	**type**\: list of    :py:class:`SessionMib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionMibs.SessionMib>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.SessionMibs, self).__init__()

            self.yang_name = "session-mibs"
            self.yang_parent_name = "bfd"

            self.session_mib = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.SessionMibs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.SessionMibs, self).__setattr__(name, value)


        class SessionMib(Entity):
            """
            Brief information for BFD session MIB
            
            .. attribute:: discriminator  <key>
            
            	Sesison Discr 
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: desired_min_tx_interval
            
            	Desired Min TX Interval
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: dest_address
            
            	Session Destination address
            	**type**\:   :py:class:`DestAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionMibs.SessionMib.DestAddress>`
            
            .. attribute:: detection_multiplier
            
            	Detection Multiplier
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: int_handle
            
            	Session Interface Handle
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Session Interface Name
            	**type**\:  str
            
            	**length:** 0..64
            
            .. attribute:: last_down_diag
            
            	Last Session Down Diag
            	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
            
            .. attribute:: last_down_time_nsec
            
            	Last Session Down Time (nanoseconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: nanosecond
            
            .. attribute:: last_down_time_sec
            
            	Last Session Down Time (seconds)
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            	**units**\: second
            
            .. attribute:: last_time_cached
            
            	Last Time Session Info Queried
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: last_up_time_nsec
            
            	Last Session Up Time (nanoseconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: nanosecond
            
            .. attribute:: last_up_time_sec
            
            	Last Session Up Time (seconds)
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            	**units**\: second
            
            .. attribute:: local_discriminator
            
            	Sessions' Local Discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: pkt_in
            
            	Packet In Counter
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: pkt_out
            
            	Packet Out Counter
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: remote_discriminator
            
            	Sessions' Remote Discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: required_min_rx_echo_interval
            
            	Required Min RX Echo Interval
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: required_min_rx_interval
            
            	Required Min RX Interval
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_state
            
            	Session State
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: sessionversion
            
            	Session BFD Version
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: trap_bitmap
            
            	Trap Generator Bitmap
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_counter
            
            	Up Count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.SessionMibs.SessionMib, self).__init__()

                self.yang_name = "session-mib"
                self.yang_parent_name = "session-mibs"

                self.discriminator = YLeaf(YType.int32, "discriminator")

                self.desired_min_tx_interval = YLeaf(YType.uint32, "desired-min-tx-interval")

                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                self.int_handle = YLeaf(YType.uint32, "int-handle")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.last_down_diag = YLeaf(YType.enumeration, "last-down-diag")

                self.last_down_time_nsec = YLeaf(YType.uint32, "last-down-time-nsec")

                self.last_down_time_sec = YLeaf(YType.uint64, "last-down-time-sec")

                self.last_time_cached = YLeaf(YType.uint64, "last-time-cached")

                self.last_up_time_nsec = YLeaf(YType.uint32, "last-up-time-nsec")

                self.last_up_time_sec = YLeaf(YType.uint64, "last-up-time-sec")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.pkt_in = YLeaf(YType.uint64, "pkt-in")

                self.pkt_out = YLeaf(YType.uint64, "pkt-out")

                self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                self.required_min_rx_echo_interval = YLeaf(YType.uint32, "required-min-rx-echo-interval")

                self.required_min_rx_interval = YLeaf(YType.uint32, "required-min-rx-interval")

                self.session_state = YLeaf(YType.uint32, "session-state")

                self.sessionversion = YLeaf(YType.uint32, "sessionversion")

                self.trap_bitmap = YLeaf(YType.uint32, "trap-bitmap")

                self.up_counter = YLeaf(YType.uint32, "up-counter")

                self.dest_address = Bfd.SessionMibs.SessionMib.DestAddress()
                self.dest_address.parent = self
                self._children_name_map["dest_address"] = "dest-address"
                self._children_yang_names.add("dest-address")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("discriminator",
                                "desired_min_tx_interval",
                                "detection_multiplier",
                                "int_handle",
                                "interface_name",
                                "last_down_diag",
                                "last_down_time_nsec",
                                "last_down_time_sec",
                                "last_time_cached",
                                "last_up_time_nsec",
                                "last_up_time_sec",
                                "local_discriminator",
                                "pkt_in",
                                "pkt_out",
                                "remote_discriminator",
                                "required_min_rx_echo_interval",
                                "required_min_rx_interval",
                                "session_state",
                                "sessionversion",
                                "trap_bitmap",
                                "up_counter") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.SessionMibs.SessionMib, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.SessionMibs.SessionMib, self).__setattr__(name, value)


            class DestAddress(Entity):
                """
                Session Destination address
                
                .. attribute:: afi
                
                	AFI
                	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                
                .. attribute:: dummy
                
                	No Address
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: ipv4
                
                	IPv4 address type
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: ipv6
                
                	IPv6 address type
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionMibs.SessionMib.DestAddress, self).__init__()

                    self.yang_name = "dest-address"
                    self.yang_parent_name = "session-mib"

                    self.afi = YLeaf(YType.enumeration, "afi")

                    self.dummy = YLeaf(YType.uint8, "dummy")

                    self.ipv4 = YLeaf(YType.str, "ipv4")

                    self.ipv6 = YLeaf(YType.str, "ipv6")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("afi",
                                    "dummy",
                                    "ipv4",
                                    "ipv6") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.SessionMibs.SessionMib.DestAddress, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.SessionMibs.SessionMib.DestAddress, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.afi.is_set or
                        self.dummy.is_set or
                        self.ipv4.is_set or
                        self.ipv6.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.afi.yfilter != YFilter.not_set or
                        self.dummy.yfilter != YFilter.not_set or
                        self.ipv4.yfilter != YFilter.not_set or
                        self.ipv6.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "dest-address" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.afi.get_name_leafdata())
                    if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.dummy.get_name_leafdata())
                    if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4.get_name_leafdata())
                    if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv6.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "afi"):
                        self.afi = value
                        self.afi.value_namespace = name_space
                        self.afi.value_namespace_prefix = name_space_prefix
                    if(value_path == "dummy"):
                        self.dummy = value
                        self.dummy.value_namespace = name_space
                        self.dummy.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4"):
                        self.ipv4 = value
                        self.ipv4.value_namespace = name_space
                        self.ipv4.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv6"):
                        self.ipv6 = value
                        self.ipv6.value_namespace = name_space
                        self.ipv6.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.discriminator.is_set or
                    self.desired_min_tx_interval.is_set or
                    self.detection_multiplier.is_set or
                    self.int_handle.is_set or
                    self.interface_name.is_set or
                    self.last_down_diag.is_set or
                    self.last_down_time_nsec.is_set or
                    self.last_down_time_sec.is_set or
                    self.last_time_cached.is_set or
                    self.last_up_time_nsec.is_set or
                    self.last_up_time_sec.is_set or
                    self.local_discriminator.is_set or
                    self.pkt_in.is_set or
                    self.pkt_out.is_set or
                    self.remote_discriminator.is_set or
                    self.required_min_rx_echo_interval.is_set or
                    self.required_min_rx_interval.is_set or
                    self.session_state.is_set or
                    self.sessionversion.is_set or
                    self.trap_bitmap.is_set or
                    self.up_counter.is_set or
                    (self.dest_address is not None and self.dest_address.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.discriminator.yfilter != YFilter.not_set or
                    self.desired_min_tx_interval.yfilter != YFilter.not_set or
                    self.detection_multiplier.yfilter != YFilter.not_set or
                    self.int_handle.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.last_down_diag.yfilter != YFilter.not_set or
                    self.last_down_time_nsec.yfilter != YFilter.not_set or
                    self.last_down_time_sec.yfilter != YFilter.not_set or
                    self.last_time_cached.yfilter != YFilter.not_set or
                    self.last_up_time_nsec.yfilter != YFilter.not_set or
                    self.last_up_time_sec.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.pkt_in.yfilter != YFilter.not_set or
                    self.pkt_out.yfilter != YFilter.not_set or
                    self.remote_discriminator.yfilter != YFilter.not_set or
                    self.required_min_rx_echo_interval.yfilter != YFilter.not_set or
                    self.required_min_rx_interval.yfilter != YFilter.not_set or
                    self.session_state.yfilter != YFilter.not_set or
                    self.sessionversion.yfilter != YFilter.not_set or
                    self.trap_bitmap.yfilter != YFilter.not_set or
                    self.up_counter.yfilter != YFilter.not_set or
                    (self.dest_address is not None and self.dest_address.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-mib" + "[discriminator='" + self.discriminator.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-mibs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.discriminator.is_set or self.discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.discriminator.get_name_leafdata())
                if (self.desired_min_tx_interval.is_set or self.desired_min_tx_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.desired_min_tx_interval.get_name_leafdata())
                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                if (self.int_handle.is_set or self.int_handle.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.int_handle.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.last_down_diag.is_set or self.last_down_diag.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_down_diag.get_name_leafdata())
                if (self.last_down_time_nsec.is_set or self.last_down_time_nsec.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_down_time_nsec.get_name_leafdata())
                if (self.last_down_time_sec.is_set or self.last_down_time_sec.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_down_time_sec.get_name_leafdata())
                if (self.last_time_cached.is_set or self.last_time_cached.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_time_cached.get_name_leafdata())
                if (self.last_up_time_nsec.is_set or self.last_up_time_nsec.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_up_time_nsec.get_name_leafdata())
                if (self.last_up_time_sec.is_set or self.last_up_time_sec.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_up_time_sec.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.pkt_in.is_set or self.pkt_in.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pkt_in.get_name_leafdata())
                if (self.pkt_out.is_set or self.pkt_out.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.pkt_out.get_name_leafdata())
                if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                if (self.required_min_rx_echo_interval.is_set or self.required_min_rx_echo_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.required_min_rx_echo_interval.get_name_leafdata())
                if (self.required_min_rx_interval.is_set or self.required_min_rx_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.required_min_rx_interval.get_name_leafdata())
                if (self.session_state.is_set or self.session_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_state.get_name_leafdata())
                if (self.sessionversion.is_set or self.sessionversion.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sessionversion.get_name_leafdata())
                if (self.trap_bitmap.is_set or self.trap_bitmap.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.trap_bitmap.get_name_leafdata())
                if (self.up_counter.is_set or self.up_counter.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_counter.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "dest-address"):
                    if (self.dest_address is None):
                        self.dest_address = Bfd.SessionMibs.SessionMib.DestAddress()
                        self.dest_address.parent = self
                        self._children_name_map["dest_address"] = "dest-address"
                    return self.dest_address

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "dest-address" or name == "discriminator" or name == "desired-min-tx-interval" or name == "detection-multiplier" or name == "int-handle" or name == "interface-name" or name == "last-down-diag" or name == "last-down-time-nsec" or name == "last-down-time-sec" or name == "last-time-cached" or name == "last-up-time-nsec" or name == "last-up-time-sec" or name == "local-discriminator" or name == "pkt-in" or name == "pkt-out" or name == "remote-discriminator" or name == "required-min-rx-echo-interval" or name == "required-min-rx-interval" or name == "session-state" or name == "sessionversion" or name == "trap-bitmap" or name == "up-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "discriminator"):
                    self.discriminator = value
                    self.discriminator.value_namespace = name_space
                    self.discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "desired-min-tx-interval"):
                    self.desired_min_tx_interval = value
                    self.desired_min_tx_interval.value_namespace = name_space
                    self.desired_min_tx_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "detection-multiplier"):
                    self.detection_multiplier = value
                    self.detection_multiplier.value_namespace = name_space
                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                if(value_path == "int-handle"):
                    self.int_handle = value
                    self.int_handle.value_namespace = name_space
                    self.int_handle.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "last-down-diag"):
                    self.last_down_diag = value
                    self.last_down_diag.value_namespace = name_space
                    self.last_down_diag.value_namespace_prefix = name_space_prefix
                if(value_path == "last-down-time-nsec"):
                    self.last_down_time_nsec = value
                    self.last_down_time_nsec.value_namespace = name_space
                    self.last_down_time_nsec.value_namespace_prefix = name_space_prefix
                if(value_path == "last-down-time-sec"):
                    self.last_down_time_sec = value
                    self.last_down_time_sec.value_namespace = name_space
                    self.last_down_time_sec.value_namespace_prefix = name_space_prefix
                if(value_path == "last-time-cached"):
                    self.last_time_cached = value
                    self.last_time_cached.value_namespace = name_space
                    self.last_time_cached.value_namespace_prefix = name_space_prefix
                if(value_path == "last-up-time-nsec"):
                    self.last_up_time_nsec = value
                    self.last_up_time_nsec.value_namespace = name_space
                    self.last_up_time_nsec.value_namespace_prefix = name_space_prefix
                if(value_path == "last-up-time-sec"):
                    self.last_up_time_sec = value
                    self.last_up_time_sec.value_namespace = name_space
                    self.last_up_time_sec.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "pkt-in"):
                    self.pkt_in = value
                    self.pkt_in.value_namespace = name_space
                    self.pkt_in.value_namespace_prefix = name_space_prefix
                if(value_path == "pkt-out"):
                    self.pkt_out = value
                    self.pkt_out.value_namespace = name_space
                    self.pkt_out.value_namespace_prefix = name_space_prefix
                if(value_path == "remote-discriminator"):
                    self.remote_discriminator = value
                    self.remote_discriminator.value_namespace = name_space
                    self.remote_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "required-min-rx-echo-interval"):
                    self.required_min_rx_echo_interval = value
                    self.required_min_rx_echo_interval.value_namespace = name_space
                    self.required_min_rx_echo_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "required-min-rx-interval"):
                    self.required_min_rx_interval = value
                    self.required_min_rx_interval.value_namespace = name_space
                    self.required_min_rx_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "session-state"):
                    self.session_state = value
                    self.session_state.value_namespace = name_space
                    self.session_state.value_namespace_prefix = name_space_prefix
                if(value_path == "sessionversion"):
                    self.sessionversion = value
                    self.sessionversion.value_namespace = name_space
                    self.sessionversion.value_namespace_prefix = name_space_prefix
                if(value_path == "trap-bitmap"):
                    self.trap_bitmap = value
                    self.trap_bitmap.value_namespace = name_space
                    self.trap_bitmap.value_namespace_prefix = name_space_prefix
                if(value_path == "up-counter"):
                    self.up_counter = value
                    self.up_counter.value_namespace = name_space
                    self.up_counter.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.session_mib:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.session_mib:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "session-mibs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-mib"):
                for c in self.session_mib:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.SessionMibs.SessionMib()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.session_mib.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-mib"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6MultiHopSummary(Entity):
        """
        Summary information of BFD IPv6 multihop
        sessions
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6MultiHopSummary, self).__init__()

            self.yang_name = "ipv6-multi-hop-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Ipv6MultiHopSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6MultiHopSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "ipv6-multi-hop-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6MultiHopSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6MultiHopSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-multi-hop-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Ipv6MultiHopSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LabelSummaryNodes(Entity):
        """
        Table of summary about Label BFD sessions for
        location
        
        .. attribute:: label_summary_node
        
        	Summary of Label BFD 
        	**type**\: list of    :py:class:`LabelSummaryNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSummaryNodes.LabelSummaryNode>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.LabelSummaryNodes, self).__init__()

            self.yang_name = "label-summary-nodes"
            self.yang_parent_name = "bfd"

            self.label_summary_node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.LabelSummaryNodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.LabelSummaryNodes, self).__setattr__(name, value)


        class LabelSummaryNode(Entity):
            """
            Summary of Label BFD 
            
            .. attribute:: location_name  <key>
            
            	Location name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSummaryNodes.LabelSummaryNode.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.LabelSummaryNodes.LabelSummaryNode, self).__init__()

                self.yang_name = "label-summary-node"
                self.yang_parent_name = "label-summary-nodes"

                self.location_name = YLeaf(YType.str, "location-name")

                self.session_state = Bfd.LabelSummaryNodes.LabelSummaryNode.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.LabelSummaryNodes.LabelSummaryNode, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.LabelSummaryNodes.LabelSummaryNode, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSummaryNodes.LabelSummaryNode.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "label-summary-node"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelSummaryNodes.LabelSummaryNode.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelSummaryNodes.LabelSummaryNode.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location_name.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location_name.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-summary-node" + "[location-name='" + self.location_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-summary-nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location_name.is_set or self.location_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.LabelSummaryNodes.LabelSummaryNode.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location-name"):
                    self.location_name = value
                    self.location_name.value_namespace = name_space
                    self.location_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.label_summary_node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.label_summary_node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "label-summary-nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "label-summary-node"):
                for c in self.label_summary_node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.LabelSummaryNodes.LabelSummaryNode()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.label_summary_node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "label-summary-node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6MultiHopSessionBriefs(Entity):
        """
        Table of brief information about all IPv6
        multihop BFD sessions in the System
        
        .. attribute:: ipv6_multi_hop_session_brief
        
        	Brief information for a single IPv6 multihop BFD session
        	**type**\: list of    :py:class:`Ipv6MultiHopSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6MultiHopSessionBriefs, self).__init__()

            self.yang_name = "ipv6-multi-hop-session-briefs"
            self.yang_parent_name = "bfd"

            self.ipv6_multi_hop_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6MultiHopSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6MultiHopSessionBriefs, self).__setattr__(name, value)


        class Ipv6MultiHopSessionBrief(Entity):
            """
            Brief information for a single IPv6 multihop
            BFD session
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: source_address
            
            	Source Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief, self).__init__()

                self.yang_name = "ipv6-multi-hop-session-brief"
                self.yang_parent_name = "ipv6-multi-hop-session-briefs"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.source_address = YLeaf(YType.str, "source-address")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.status_brief_information = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "source_address",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "ipv6-multi-hop-session-brief"

                    self.async_interval_multiplier = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/ipv6-multi-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/ipv6-multi-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/ipv6-multi-hop-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.source_address.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.source_address.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-multi-hop-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_address.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "destination-address" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "source-address" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "source-address"):
                    self.source_address = value
                    self.source_address.value_namespace = name_space
                    self.source_address.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_multi_hop_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_multi_hop_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-multi-hop-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-multi-hop-session-brief"):
                for c in self.ipv6_multi_hop_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6MultiHopSessionBriefs.Ipv6MultiHopSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_multi_hop_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-multi-hop-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class SessionBriefs(Entity):
        """
        Table of brief information about singlehop IPv4
        BFD sessions in the System
        
        .. attribute:: session_brief
        
        	Brief information for a single IPv4 singlehop BFD session
        	**type**\: list of    :py:class:`SessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionBriefs.SessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.SessionBriefs, self).__init__()

            self.yang_name = "session-briefs"
            self.yang_parent_name = "bfd"

            self.session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.SessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.SessionBriefs, self).__setattr__(name, value)


        class SessionBrief(Entity):
            """
            Brief information for a single IPv4 singlehop
            BFD session
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionBriefs.SessionBrief.StatusBriefInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.SessionBriefs.SessionBrief, self).__init__()

                self.yang_name = "session-brief"
                self.yang_parent_name = "session-briefs"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.state = YLeaf(YType.enumeration, "state")

                self.status_brief_information = Bfd.SessionBriefs.SessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.SessionBriefs.SessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.SessionBriefs.SessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "session-brief"

                    self.async_interval_multiplier = Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.SessionBriefs.SessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.state.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.SessionBriefs.SessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "destination-address" or name == "interface-name" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-brief"):
                for c in self.session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.SessionBriefs.SessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopNodeLocationSummaries(Entity):
        """
        Table of summary information about BFD IPv6
        singlehop sessions per location
        
        .. attribute:: ipv6_single_hop_node_location_summary
        
        	Summary information for BFD IPv6 singlehop sessions for location
        	**type**\: list of    :py:class:`Ipv6SingleHopNodeLocationSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopNodeLocationSummaries, self).__init__()

            self.yang_name = "ipv6-single-hop-node-location-summaries"
            self.yang_parent_name = "bfd"

            self.ipv6_single_hop_node_location_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6SingleHopNodeLocationSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6SingleHopNodeLocationSummaries, self).__setattr__(name, value)


        class Ipv6SingleHopNodeLocationSummary(Entity):
            """
            Summary information for BFD IPv6 singlehop
            sessions for location
            
            .. attribute:: location  <key>
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary, self).__init__()

                self.yang_name = "ipv6-single-hop-node-location-summary"
                self.yang_parent_name = "ipv6-single-hop-node-location-summaries"

                self.location = YLeaf(YType.str, "location")

                self.session_state = Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv6-single-hop-node-location-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-single-hop-node-location-summary" + "[location='" + self.location.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-node-location-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_single_hop_node_location_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_single_hop_node_location_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-node-location-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-single-hop-node-location-summary"):
                for c in self.ipv6_single_hop_node_location_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6SingleHopNodeLocationSummaries.Ipv6SingleHopNodeLocationSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_single_hop_node_location_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-single-hop-node-location-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Summary(Entity):
        """
        Summary information of BFD IPv4 singlehop
        sessions
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Summary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Summary, self).__init__()

            self.yang_name = "summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Summary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Summary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Summary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Summary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Summary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfdMplsteTailNodeSummaries(Entity):
        """
        Table of summary about IPv4 TE tail BFD sessions
        for location
        
        .. attribute:: ipv4bfd_mplste_tail_node_summary
        
        	Summary of IPv4 BFD over MPLS\-TE tail
        	**type**\: list of    :py:class:`Ipv4BfdMplsteTailNodeSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfdMplsteTailNodeSummaries, self).__init__()

            self.yang_name = "ipv4bfd-mplste-tail-node-summaries"
            self.yang_parent_name = "bfd"

            self.ipv4bfd_mplste_tail_node_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfdMplsteTailNodeSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfdMplsteTailNodeSummaries, self).__setattr__(name, value)


        class Ipv4BfdMplsteTailNodeSummary(Entity):
            """
            Summary of IPv4 BFD over MPLS\-TE tail
            
            .. attribute:: location_name  <key>
            
            	Location name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary, self).__init__()

                self.yang_name = "ipv4bfd-mplste-tail-node-summary"
                self.yang_parent_name = "ipv4bfd-mplste-tail-node-summaries"

                self.location_name = YLeaf(YType.str, "location-name")

                self.session_state = Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv4bfd-mplste-tail-node-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location_name.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location_name.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bfd-mplste-tail-node-summary" + "[location-name='" + self.location_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bfd-mplste-tail-node-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location_name.is_set or self.location_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location-name"):
                    self.location_name = value
                    self.location_name.value_namespace = name_space
                    self.location_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bfd_mplste_tail_node_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bfd_mplste_tail_node_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bfd-mplste-tail-node-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bfd-mplste-tail-node-summary"):
                for c in self.ipv4bfd_mplste_tail_node_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfdMplsteTailNodeSummaries.Ipv4BfdMplsteTailNodeSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bfd_mplste_tail_node_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bfd-mplste-tail-node-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopLocationSummaries(Entity):
        """
        Table of summary information about IPv4
        singlehop BFD sessions for location
        
        .. attribute:: ipv4_single_hop_location_summary
        
        	Summary information for BFD IPv4 singlehop sessions for location
        	**type**\: list of    :py:class:`Ipv4SingleHopLocationSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopLocationSummaries, self).__init__()

            self.yang_name = "ipv4-single-hop-location-summaries"
            self.yang_parent_name = "bfd"

            self.ipv4_single_hop_location_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4SingleHopLocationSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4SingleHopLocationSummaries, self).__setattr__(name, value)


        class Ipv4SingleHopLocationSummary(Entity):
            """
            Summary information for BFD IPv4 singlehop
            sessions for location
            
            .. attribute:: location_name  <key>
            
            	Location Name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary, self).__init__()

                self.yang_name = "ipv4-single-hop-location-summary"
                self.yang_parent_name = "ipv4-single-hop-location-summaries"

                self.location_name = YLeaf(YType.str, "location-name")

                self.session_state = Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv4-single-hop-location-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location_name.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location_name.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-single-hop-location-summary" + "[location-name='" + self.location_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-location-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location_name.is_set or self.location_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location-name"):
                    self.location_name = value
                    self.location_name.value_namespace = name_space
                    self.location_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_single_hop_location_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_single_hop_location_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-location-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-single-hop-location-summary"):
                for c in self.ipv4_single_hop_location_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4SingleHopLocationSummaries.Ipv4SingleHopLocationSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_single_hop_location_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-single-hop-location-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfdMplsteHeadSummaryNodes(Entity):
        """
        Table of summary about IPv4 TE head BFD sessions
        for location
        
        .. attribute:: ipv4bfd_mplste_head_summary_node
        
        	Summary of IPv4 BFD over MPLS\-TE head
        	**type**\: list of    :py:class:`Ipv4BfdMplsteHeadSummaryNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfdMplsteHeadSummaryNodes, self).__init__()

            self.yang_name = "ipv4bfd-mplste-head-summary-nodes"
            self.yang_parent_name = "bfd"

            self.ipv4bfd_mplste_head_summary_node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfdMplsteHeadSummaryNodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfdMplsteHeadSummaryNodes, self).__setattr__(name, value)


        class Ipv4BfdMplsteHeadSummaryNode(Entity):
            """
            Summary of IPv4 BFD over MPLS\-TE head
            
            .. attribute:: location_name  <key>
            
            	Location name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode, self).__init__()

                self.yang_name = "ipv4bfd-mplste-head-summary-node"
                self.yang_parent_name = "ipv4bfd-mplste-head-summary-nodes"

                self.location_name = YLeaf(YType.str, "location-name")

                self.session_state = Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv4bfd-mplste-head-summary-node"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location_name.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location_name.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bfd-mplste-head-summary-node" + "[location-name='" + self.location_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bfd-mplste-head-summary-nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location_name.is_set or self.location_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location-name"):
                    self.location_name = value
                    self.location_name.value_namespace = name_space
                    self.location_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bfd_mplste_head_summary_node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bfd_mplste_head_summary_node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bfd-mplste-head-summary-nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bfd-mplste-head-summary-node"):
                for c in self.ipv4bfd_mplste_head_summary_node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfdMplsteHeadSummaryNodes.Ipv4BfdMplsteHeadSummaryNode()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bfd_mplste_head_summary_node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bfd-mplste-head-summary-node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LabelSessionDetails(Entity):
        """
        Table of detailed information about all Label
        BFD sessions in the System 
        
        .. attribute:: label_session_detail
        
        	Detailed information for a single BFD session
        	**type**\: list of    :py:class:`LabelSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.LabelSessionDetails, self).__init__()

            self.yang_name = "label-session-details"
            self.yang_parent_name = "bfd"

            self.label_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.LabelSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.LabelSessionDetails, self).__setattr__(name, value)


        class LabelSessionDetail(Entity):
            """
            Detailed information for a single BFD session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation>`
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.OwnerInformation>`
            
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.LabelSessionDetails.LabelSessionDetail, self).__init__()

                self.yang_name = "label-session-detail"
                self.yang_parent_name = "label-session-details"

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.lsp_ping_info = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("incoming_label",
                                "interface_name",
                                "location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.LabelSessionDetails.LabelSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "label-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "label-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "label-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSessionDetails.LabelSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "label-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "label-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.incoming_label.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.LabelSessionDetails.LabelSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.LabelSessionDetails.LabelSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.LabelSessionDetails.LabelSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.LabelSessionDetails.LabelSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.LabelSessionDetails.LabelSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "incoming-label" or name == "interface-name" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.label_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.label_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "label-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "label-session-detail"):
                for c in self.label_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.LabelSessionDetails.LabelSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.label_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "label-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopSessionDetails(Entity):
        """
        Table of detailed information about all IPv6
        singlehop BFD sessions in the System 
        
        .. attribute:: ipv6_single_hop_session_detail
        
        	Detailed information for a single IPv6 singlehop BFD session
        	**type**\: list of    :py:class:`Ipv6SingleHopSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopSessionDetails, self).__init__()

            self.yang_name = "ipv6-single-hop-session-details"
            self.yang_parent_name = "bfd"

            self.ipv6_single_hop_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6SingleHopSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6SingleHopSessionDetails, self).__setattr__(name, value)


        class Ipv6SingleHopSessionDetail(Entity):
            """
            Detailed information for a single IPv6
            singlehop BFD session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation>`
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.OwnerInformation>`
            
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail, self).__init__()

                self.yang_name = "ipv6-single-hop-session-detail"
                self.yang_parent_name = "ipv6-single-hop-session-details"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.lsp_ping_info = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "ipv6-single-hop-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "ipv6-single-hop-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "ipv6-single-hop-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "ipv6-single-hop-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "ipv6-single-hop-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-single-hop-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "destination-address" or name == "interface-name" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_single_hop_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_single_hop_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-single-hop-session-detail"):
                for c in self.ipv6_single_hop_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6SingleHopSessionDetails.Ipv6SingleHopSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_single_hop_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-single-hop-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4MultiHopCounters(Entity):
        """
        IPv4 multiple hop Counters
        
        .. attribute:: ipv4_multi_hop_packet_counters
        
        	Table of IPv4 multiple hop Packet counters
        	**type**\:   :py:class:`Ipv4MultiHopPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4MultiHopCounters, self).__init__()

            self.yang_name = "ipv4-multi-hop-counters"
            self.yang_parent_name = "bfd"

            self.ipv4_multi_hop_packet_counters = Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters()
            self.ipv4_multi_hop_packet_counters.parent = self
            self._children_name_map["ipv4_multi_hop_packet_counters"] = "ipv4-multi-hop-packet-counters"
            self._children_yang_names.add("ipv4-multi-hop-packet-counters")


        class Ipv4MultiHopPacketCounters(Entity):
            """
            Table of IPv4 multiple hop Packet counters
            
            .. attribute:: ipv4_multi_hop_packet_counter
            
            	IPv4 multiple hop Packet counters
            	**type**\: list of    :py:class:`Ipv4MultiHopPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters.Ipv4MultiHopPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters, self).__init__()

                self.yang_name = "ipv4-multi-hop-packet-counters"
                self.yang_parent_name = "ipv4-multi-hop-counters"

                self.ipv4_multi_hop_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters, self).__setattr__(name, value)


            class Ipv4MultiHopPacketCounter(Entity):
                """
                IPv4 multiple hop Packet counters
                
                .. attribute:: destination_address
                
                	Destination Address
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: location
                
                	Location
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: source_address
                
                	Source Address
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: vrf_name
                
                	VRF name
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters.Ipv4MultiHopPacketCounter, self).__init__()

                    self.yang_name = "ipv4-multi-hop-packet-counter"
                    self.yang_parent_name = "ipv4-multi-hop-packet-counters"

                    self.destination_address = YLeaf(YType.str, "destination-address")

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                    self.location = YLeaf(YType.str, "location")

                    self.source_address = YLeaf(YType.str, "source-address")

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("destination_address",
                                    "display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count",
                                    "location",
                                    "source_address",
                                    "vrf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters.Ipv4MultiHopPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters.Ipv4MultiHopPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.destination_address.is_set or
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set or
                        self.location.is_set or
                        self.source_address.is_set or
                        self.vrf_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.destination_address.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set or
                        self.location.yfilter != YFilter.not_set or
                        self.source_address.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4-multi-hop-packet-counter" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-counters/ipv4-multi-hop-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.destination_address.get_name_leafdata())
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())
                    if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.location.get_name_leafdata())
                    if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_address.get_name_leafdata())
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "destination-address" or name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count" or name == "location" or name == "source-address" or name == "vrf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "destination-address"):
                        self.destination_address = value
                        self.destination_address.value_namespace = name_space
                        self.destination_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "location"):
                        self.location = value
                        self.location.value_namespace = name_space
                        self.location.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-address"):
                        self.source_address = value
                        self.source_address.value_namespace = name_space
                        self.source_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv4_multi_hop_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ipv4_multi_hop_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-multi-hop-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4-multi-hop-packet-counter"):
                    for c in self.ipv4_multi_hop_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters.Ipv4MultiHopPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv4_multi_hop_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4-multi-hop-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.ipv4_multi_hop_packet_counters is not None and self.ipv4_multi_hop_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv4_multi_hop_packet_counters is not None and self.ipv4_multi_hop_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-multi-hop-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-multi-hop-packet-counters"):
                if (self.ipv4_multi_hop_packet_counters is None):
                    self.ipv4_multi_hop_packet_counters = Bfd.Ipv4MultiHopCounters.Ipv4MultiHopPacketCounters()
                    self.ipv4_multi_hop_packet_counters.parent = self
                    self._children_name_map["ipv4_multi_hop_packet_counters"] = "ipv4-multi-hop-packet-counters"
                return self.ipv4_multi_hop_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-multi-hop-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class SessionDetails(Entity):
        """
        Table of detailed information about IPv4
        singlehop BFD sessions in the System 
        
        .. attribute:: session_detail
        
        	Detailed information for a single IPv4 singlehop BFD session
        	**type**\: list of    :py:class:`SessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.SessionDetails, self).__init__()

            self.yang_name = "session-details"
            self.yang_parent_name = "bfd"

            self.session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.SessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.SessionDetails, self).__setattr__(name, value)


        class SessionDetail(Entity):
            """
            Detailed information for a single IPv4
            singlehop BFD session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation>`
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.OwnerInformation>`
            
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.SessionDetails.SessionDetail, self).__init__()

                self.yang_name = "session-detail"
                self.yang_parent_name = "session-details"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.lsp_ping_info = Bfd.SessionDetails.SessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.SessionDetails.SessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.SessionDetails.SessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "location") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.SessionDetails.SessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.SessionDetails.SessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionDetails.SessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.SessionDetails.SessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.SessionDetails.SessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.SessionDetails.SessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.SessionDetails.SessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.SessionDetails.SessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.SessionDetails.SessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.SessionDetails.SessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.SessionDetails.SessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.SessionDetails.SessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.SessionDetails.SessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.SessionDetails.SessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionDetails.SessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.SessionDetails.SessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.SessionDetails.SessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.SessionDetails.SessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.SessionDetails.SessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionDetails.SessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.SessionDetails.SessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.SessionDetails.SessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.SessionDetails.SessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionDetails.SessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.SessionDetails.SessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.SessionDetails.SessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.SessionDetails.SessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.SessionDetails.SessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.SessionDetails.SessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.SessionDetails.SessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.SessionDetails.SessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.SessionDetails.SessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.SessionDetails.SessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.SessionDetails.SessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.SessionDetails.SessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.SessionDetails.SessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.SessionDetails.SessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "destination-address" or name == "interface-name" or name == "location"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-detail"):
                for c in self.session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.SessionDetails.SessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopMultiPaths(Entity):
        """
        IPv4 single hop multipath
        
        .. attribute:: ipv4_single_hop_multi_path
        
        	IPv4 single hop multipath table
        	**type**\: list of    :py:class:`Ipv4SingleHopMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopMultiPaths.Ipv4SingleHopMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopMultiPaths, self).__init__()

            self.yang_name = "ipv4-single-hop-multi-paths"
            self.yang_parent_name = "bfd"

            self.ipv4_single_hop_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4SingleHopMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4SingleHopMultiPaths, self).__setattr__(name, value)


        class Ipv4SingleHopMultiPath(Entity):
            """
            IPv4 single hop multipath table
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopMultiPaths.Ipv4SingleHopMultiPath, self).__init__()

                self.yang_name = "ipv4-single-hop-multi-path"
                self.yang_parent_name = "ipv4-single-hop-multi-paths"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.state = YLeaf(YType.enumeration, "state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "incoming_label_xr",
                                "interface_name",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopMultiPaths.Ipv4SingleHopMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopMultiPaths.Ipv4SingleHopMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.incoming_label_xr.is_set or
                    self.interface_name.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.state.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-single-hop-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "destination-address" or name == "incoming-label-xr" or name == "interface-name" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_single_hop_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_single_hop_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-single-hop-multi-path"):
                for c in self.ipv4_single_hop_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4SingleHopMultiPaths.Ipv4SingleHopMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_single_hop_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-single-hop-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4SingleHopSessionBriefs(Entity):
        """
        Table of brief information about all IPv4
        singlehop BFD sessions in the System
        
        .. attribute:: ipv4_single_hop_session_brief
        
        	Brief information for a single IPv4 singlehop BFD session
        	**type**\: list of    :py:class:`Ipv4SingleHopSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4SingleHopSessionBriefs, self).__init__()

            self.yang_name = "ipv4-single-hop-session-briefs"
            self.yang_parent_name = "bfd"

            self.ipv4_single_hop_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4SingleHopSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4SingleHopSessionBriefs, self).__setattr__(name, value)


        class Ipv4SingleHopSessionBrief(Entity):
            """
            Brief information for a single IPv4 singlehop
            BFD session
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief, self).__init__()

                self.yang_name = "ipv4-single-hop-session-brief"
                self.yang_parent_name = "ipv4-single-hop-session-briefs"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.state = YLeaf(YType.enumeration, "state")

                self.status_brief_information = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "ipv4-single-hop-session-brief"

                    self.async_interval_multiplier = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/ipv4-single-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/ipv4-single-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/ipv4-single-hop-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.state.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-single-hop-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "destination-address" or name == "interface-name" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_single_hop_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_single_hop_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-single-hop-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-single-hop-session-brief"):
                for c in self.ipv4_single_hop_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4SingleHopSessionBriefs.Ipv4SingleHopSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_single_hop_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-single-hop-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6MultiHopCounters(Entity):
        """
        IPv6 multiple hop Counters
        
        .. attribute:: ipv6_multi_hop_packet_counters
        
        	Table of IPv6 multiple hop Packet counters
        	**type**\:   :py:class:`Ipv6MultiHopPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6MultiHopCounters, self).__init__()

            self.yang_name = "ipv6-multi-hop-counters"
            self.yang_parent_name = "bfd"

            self.ipv6_multi_hop_packet_counters = Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters()
            self.ipv6_multi_hop_packet_counters.parent = self
            self._children_name_map["ipv6_multi_hop_packet_counters"] = "ipv6-multi-hop-packet-counters"
            self._children_yang_names.add("ipv6-multi-hop-packet-counters")


        class Ipv6MultiHopPacketCounters(Entity):
            """
            Table of IPv6 multiple hop Packet counters
            
            .. attribute:: ipv6_multi_hop_packet_counter
            
            	IPv4 multiple hop Packet counters
            	**type**\: list of    :py:class:`Ipv6MultiHopPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters.Ipv6MultiHopPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters, self).__init__()

                self.yang_name = "ipv6-multi-hop-packet-counters"
                self.yang_parent_name = "ipv6-multi-hop-counters"

                self.ipv6_multi_hop_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters, self).__setattr__(name, value)


            class Ipv6MultiHopPacketCounter(Entity):
                """
                IPv4 multiple hop Packet counters
                
                .. attribute:: destination_address
                
                	Destination Address
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: location
                
                	Location
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: source_address
                
                	Source Address
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: vrf_name
                
                	VRF name
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters.Ipv6MultiHopPacketCounter, self).__init__()

                    self.yang_name = "ipv6-multi-hop-packet-counter"
                    self.yang_parent_name = "ipv6-multi-hop-packet-counters"

                    self.destination_address = YLeaf(YType.str, "destination-address")

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                    self.location = YLeaf(YType.str, "location")

                    self.source_address = YLeaf(YType.str, "source-address")

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("destination_address",
                                    "display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count",
                                    "location",
                                    "source_address",
                                    "vrf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters.Ipv6MultiHopPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters.Ipv6MultiHopPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.destination_address.is_set or
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set or
                        self.location.is_set or
                        self.source_address.is_set or
                        self.vrf_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.destination_address.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set or
                        self.location.yfilter != YFilter.not_set or
                        self.source_address.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv6-multi-hop-packet-counter" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-counters/ipv6-multi-hop-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.destination_address.get_name_leafdata())
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())
                    if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.location.get_name_leafdata())
                    if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.source_address.get_name_leafdata())
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "destination-address" or name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count" or name == "location" or name == "source-address" or name == "vrf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "destination-address"):
                        self.destination_address = value
                        self.destination_address.value_namespace = name_space
                        self.destination_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "location"):
                        self.location = value
                        self.location.value_namespace = name_space
                        self.location.value_namespace_prefix = name_space_prefix
                    if(value_path == "source-address"):
                        self.source_address = value
                        self.source_address.value_namespace = name_space
                        self.source_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv6_multi_hop_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ipv6_multi_hop_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-multi-hop-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv6-multi-hop-packet-counter"):
                    for c in self.ipv6_multi_hop_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters.Ipv6MultiHopPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv6_multi_hop_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv6-multi-hop-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.ipv6_multi_hop_packet_counters is not None and self.ipv6_multi_hop_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv6_multi_hop_packet_counters is not None and self.ipv6_multi_hop_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-multi-hop-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-multi-hop-packet-counters"):
                if (self.ipv6_multi_hop_packet_counters is None):
                    self.ipv6_multi_hop_packet_counters = Bfd.Ipv6MultiHopCounters.Ipv6MultiHopPacketCounters()
                    self.ipv6_multi_hop_packet_counters.parent = self
                    self._children_name_map["ipv6_multi_hop_packet_counters"] = "ipv6-multi-hop-packet-counters"
                return self.ipv6_multi_hop_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-multi-hop-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopLocationSummaries(Entity):
        """
        Table of summary information about BFD IPv6
        singlehop sessions per location
        
        .. attribute:: ipv6_single_hop_location_summary
        
        	Summary information for BFD IPv6 singlehop sessions for location
        	**type**\: list of    :py:class:`Ipv6SingleHopLocationSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopLocationSummaries, self).__init__()

            self.yang_name = "ipv6-single-hop-location-summaries"
            self.yang_parent_name = "bfd"

            self.ipv6_single_hop_location_summary = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6SingleHopLocationSummaries, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6SingleHopLocationSummaries, self).__setattr__(name, value)


        class Ipv6SingleHopLocationSummary(Entity):
            """
            Summary information for BFD IPv6 singlehop
            sessions for location
            
            .. attribute:: location_name  <key>
            
            	Location Name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: session_state
            
            	Statistics of states for sessions
            	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary.SessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary, self).__init__()

                self.yang_name = "ipv6-single-hop-location-summary"
                self.yang_parent_name = "ipv6-single-hop-location-summaries"

                self.location_name = YLeaf(YType.str, "location-name")

                self.session_state = Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary.SessionState()
                self.session_state.parent = self
                self._children_name_map["session_state"] = "session-state"
                self._children_yang_names.add("session-state")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("location_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary, self).__setattr__(name, value)


            class SessionState(Entity):
                """
                Statistics of states for sessions
                
                .. attribute:: down_count
                
                	Number of sessions in down state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: retry_count
                
                	Number of sessions in retry state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: standby_count
                
                	Number of sessions in standby state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_count
                
                	Number of sessions in database
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: unknown_count
                
                	Number of sessions in unknown state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: up_count
                
                	Number of sessions in up state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary.SessionState, self).__init__()

                    self.yang_name = "session-state"
                    self.yang_parent_name = "ipv6-single-hop-location-summary"

                    self.down_count = YLeaf(YType.uint32, "down-count")

                    self.retry_count = YLeaf(YType.uint32, "retry-count")

                    self.standby_count = YLeaf(YType.uint32, "standby-count")

                    self.total_count = YLeaf(YType.uint32, "total-count")

                    self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                    self.up_count = YLeaf(YType.uint32, "up-count")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_count",
                                    "retry_count",
                                    "standby_count",
                                    "total_count",
                                    "unknown_count",
                                    "up_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary.SessionState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary.SessionState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_count.is_set or
                        self.retry_count.is_set or
                        self.standby_count.is_set or
                        self.total_count.is_set or
                        self.unknown_count.is_set or
                        self.up_count.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_count.yfilter != YFilter.not_set or
                        self.retry_count.yfilter != YFilter.not_set or
                        self.standby_count.yfilter != YFilter.not_set or
                        self.total_count.yfilter != YFilter.not_set or
                        self.unknown_count.yfilter != YFilter.not_set or
                        self.up_count.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_count.get_name_leafdata())
                    if (self.retry_count.is_set or self.retry_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.retry_count.get_name_leafdata())
                    if (self.standby_count.is_set or self.standby_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_count.get_name_leafdata())
                    if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_count.get_name_leafdata())
                    if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unknown_count.get_name_leafdata())
                    if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-count" or name == "retry-count" or name == "standby-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-count"):
                        self.down_count = value
                        self.down_count.value_namespace = name_space
                        self.down_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "retry-count"):
                        self.retry_count = value
                        self.retry_count.value_namespace = name_space
                        self.retry_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-count"):
                        self.standby_count = value
                        self.standby_count.value_namespace = name_space
                        self.standby_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-count"):
                        self.total_count = value
                        self.total_count.value_namespace = name_space
                        self.total_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "unknown-count"):
                        self.unknown_count = value
                        self.unknown_count.value_namespace = name_space
                        self.unknown_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-count"):
                        self.up_count = value
                        self.up_count.value_namespace = name_space
                        self.up_count.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.location_name.is_set or
                    (self.session_state is not None and self.session_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.location_name.yfilter != YFilter.not_set or
                    (self.session_state is not None and self.session_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-single-hop-location-summary" + "[location-name='" + self.location_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-location-summaries/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.location_name.is_set or self.location_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session-state"):
                    if (self.session_state is None):
                        self.session_state = Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary.SessionState()
                        self.session_state.parent = self
                        self._children_name_map["session_state"] = "session-state"
                    return self.session_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session-state" or name == "location-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "location-name"):
                    self.location_name = value
                    self.location_name.value_namespace = name_space
                    self.location_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_single_hop_location_summary:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_single_hop_location_summary:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-location-summaries" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-single-hop-location-summary"):
                for c in self.ipv6_single_hop_location_summary:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6SingleHopLocationSummaries.Ipv6SingleHopLocationSummary()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_single_hop_location_summary.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-single-hop-location-summary"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class LabelCounters(Entity):
        """
        Label Counters
        
        .. attribute:: label_packet_counters
        
        	Table of Label Packet counters
        	**type**\:   :py:class:`LabelPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelCounters.LabelPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.LabelCounters, self).__init__()

            self.yang_name = "label-counters"
            self.yang_parent_name = "bfd"

            self.label_packet_counters = Bfd.LabelCounters.LabelPacketCounters()
            self.label_packet_counters.parent = self
            self._children_name_map["label_packet_counters"] = "label-packet-counters"
            self._children_yang_names.add("label-packet-counters")


        class LabelPacketCounters(Entity):
            """
            Table of Label Packet counters
            
            .. attribute:: label_packet_counter
            
            	Interface Label Packet counters
            	**type**\: list of    :py:class:`LabelPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.LabelCounters.LabelPacketCounters.LabelPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.LabelCounters.LabelPacketCounters, self).__init__()

                self.yang_name = "label-packet-counters"
                self.yang_parent_name = "label-counters"

                self.label_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.LabelCounters.LabelPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.LabelCounters.LabelPacketCounters, self).__setattr__(name, value)


            class LabelPacketCounter(Entity):
                """
                Interface Label Packet counters
                
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interface_name
                
                	Interface Name
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: location
                
                	Location
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.LabelCounters.LabelPacketCounters.LabelPacketCounter, self).__init__()

                    self.yang_name = "label-packet-counter"
                    self.yang_parent_name = "label-packet-counters"

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.location = YLeaf(YType.str, "location")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "hello_receive_count",
                                    "hello_transmit_count",
                                    "interface_name",
                                    "location") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.LabelCounters.LabelPacketCounters.LabelPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.LabelCounters.LabelPacketCounters.LabelPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set or
                        self.interface_name.is_set or
                        self.location.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.location.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "label-packet-counter" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-counters/label-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.location.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "hello-receive-count" or name == "hello-transmit-count" or name == "interface-name" or name == "location"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "location"):
                        self.location = value
                        self.location.value_namespace = name_space
                        self.location.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.label_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.label_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/label-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "label-packet-counter"):
                    for c in self.label_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.LabelCounters.LabelPacketCounters.LabelPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.label_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "label-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.label_packet_counters is not None and self.label_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.label_packet_counters is not None and self.label_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "label-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "label-packet-counters"):
                if (self.label_packet_counters is None):
                    self.label_packet_counters = Bfd.LabelCounters.LabelPacketCounters()
                    self.label_packet_counters.parent = self
                    self._children_name_map["label_packet_counters"] = "label-packet-counters"
                return self.label_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "label-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteHeadSessionDetails(Entity):
        """
        Table of detailed information about all IPv4 BFD
        over MPLS\-TE Head sessions in the System
        
        .. attribute:: ipv4bf_do_mplste_head_session_detail
        
        	Detailed information for a single IPv4 BFD over MPLS\-TE head session
        	**type**\: list of    :py:class:`Ipv4BfDoMplsteHeadSessionDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-head-session-details"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_head_session_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails, self).__setattr__(name, value)


        class Ipv4BfDoMplsteHeadSessionDetail(Entity):
            """
            Detailed information for a single IPv4 BFD over
            MPLS\-TE head session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation>`
            
            .. attribute:: fe_ctype
            
            	FEC Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_ctype
            
            	FEC C Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_destination
            
            	FEC Destination
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_extended_tunnel_id
            
            	FEC Extended Tunnel ID
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_source
            
            	FEC Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_subgroup_id
            
            	FEC Subgroup ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_subgroup_originator
            
            	FEC Subgroup originator
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_tunnel_id
            
            	FEC Tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: feclspid
            
            	FEC LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fecp2mpid
            
            	FEC P2MP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: lsp_ping_info
            
            	LSP Ping Info
            	**type**\:   :py:class:`LspPingInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo>`
            
            .. attribute:: mp_download_state
            
            	MP Dowload State
            	**type**\:   :py:class:`MpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState>`
            
            .. attribute:: owner_information
            
            	Client applications owning the session
            	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.OwnerInformation>`
            
            .. attribute:: status_information
            
            	Session status information
            	**type**\:   :py:class:`StatusInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-head-session-detail"
                self.yang_parent_name = "ipv4bf-do-mplste-head-session-details"

                self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                self.fec_destination = YLeaf(YType.str, "fec-destination")

                self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                self.fec_source = YLeaf(YType.str, "fec-source")

                self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                self.feclspid = YLeaf(YType.int32, "feclspid")

                self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

                self.lsp_ping_info = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo()
                self.lsp_ping_info.parent = self
                self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                self._children_yang_names.add("lsp-ping-info")

                self.mp_download_state = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState()
                self.mp_download_state.parent = self
                self._children_name_map["mp_download_state"] = "mp-download-state"
                self._children_yang_names.add("mp-download-state")

                self.status_information = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation()
                self.status_information.parent = self
                self._children_name_map["status_information"] = "status-information"
                self._children_yang_names.add("status-information")

                self.association_information = YList(self)
                self.owner_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("fe_ctype",
                                "fec_ctype",
                                "fec_destination",
                                "fec_extended_tunnel_id",
                                "fec_source",
                                "fec_subgroup_id",
                                "fec_subgroup_originator",
                                "fec_tunnel_id",
                                "feclspid",
                                "fecp2mpid",
                                "incoming_label",
                                "interface_name",
                                "location",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail, self).__setattr__(name, value)


            class StatusInformation(Entity):
                """
                Session status information
                
                .. attribute:: async_receive_statistics
                
                	Statistics of Interval between Async Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`AsyncReceiveStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncReceiveStatistics>`
                
                .. attribute:: async_transmit_statistics
                
                	Statistics of Interval between Async Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`AsyncTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncTransmitStatistics>`
                
                .. attribute:: desired_minimum_echo_transmit_interval
                
                	Desired minimum echo transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: echo_received_statistics
                
                	Statistics of Interval between Echo Packets Received (in milli\-seconds)
                	**type**\:   :py:class:`EchoReceivedStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoReceivedStatistics>`
                
                .. attribute:: echo_transmit_statistics
                
                	Statistics of Interval between Echo Packets Transmitted (in milli\-seconds)
                	**type**\:   :py:class:`EchoTransmitStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoTransmitStatistics>`
                
                .. attribute:: internal_label
                
                	Internal Label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: last_state_change
                
                	Time since last state change
                	**type**\:   :py:class:`LastStateChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.LastStateChange>`
                
                .. attribute:: latency_average
                
                	Average value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_maximum
                
                	Maximum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_minimum
                
                	Minimum value of Latency (in micro\-seconds)
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: latency_number
                
                	Number of Latency Samples. Time between Transmit and Receive
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: node_id
                
                	Location where session is housed
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: receive_packet
                
                	Receive Packet
                	**type**\:   :py:class:`ReceivePacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.ReceivePacket>`
                
                .. attribute:: remote_discriminator
                
                	Session's Remote discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_negotiated_interval
                
                	Remote Negotiated Interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: session_subtype
                
                	Session subtype
                	**type**\:  str
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                .. attribute:: source_address
                
                	Source address
                	**type**\:   :py:class:`SourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.SourceAddress>`
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                .. attribute:: status_brief_information
                
                	Brief Status Information
                	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation>`
                
                .. attribute:: to_up_state_count
                
                	Number of times session state went to UP
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: transmit_packet
                
                	Transmit Packet
                	**type**\:   :py:class:`TransmitPacket <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.TransmitPacket>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation, self).__init__()

                    self.yang_name = "status-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-session-detail"

                    self.desired_minimum_echo_transmit_interval = YLeaf(YType.uint32, "desired-minimum-echo-transmit-interval")

                    self.internal_label = YLeaf(YType.uint32, "internal-label")

                    self.latency_average = YLeaf(YType.uint32, "latency-average")

                    self.latency_maximum = YLeaf(YType.uint32, "latency-maximum")

                    self.latency_minimum = YLeaf(YType.uint32, "latency-minimum")

                    self.latency_number = YLeaf(YType.uint32, "latency-number")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.node_id = YLeaf(YType.str, "node-id")

                    self.remote_discriminator = YLeaf(YType.uint32, "remote-discriminator")

                    self.remote_negotiated_interval = YLeaf(YType.uint32, "remote-negotiated-interval")

                    self.session_subtype = YLeaf(YType.str, "session-subtype")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.state = YLeaf(YType.enumeration, "state")

                    self.to_up_state_count = YLeaf(YType.uint32, "to-up-state-count")

                    self.async_receive_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncReceiveStatistics()
                    self.async_receive_statistics.parent = self
                    self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                    self._children_yang_names.add("async-receive-statistics")

                    self.async_transmit_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncTransmitStatistics()
                    self.async_transmit_statistics.parent = self
                    self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                    self._children_yang_names.add("async-transmit-statistics")

                    self.echo_received_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoReceivedStatistics()
                    self.echo_received_statistics.parent = self
                    self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                    self._children_yang_names.add("echo-received-statistics")

                    self.echo_transmit_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoTransmitStatistics()
                    self.echo_transmit_statistics.parent = self
                    self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                    self._children_yang_names.add("echo-transmit-statistics")

                    self.last_state_change = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.LastStateChange()
                    self.last_state_change.parent = self
                    self._children_name_map["last_state_change"] = "last-state-change"
                    self._children_yang_names.add("last-state-change")

                    self.receive_packet = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.ReceivePacket()
                    self.receive_packet.parent = self
                    self._children_name_map["receive_packet"] = "receive-packet"
                    self._children_yang_names.add("receive-packet")

                    self.source_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.SourceAddress()
                    self.source_address.parent = self
                    self._children_name_map["source_address"] = "source-address"
                    self._children_yang_names.add("source-address")

                    self.status_brief_information = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation()
                    self.status_brief_information.parent = self
                    self._children_name_map["status_brief_information"] = "status-brief-information"
                    self._children_yang_names.add("status-brief-information")

                    self.transmit_packet = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.TransmitPacket()
                    self.transmit_packet.parent = self
                    self._children_name_map["transmit_packet"] = "transmit-packet"
                    self._children_yang_names.add("transmit-packet")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("desired_minimum_echo_transmit_interval",
                                    "internal_label",
                                    "latency_average",
                                    "latency_maximum",
                                    "latency_minimum",
                                    "latency_number",
                                    "local_discriminator",
                                    "node_id",
                                    "remote_discriminator",
                                    "remote_negotiated_interval",
                                    "session_subtype",
                                    "sessiontype",
                                    "state",
                                    "to_up_state_count") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation, self).__setattr__(name, value)


                class SourceAddress(Entity):
                    """
                    Source address
                    
                    .. attribute:: afi
                    
                    	AFI
                    	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                    
                    .. attribute:: dummy
                    
                    	No Address
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: ipv4
                    
                    	IPv4 address type
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: ipv6
                    
                    	IPv6 address type
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.SourceAddress, self).__init__()

                        self.yang_name = "source-address"
                        self.yang_parent_name = "status-information"

                        self.afi = YLeaf(YType.enumeration, "afi")

                        self.dummy = YLeaf(YType.uint8, "dummy")

                        self.ipv4 = YLeaf(YType.str, "ipv4")

                        self.ipv6 = YLeaf(YType.str, "ipv6")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("afi",
                                        "dummy",
                                        "ipv4",
                                        "ipv6") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.SourceAddress, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.afi.is_set or
                            self.dummy.is_set or
                            self.ipv4.is_set or
                            self.ipv6.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.afi.yfilter != YFilter.not_set or
                            self.dummy.yfilter != YFilter.not_set or
                            self.ipv4.yfilter != YFilter.not_set or
                            self.ipv6.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source-address" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.afi.get_name_leafdata())
                        if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.dummy.get_name_leafdata())
                        if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv4.get_name_leafdata())
                        if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipv6.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "afi"):
                            self.afi = value
                            self.afi.value_namespace = name_space
                            self.afi.value_namespace_prefix = name_space_prefix
                        if(value_path == "dummy"):
                            self.dummy = value
                            self.dummy.value_namespace = name_space
                            self.dummy.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv4"):
                            self.ipv4 = value
                            self.ipv4.value_namespace = name_space
                            self.ipv4.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipv6"):
                            self.ipv6 = value
                            self.ipv6.value_namespace = name_space
                            self.ipv6.value_namespace_prefix = name_space_prefix


                class LastStateChange(Entity):
                    """
                    Time since last state change
                    
                    .. attribute:: days
                    
                    	Number of days since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: day
                    
                    .. attribute:: hours
                    
                    	Number of hours since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: hour
                    
                    .. attribute:: minutes
                    
                    	Number of mins since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: minute
                    
                    .. attribute:: seconds
                    
                    	Number of seconds since last session state transition
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.LastStateChange, self).__init__()

                        self.yang_name = "last-state-change"
                        self.yang_parent_name = "status-information"

                        self.days = YLeaf(YType.uint32, "days")

                        self.hours = YLeaf(YType.uint8, "hours")

                        self.minutes = YLeaf(YType.uint8, "minutes")

                        self.seconds = YLeaf(YType.uint8, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("days",
                                        "hours",
                                        "minutes",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.LastStateChange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.days.is_set or
                            self.hours.is_set or
                            self.minutes.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.days.yfilter != YFilter.not_set or
                            self.hours.yfilter != YFilter.not_set or
                            self.minutes.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "last-state-change" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.days.is_set or self.days.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.days.get_name_leafdata())
                        if (self.hours.is_set or self.hours.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hours.get_name_leafdata())
                        if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minutes.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "days" or name == "hours" or name == "minutes" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "days"):
                            self.days = value
                            self.days.value_namespace = name_space
                            self.days.value_namespace_prefix = name_space_prefix
                        if(value_path == "hours"):
                            self.hours = value
                            self.hours.value_namespace = name_space
                            self.hours.value_namespace_prefix = name_space_prefix
                        if(value_path == "minutes"):
                            self.minutes = value
                            self.minutes.value_namespace = name_space
                            self.minutes.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class TransmitPacket(Entity):
                    """
                    Transmit Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.TransmitPacket, self).__init__()

                        self.yang_name = "transmit-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.TransmitPacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "transmit-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class ReceivePacket(Entity):
                    """
                    Receive Packet
                    
                    .. attribute:: authentication_present
                    
                    	Requesting authentication for the session
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: control_plane_independent
                    
                    	BFD implementation does not share fate with its control plane
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: demand
                    
                    	Demand mode
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: desired_minimum_transmit_interval
                    
                    	Desired minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: diagnostic
                    
                    	Diagnostic
                    	**type**\:   :py:class:`BfdMgmtSessionDiag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionDiag>`
                    
                    .. attribute:: final
                    
                    	Final bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ihear_you
                    
                    	I Hear You (v0)
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: length
                    
                    	Length
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: my_discriminator
                    
                    	My Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: poll
                    
                    	Poll bit
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: required_minimum_echo_receive_interval
                    
                    	Required echo receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: required_minimum_receive_interval
                    
                    	Required receive interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: state
                    
                    	State (v1)
                    	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                    
                    .. attribute:: version
                    
                    	Version
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: your_discriminator
                    
                    	Your Discriminator
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.ReceivePacket, self).__init__()

                        self.yang_name = "receive-packet"
                        self.yang_parent_name = "status-information"

                        self.authentication_present = YLeaf(YType.int32, "authentication-present")

                        self.control_plane_independent = YLeaf(YType.int32, "control-plane-independent")

                        self.demand = YLeaf(YType.int32, "demand")

                        self.desired_minimum_transmit_interval = YLeaf(YType.uint32, "desired-minimum-transmit-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.diagnostic = YLeaf(YType.enumeration, "diagnostic")

                        self.final = YLeaf(YType.int32, "final")

                        self.ihear_you = YLeaf(YType.int32, "ihear-you")

                        self.length = YLeaf(YType.uint32, "length")

                        self.my_discriminator = YLeaf(YType.uint32, "my-discriminator")

                        self.poll = YLeaf(YType.int32, "poll")

                        self.required_minimum_echo_receive_interval = YLeaf(YType.uint32, "required-minimum-echo-receive-interval")

                        self.required_minimum_receive_interval = YLeaf(YType.uint32, "required-minimum-receive-interval")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.version = YLeaf(YType.uint8, "version")

                        self.your_discriminator = YLeaf(YType.uint32, "your-discriminator")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("authentication_present",
                                        "control_plane_independent",
                                        "demand",
                                        "desired_minimum_transmit_interval",
                                        "detection_multiplier",
                                        "diagnostic",
                                        "final",
                                        "ihear_you",
                                        "length",
                                        "my_discriminator",
                                        "poll",
                                        "required_minimum_echo_receive_interval",
                                        "required_minimum_receive_interval",
                                        "state",
                                        "version",
                                        "your_discriminator") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.ReceivePacket, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.authentication_present.is_set or
                            self.control_plane_independent.is_set or
                            self.demand.is_set or
                            self.desired_minimum_transmit_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.diagnostic.is_set or
                            self.final.is_set or
                            self.ihear_you.is_set or
                            self.length.is_set or
                            self.my_discriminator.is_set or
                            self.poll.is_set or
                            self.required_minimum_echo_receive_interval.is_set or
                            self.required_minimum_receive_interval.is_set or
                            self.state.is_set or
                            self.version.is_set or
                            self.your_discriminator.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.authentication_present.yfilter != YFilter.not_set or
                            self.control_plane_independent.yfilter != YFilter.not_set or
                            self.demand.yfilter != YFilter.not_set or
                            self.desired_minimum_transmit_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.diagnostic.yfilter != YFilter.not_set or
                            self.final.yfilter != YFilter.not_set or
                            self.ihear_you.yfilter != YFilter.not_set or
                            self.length.yfilter != YFilter.not_set or
                            self.my_discriminator.yfilter != YFilter.not_set or
                            self.poll.yfilter != YFilter.not_set or
                            self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set or
                            self.required_minimum_receive_interval.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set or
                            self.your_discriminator.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "receive-packet" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.authentication_present.is_set or self.authentication_present.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.authentication_present.get_name_leafdata())
                        if (self.control_plane_independent.is_set or self.control_plane_independent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.control_plane_independent.get_name_leafdata())
                        if (self.demand.is_set or self.demand.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.demand.get_name_leafdata())
                        if (self.desired_minimum_transmit_interval.is_set or self.desired_minimum_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.desired_minimum_transmit_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.diagnostic.is_set or self.diagnostic.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.diagnostic.get_name_leafdata())
                        if (self.final.is_set or self.final.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.final.get_name_leafdata())
                        if (self.ihear_you.is_set or self.ihear_you.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ihear_you.get_name_leafdata())
                        if (self.length.is_set or self.length.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.length.get_name_leafdata())
                        if (self.my_discriminator.is_set or self.my_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.my_discriminator.get_name_leafdata())
                        if (self.poll.is_set or self.poll.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.poll.get_name_leafdata())
                        if (self.required_minimum_echo_receive_interval.is_set or self.required_minimum_echo_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_echo_receive_interval.get_name_leafdata())
                        if (self.required_minimum_receive_interval.is_set or self.required_minimum_receive_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.required_minimum_receive_interval.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())
                        if (self.your_discriminator.is_set or self.your_discriminator.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.your_discriminator.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "authentication-present" or name == "control-plane-independent" or name == "demand" or name == "desired-minimum-transmit-interval" or name == "detection-multiplier" or name == "diagnostic" or name == "final" or name == "ihear-you" or name == "length" or name == "my-discriminator" or name == "poll" or name == "required-minimum-echo-receive-interval" or name == "required-minimum-receive-interval" or name == "state" or name == "version" or name == "your-discriminator"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "authentication-present"):
                            self.authentication_present = value
                            self.authentication_present.value_namespace = name_space
                            self.authentication_present.value_namespace_prefix = name_space_prefix
                        if(value_path == "control-plane-independent"):
                            self.control_plane_independent = value
                            self.control_plane_independent.value_namespace = name_space
                            self.control_plane_independent.value_namespace_prefix = name_space_prefix
                        if(value_path == "demand"):
                            self.demand = value
                            self.demand.value_namespace = name_space
                            self.demand.value_namespace_prefix = name_space_prefix
                        if(value_path == "desired-minimum-transmit-interval"):
                            self.desired_minimum_transmit_interval = value
                            self.desired_minimum_transmit_interval.value_namespace = name_space
                            self.desired_minimum_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "diagnostic"):
                            self.diagnostic = value
                            self.diagnostic.value_namespace = name_space
                            self.diagnostic.value_namespace_prefix = name_space_prefix
                        if(value_path == "final"):
                            self.final = value
                            self.final.value_namespace = name_space
                            self.final.value_namespace_prefix = name_space_prefix
                        if(value_path == "ihear-you"):
                            self.ihear_you = value
                            self.ihear_you.value_namespace = name_space
                            self.ihear_you.value_namespace_prefix = name_space_prefix
                        if(value_path == "length"):
                            self.length = value
                            self.length.value_namespace = name_space
                            self.length.value_namespace_prefix = name_space_prefix
                        if(value_path == "my-discriminator"):
                            self.my_discriminator = value
                            self.my_discriminator.value_namespace = name_space
                            self.my_discriminator.value_namespace_prefix = name_space_prefix
                        if(value_path == "poll"):
                            self.poll = value
                            self.poll.value_namespace = name_space
                            self.poll.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-echo-receive-interval"):
                            self.required_minimum_echo_receive_interval = value
                            self.required_minimum_echo_receive_interval.value_namespace = name_space
                            self.required_minimum_echo_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "required-minimum-receive-interval"):
                            self.required_minimum_receive_interval = value
                            self.required_minimum_receive_interval.value_namespace = name_space
                            self.required_minimum_receive_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix
                        if(value_path == "your-discriminator"):
                            self.your_discriminator = value
                            self.your_discriminator.value_namespace = name_space
                            self.your_discriminator.value_namespace_prefix = name_space_prefix


                class StatusBriefInformation(Entity):
                    """
                    Brief Status Information
                    
                    .. attribute:: async_interval_multiplier
                    
                    	Async Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier>`
                    
                    .. attribute:: echo_interval_multiplier
                    
                    	Echo Interval and Detect Multiplier Information
                    	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier>`
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation, self).__init__()

                        self.yang_name = "status-brief-information"
                        self.yang_parent_name = "status-information"

                        self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                        self.async_interval_multiplier.parent = self
                        self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        self._children_yang_names.add("async-interval-multiplier")

                        self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                        self.echo_interval_multiplier.parent = self
                        self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        self._children_yang_names.add("echo-interval-multiplier")


                    class AsyncIntervalMultiplier(Entity):
                        """
                        Async Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_local_transmit_interval
                        
                        	Negotiated local transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_remote_transmit_interval
                        
                        	Negotiated remote transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                            self.yang_name = "async-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                            self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_local_transmit_interval",
                                            "negotiated_remote_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_local_transmit_interval.is_set or
                                self.negotiated_remote_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                                self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "async-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                            if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-local-transmit-interval"):
                                self.negotiated_local_transmit_interval = value
                                self.negotiated_local_transmit_interval.value_namespace = name_space
                                self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-remote-transmit-interval"):
                                self.negotiated_remote_transmit_interval = value
                                self.negotiated_remote_transmit_interval.value_namespace = name_space
                                self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                    class EchoIntervalMultiplier(Entity):
                        """
                        Echo Interval and Detect Multiplier Information
                        
                        .. attribute:: detection_multiplier
                        
                        	Detection Multiplier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: detection_time
                        
                        	Detection time in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        .. attribute:: negotiated_transmit_interval
                        
                        	Negotiated transmit interval in micro\-seconds
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: microsecond
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                            self.yang_name = "echo-interval-multiplier"
                            self.yang_parent_name = "status-brief-information"

                            self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                            self.detection_time = YLeaf(YType.uint32, "detection-time")

                            self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("detection_multiplier",
                                            "detection_time",
                                            "negotiated_transmit_interval") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.detection_multiplier.is_set or
                                self.detection_time.is_set or
                                self.negotiated_transmit_interval.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.detection_multiplier.yfilter != YFilter.not_set or
                                self.detection_time.yfilter != YFilter.not_set or
                                self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "echo-interval-multiplier" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/status-brief-information/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                            if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.detection_time.get_name_leafdata())
                            if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "detection-multiplier"):
                                self.detection_multiplier = value
                                self.detection_multiplier.value_namespace = name_space
                                self.detection_multiplier.value_namespace_prefix = name_space_prefix
                            if(value_path == "detection-time"):
                                self.detection_time = value
                                self.detection_time.value_namespace = name_space
                                self.detection_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "negotiated-transmit-interval"):
                                self.negotiated_transmit_interval = value
                                self.negotiated_transmit_interval.value_namespace = name_space
                                self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                            (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "status-brief-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "async-interval-multiplier"):
                            if (self.async_interval_multiplier is None):
                                self.async_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.AsyncIntervalMultiplier()
                                self.async_interval_multiplier.parent = self
                                self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                            return self.async_interval_multiplier

                        if (child_yang_name == "echo-interval-multiplier"):
                            if (self.echo_interval_multiplier is None):
                                self.echo_interval_multiplier = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation.EchoIntervalMultiplier()
                                self.echo_interval_multiplier.parent = self
                                self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                            return self.echo_interval_multiplier

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AsyncTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__init__()

                        self.yang_name = "async-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class AsyncReceiveStatistics(Entity):
                    """
                    Statistics of Interval between Async Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__init__()

                        self.yang_name = "async-receive-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncReceiveStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-receive-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoTransmitStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Transmitted (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoTransmitStatistics, self).__init__()

                        self.yang_name = "echo-transmit-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoTransmitStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-transmit-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix


                class EchoReceivedStatistics(Entity):
                    """
                    Statistics of Interval between Echo Packets
                    Received (in milli\-seconds)
                    
                    .. attribute:: average
                    
                    	Average of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: last
                    
                    	Time since last Transmit/Receive (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: maximum
                    
                    	Maximum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: minimum
                    
                    	Minimum of Transmit/Receive Interval (in milli\-seconds)
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: number
                    
                    	Number of Interval Samples between Packets sent/received
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoReceivedStatistics, self).__init__()

                        self.yang_name = "echo-received-statistics"
                        self.yang_parent_name = "status-information"

                        self.average = YLeaf(YType.uint32, "average")

                        self.last = YLeaf(YType.uint32, "last")

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                        self.number = YLeaf(YType.uint32, "number")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("average",
                                        "last",
                                        "maximum",
                                        "minimum",
                                        "number") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoReceivedStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.average.is_set or
                            self.last.is_set or
                            self.maximum.is_set or
                            self.minimum.is_set or
                            self.number.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.average.yfilter != YFilter.not_set or
                            self.last.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set or
                            self.number.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-received-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.average.is_set or self.average.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.average.get_name_leafdata())
                        if (self.last.is_set or self.last.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last.get_name_leafdata())
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())
                        if (self.number.is_set or self.number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "average" or name == "last" or name == "maximum" or name == "minimum" or name == "number"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "average"):
                            self.average = value
                            self.average.value_namespace = name_space
                            self.average.value_namespace_prefix = name_space_prefix
                        if(value_path == "last"):
                            self.last = value
                            self.last.value_namespace = name_space
                            self.last.value_namespace_prefix = name_space_prefix
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix
                        if(value_path == "number"):
                            self.number = value
                            self.number.value_namespace = name_space
                            self.number.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.desired_minimum_echo_transmit_interval.is_set or
                        self.internal_label.is_set or
                        self.latency_average.is_set or
                        self.latency_maximum.is_set or
                        self.latency_minimum.is_set or
                        self.latency_number.is_set or
                        self.local_discriminator.is_set or
                        self.node_id.is_set or
                        self.remote_discriminator.is_set or
                        self.remote_negotiated_interval.is_set or
                        self.session_subtype.is_set or
                        self.sessiontype.is_set or
                        self.state.is_set or
                        self.to_up_state_count.is_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_data()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_data()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_data()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_data()) or
                        (self.last_state_change is not None and self.last_state_change.has_data()) or
                        (self.receive_packet is not None and self.receive_packet.has_data()) or
                        (self.source_address is not None and self.source_address.has_data()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_data()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set or
                        self.internal_label.yfilter != YFilter.not_set or
                        self.latency_average.yfilter != YFilter.not_set or
                        self.latency_maximum.yfilter != YFilter.not_set or
                        self.latency_minimum.yfilter != YFilter.not_set or
                        self.latency_number.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.node_id.yfilter != YFilter.not_set or
                        self.remote_discriminator.yfilter != YFilter.not_set or
                        self.remote_negotiated_interval.yfilter != YFilter.not_set or
                        self.session_subtype.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set or
                        self.to_up_state_count.yfilter != YFilter.not_set or
                        (self.async_receive_statistics is not None and self.async_receive_statistics.has_operation()) or
                        (self.async_transmit_statistics is not None and self.async_transmit_statistics.has_operation()) or
                        (self.echo_received_statistics is not None and self.echo_received_statistics.has_operation()) or
                        (self.echo_transmit_statistics is not None and self.echo_transmit_statistics.has_operation()) or
                        (self.last_state_change is not None and self.last_state_change.has_operation()) or
                        (self.receive_packet is not None and self.receive_packet.has_operation()) or
                        (self.source_address is not None and self.source_address.has_operation()) or
                        (self.status_brief_information is not None and self.status_brief_information.has_operation()) or
                        (self.transmit_packet is not None and self.transmit_packet.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.desired_minimum_echo_transmit_interval.is_set or self.desired_minimum_echo_transmit_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.desired_minimum_echo_transmit_interval.get_name_leafdata())
                    if (self.internal_label.is_set or self.internal_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.internal_label.get_name_leafdata())
                    if (self.latency_average.is_set or self.latency_average.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_average.get_name_leafdata())
                    if (self.latency_maximum.is_set or self.latency_maximum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_maximum.get_name_leafdata())
                    if (self.latency_minimum.is_set or self.latency_minimum.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_minimum.get_name_leafdata())
                    if (self.latency_number.is_set or self.latency_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.latency_number.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.node_id.get_name_leafdata())
                    if (self.remote_discriminator.is_set or self.remote_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_discriminator.get_name_leafdata())
                    if (self.remote_negotiated_interval.is_set or self.remote_negotiated_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_negotiated_interval.get_name_leafdata())
                    if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_subtype.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())
                    if (self.to_up_state_count.is_set or self.to_up_state_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.to_up_state_count.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-receive-statistics"):
                        if (self.async_receive_statistics is None):
                            self.async_receive_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncReceiveStatistics()
                            self.async_receive_statistics.parent = self
                            self._children_name_map["async_receive_statistics"] = "async-receive-statistics"
                        return self.async_receive_statistics

                    if (child_yang_name == "async-transmit-statistics"):
                        if (self.async_transmit_statistics is None):
                            self.async_transmit_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.AsyncTransmitStatistics()
                            self.async_transmit_statistics.parent = self
                            self._children_name_map["async_transmit_statistics"] = "async-transmit-statistics"
                        return self.async_transmit_statistics

                    if (child_yang_name == "echo-received-statistics"):
                        if (self.echo_received_statistics is None):
                            self.echo_received_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoReceivedStatistics()
                            self.echo_received_statistics.parent = self
                            self._children_name_map["echo_received_statistics"] = "echo-received-statistics"
                        return self.echo_received_statistics

                    if (child_yang_name == "echo-transmit-statistics"):
                        if (self.echo_transmit_statistics is None):
                            self.echo_transmit_statistics = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.EchoTransmitStatistics()
                            self.echo_transmit_statistics.parent = self
                            self._children_name_map["echo_transmit_statistics"] = "echo-transmit-statistics"
                        return self.echo_transmit_statistics

                    if (child_yang_name == "last-state-change"):
                        if (self.last_state_change is None):
                            self.last_state_change = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.LastStateChange()
                            self.last_state_change.parent = self
                            self._children_name_map["last_state_change"] = "last-state-change"
                        return self.last_state_change

                    if (child_yang_name == "receive-packet"):
                        if (self.receive_packet is None):
                            self.receive_packet = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.ReceivePacket()
                            self.receive_packet.parent = self
                            self._children_name_map["receive_packet"] = "receive-packet"
                        return self.receive_packet

                    if (child_yang_name == "source-address"):
                        if (self.source_address is None):
                            self.source_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.SourceAddress()
                            self.source_address.parent = self
                            self._children_name_map["source_address"] = "source-address"
                        return self.source_address

                    if (child_yang_name == "status-brief-information"):
                        if (self.status_brief_information is None):
                            self.status_brief_information = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.StatusBriefInformation()
                            self.status_brief_information.parent = self
                            self._children_name_map["status_brief_information"] = "status-brief-information"
                        return self.status_brief_information

                    if (child_yang_name == "transmit-packet"):
                        if (self.transmit_packet is None):
                            self.transmit_packet = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation.TransmitPacket()
                            self.transmit_packet.parent = self
                            self._children_name_map["transmit_packet"] = "transmit-packet"
                        return self.transmit_packet

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-receive-statistics" or name == "async-transmit-statistics" or name == "echo-received-statistics" or name == "echo-transmit-statistics" or name == "last-state-change" or name == "receive-packet" or name == "source-address" or name == "status-brief-information" or name == "transmit-packet" or name == "desired-minimum-echo-transmit-interval" or name == "internal-label" or name == "latency-average" or name == "latency-maximum" or name == "latency-minimum" or name == "latency-number" or name == "local-discriminator" or name == "node-id" or name == "remote-discriminator" or name == "remote-negotiated-interval" or name == "session-subtype" or name == "sessiontype" or name == "state" or name == "to-up-state-count"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "desired-minimum-echo-transmit-interval"):
                        self.desired_minimum_echo_transmit_interval = value
                        self.desired_minimum_echo_transmit_interval.value_namespace = name_space
                        self.desired_minimum_echo_transmit_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "internal-label"):
                        self.internal_label = value
                        self.internal_label.value_namespace = name_space
                        self.internal_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-average"):
                        self.latency_average = value
                        self.latency_average.value_namespace = name_space
                        self.latency_average.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-maximum"):
                        self.latency_maximum = value
                        self.latency_maximum.value_namespace = name_space
                        self.latency_maximum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-minimum"):
                        self.latency_minimum = value
                        self.latency_minimum.value_namespace = name_space
                        self.latency_minimum.value_namespace_prefix = name_space_prefix
                    if(value_path == "latency-number"):
                        self.latency_number = value
                        self.latency_number.value_namespace = name_space
                        self.latency_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "node-id"):
                        self.node_id = value
                        self.node_id.value_namespace = name_space
                        self.node_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-discriminator"):
                        self.remote_discriminator = value
                        self.remote_discriminator.value_namespace = name_space
                        self.remote_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-negotiated-interval"):
                        self.remote_negotiated_interval = value
                        self.remote_negotiated_interval.value_namespace = name_space
                        self.remote_negotiated_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-subtype"):
                        self.session_subtype = value
                        self.session_subtype.value_namespace = name_space
                        self.session_subtype.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix
                    if(value_path == "to-up-state-count"):
                        self.to_up_state_count = value
                        self.to_up_state_count.value_namespace = name_space
                        self.to_up_state_count.value_namespace_prefix = name_space_prefix


            class MpDownloadState(Entity):
                """
                MP Dowload State
                
                .. attribute:: change_time
                
                	Change time
                	**type**\:   :py:class:`ChangeTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState.ChangeTime>`
                
                .. attribute:: mp_download_state
                
                	MP Download State
                	**type**\:   :py:class:`BfdMpDownloadState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMpDownloadState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState, self).__init__()

                    self.yang_name = "mp-download-state"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-session-detail"

                    self.mp_download_state = YLeaf(YType.enumeration, "mp-download-state")

                    self.change_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState.ChangeTime()
                    self.change_time.parent = self
                    self._children_name_map["change_time"] = "change-time"
                    self._children_yang_names.add("change-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("mp_download_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState, self).__setattr__(name, value)


                class ChangeTime(Entity):
                    """
                    Change time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState.ChangeTime, self).__init__()

                        self.yang_name = "change-time"
                        self.yang_parent_name = "mp-download-state"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState.ChangeTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "change-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/mp-download-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.mp_download_state.is_set or
                        (self.change_time is not None and self.change_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.mp_download_state.yfilter != YFilter.not_set or
                        (self.change_time is not None and self.change_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mp-download-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.mp_download_state.is_set or self.mp_download_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mp_download_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "change-time"):
                        if (self.change_time is None):
                            self.change_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState.ChangeTime()
                            self.change_time.parent = self
                            self._children_name_map["change_time"] = "change-time"
                        return self.change_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "change-time" or name == "mp-download-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "mp-download-state"):
                        self.mp_download_state = value
                        self.mp_download_state.value_namespace = name_space
                        self.mp_download_state.value_namespace_prefix = name_space_prefix


            class LspPingInfo(Entity):
                """
                LSP Ping Info
                
                .. attribute:: lsp_ping_rx_count
                
                	LSP Ping numer of times received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_code
                
                	LSP Ping Rx Last Code
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_discr
                
                	LSP Ping Rx last received discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_rx_last_output
                
                	LSP Ping Rx Last Output
                	**type**\:  str
                
                .. attribute:: lsp_ping_rx_last_subcode
                
                	LSP Ping Rx Last Subcode
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: lsp_ping_rx_last_time
                
                	LSP Ping last received time
                	**type**\:   :py:class:`LspPingRxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingRxLastTime>`
                
                .. attribute:: lsp_ping_tx_count
                
                	LSP Ping Tx count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_error_count
                
                	LSP Ping Tx error count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lsp_ping_tx_last_error_rc
                
                	LSP Ping Tx last error
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_error_time
                
                	LSP Ping last error time
                	**type**\:   :py:class:`LspPingTxLastErrorTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastErrorTime>`
                
                .. attribute:: lsp_ping_tx_last_rc
                
                	LSP Ping Tx last result
                	**type**\:  str
                
                .. attribute:: lsp_ping_tx_last_time
                
                	LSP Ping last sent time
                	**type**\:   :py:class:`LspPingTxLastTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastTime>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo, self).__init__()

                    self.yang_name = "lsp-ping-info"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-session-detail"

                    self.lsp_ping_rx_count = YLeaf(YType.uint32, "lsp-ping-rx-count")

                    self.lsp_ping_rx_last_code = YLeaf(YType.uint8, "lsp-ping-rx-last-code")

                    self.lsp_ping_rx_last_discr = YLeaf(YType.uint32, "lsp-ping-rx-last-discr")

                    self.lsp_ping_rx_last_output = YLeaf(YType.str, "lsp-ping-rx-last-output")

                    self.lsp_ping_rx_last_subcode = YLeaf(YType.uint8, "lsp-ping-rx-last-subcode")

                    self.lsp_ping_tx_count = YLeaf(YType.uint32, "lsp-ping-tx-count")

                    self.lsp_ping_tx_error_count = YLeaf(YType.uint32, "lsp-ping-tx-error-count")

                    self.lsp_ping_tx_last_error_rc = YLeaf(YType.str, "lsp-ping-tx-last-error-rc")

                    self.lsp_ping_tx_last_rc = YLeaf(YType.str, "lsp-ping-tx-last-rc")

                    self.lsp_ping_rx_last_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingRxLastTime()
                    self.lsp_ping_rx_last_time.parent = self
                    self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                    self._children_yang_names.add("lsp-ping-rx-last-time")

                    self.lsp_ping_tx_last_error_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                    self.lsp_ping_tx_last_error_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                    self._children_yang_names.add("lsp-ping-tx-last-error-time")

                    self.lsp_ping_tx_last_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastTime()
                    self.lsp_ping_tx_last_time.parent = self
                    self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                    self._children_yang_names.add("lsp-ping-tx-last-time")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lsp_ping_rx_count",
                                    "lsp_ping_rx_last_code",
                                    "lsp_ping_rx_last_discr",
                                    "lsp_ping_rx_last_output",
                                    "lsp_ping_rx_last_subcode",
                                    "lsp_ping_tx_count",
                                    "lsp_ping_tx_error_count",
                                    "lsp_ping_tx_last_error_rc",
                                    "lsp_ping_tx_last_rc") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo, self).__setattr__(name, value)


                class LspPingTxLastTime(Entity):
                    """
                    LSP Ping last sent time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingTxLastErrorTime(Entity):
                    """
                    LSP Ping last error time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__init__()

                        self.yang_name = "lsp-ping-tx-last-error-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastErrorTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-tx-last-error-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix


                class LspPingRxLastTime(Entity):
                    """
                    LSP Ping last received time
                    
                    .. attribute:: nanoseconds
                    
                    	nanoseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    .. attribute:: seconds
                    
                    	seconds
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingRxLastTime, self).__init__()

                        self.yang_name = "lsp-ping-rx-last-time"
                        self.yang_parent_name = "lsp-ping-info"

                        self.nanoseconds = YLeaf(YType.uint32, "nanoseconds")

                        self.seconds = YLeaf(YType.uint64, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("nanoseconds",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingRxLastTime, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.nanoseconds.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.nanoseconds.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-ping-rx-last-time" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/lsp-ping-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nanoseconds" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "nanoseconds"):
                            self.nanoseconds = value
                            self.nanoseconds.value_namespace = name_space
                            self.nanoseconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.lsp_ping_rx_count.is_set or
                        self.lsp_ping_rx_last_code.is_set or
                        self.lsp_ping_rx_last_discr.is_set or
                        self.lsp_ping_rx_last_output.is_set or
                        self.lsp_ping_rx_last_subcode.is_set or
                        self.lsp_ping_tx_count.is_set or
                        self.lsp_ping_tx_error_count.is_set or
                        self.lsp_ping_tx_last_error_rc.is_set or
                        self.lsp_ping_tx_last_rc.is_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_data()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_data()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_code.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_output.yfilter != YFilter.not_set or
                        self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_error_count.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set or
                        self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set or
                        (self.lsp_ping_rx_last_time is not None and self.lsp_ping_rx_last_time.has_operation()) or
                        (self.lsp_ping_tx_last_error_time is not None and self.lsp_ping_tx_last_error_time.has_operation()) or
                        (self.lsp_ping_tx_last_time is not None and self.lsp_ping_tx_last_time.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-ping-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lsp_ping_rx_count.is_set or self.lsp_ping_rx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_count.get_name_leafdata())
                    if (self.lsp_ping_rx_last_code.is_set or self.lsp_ping_rx_last_code.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_code.get_name_leafdata())
                    if (self.lsp_ping_rx_last_discr.is_set or self.lsp_ping_rx_last_discr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_discr.get_name_leafdata())
                    if (self.lsp_ping_rx_last_output.is_set or self.lsp_ping_rx_last_output.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_output.get_name_leafdata())
                    if (self.lsp_ping_rx_last_subcode.is_set or self.lsp_ping_rx_last_subcode.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_rx_last_subcode.get_name_leafdata())
                    if (self.lsp_ping_tx_count.is_set or self.lsp_ping_tx_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_count.get_name_leafdata())
                    if (self.lsp_ping_tx_error_count.is_set or self.lsp_ping_tx_error_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_error_count.get_name_leafdata())
                    if (self.lsp_ping_tx_last_error_rc.is_set or self.lsp_ping_tx_last_error_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_error_rc.get_name_leafdata())
                    if (self.lsp_ping_tx_last_rc.is_set or self.lsp_ping_tx_last_rc.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_ping_tx_last_rc.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "lsp-ping-rx-last-time"):
                        if (self.lsp_ping_rx_last_time is None):
                            self.lsp_ping_rx_last_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingRxLastTime()
                            self.lsp_ping_rx_last_time.parent = self
                            self._children_name_map["lsp_ping_rx_last_time"] = "lsp-ping-rx-last-time"
                        return self.lsp_ping_rx_last_time

                    if (child_yang_name == "lsp-ping-tx-last-error-time"):
                        if (self.lsp_ping_tx_last_error_time is None):
                            self.lsp_ping_tx_last_error_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastErrorTime()
                            self.lsp_ping_tx_last_error_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_error_time"] = "lsp-ping-tx-last-error-time"
                        return self.lsp_ping_tx_last_error_time

                    if (child_yang_name == "lsp-ping-tx-last-time"):
                        if (self.lsp_ping_tx_last_time is None):
                            self.lsp_ping_tx_last_time = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo.LspPingTxLastTime()
                            self.lsp_ping_tx_last_time.parent = self
                            self._children_name_map["lsp_ping_tx_last_time"] = "lsp-ping-tx-last-time"
                        return self.lsp_ping_tx_last_time

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lsp-ping-rx-last-time" or name == "lsp-ping-tx-last-error-time" or name == "lsp-ping-tx-last-time" or name == "lsp-ping-rx-count" or name == "lsp-ping-rx-last-code" or name == "lsp-ping-rx-last-discr" or name == "lsp-ping-rx-last-output" or name == "lsp-ping-rx-last-subcode" or name == "lsp-ping-tx-count" or name == "lsp-ping-tx-error-count" or name == "lsp-ping-tx-last-error-rc" or name == "lsp-ping-tx-last-rc"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lsp-ping-rx-count"):
                        self.lsp_ping_rx_count = value
                        self.lsp_ping_rx_count.value_namespace = name_space
                        self.lsp_ping_rx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-code"):
                        self.lsp_ping_rx_last_code = value
                        self.lsp_ping_rx_last_code.value_namespace = name_space
                        self.lsp_ping_rx_last_code.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-discr"):
                        self.lsp_ping_rx_last_discr = value
                        self.lsp_ping_rx_last_discr.value_namespace = name_space
                        self.lsp_ping_rx_last_discr.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-output"):
                        self.lsp_ping_rx_last_output = value
                        self.lsp_ping_rx_last_output.value_namespace = name_space
                        self.lsp_ping_rx_last_output.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-rx-last-subcode"):
                        self.lsp_ping_rx_last_subcode = value
                        self.lsp_ping_rx_last_subcode.value_namespace = name_space
                        self.lsp_ping_rx_last_subcode.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-count"):
                        self.lsp_ping_tx_count = value
                        self.lsp_ping_tx_count.value_namespace = name_space
                        self.lsp_ping_tx_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-error-count"):
                        self.lsp_ping_tx_error_count = value
                        self.lsp_ping_tx_error_count.value_namespace = name_space
                        self.lsp_ping_tx_error_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-error-rc"):
                        self.lsp_ping_tx_last_error_rc = value
                        self.lsp_ping_tx_last_error_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_error_rc.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-ping-tx-last-rc"):
                        self.lsp_ping_tx_last_rc = value
                        self.lsp_ping_tx_last_rc.value_namespace = name_space
                        self.lsp_ping_tx_last_rc.value_namespace_prefix = name_space_prefix


            class OwnerInformation(Entity):
                """
                Client applications owning the session
                
                .. attribute:: adjusted_detection_multiplier
                
                	Adjusted detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: adjusted_interval
                
                	Adjusted minimum transmit interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: millisecond
                
                .. attribute:: detection_multiplier
                
                	Client specified detection multiplier to compute detection time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: interval
                
                	Client specified minimum transmit interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: microsecond
                
                .. attribute:: name
                
                	Client process name
                	**type**\:  str
                
                	**length:** 0..257
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.OwnerInformation, self).__init__()

                    self.yang_name = "owner-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-session-detail"

                    self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                    self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                    self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                    self.interval = YLeaf(YType.uint32, "interval")

                    self.name = YLeaf(YType.str, "name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("adjusted_detection_multiplier",
                                    "adjusted_interval",
                                    "detection_multiplier",
                                    "interval",
                                    "name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.OwnerInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.OwnerInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.adjusted_detection_multiplier.is_set or
                        self.adjusted_interval.is_set or
                        self.detection_multiplier.is_set or
                        self.interval.is_set or
                        self.name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                        self.adjusted_interval.yfilter != YFilter.not_set or
                        self.detection_multiplier.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        self.name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "owner-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                    if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                    if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())
                    if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "adjusted-detection-multiplier"):
                        self.adjusted_detection_multiplier = value
                        self.adjusted_detection_multiplier.value_namespace = name_space
                        self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "adjusted-interval"):
                        self.adjusted_interval = value
                        self.adjusted_interval.value_namespace = name_space
                        self.adjusted_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "detection-multiplier"):
                        self.detection_multiplier = value
                        self.detection_multiplier.value_namespace = name_space
                        self.detection_multiplier.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "name"):
                        self.name = value
                        self.name.value_namespace = name_space
                        self.name.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "ipv4bf-do-mplste-head-session-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.owner_information:
                    if (c.has_data()):
                        return True
                return (
                    self.fe_ctype.is_set or
                    self.fec_ctype.is_set or
                    self.fec_destination.is_set or
                    self.fec_extended_tunnel_id.is_set or
                    self.fec_source.is_set or
                    self.fec_subgroup_id.is_set or
                    self.fec_subgroup_originator.is_set or
                    self.fec_tunnel_id.is_set or
                    self.feclspid.is_set or
                    self.fecp2mpid.is_set or
                    self.incoming_label.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    self.vrf_name.is_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_data()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_data()) or
                    (self.status_information is not None and self.status_information.has_data()))

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.owner_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.fe_ctype.yfilter != YFilter.not_set or
                    self.fec_ctype.yfilter != YFilter.not_set or
                    self.fec_destination.yfilter != YFilter.not_set or
                    self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                    self.fec_source.yfilter != YFilter.not_set or
                    self.fec_subgroup_id.yfilter != YFilter.not_set or
                    self.fec_subgroup_originator.yfilter != YFilter.not_set or
                    self.fec_tunnel_id.yfilter != YFilter.not_set or
                    self.feclspid.yfilter != YFilter.not_set or
                    self.fecp2mpid.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set or
                    (self.lsp_ping_info is not None and self.lsp_ping_info.has_operation()) or
                    (self.mp_download_state is not None and self.mp_download_state.has_operation()) or
                    (self.status_information is not None and self.status_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-head-session-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_destination.get_name_leafdata())
                if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_source.get_name_leafdata())
                if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.feclspid.get_name_leafdata())
                if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "lsp-ping-info"):
                    if (self.lsp_ping_info is None):
                        self.lsp_ping_info = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.LspPingInfo()
                        self.lsp_ping_info.parent = self
                        self._children_name_map["lsp_ping_info"] = "lsp-ping-info"
                    return self.lsp_ping_info

                if (child_yang_name == "mp-download-state"):
                    if (self.mp_download_state is None):
                        self.mp_download_state = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.MpDownloadState()
                        self.mp_download_state.parent = self
                        self._children_name_map["mp_download_state"] = "mp-download-state"
                    return self.mp_download_state

                if (child_yang_name == "owner-information"):
                    for c in self.owner_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.OwnerInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.owner_information.append(c)
                    return c

                if (child_yang_name == "status-information"):
                    if (self.status_information is None):
                        self.status_information = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail.StatusInformation()
                        self.status_information.parent = self
                        self._children_name_map["status_information"] = "status-information"
                    return self.status_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "lsp-ping-info" or name == "mp-download-state" or name == "owner-information" or name == "status-information" or name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "incoming-label" or name == "interface-name" or name == "location" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "fe-ctype"):
                    self.fe_ctype = value
                    self.fe_ctype.value_namespace = name_space
                    self.fe_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-ctype"):
                    self.fec_ctype = value
                    self.fec_ctype.value_namespace = name_space
                    self.fec_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-destination"):
                    self.fec_destination = value
                    self.fec_destination.value_namespace = name_space
                    self.fec_destination.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-extended-tunnel-id"):
                    self.fec_extended_tunnel_id = value
                    self.fec_extended_tunnel_id.value_namespace = name_space
                    self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-source"):
                    self.fec_source = value
                    self.fec_source.value_namespace = name_space
                    self.fec_source.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-id"):
                    self.fec_subgroup_id = value
                    self.fec_subgroup_id.value_namespace = name_space
                    self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-originator"):
                    self.fec_subgroup_originator = value
                    self.fec_subgroup_originator.value_namespace = name_space
                    self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-tunnel-id"):
                    self.fec_tunnel_id = value
                    self.fec_tunnel_id.value_namespace = name_space
                    self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "feclspid"):
                    self.feclspid = value
                    self.feclspid.value_namespace = name_space
                    self.feclspid.value_namespace_prefix = name_space_prefix
                if(value_path == "fecp2mpid"):
                    self.fecp2mpid = value
                    self.fecp2mpid.value_namespace = name_space
                    self.fecp2mpid.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bf_do_mplste_head_session_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bf_do_mplste_head_session_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-head-session-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-head-session-detail"):
                for c in self.ipv4bf_do_mplste_head_session_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfDoMplsteHeadSessionDetails.Ipv4BfDoMplsteHeadSessionDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bf_do_mplste_head_session_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-head-session-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class RelationBriefs(Entity):
        """
        Table of brief information about all BFD
        relations in the System
        
        .. attribute:: relation_brief
        
        	Brief information for relation of a single BFD session
        	**type**\: list of    :py:class:`RelationBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationBriefs.RelationBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.RelationBriefs, self).__init__()

            self.yang_name = "relation-briefs"
            self.yang_parent_name = "bfd"

            self.relation_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.RelationBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.RelationBriefs, self).__setattr__(name, value)


        class RelationBrief(Entity):
            """
            Brief information for relation of a single BFD
            session
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: link_information
            
            	Brief Member Link Information
            	**type**\: list of    :py:class:`LinkInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationBriefs.RelationBrief.LinkInformation>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.RelationBriefs.RelationBrief, self).__init__()

                self.yang_name = "relation-brief"
                self.yang_parent_name = "relation-briefs"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.state = YLeaf(YType.enumeration, "state")

                self.link_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.RelationBriefs.RelationBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.RelationBriefs.RelationBrief, self).__setattr__(name, value)


            class LinkInformation(Entity):
                """
                Brief Member Link Information
                
                .. attribute:: interface_name
                
                	Session Interface Name
                	**type**\:  str
                
                	**length:** 0..64
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.RelationBriefs.RelationBrief.LinkInformation, self).__init__()

                    self.yang_name = "link-information"
                    self.yang_parent_name = "relation-brief"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.state = YLeaf(YType.enumeration, "state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.RelationBriefs.RelationBrief.LinkInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.RelationBriefs.RelationBrief.LinkInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.state.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "link-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-briefs/relation-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.link_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.state.is_set)

            def has_operation(self):
                for c in self.link_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "relation-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "link-information"):
                    for c in self.link_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.RelationBriefs.RelationBrief.LinkInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.link_information.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "link-information" or name == "destination-address" or name == "interface-name" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.relation_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.relation_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "relation-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "relation-brief"):
                for c in self.relation_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.RelationBriefs.RelationBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.relation_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "relation-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class ClientBriefs(Entity):
        """
        Table of Brief information about BFD clients
        
        .. attribute:: client_brief
        
        	Brief information of client
        	**type**\: list of    :py:class:`ClientBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.ClientBriefs.ClientBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.ClientBriefs, self).__init__()

            self.yang_name = "client-briefs"
            self.yang_parent_name = "bfd"

            self.client_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.ClientBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.ClientBriefs, self).__setattr__(name, value)


        class ClientBrief(Entity):
            """
            Brief information of client
            
            .. attribute:: name  <key>
            
            	Client Name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            .. attribute:: name_xr
            
            	Client process name
            	**type**\:  str
            
            	**length:** 0..257
            
            .. attribute:: node_id
            
            	Location where client resides
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_count
            
            	Number of sessions created by this client
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.ClientBriefs.ClientBrief, self).__init__()

                self.yang_name = "client-brief"
                self.yang_parent_name = "client-briefs"

                self.name = YLeaf(YType.str, "name")

                self.name_xr = YLeaf(YType.str, "name-xr")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_count = YLeaf(YType.uint32, "session-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("name",
                                "name_xr",
                                "node_id",
                                "session_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.ClientBriefs.ClientBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.ClientBriefs.ClientBrief, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.name.is_set or
                    self.name_xr.is_set or
                    self.node_id.is_set or
                    self.session_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.name.yfilter != YFilter.not_set or
                    self.name_xr.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "client-brief" + "[name='" + self.name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/client-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name.get_name_leafdata())
                if (self.name_xr.is_set or self.name_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.name_xr.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_count.is_set or self.session_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "name" or name == "name-xr" or name == "node-id" or name == "session-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "name"):
                    self.name = value
                    self.name.value_namespace = name_space
                    self.name.value_namespace_prefix = name_space_prefix
                if(value_path == "name-xr"):
                    self.name_xr = value
                    self.name_xr.value_namespace = name_space
                    self.name_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-count"):
                    self.session_count = value
                    self.session_count.value_namespace = name_space
                    self.session_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.client_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.client_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "client-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "client-brief"):
                for c in self.client_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.ClientBriefs.ClientBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.client_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "client-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteHeadMultiPaths(Entity):
        """
        IPv4 BFD over MPLS\-TE Head multipath
        
        .. attribute:: ipv4bf_do_mplste_head_multi_path
        
        	Label multipath table
        	**type**\: list of    :py:class:`Ipv4BfDoMplsteHeadMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadMultiPaths.Ipv4BfDoMplsteHeadMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteHeadMultiPaths, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-head-multi-paths"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_head_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfDoMplsteHeadMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfDoMplsteHeadMultiPaths, self).__setattr__(name, value)


        class Ipv4BfDoMplsteHeadMultiPath(Entity):
            """
            Label multipath table
            
            .. attribute:: fe_ctype
            
            	FEC Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_ctype
            
            	FEC C Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_destination
            
            	FEC Destination
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_extended_tunnel_id
            
            	FEC Extended Tunnel ID
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_source
            
            	FEC Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_subgroup_id
            
            	FEC Subgroup ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_subgroup_originator
            
            	FEC Subgroup originator
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_tunnel_id
            
            	FEC Tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: feclspid
            
            	FEC LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fecp2mpid
            
            	FEC P2MP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteHeadMultiPaths.Ipv4BfDoMplsteHeadMultiPath, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-head-multi-path"
                self.yang_parent_name = "ipv4bf-do-mplste-head-multi-paths"

                self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                self.fec_destination = YLeaf(YType.str, "fec-destination")

                self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                self.fec_source = YLeaf(YType.str, "fec-source")

                self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                self.feclspid = YLeaf(YType.int32, "feclspid")

                self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("fe_ctype",
                                "fec_ctype",
                                "fec_destination",
                                "fec_extended_tunnel_id",
                                "fec_source",
                                "fec_subgroup_id",
                                "fec_subgroup_originator",
                                "fec_tunnel_id",
                                "feclspid",
                                "fecp2mpid",
                                "incoming_label",
                                "incoming_label_xr",
                                "interface_name",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteHeadMultiPaths.Ipv4BfDoMplsteHeadMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteHeadMultiPaths.Ipv4BfDoMplsteHeadMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.fe_ctype.is_set or
                    self.fec_ctype.is_set or
                    self.fec_destination.is_set or
                    self.fec_extended_tunnel_id.is_set or
                    self.fec_source.is_set or
                    self.fec_subgroup_id.is_set or
                    self.fec_subgroup_originator.is_set or
                    self.fec_tunnel_id.is_set or
                    self.feclspid.is_set or
                    self.fecp2mpid.is_set or
                    self.incoming_label.is_set or
                    self.incoming_label_xr.is_set or
                    self.interface_name.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.fe_ctype.yfilter != YFilter.not_set or
                    self.fec_ctype.yfilter != YFilter.not_set or
                    self.fec_destination.yfilter != YFilter.not_set or
                    self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                    self.fec_source.yfilter != YFilter.not_set or
                    self.fec_subgroup_id.yfilter != YFilter.not_set or
                    self.fec_subgroup_originator.yfilter != YFilter.not_set or
                    self.fec_tunnel_id.yfilter != YFilter.not_set or
                    self.feclspid.yfilter != YFilter.not_set or
                    self.fecp2mpid.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-head-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_destination.get_name_leafdata())
                if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_source.get_name_leafdata())
                if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.feclspid.get_name_leafdata())
                if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "incoming-label" or name == "incoming-label-xr" or name == "interface-name" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "fe-ctype"):
                    self.fe_ctype = value
                    self.fe_ctype.value_namespace = name_space
                    self.fe_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-ctype"):
                    self.fec_ctype = value
                    self.fec_ctype.value_namespace = name_space
                    self.fec_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-destination"):
                    self.fec_destination = value
                    self.fec_destination.value_namespace = name_space
                    self.fec_destination.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-extended-tunnel-id"):
                    self.fec_extended_tunnel_id = value
                    self.fec_extended_tunnel_id.value_namespace = name_space
                    self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-source"):
                    self.fec_source = value
                    self.fec_source.value_namespace = name_space
                    self.fec_source.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-id"):
                    self.fec_subgroup_id = value
                    self.fec_subgroup_id.value_namespace = name_space
                    self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-originator"):
                    self.fec_subgroup_originator = value
                    self.fec_subgroup_originator.value_namespace = name_space
                    self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-tunnel-id"):
                    self.fec_tunnel_id = value
                    self.fec_tunnel_id.value_namespace = name_space
                    self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "feclspid"):
                    self.feclspid = value
                    self.feclspid.value_namespace = name_space
                    self.feclspid.value_namespace_prefix = name_space_prefix
                if(value_path == "fecp2mpid"):
                    self.fecp2mpid = value
                    self.fecp2mpid.value_namespace = name_space
                    self.fecp2mpid.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bf_do_mplste_head_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bf_do_mplste_head_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-head-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-head-multi-path"):
                for c in self.ipv4bf_do_mplste_head_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfDoMplsteHeadMultiPaths.Ipv4BfDoMplsteHeadMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bf_do_mplste_head_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-head-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class RelationDetails(Entity):
        """
        Table of detail information about all BFD
        relations in the System
        
        .. attribute:: relation_detail
        
        	Detail information for relation of a single BFD session
        	**type**\: list of    :py:class:`RelationDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.RelationDetails, self).__init__()

            self.yang_name = "relation-details"
            self.yang_parent_name = "bfd"

            self.relation_detail = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.RelationDetails, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.RelationDetails, self).__setattr__(name, value)


        class RelationDetail(Entity):
            """
            Detail information for relation of a single BFD
            session
            
            .. attribute:: association_information
            
            	Association session information
            	**type**\: list of    :py:class:`AssociationInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation>`
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: link_information
            
            	Detail Member Link Information
            	**type**\: list of    :py:class:`LinkInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.LinkInformation>`
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.RelationDetails.RelationDetail, self).__init__()

                self.yang_name = "relation-detail"
                self.yang_parent_name = "relation-details"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.state = YLeaf(YType.enumeration, "state")

                self.association_information = YList(self)
                self.link_information = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "local_discriminator",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.RelationDetails.RelationDetail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.RelationDetails.RelationDetail, self).__setattr__(name, value)


            class LinkInformation(Entity):
                """
                Detail Member Link Information
                
                .. attribute:: interface_name
                
                	Session Interface Name
                	**type**\:  str
                
                	**length:** 0..64
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: state
                
                	State
                	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.RelationDetails.RelationDetail.LinkInformation, self).__init__()

                    self.yang_name = "link-information"
                    self.yang_parent_name = "relation-detail"

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.state = YLeaf(YType.enumeration, "state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface_name",
                                    "local_discriminator",
                                    "state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.RelationDetails.RelationDetail.LinkInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.RelationDetails.RelationDetail.LinkInformation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface_name.is_set or
                        self.local_discriminator.is_set or
                        self.state.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "link-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface-name" or name == "local-discriminator" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix


            class AssociationInformation(Entity):
                """
                Association session information
                
                .. attribute:: local_discriminator
                
                	Session's Local discriminator
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: owner_information
                
                	Client applications owning the session
                	**type**\: list of    :py:class:`OwnerInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.OwnerInformation>`
                
                .. attribute:: session_key
                
                	Session Key
                	**type**\:   :py:class:`SessionKey <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey>`
                
                .. attribute:: sessiontype
                
                	Session type
                	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation, self).__init__()

                    self.yang_name = "association-information"
                    self.yang_parent_name = "relation-detail"

                    self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                    self.sessiontype = YLeaf(YType.enumeration, "sessiontype")

                    self.session_key = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey()
                    self.session_key.parent = self
                    self._children_name_map["session_key"] = "session-key"
                    self._children_yang_names.add("session-key")

                    self.owner_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("local_discriminator",
                                    "sessiontype") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.RelationDetails.RelationDetail.AssociationInformation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation, self).__setattr__(name, value)


                class SessionKey(Entity):
                    """
                    Session Key
                    
                    .. attribute:: bfdfec
                    
                    	Union of FECs
                    	**type**\:   :py:class:`Bfdfec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec>`
                    
                    .. attribute:: incoming_label
                    
                    	Incoming Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interface_name
                    
                    	Session Interface Name
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: ip_destination_address
                    
                    	IPv4/v6 dest address
                    	**type**\:   :py:class:`IpDestinationAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpDestinationAddress>`
                    
                    .. attribute:: ip_source_address
                    
                    	IPv4/v6 source address
                    	**type**\:   :py:class:`IpSourceAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpSourceAddress>`
                    
                    .. attribute:: sbfd_enabled
                    
                    	SBFD enable flag
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: sbfd_target_type
                    
                    	SBFD target type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_key_type
                    
                    	Session Key Type
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: target_address
                    
                    	sbfd target address
                    	**type**\:   :py:class:`TargetAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.TargetAddress>`
                    
                    .. attribute:: vrf_name
                    
                    	Session VRF Name
                    	**type**\:  str
                    
                    	**length:** 0..120
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey, self).__init__()

                        self.yang_name = "session-key"
                        self.yang_parent_name = "association-information"

                        self.incoming_label = YLeaf(YType.uint32, "incoming-label")

                        self.interface_name = YLeaf(YType.str, "interface-name")

                        self.sbfd_enabled = YLeaf(YType.int32, "sbfd-enabled")

                        self.sbfd_target_type = YLeaf(YType.uint32, "sbfd-target-type")

                        self.session_key_type = YLeaf(YType.uint32, "session-key-type")

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.bfdfec = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec()
                        self.bfdfec.parent = self
                        self._children_name_map["bfdfec"] = "bfdfec"
                        self._children_yang_names.add("bfdfec")

                        self.ip_destination_address = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                        self.ip_destination_address.parent = self
                        self._children_name_map["ip_destination_address"] = "ip-destination-address"
                        self._children_yang_names.add("ip-destination-address")

                        self.ip_source_address = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpSourceAddress()
                        self.ip_source_address.parent = self
                        self._children_name_map["ip_source_address"] = "ip-source-address"
                        self._children_yang_names.add("ip-source-address")

                        self.target_address = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.TargetAddress()
                        self.target_address.parent = self
                        self._children_name_map["target_address"] = "target-address"
                        self._children_yang_names.add("target-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("incoming_label",
                                        "interface_name",
                                        "sbfd_enabled",
                                        "sbfd_target_type",
                                        "session_key_type",
                                        "vrf_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey, self).__setattr__(name, value)


                    class IpDestinationAddress(Entity):
                        """
                        IPv4/v6 dest address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__init__()

                            self.yang_name = "ip-destination-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpDestinationAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-destination-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class IpSourceAddress(Entity):
                        """
                        IPv4/v6 source address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__init__()

                            self.yang_name = "ip-source-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpSourceAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ip-source-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix


                    class Bfdfec(Entity):
                        """
                        Union of FECs
                        
                        .. attribute:: bfdfe_ctype
                        
                        	BFDFECType
                        	**type**\:   :py:class:`BfdApiFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdApiFec>`
                        
                        .. attribute:: dummy
                        
                        	dummy
                        	**type**\:   :py:class:`Dummy <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.Dummy>`
                        
                        .. attribute:: te_s2l_fec
                        
                        	te s2l fec
                        	**type**\:   :py:class:`TeS2LFec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec>`
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec, self).__init__()

                            self.yang_name = "bfdfec"
                            self.yang_parent_name = "session-key"

                            self.bfdfe_ctype = YLeaf(YType.enumeration, "bfdfe-ctype")

                            self.dummy = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                            self.dummy.parent = self
                            self._children_name_map["dummy"] = "dummy"
                            self._children_yang_names.add("dummy")

                            self.te_s2l_fec = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                            self.te_s2l_fec.parent = self
                            self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                            self._children_yang_names.add("te-s2l-fec")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfdfe_ctype") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec, self).__setattr__(name, value)


                        class Dummy(Entity):
                            """
                            dummy
                            
                            .. attribute:: dummy
                            
                            	dummy
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__init__()

                                self.yang_name = "dummy"
                                self.yang_parent_name = "bfdfec"

                                self.dummy = YLeaf(YType.str, "dummy")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dummy") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.Dummy, self).__setattr__(name, value)

                            def has_data(self):
                                return self.dummy.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dummy.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dummy" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dummy.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dummy"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dummy"):
                                    self.dummy = value
                                    self.dummy.value_namespace = name_space
                                    self.dummy.value_namespace_prefix = name_space_prefix


                        class TeS2LFec(Entity):
                            """
                            te s2l fec
                            
                            .. attribute:: s2l_fec_ctype
                            
                            	Session identifier (ctype)
                            	**type**\:   :py:class:`MplsLibC <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.MplsLibC>`
                            
                            .. attribute:: s2l_fec_dest
                            
                            	sub\-LSP destination address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_extended_tunnel_id
                            
                            	Extended tunnel ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_lsp_id
                            
                            	LSP ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_p2mp_id
                            
                            	P2MP ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: s2l_fec_source
                            
                            	LSP source address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_subgroup_id
                            
                            	sub\-LSP subgroup ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_subgroup_originator
                            
                            	Subgroup Originator
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: s2l_fec_tunnel_id
                            
                            	Tunnel ID
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: s2l_fec_vrf
                            
                            	VRF; currently only for GMPLS tunnels
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'ip-bfd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__init__()

                                self.yang_name = "te-s2l-fec"
                                self.yang_parent_name = "bfdfec"

                                self.s2l_fec_ctype = YLeaf(YType.enumeration, "s2l-fec-ctype")

                                self.s2l_fec_dest = YLeaf(YType.str, "s2l-fec-dest")

                                self.s2l_fec_extended_tunnel_id = YLeaf(YType.str, "s2l-fec-extended-tunnel-id")

                                self.s2l_fec_lsp_id = YLeaf(YType.uint16, "s2l-fec-lsp-id")

                                self.s2l_fec_p2mp_id = YLeaf(YType.uint32, "s2l-fec-p2mp-id")

                                self.s2l_fec_source = YLeaf(YType.str, "s2l-fec-source")

                                self.s2l_fec_subgroup_id = YLeaf(YType.uint16, "s2l-fec-subgroup-id")

                                self.s2l_fec_subgroup_originator = YLeaf(YType.str, "s2l-fec-subgroup-originator")

                                self.s2l_fec_tunnel_id = YLeaf(YType.uint16, "s2l-fec-tunnel-id")

                                self.s2l_fec_vrf = YLeaf(YType.str, "s2l-fec-vrf")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("s2l_fec_ctype",
                                                "s2l_fec_dest",
                                                "s2l_fec_extended_tunnel_id",
                                                "s2l_fec_lsp_id",
                                                "s2l_fec_p2mp_id",
                                                "s2l_fec_source",
                                                "s2l_fec_subgroup_id",
                                                "s2l_fec_subgroup_originator",
                                                "s2l_fec_tunnel_id",
                                                "s2l_fec_vrf") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.s2l_fec_ctype.is_set or
                                    self.s2l_fec_dest.is_set or
                                    self.s2l_fec_extended_tunnel_id.is_set or
                                    self.s2l_fec_lsp_id.is_set or
                                    self.s2l_fec_p2mp_id.is_set or
                                    self.s2l_fec_source.is_set or
                                    self.s2l_fec_subgroup_id.is_set or
                                    self.s2l_fec_subgroup_originator.is_set or
                                    self.s2l_fec_tunnel_id.is_set or
                                    self.s2l_fec_vrf.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.s2l_fec_ctype.yfilter != YFilter.not_set or
                                    self.s2l_fec_dest.yfilter != YFilter.not_set or
                                    self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_lsp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_p2mp_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_source.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set or
                                    self.s2l_fec_tunnel_id.yfilter != YFilter.not_set or
                                    self.s2l_fec_vrf.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "te-s2l-fec" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/bfdfec/%s" % self.get_segment_path()
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.s2l_fec_ctype.is_set or self.s2l_fec_ctype.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_ctype.get_name_leafdata())
                                if (self.s2l_fec_dest.is_set or self.s2l_fec_dest.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_dest.get_name_leafdata())
                                if (self.s2l_fec_extended_tunnel_id.is_set or self.s2l_fec_extended_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_extended_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_lsp_id.is_set or self.s2l_fec_lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_lsp_id.get_name_leafdata())
                                if (self.s2l_fec_p2mp_id.is_set or self.s2l_fec_p2mp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_p2mp_id.get_name_leafdata())
                                if (self.s2l_fec_source.is_set or self.s2l_fec_source.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_source.get_name_leafdata())
                                if (self.s2l_fec_subgroup_id.is_set or self.s2l_fec_subgroup_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_id.get_name_leafdata())
                                if (self.s2l_fec_subgroup_originator.is_set or self.s2l_fec_subgroup_originator.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_subgroup_originator.get_name_leafdata())
                                if (self.s2l_fec_tunnel_id.is_set or self.s2l_fec_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_tunnel_id.get_name_leafdata())
                                if (self.s2l_fec_vrf.is_set or self.s2l_fec_vrf.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.s2l_fec_vrf.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "s2l-fec-ctype" or name == "s2l-fec-dest" or name == "s2l-fec-extended-tunnel-id" or name == "s2l-fec-lsp-id" or name == "s2l-fec-p2mp-id" or name == "s2l-fec-source" or name == "s2l-fec-subgroup-id" or name == "s2l-fec-subgroup-originator" or name == "s2l-fec-tunnel-id" or name == "s2l-fec-vrf"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "s2l-fec-ctype"):
                                    self.s2l_fec_ctype = value
                                    self.s2l_fec_ctype.value_namespace = name_space
                                    self.s2l_fec_ctype.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-dest"):
                                    self.s2l_fec_dest = value
                                    self.s2l_fec_dest.value_namespace = name_space
                                    self.s2l_fec_dest.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-extended-tunnel-id"):
                                    self.s2l_fec_extended_tunnel_id = value
                                    self.s2l_fec_extended_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-lsp-id"):
                                    self.s2l_fec_lsp_id = value
                                    self.s2l_fec_lsp_id.value_namespace = name_space
                                    self.s2l_fec_lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-p2mp-id"):
                                    self.s2l_fec_p2mp_id = value
                                    self.s2l_fec_p2mp_id.value_namespace = name_space
                                    self.s2l_fec_p2mp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-source"):
                                    self.s2l_fec_source = value
                                    self.s2l_fec_source.value_namespace = name_space
                                    self.s2l_fec_source.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-id"):
                                    self.s2l_fec_subgroup_id = value
                                    self.s2l_fec_subgroup_id.value_namespace = name_space
                                    self.s2l_fec_subgroup_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-subgroup-originator"):
                                    self.s2l_fec_subgroup_originator = value
                                    self.s2l_fec_subgroup_originator.value_namespace = name_space
                                    self.s2l_fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-tunnel-id"):
                                    self.s2l_fec_tunnel_id = value
                                    self.s2l_fec_tunnel_id.value_namespace = name_space
                                    self.s2l_fec_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "s2l-fec-vrf"):
                                    self.s2l_fec_vrf = value
                                    self.s2l_fec_vrf.value_namespace = name_space
                                    self.s2l_fec_vrf.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.bfdfe_ctype.is_set or
                                (self.dummy is not None and self.dummy.has_data()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfdfe_ctype.yfilter != YFilter.not_set or
                                (self.dummy is not None and self.dummy.has_operation()) or
                                (self.te_s2l_fec is not None and self.te_s2l_fec.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfdfec" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfdfe_ctype.is_set or self.bfdfe_ctype.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfdfe_ctype.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dummy"):
                                if (self.dummy is None):
                                    self.dummy = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.Dummy()
                                    self.dummy.parent = self
                                    self._children_name_map["dummy"] = "dummy"
                                return self.dummy

                            if (child_yang_name == "te-s2l-fec"):
                                if (self.te_s2l_fec is None):
                                    self.te_s2l_fec = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec.TeS2LFec()
                                    self.te_s2l_fec.parent = self
                                    self._children_name_map["te_s2l_fec"] = "te-s2l-fec"
                                return self.te_s2l_fec

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dummy" or name == "te-s2l-fec" or name == "bfdfe-ctype"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfdfe-ctype"):
                                self.bfdfe_ctype = value
                                self.bfdfe_ctype.value_namespace = name_space
                                self.bfdfe_ctype.value_namespace_prefix = name_space_prefix


                    class TargetAddress(Entity):
                        """
                        sbfd target address
                        
                        .. attribute:: afi
                        
                        	AFI
                        	**type**\:   :py:class:`BfdAfId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdAfId>`
                        
                        .. attribute:: dummy
                        
                        	No Address
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: ipv4
                        
                        	IPv4 address type
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: ipv6
                        
                        	IPv6 address type
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        

                        """

                        _prefix = 'ip-bfd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.TargetAddress, self).__init__()

                            self.yang_name = "target-address"
                            self.yang_parent_name = "session-key"

                            self.afi = YLeaf(YType.enumeration, "afi")

                            self.dummy = YLeaf(YType.uint8, "dummy")

                            self.ipv4 = YLeaf(YType.str, "ipv4")

                            self.ipv6 = YLeaf(YType.str, "ipv6")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi",
                                            "dummy",
                                            "ipv4",
                                            "ipv6") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.TargetAddress, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.afi.is_set or
                                self.dummy.is_set or
                                self.ipv4.is_set or
                                self.ipv6.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi.yfilter != YFilter.not_set or
                                self.dummy.yfilter != YFilter.not_set or
                                self.ipv4.yfilter != YFilter.not_set or
                                self.ipv6.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "target-address" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi.is_set or self.afi.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi.get_name_leafdata())
                            if (self.dummy.is_set or self.dummy.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dummy.get_name_leafdata())
                            if (self.ipv4.is_set or self.ipv4.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv4.get_name_leafdata())
                            if (self.ipv6.is_set or self.ipv6.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipv6.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "afi" or name == "dummy" or name == "ipv4" or name == "ipv6"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi"):
                                self.afi = value
                                self.afi.value_namespace = name_space
                                self.afi.value_namespace_prefix = name_space_prefix
                            if(value_path == "dummy"):
                                self.dummy = value
                                self.dummy.value_namespace = name_space
                                self.dummy.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv4"):
                                self.ipv4 = value
                                self.ipv4.value_namespace = name_space
                                self.ipv4.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipv6"):
                                self.ipv6 = value
                                self.ipv6.value_namespace = name_space
                                self.ipv6.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.incoming_label.is_set or
                            self.interface_name.is_set or
                            self.sbfd_enabled.is_set or
                            self.sbfd_target_type.is_set or
                            self.session_key_type.is_set or
                            self.vrf_name.is_set or
                            (self.bfdfec is not None and self.bfdfec.has_data()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_data()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_data()) or
                            (self.target_address is not None and self.target_address.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.incoming_label.yfilter != YFilter.not_set or
                            self.interface_name.yfilter != YFilter.not_set or
                            self.sbfd_enabled.yfilter != YFilter.not_set or
                            self.sbfd_target_type.yfilter != YFilter.not_set or
                            self.session_key_type.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            (self.bfdfec is not None and self.bfdfec.has_operation()) or
                            (self.ip_destination_address is not None and self.ip_destination_address.has_operation()) or
                            (self.ip_source_address is not None and self.ip_source_address.has_operation()) or
                            (self.target_address is not None and self.target_address.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-key" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.incoming_label.get_name_leafdata())
                        if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_name.get_name_leafdata())
                        if (self.sbfd_enabled.is_set or self.sbfd_enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_enabled.get_name_leafdata())
                        if (self.sbfd_target_type.is_set or self.sbfd_target_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.sbfd_target_type.get_name_leafdata())
                        if (self.session_key_type.is_set or self.session_key_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_key_type.get_name_leafdata())
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "bfdfec"):
                            if (self.bfdfec is None):
                                self.bfdfec = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.Bfdfec()
                                self.bfdfec.parent = self
                                self._children_name_map["bfdfec"] = "bfdfec"
                            return self.bfdfec

                        if (child_yang_name == "ip-destination-address"):
                            if (self.ip_destination_address is None):
                                self.ip_destination_address = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpDestinationAddress()
                                self.ip_destination_address.parent = self
                                self._children_name_map["ip_destination_address"] = "ip-destination-address"
                            return self.ip_destination_address

                        if (child_yang_name == "ip-source-address"):
                            if (self.ip_source_address is None):
                                self.ip_source_address = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.IpSourceAddress()
                                self.ip_source_address.parent = self
                                self._children_name_map["ip_source_address"] = "ip-source-address"
                            return self.ip_source_address

                        if (child_yang_name == "target-address"):
                            if (self.target_address is None):
                                self.target_address = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey.TargetAddress()
                                self.target_address.parent = self
                                self._children_name_map["target_address"] = "target-address"
                            return self.target_address

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bfdfec" or name == "ip-destination-address" or name == "ip-source-address" or name == "target-address" or name == "incoming-label" or name == "interface-name" or name == "sbfd-enabled" or name == "sbfd-target-type" or name == "session-key-type" or name == "vrf-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "incoming-label"):
                            self.incoming_label = value
                            self.incoming_label.value_namespace = name_space
                            self.incoming_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-name"):
                            self.interface_name = value
                            self.interface_name.value_namespace = name_space
                            self.interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-enabled"):
                            self.sbfd_enabled = value
                            self.sbfd_enabled.value_namespace = name_space
                            self.sbfd_enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "sbfd-target-type"):
                            self.sbfd_target_type = value
                            self.sbfd_target_type.value_namespace = name_space
                            self.sbfd_target_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-key-type"):
                            self.session_key_type = value
                            self.session_key_type.value_namespace = name_space
                            self.session_key_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix


                class OwnerInformation(Entity):
                    """
                    Client applications owning the session
                    
                    .. attribute:: adjusted_detection_multiplier
                    
                    	Adjusted detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: adjusted_interval
                    
                    	Adjusted minimum transmit interval in milli\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: millisecond
                    
                    .. attribute:: detection_multiplier
                    
                    	Client specified detection multiplier to compute detection time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: interval
                    
                    	Client specified minimum transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: name
                    
                    	Client process name
                    	**type**\:  str
                    
                    	**length:** 0..257
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.RelationDetails.RelationDetail.AssociationInformation.OwnerInformation, self).__init__()

                        self.yang_name = "owner-information"
                        self.yang_parent_name = "association-information"

                        self.adjusted_detection_multiplier = YLeaf(YType.uint32, "adjusted-detection-multiplier")

                        self.adjusted_interval = YLeaf(YType.uint32, "adjusted-interval")

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.interval = YLeaf(YType.uint32, "interval")

                        self.name = YLeaf(YType.str, "name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("adjusted_detection_multiplier",
                                        "adjusted_interval",
                                        "detection_multiplier",
                                        "interval",
                                        "name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.RelationDetails.RelationDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.RelationDetails.RelationDetail.AssociationInformation.OwnerInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.adjusted_detection_multiplier.is_set or
                            self.adjusted_interval.is_set or
                            self.detection_multiplier.is_set or
                            self.interval.is_set or
                            self.name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.adjusted_detection_multiplier.yfilter != YFilter.not_set or
                            self.adjusted_interval.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.interval.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "owner-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.adjusted_detection_multiplier.is_set or self.adjusted_detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_detection_multiplier.get_name_leafdata())
                        if (self.adjusted_interval.is_set or self.adjusted_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adjusted_interval.get_name_leafdata())
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interval.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "adjusted-detection-multiplier" or name == "adjusted-interval" or name == "detection-multiplier" or name == "interval" or name == "name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "adjusted-detection-multiplier"):
                            self.adjusted_detection_multiplier = value
                            self.adjusted_detection_multiplier.value_namespace = name_space
                            self.adjusted_detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "adjusted-interval"):
                            self.adjusted_interval = value
                            self.adjusted_interval.value_namespace = name_space
                            self.adjusted_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "interval"):
                            self.interval = value
                            self.interval.value_namespace = name_space
                            self.interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.owner_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.local_discriminator.is_set or
                        self.sessiontype.is_set or
                        (self.session_key is not None and self.session_key.has_data()))

                def has_operation(self):
                    for c in self.owner_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.local_discriminator.yfilter != YFilter.not_set or
                        self.sessiontype.yfilter != YFilter.not_set or
                        (self.session_key is not None and self.session_key.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "association-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                    if (self.sessiontype.is_set or self.sessiontype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sessiontype.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "owner-information"):
                        for c in self.owner_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Bfd.RelationDetails.RelationDetail.AssociationInformation.OwnerInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.owner_information.append(c)
                        return c

                    if (child_yang_name == "session-key"):
                        if (self.session_key is None):
                            self.session_key = Bfd.RelationDetails.RelationDetail.AssociationInformation.SessionKey()
                            self.session_key.parent = self
                            self._children_name_map["session_key"] = "session-key"
                        return self.session_key

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "owner-information" or name == "session-key" or name == "local-discriminator" or name == "sessiontype"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "local-discriminator"):
                        self.local_discriminator = value
                        self.local_discriminator.value_namespace = name_space
                        self.local_discriminator.value_namespace_prefix = name_space_prefix
                    if(value_path == "sessiontype"):
                        self.sessiontype = value
                        self.sessiontype.value_namespace = name_space
                        self.sessiontype.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.association_information:
                    if (c.has_data()):
                        return True
                for c in self.link_information:
                    if (c.has_data()):
                        return True
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.local_discriminator.is_set or
                    self.state.is_set)

            def has_operation(self):
                for c in self.association_information:
                    if (c.has_operation()):
                        return True
                for c in self.link_information:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "relation-detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "association-information"):
                    for c in self.association_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.RelationDetails.RelationDetail.AssociationInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.association_information.append(c)
                    return c

                if (child_yang_name == "link-information"):
                    for c in self.link_information:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.RelationDetails.RelationDetail.LinkInformation()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.link_information.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "association-information" or name == "link-information" or name == "destination-address" or name == "interface-name" or name == "local-discriminator" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.relation_detail:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.relation_detail:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "relation-details" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "relation-detail"):
                for c in self.relation_detail:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.RelationDetails.RelationDetail()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.relation_detail.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "relation-detail"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteTailCounters(Entity):
        """
        IPv4 BFD over MPLS\-TE Counters
        
        .. attribute:: ipv4bf_do_mplste_tail_packet_counters
        
        	Table of IPv4 BFD over MPLS\-TE Packet counters
        	**type**\:   :py:class:`Ipv4BfDoMplsteTailPacketCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteTailCounters, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-tail-counters"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_tail_packet_counters = Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters()
            self.ipv4bf_do_mplste_tail_packet_counters.parent = self
            self._children_name_map["ipv4bf_do_mplste_tail_packet_counters"] = "ipv4bf-do-mplste-tail-packet-counters"
            self._children_yang_names.add("ipv4bf-do-mplste-tail-packet-counters")


        class Ipv4BfDoMplsteTailPacketCounters(Entity):
            """
            Table of IPv4 BFD over MPLS\-TE Packet counters
            
            .. attribute:: ipv4bf_do_mplste_tail_packet_counter
            
            	Interface  IPv4 BFD over MPLS\-TE Packet counters
            	**type**\: list of    :py:class:`Ipv4BfDoMplsteTailPacketCounter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters.Ipv4BfDoMplsteTailPacketCounter>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-tail-packet-counters"
                self.yang_parent_name = "ipv4bf-do-mplste-tail-counters"

                self.ipv4bf_do_mplste_tail_packet_counter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters, self).__setattr__(name, value)


            class Ipv4BfDoMplsteTailPacketCounter(Entity):
                """
                Interface  IPv4 BFD over MPLS\-TE Packet
                counters
                
                .. attribute:: display_type
                
                	Packet Display Type
                	**type**\:   :py:class:`BfdMgmtPktDisplay <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtPktDisplay>`
                
                .. attribute:: echo_receive_count
                
                	Number of echo packets received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: echo_transmit_count
                
                	Number of echo packets transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: fe_ctype
                
                	FEC Type
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: fec_ctype
                
                	FEC C Type
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: fec_destination
                
                	FEC Destination
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: fec_extended_tunnel_id
                
                	FEC Extended Tunnel ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: fec_source
                
                	FEC Source
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: fec_subgroup_id
                
                	FEC Subgroup ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: fec_subgroup_originator
                
                	FEC Subgroup originator
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: fec_tunnel_id
                
                	FEC Tunnel ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: feclspid
                
                	FEC LSP ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: fecp2mpid
                
                	FEC P2MP ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: hello_receive_count
                
                	Number of Hellos received
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: hello_transmit_count
                
                	Number of Hellos transmitted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: incoming_label
                
                	Incoming Label
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: location
                
                	Location
                	**type**\:  str
                
                	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                
                .. attribute:: vrf_name
                
                	VRF name
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters.Ipv4BfDoMplsteTailPacketCounter, self).__init__()

                    self.yang_name = "ipv4bf-do-mplste-tail-packet-counter"
                    self.yang_parent_name = "ipv4bf-do-mplste-tail-packet-counters"

                    self.display_type = YLeaf(YType.enumeration, "display-type")

                    self.echo_receive_count = YLeaf(YType.uint32, "echo-receive-count")

                    self.echo_transmit_count = YLeaf(YType.uint32, "echo-transmit-count")

                    self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                    self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                    self.fec_destination = YLeaf(YType.str, "fec-destination")

                    self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                    self.fec_source = YLeaf(YType.str, "fec-source")

                    self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                    self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                    self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                    self.feclspid = YLeaf(YType.int32, "feclspid")

                    self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                    self.hello_receive_count = YLeaf(YType.uint32, "hello-receive-count")

                    self.hello_transmit_count = YLeaf(YType.uint32, "hello-transmit-count")

                    self.incoming_label = YLeaf(YType.int32, "incoming-label")

                    self.location = YLeaf(YType.str, "location")

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("display_type",
                                    "echo_receive_count",
                                    "echo_transmit_count",
                                    "fe_ctype",
                                    "fec_ctype",
                                    "fec_destination",
                                    "fec_extended_tunnel_id",
                                    "fec_source",
                                    "fec_subgroup_id",
                                    "fec_subgroup_originator",
                                    "fec_tunnel_id",
                                    "feclspid",
                                    "fecp2mpid",
                                    "hello_receive_count",
                                    "hello_transmit_count",
                                    "incoming_label",
                                    "location",
                                    "vrf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters.Ipv4BfDoMplsteTailPacketCounter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters.Ipv4BfDoMplsteTailPacketCounter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.display_type.is_set or
                        self.echo_receive_count.is_set or
                        self.echo_transmit_count.is_set or
                        self.fe_ctype.is_set or
                        self.fec_ctype.is_set or
                        self.fec_destination.is_set or
                        self.fec_extended_tunnel_id.is_set or
                        self.fec_source.is_set or
                        self.fec_subgroup_id.is_set or
                        self.fec_subgroup_originator.is_set or
                        self.fec_tunnel_id.is_set or
                        self.feclspid.is_set or
                        self.fecp2mpid.is_set or
                        self.hello_receive_count.is_set or
                        self.hello_transmit_count.is_set or
                        self.incoming_label.is_set or
                        self.location.is_set or
                        self.vrf_name.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.display_type.yfilter != YFilter.not_set or
                        self.echo_receive_count.yfilter != YFilter.not_set or
                        self.echo_transmit_count.yfilter != YFilter.not_set or
                        self.fe_ctype.yfilter != YFilter.not_set or
                        self.fec_ctype.yfilter != YFilter.not_set or
                        self.fec_destination.yfilter != YFilter.not_set or
                        self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                        self.fec_source.yfilter != YFilter.not_set or
                        self.fec_subgroup_id.yfilter != YFilter.not_set or
                        self.fec_subgroup_originator.yfilter != YFilter.not_set or
                        self.fec_tunnel_id.yfilter != YFilter.not_set or
                        self.feclspid.yfilter != YFilter.not_set or
                        self.fecp2mpid.yfilter != YFilter.not_set or
                        self.hello_receive_count.yfilter != YFilter.not_set or
                        self.hello_transmit_count.yfilter != YFilter.not_set or
                        self.incoming_label.yfilter != YFilter.not_set or
                        self.location.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ipv4bf-do-mplste-tail-packet-counter" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-counters/ipv4bf-do-mplste-tail-packet-counters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.display_type.is_set or self.display_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.display_type.get_name_leafdata())
                    if (self.echo_receive_count.is_set or self.echo_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_receive_count.get_name_leafdata())
                    if (self.echo_transmit_count.is_set or self.echo_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.echo_transmit_count.get_name_leafdata())
                    if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                    if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                    if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_destination.get_name_leafdata())
                    if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                    if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_source.get_name_leafdata())
                    if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                    if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                    if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                    if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.feclspid.get_name_leafdata())
                    if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                    if (self.hello_receive_count.is_set or self.hello_receive_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_receive_count.get_name_leafdata())
                    if (self.hello_transmit_count.is_set or self.hello_transmit_count.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hello_transmit_count.get_name_leafdata())
                    if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.incoming_label.get_name_leafdata())
                    if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.location.get_name_leafdata())
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "display-type" or name == "echo-receive-count" or name == "echo-transmit-count" or name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "hello-receive-count" or name == "hello-transmit-count" or name == "incoming-label" or name == "location" or name == "vrf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "display-type"):
                        self.display_type = value
                        self.display_type.value_namespace = name_space
                        self.display_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-receive-count"):
                        self.echo_receive_count = value
                        self.echo_receive_count.value_namespace = name_space
                        self.echo_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "echo-transmit-count"):
                        self.echo_transmit_count = value
                        self.echo_transmit_count.value_namespace = name_space
                        self.echo_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "fe-ctype"):
                        self.fe_ctype = value
                        self.fe_ctype.value_namespace = name_space
                        self.fe_ctype.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-ctype"):
                        self.fec_ctype = value
                        self.fec_ctype.value_namespace = name_space
                        self.fec_ctype.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-destination"):
                        self.fec_destination = value
                        self.fec_destination.value_namespace = name_space
                        self.fec_destination.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-extended-tunnel-id"):
                        self.fec_extended_tunnel_id = value
                        self.fec_extended_tunnel_id.value_namespace = name_space
                        self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-source"):
                        self.fec_source = value
                        self.fec_source.value_namespace = name_space
                        self.fec_source.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-subgroup-id"):
                        self.fec_subgroup_id = value
                        self.fec_subgroup_id.value_namespace = name_space
                        self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-subgroup-originator"):
                        self.fec_subgroup_originator = value
                        self.fec_subgroup_originator.value_namespace = name_space
                        self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                    if(value_path == "fec-tunnel-id"):
                        self.fec_tunnel_id = value
                        self.fec_tunnel_id.value_namespace = name_space
                        self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "feclspid"):
                        self.feclspid = value
                        self.feclspid.value_namespace = name_space
                        self.feclspid.value_namespace_prefix = name_space_prefix
                    if(value_path == "fecp2mpid"):
                        self.fecp2mpid = value
                        self.fecp2mpid.value_namespace = name_space
                        self.fecp2mpid.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-receive-count"):
                        self.hello_receive_count = value
                        self.hello_receive_count.value_namespace = name_space
                        self.hello_receive_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "hello-transmit-count"):
                        self.hello_transmit_count = value
                        self.hello_transmit_count.value_namespace = name_space
                        self.hello_transmit_count.value_namespace_prefix = name_space_prefix
                    if(value_path == "incoming-label"):
                        self.incoming_label = value
                        self.incoming_label.value_namespace = name_space
                        self.incoming_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "location"):
                        self.location = value
                        self.location.value_namespace = name_space
                        self.location.value_namespace_prefix = name_space_prefix
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.ipv4bf_do_mplste_tail_packet_counter:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.ipv4bf_do_mplste_tail_packet_counter:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-tail-packet-counters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-counters/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ipv4bf-do-mplste-tail-packet-counter"):
                    for c in self.ipv4bf_do_mplste_tail_packet_counter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters.Ipv4BfDoMplsteTailPacketCounter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.ipv4bf_do_mplste_tail_packet_counter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ipv4bf-do-mplste-tail-packet-counter"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.ipv4bf_do_mplste_tail_packet_counters is not None and self.ipv4bf_do_mplste_tail_packet_counters.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.ipv4bf_do_mplste_tail_packet_counters is not None and self.ipv4bf_do_mplste_tail_packet_counters.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-tail-counters" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-tail-packet-counters"):
                if (self.ipv4bf_do_mplste_tail_packet_counters is None):
                    self.ipv4bf_do_mplste_tail_packet_counters = Bfd.Ipv4BfDoMplsteTailCounters.Ipv4BfDoMplsteTailPacketCounters()
                    self.ipv4bf_do_mplste_tail_packet_counters.parent = self
                    self._children_name_map["ipv4bf_do_mplste_tail_packet_counters"] = "ipv4bf-do-mplste-tail-packet-counters"
                return self.ipv4bf_do_mplste_tail_packet_counters

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-tail-packet-counters"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv6SingleHopSessionBriefs(Entity):
        """
        Table of brief information about all IPv6
        singlehop BFD sessions in the System
        
        .. attribute:: ipv6_single_hop_session_brief
        
        	Brief information for a single IPv6 singlehop BFD session
        	**type**\: list of    :py:class:`Ipv6SingleHopSessionBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv6SingleHopSessionBriefs, self).__init__()

            self.yang_name = "ipv6-single-hop-session-briefs"
            self.yang_parent_name = "bfd"

            self.ipv6_single_hop_session_brief = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv6SingleHopSessionBriefs, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv6SingleHopSessionBriefs, self).__setattr__(name, value)


        class Ipv6SingleHopSessionBrief(Entity):
            """
            Brief information for a single IPv6 singlehop
            BFD session
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: interface_name
            
            	Interface Name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_flags
            
            	Session Flags
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: session_type
            
            	Session type
            	**type**\:   :py:class:`BfdSession <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdSession>`
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: status_brief_information
            
            	Brief Status Information
            	**type**\:   :py:class:`StatusBriefInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation>`
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief, self).__init__()

                self.yang_name = "ipv6-single-hop-session-brief"
                self.yang_parent_name = "ipv6-single-hop-session-briefs"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_flags = YLeaf(YType.uint32, "session-flags")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.session_type = YLeaf(YType.enumeration, "session-type")

                self.state = YLeaf(YType.enumeration, "state")

                self.status_brief_information = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation()
                self.status_brief_information.parent = self
                self._children_name_map["status_brief_information"] = "status-brief-information"
                self._children_yang_names.add("status-brief-information")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "interface_name",
                                "location",
                                "node_id",
                                "session_flags",
                                "session_subtype",
                                "session_type",
                                "state") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief, self).__setattr__(name, value)


            class StatusBriefInformation(Entity):
                """
                Brief Status Information
                
                .. attribute:: async_interval_multiplier
                
                	Async Interval and Detect Multiplier Information
                	**type**\:   :py:class:`AsyncIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier>`
                
                .. attribute:: echo_interval_multiplier
                
                	Echo Interval and Detect Multiplier Information
                	**type**\:   :py:class:`EchoIntervalMultiplier <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier>`
                
                

                """

                _prefix = 'ip-bfd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation, self).__init__()

                    self.yang_name = "status-brief-information"
                    self.yang_parent_name = "ipv6-single-hop-session-brief"

                    self.async_interval_multiplier = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                    self.async_interval_multiplier.parent = self
                    self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                    self._children_yang_names.add("async-interval-multiplier")

                    self.echo_interval_multiplier = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                    self.echo_interval_multiplier.parent = self
                    self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                    self._children_yang_names.add("echo-interval-multiplier")


                class AsyncIntervalMultiplier(Entity):
                    """
                    Async Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_local_transmit_interval
                    
                    	Negotiated local transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_remote_transmit_interval
                    
                    	Negotiated remote transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__init__()

                        self.yang_name = "async-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_local_transmit_interval = YLeaf(YType.uint32, "negotiated-local-transmit-interval")

                        self.negotiated_remote_transmit_interval = YLeaf(YType.uint32, "negotiated-remote-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_local_transmit_interval",
                                        "negotiated_remote_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_local_transmit_interval.is_set or
                            self.negotiated_remote_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_local_transmit_interval.yfilter != YFilter.not_set or
                            self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "async-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/ipv6-single-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_local_transmit_interval.is_set or self.negotiated_local_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_local_transmit_interval.get_name_leafdata())
                        if (self.negotiated_remote_transmit_interval.is_set or self.negotiated_remote_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_remote_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-local-transmit-interval" or name == "negotiated-remote-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-local-transmit-interval"):
                            self.negotiated_local_transmit_interval = value
                            self.negotiated_local_transmit_interval.value_namespace = name_space
                            self.negotiated_local_transmit_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-remote-transmit-interval"):
                            self.negotiated_remote_transmit_interval = value
                            self.negotiated_remote_transmit_interval.value_namespace = name_space
                            self.negotiated_remote_transmit_interval.value_namespace_prefix = name_space_prefix


                class EchoIntervalMultiplier(Entity):
                    """
                    Echo Interval and Detect Multiplier Information
                    
                    .. attribute:: detection_multiplier
                    
                    	Detection Multiplier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: detection_time
                    
                    	Detection time in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    .. attribute:: negotiated_transmit_interval
                    
                    	Negotiated transmit interval in micro\-seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microsecond
                    
                    

                    """

                    _prefix = 'ip-bfd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__init__()

                        self.yang_name = "echo-interval-multiplier"
                        self.yang_parent_name = "status-brief-information"

                        self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                        self.detection_time = YLeaf(YType.uint32, "detection-time")

                        self.negotiated_transmit_interval = YLeaf(YType.uint32, "negotiated-transmit-interval")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("detection_multiplier",
                                        "detection_time",
                                        "negotiated_transmit_interval") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.detection_multiplier.is_set or
                            self.detection_time.is_set or
                            self.negotiated_transmit_interval.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.detection_multiplier.yfilter != YFilter.not_set or
                            self.detection_time.yfilter != YFilter.not_set or
                            self.negotiated_transmit_interval.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "echo-interval-multiplier" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/ipv6-single-hop-session-brief/status-brief-information/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                        if (self.detection_time.is_set or self.detection_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.detection_time.get_name_leafdata())
                        if (self.negotiated_transmit_interval.is_set or self.negotiated_transmit_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.negotiated_transmit_interval.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "detection-multiplier" or name == "detection-time" or name == "negotiated-transmit-interval"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "detection-multiplier"):
                            self.detection_multiplier = value
                            self.detection_multiplier.value_namespace = name_space
                            self.detection_multiplier.value_namespace_prefix = name_space_prefix
                        if(value_path == "detection-time"):
                            self.detection_time = value
                            self.detection_time.value_namespace = name_space
                            self.detection_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "negotiated-transmit-interval"):
                            self.negotiated_transmit_interval = value
                            self.negotiated_transmit_interval.value_namespace = name_space
                            self.negotiated_transmit_interval.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_data()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.async_interval_multiplier is not None and self.async_interval_multiplier.has_operation()) or
                        (self.echo_interval_multiplier is not None and self.echo_interval_multiplier.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "status-brief-information" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/ipv6-single-hop-session-brief/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "async-interval-multiplier"):
                        if (self.async_interval_multiplier is None):
                            self.async_interval_multiplier = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.AsyncIntervalMultiplier()
                            self.async_interval_multiplier.parent = self
                            self._children_name_map["async_interval_multiplier"] = "async-interval-multiplier"
                        return self.async_interval_multiplier

                    if (child_yang_name == "echo-interval-multiplier"):
                        if (self.echo_interval_multiplier is None):
                            self.echo_interval_multiplier = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation.EchoIntervalMultiplier()
                            self.echo_interval_multiplier.parent = self
                            self._children_name_map["echo_interval_multiplier"] = "echo-interval-multiplier"
                        return self.echo_interval_multiplier

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "async-interval-multiplier" or name == "echo-interval-multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.interface_name.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_flags.is_set or
                    self.session_subtype.is_set or
                    self.session_type.is_set or
                    self.state.is_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_flags.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.session_type.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    (self.status_brief_information is not None and self.status_brief_information.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv6-single-hop-session-brief" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_flags.is_set or self.session_flags.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_flags.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.session_type.is_set or self.session_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_type.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "status-brief-information"):
                    if (self.status_brief_information is None):
                        self.status_brief_information = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief.StatusBriefInformation()
                        self.status_brief_information.parent = self
                        self._children_name_map["status_brief_information"] = "status-brief-information"
                    return self.status_brief_information

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "status-brief-information" or name == "destination-address" or name == "interface-name" or name == "location" or name == "node-id" or name == "session-flags" or name == "session-subtype" or name == "session-type" or name == "state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-flags"):
                    self.session_flags = value
                    self.session_flags.value_namespace = name_space
                    self.session_flags.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "session-type"):
                    self.session_type = value
                    self.session_type.value_namespace = name_space
                    self.session_type.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv6_single_hop_session_brief:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv6_single_hop_session_brief:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv6-single-hop-session-briefs" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv6-single-hop-session-brief"):
                for c in self.ipv6_single_hop_session_brief:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv6SingleHopSessionBriefs.Ipv6SingleHopSessionBrief()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv6_single_hop_session_brief.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv6-single-hop-session-brief"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteTailMultiPaths(Entity):
        """
        IPv4 BFD over MPLS\-TE Tail multipath
        
        .. attribute:: ipv4bf_do_mplste_tail_multi_path
        
        	Label multipath table
        	**type**\: list of    :py:class:`Ipv4BfDoMplsteTailMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteTailMultiPaths.Ipv4BfDoMplsteTailMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteTailMultiPaths, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-tail-multi-paths"
            self.yang_parent_name = "bfd"

            self.ipv4bf_do_mplste_tail_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4BfDoMplsteTailMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4BfDoMplsteTailMultiPaths, self).__setattr__(name, value)


        class Ipv4BfDoMplsteTailMultiPath(Entity):
            """
            Label multipath table
            
            .. attribute:: fe_ctype
            
            	FEC Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_ctype
            
            	FEC C Type
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_destination
            
            	FEC Destination
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_extended_tunnel_id
            
            	FEC Extended Tunnel ID
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_source
            
            	FEC Source
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_subgroup_id
            
            	FEC Subgroup ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fec_subgroup_originator
            
            	FEC Subgroup originator
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: fec_tunnel_id
            
            	FEC Tunnel ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: feclspid
            
            	FEC LSP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: fecp2mpid
            
            	FEC P2MP ID
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteTailMultiPaths.Ipv4BfDoMplsteTailMultiPath, self).__init__()

                self.yang_name = "ipv4bf-do-mplste-tail-multi-path"
                self.yang_parent_name = "ipv4bf-do-mplste-tail-multi-paths"

                self.fe_ctype = YLeaf(YType.int32, "fe-ctype")

                self.fec_ctype = YLeaf(YType.int32, "fec-ctype")

                self.fec_destination = YLeaf(YType.str, "fec-destination")

                self.fec_extended_tunnel_id = YLeaf(YType.str, "fec-extended-tunnel-id")

                self.fec_source = YLeaf(YType.str, "fec-source")

                self.fec_subgroup_id = YLeaf(YType.int32, "fec-subgroup-id")

                self.fec_subgroup_originator = YLeaf(YType.str, "fec-subgroup-originator")

                self.fec_tunnel_id = YLeaf(YType.int32, "fec-tunnel-id")

                self.feclspid = YLeaf(YType.int32, "feclspid")

                self.fecp2mpid = YLeaf(YType.int32, "fecp2mpid")

                self.incoming_label = YLeaf(YType.int32, "incoming-label")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("fe_ctype",
                                "fec_ctype",
                                "fec_destination",
                                "fec_extended_tunnel_id",
                                "fec_source",
                                "fec_subgroup_id",
                                "fec_subgroup_originator",
                                "fec_tunnel_id",
                                "feclspid",
                                "fecp2mpid",
                                "incoming_label",
                                "incoming_label_xr",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteTailMultiPaths.Ipv4BfDoMplsteTailMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteTailMultiPaths.Ipv4BfDoMplsteTailMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.fe_ctype.is_set or
                    self.fec_ctype.is_set or
                    self.fec_destination.is_set or
                    self.fec_extended_tunnel_id.is_set or
                    self.fec_source.is_set or
                    self.fec_subgroup_id.is_set or
                    self.fec_subgroup_originator.is_set or
                    self.fec_tunnel_id.is_set or
                    self.feclspid.is_set or
                    self.fecp2mpid.is_set or
                    self.incoming_label.is_set or
                    self.incoming_label_xr.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.fe_ctype.yfilter != YFilter.not_set or
                    self.fec_ctype.yfilter != YFilter.not_set or
                    self.fec_destination.yfilter != YFilter.not_set or
                    self.fec_extended_tunnel_id.yfilter != YFilter.not_set or
                    self.fec_source.yfilter != YFilter.not_set or
                    self.fec_subgroup_id.yfilter != YFilter.not_set or
                    self.fec_subgroup_originator.yfilter != YFilter.not_set or
                    self.fec_tunnel_id.yfilter != YFilter.not_set or
                    self.feclspid.yfilter != YFilter.not_set or
                    self.fecp2mpid.yfilter != YFilter.not_set or
                    self.incoming_label.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4bf-do-mplste-tail-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.fe_ctype.is_set or self.fe_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fe_ctype.get_name_leafdata())
                if (self.fec_ctype.is_set or self.fec_ctype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_ctype.get_name_leafdata())
                if (self.fec_destination.is_set or self.fec_destination.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_destination.get_name_leafdata())
                if (self.fec_extended_tunnel_id.is_set or self.fec_extended_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_extended_tunnel_id.get_name_leafdata())
                if (self.fec_source.is_set or self.fec_source.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_source.get_name_leafdata())
                if (self.fec_subgroup_id.is_set or self.fec_subgroup_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_id.get_name_leafdata())
                if (self.fec_subgroup_originator.is_set or self.fec_subgroup_originator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_subgroup_originator.get_name_leafdata())
                if (self.fec_tunnel_id.is_set or self.fec_tunnel_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fec_tunnel_id.get_name_leafdata())
                if (self.feclspid.is_set or self.feclspid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.feclspid.get_name_leafdata())
                if (self.fecp2mpid.is_set or self.fecp2mpid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fecp2mpid.get_name_leafdata())
                if (self.incoming_label.is_set or self.incoming_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "fe-ctype" or name == "fec-ctype" or name == "fec-destination" or name == "fec-extended-tunnel-id" or name == "fec-source" or name == "fec-subgroup-id" or name == "fec-subgroup-originator" or name == "fec-tunnel-id" or name == "feclspid" or name == "fecp2mpid" or name == "incoming-label" or name == "incoming-label-xr" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "fe-ctype"):
                    self.fe_ctype = value
                    self.fe_ctype.value_namespace = name_space
                    self.fe_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-ctype"):
                    self.fec_ctype = value
                    self.fec_ctype.value_namespace = name_space
                    self.fec_ctype.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-destination"):
                    self.fec_destination = value
                    self.fec_destination.value_namespace = name_space
                    self.fec_destination.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-extended-tunnel-id"):
                    self.fec_extended_tunnel_id = value
                    self.fec_extended_tunnel_id.value_namespace = name_space
                    self.fec_extended_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-source"):
                    self.fec_source = value
                    self.fec_source.value_namespace = name_space
                    self.fec_source.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-id"):
                    self.fec_subgroup_id = value
                    self.fec_subgroup_id.value_namespace = name_space
                    self.fec_subgroup_id.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-subgroup-originator"):
                    self.fec_subgroup_originator = value
                    self.fec_subgroup_originator.value_namespace = name_space
                    self.fec_subgroup_originator.value_namespace_prefix = name_space_prefix
                if(value_path == "fec-tunnel-id"):
                    self.fec_tunnel_id = value
                    self.fec_tunnel_id.value_namespace = name_space
                    self.fec_tunnel_id.value_namespace_prefix = name_space_prefix
                if(value_path == "feclspid"):
                    self.feclspid = value
                    self.feclspid.value_namespace = name_space
                    self.feclspid.value_namespace_prefix = name_space_prefix
                if(value_path == "fecp2mpid"):
                    self.fecp2mpid = value
                    self.fecp2mpid.value_namespace = name_space
                    self.fecp2mpid.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label"):
                    self.incoming_label = value
                    self.incoming_label.value_namespace = name_space
                    self.incoming_label.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4bf_do_mplste_tail_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4bf_do_mplste_tail_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-tail-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4bf-do-mplste-tail-multi-path"):
                for c in self.ipv4bf_do_mplste_tail_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4BfDoMplsteTailMultiPaths.Ipv4BfDoMplsteTailMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4bf_do_mplste_tail_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4bf-do-mplste-tail-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4MultiHopMultiPaths(Entity):
        """
        IPv4 multi\-hop multipath
        
        .. attribute:: ipv4_multi_hop_multi_path
        
        	IPv4 multi hop multipath table
        	**type**\: list of    :py:class:`Ipv4MultiHopMultiPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4MultiHopMultiPaths.Ipv4MultiHopMultiPath>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4MultiHopMultiPaths, self).__init__()

            self.yang_name = "ipv4-multi-hop-multi-paths"
            self.yang_parent_name = "bfd"

            self.ipv4_multi_hop_multi_path = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Bfd.Ipv4MultiHopMultiPaths, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Bfd.Ipv4MultiHopMultiPaths, self).__setattr__(name, value)


        class Ipv4MultiHopMultiPath(Entity):
            """
            IPv4 multi hop multipath table
            
            .. attribute:: destination_address
            
            	Destination Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: incoming_label_xr
            
            	Incoming Label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: local_discriminator
            
            	Session's Local discriminator
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: location
            
            	Location
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: node_id
            
            	Location where session is housed
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: session_interface_name
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: session_subtype
            
            	Session subtype
            	**type**\:  str
            
            .. attribute:: source_address
            
            	Source Address
            	**type**\: one of the below types:
            
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            
            ----
            	**type**\:  str
            
            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
            
            
            ----
            .. attribute:: state
            
            	State
            	**type**\:   :py:class:`BfdMgmtSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.BfdMgmtSessionState>`
            
            .. attribute:: vrf_name
            
            	VRF name
            	**type**\:  str
            
            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4MultiHopMultiPaths.Ipv4MultiHopMultiPath, self).__init__()

                self.yang_name = "ipv4-multi-hop-multi-path"
                self.yang_parent_name = "ipv4-multi-hop-multi-paths"

                self.destination_address = YLeaf(YType.str, "destination-address")

                self.incoming_label_xr = YLeaf(YType.uint32, "incoming-label-xr")

                self.local_discriminator = YLeaf(YType.uint32, "local-discriminator")

                self.location = YLeaf(YType.str, "location")

                self.node_id = YLeaf(YType.str, "node-id")

                self.session_interface_name = YLeaf(YType.str, "session-interface-name")

                self.session_subtype = YLeaf(YType.str, "session-subtype")

                self.source_address = YLeaf(YType.str, "source-address")

                self.state = YLeaf(YType.enumeration, "state")

                self.vrf_name = YLeaf(YType.str, "vrf-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("destination_address",
                                "incoming_label_xr",
                                "local_discriminator",
                                "location",
                                "node_id",
                                "session_interface_name",
                                "session_subtype",
                                "source_address",
                                "state",
                                "vrf_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4MultiHopMultiPaths.Ipv4MultiHopMultiPath, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4MultiHopMultiPaths.Ipv4MultiHopMultiPath, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.destination_address.is_set or
                    self.incoming_label_xr.is_set or
                    self.local_discriminator.is_set or
                    self.location.is_set or
                    self.node_id.is_set or
                    self.session_interface_name.is_set or
                    self.session_subtype.is_set or
                    self.source_address.is_set or
                    self.state.is_set or
                    self.vrf_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.destination_address.yfilter != YFilter.not_set or
                    self.incoming_label_xr.yfilter != YFilter.not_set or
                    self.local_discriminator.yfilter != YFilter.not_set or
                    self.location.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.session_interface_name.yfilter != YFilter.not_set or
                    self.session_subtype.yfilter != YFilter.not_set or
                    self.source_address.yfilter != YFilter.not_set or
                    self.state.yfilter != YFilter.not_set or
                    self.vrf_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ipv4-multi-hop-multi-path" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-multi-paths/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.destination_address.get_name_leafdata())
                if (self.incoming_label_xr.is_set or self.incoming_label_xr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.incoming_label_xr.get_name_leafdata())
                if (self.local_discriminator.is_set or self.local_discriminator.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_discriminator.get_name_leafdata())
                if (self.location.is_set or self.location.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.location.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.session_interface_name.is_set or self.session_interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_interface_name.get_name_leafdata())
                if (self.session_subtype.is_set or self.session_subtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_subtype.get_name_leafdata())
                if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.source_address.get_name_leafdata())
                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.state.get_name_leafdata())
                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "destination-address" or name == "incoming-label-xr" or name == "local-discriminator" or name == "location" or name == "node-id" or name == "session-interface-name" or name == "session-subtype" or name == "source-address" or name == "state" or name == "vrf-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "destination-address"):
                    self.destination_address = value
                    self.destination_address.value_namespace = name_space
                    self.destination_address.value_namespace_prefix = name_space_prefix
                if(value_path == "incoming-label-xr"):
                    self.incoming_label_xr = value
                    self.incoming_label_xr.value_namespace = name_space
                    self.incoming_label_xr.value_namespace_prefix = name_space_prefix
                if(value_path == "local-discriminator"):
                    self.local_discriminator = value
                    self.local_discriminator.value_namespace = name_space
                    self.local_discriminator.value_namespace_prefix = name_space_prefix
                if(value_path == "location"):
                    self.location = value
                    self.location.value_namespace = name_space
                    self.location.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "session-interface-name"):
                    self.session_interface_name = value
                    self.session_interface_name.value_namespace = name_space
                    self.session_interface_name.value_namespace_prefix = name_space_prefix
                if(value_path == "session-subtype"):
                    self.session_subtype = value
                    self.session_subtype.value_namespace = name_space
                    self.session_subtype.value_namespace_prefix = name_space_prefix
                if(value_path == "source-address"):
                    self.source_address = value
                    self.source_address.value_namespace = name_space
                    self.source_address.value_namespace_prefix = name_space_prefix
                if(value_path == "state"):
                    self.state = value
                    self.state.value_namespace = name_space
                    self.state.value_namespace_prefix = name_space_prefix
                if(value_path == "vrf-name"):
                    self.vrf_name = value
                    self.vrf_name.value_namespace = name_space
                    self.vrf_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ipv4_multi_hop_multi_path:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ipv4_multi_hop_multi_path:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4-multi-hop-multi-paths" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "ipv4-multi-hop-multi-path"):
                for c in self.ipv4_multi_hop_multi_path:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Bfd.Ipv4MultiHopMultiPaths.Ipv4MultiHopMultiPath()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ipv4_multi_hop_multi_path.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "ipv4-multi-hop-multi-path"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ipv4BfDoMplsteHeadSummary(Entity):
        """
        Summary information of IPv4 BFD over MPLS\-TE
        Head
        
        .. attribute:: session_state
        
        	Statistics of states for sessions
        	**type**\:   :py:class:`SessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_ip_bfd_oper.Bfd.Ipv4BfDoMplsteHeadSummary.SessionState>`
        
        

        """

        _prefix = 'ip-bfd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Bfd.Ipv4BfDoMplsteHeadSummary, self).__init__()

            self.yang_name = "ipv4bf-do-mplste-head-summary"
            self.yang_parent_name = "bfd"

            self.session_state = Bfd.Ipv4BfDoMplsteHeadSummary.SessionState()
            self.session_state.parent = self
            self._children_name_map["session_state"] = "session-state"
            self._children_yang_names.add("session-state")


        class SessionState(Entity):
            """
            Statistics of states for sessions
            
            .. attribute:: down_count
            
            	Number of sessions in down state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total_count
            
            	Number of sessions in database
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: unknown_count
            
            	Number of sessions in unknown state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: up_count
            
            	Number of sessions in up state
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'ip-bfd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Bfd.Ipv4BfDoMplsteHeadSummary.SessionState, self).__init__()

                self.yang_name = "session-state"
                self.yang_parent_name = "ipv4bf-do-mplste-head-summary"

                self.down_count = YLeaf(YType.uint32, "down-count")

                self.total_count = YLeaf(YType.uint32, "total-count")

                self.unknown_count = YLeaf(YType.uint32, "unknown-count")

                self.up_count = YLeaf(YType.uint32, "up-count")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_count",
                                "total_count",
                                "unknown_count",
                                "up_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Bfd.Ipv4BfDoMplsteHeadSummary.SessionState, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Bfd.Ipv4BfDoMplsteHeadSummary.SessionState, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_count.is_set or
                    self.total_count.is_set or
                    self.unknown_count.is_set or
                    self.up_count.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_count.yfilter != YFilter.not_set or
                    self.total_count.yfilter != YFilter.not_set or
                    self.unknown_count.yfilter != YFilter.not_set or
                    self.up_count.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session-state" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-summary/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_count.is_set or self.down_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_count.get_name_leafdata())
                if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total_count.get_name_leafdata())
                if (self.unknown_count.is_set or self.unknown_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.unknown_count.get_name_leafdata())
                if (self.up_count.is_set or self.up_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-count" or name == "total-count" or name == "unknown-count" or name == "up-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-count"):
                    self.down_count = value
                    self.down_count.value_namespace = name_space
                    self.down_count.value_namespace_prefix = name_space_prefix
                if(value_path == "total-count"):
                    self.total_count = value
                    self.total_count.value_namespace = name_space
                    self.total_count.value_namespace_prefix = name_space_prefix
                if(value_path == "unknown-count"):
                    self.unknown_count = value
                    self.unknown_count.value_namespace = name_space
                    self.unknown_count.value_namespace_prefix = name_space_prefix
                if(value_path == "up-count"):
                    self.up_count = value
                    self.up_count.value_namespace = name_space
                    self.up_count.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (self.session_state is not None and self.session_state.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.session_state is not None and self.session_state.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ipv4bf-do-mplste-head-summary" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "session-state"):
                if (self.session_state is None):
                    self.session_state = Bfd.Ipv4BfDoMplsteHeadSummary.SessionState()
                    self.session_state.parent = self
                    self._children_name_map["session_state"] = "session-state"
                return self.session_state

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "session-state"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.client_briefs is not None and self.client_briefs.has_data()) or
            (self.client_details is not None and self.client_details.has_data()) or
            (self.counters is not None and self.counters.has_data()) or
            (self.generic_summaries is not None and self.generic_summaries.has_data()) or
            (self.ipv4_multi_hop_counters is not None and self.ipv4_multi_hop_counters.has_data()) or
            (self.ipv4_multi_hop_multi_paths is not None and self.ipv4_multi_hop_multi_paths.has_data()) or
            (self.ipv4_multi_hop_node_location_summaries is not None and self.ipv4_multi_hop_node_location_summaries.has_data()) or
            (self.ipv4_multi_hop_session_briefs is not None and self.ipv4_multi_hop_session_briefs.has_data()) or
            (self.ipv4_multi_hop_session_details is not None and self.ipv4_multi_hop_session_details.has_data()) or
            (self.ipv4_multi_hop_summary is not None and self.ipv4_multi_hop_summary.has_data()) or
            (self.ipv4_single_hop_counters is not None and self.ipv4_single_hop_counters.has_data()) or
            (self.ipv4_single_hop_location_summaries is not None and self.ipv4_single_hop_location_summaries.has_data()) or
            (self.ipv4_single_hop_multi_paths is not None and self.ipv4_single_hop_multi_paths.has_data()) or
            (self.ipv4_single_hop_node_location_summaries is not None and self.ipv4_single_hop_node_location_summaries.has_data()) or
            (self.ipv4_single_hop_session_briefs is not None and self.ipv4_single_hop_session_briefs.has_data()) or
            (self.ipv4_single_hop_session_details is not None and self.ipv4_single_hop_session_details.has_data()) or
            (self.ipv4_single_hop_summary is not None and self.ipv4_single_hop_summary.has_data()) or
            (self.ipv4bf_do_mplste_head_counters is not None and self.ipv4bf_do_mplste_head_counters.has_data()) or
            (self.ipv4bf_do_mplste_head_multi_paths is not None and self.ipv4bf_do_mplste_head_multi_paths.has_data()) or
            (self.ipv4bf_do_mplste_head_session_briefs is not None and self.ipv4bf_do_mplste_head_session_briefs.has_data()) or
            (self.ipv4bf_do_mplste_head_session_details is not None and self.ipv4bf_do_mplste_head_session_details.has_data()) or
            (self.ipv4bf_do_mplste_head_summary is not None and self.ipv4bf_do_mplste_head_summary.has_data()) or
            (self.ipv4bf_do_mplste_tail_counters is not None and self.ipv4bf_do_mplste_tail_counters.has_data()) or
            (self.ipv4bf_do_mplste_tail_multi_paths is not None and self.ipv4bf_do_mplste_tail_multi_paths.has_data()) or
            (self.ipv4bf_do_mplste_tail_session_briefs is not None and self.ipv4bf_do_mplste_tail_session_briefs.has_data()) or
            (self.ipv4bf_do_mplste_tail_session_details is not None and self.ipv4bf_do_mplste_tail_session_details.has_data()) or
            (self.ipv4bf_do_mplste_tail_summary is not None and self.ipv4bf_do_mplste_tail_summary.has_data()) or
            (self.ipv4bfd_mplste_head_summary_nodes is not None and self.ipv4bfd_mplste_head_summary_nodes.has_data()) or
            (self.ipv4bfd_mplste_tail_node_summaries is not None and self.ipv4bfd_mplste_tail_node_summaries.has_data()) or
            (self.ipv6_multi_hop_counters is not None and self.ipv6_multi_hop_counters.has_data()) or
            (self.ipv6_multi_hop_multi_paths is not None and self.ipv6_multi_hop_multi_paths.has_data()) or
            (self.ipv6_multi_hop_node_location_summaries is not None and self.ipv6_multi_hop_node_location_summaries.has_data()) or
            (self.ipv6_multi_hop_session_briefs is not None and self.ipv6_multi_hop_session_briefs.has_data()) or
            (self.ipv6_multi_hop_session_details is not None and self.ipv6_multi_hop_session_details.has_data()) or
            (self.ipv6_multi_hop_summary is not None and self.ipv6_multi_hop_summary.has_data()) or
            (self.ipv6_single_hop_counters is not None and self.ipv6_single_hop_counters.has_data()) or
            (self.ipv6_single_hop_location_summaries is not None and self.ipv6_single_hop_location_summaries.has_data()) or
            (self.ipv6_single_hop_multi_paths is not None and self.ipv6_single_hop_multi_paths.has_data()) or
            (self.ipv6_single_hop_node_location_summaries is not None and self.ipv6_single_hop_node_location_summaries.has_data()) or
            (self.ipv6_single_hop_session_briefs is not None and self.ipv6_single_hop_session_briefs.has_data()) or
            (self.ipv6_single_hop_session_details is not None and self.ipv6_single_hop_session_details.has_data()) or
            (self.ipv6_single_hop_summary is not None and self.ipv6_single_hop_summary.has_data()) or
            (self.label_counters is not None and self.label_counters.has_data()) or
            (self.label_multi_paths is not None and self.label_multi_paths.has_data()) or
            (self.label_session_briefs is not None and self.label_session_briefs.has_data()) or
            (self.label_session_details is not None and self.label_session_details.has_data()) or
            (self.label_summary is not None and self.label_summary.has_data()) or
            (self.label_summary_nodes is not None and self.label_summary_nodes.has_data()) or
            (self.relation_briefs is not None and self.relation_briefs.has_data()) or
            (self.relation_details is not None and self.relation_details.has_data()) or
            (self.session_briefs is not None and self.session_briefs.has_data()) or
            (self.session_details is not None and self.session_details.has_data()) or
            (self.session_mibs is not None and self.session_mibs.has_data()) or
            (self.summary is not None and self.summary.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.client_briefs is not None and self.client_briefs.has_operation()) or
            (self.client_details is not None and self.client_details.has_operation()) or
            (self.counters is not None and self.counters.has_operation()) or
            (self.generic_summaries is not None and self.generic_summaries.has_operation()) or
            (self.ipv4_multi_hop_counters is not None and self.ipv4_multi_hop_counters.has_operation()) or
            (self.ipv4_multi_hop_multi_paths is not None and self.ipv4_multi_hop_multi_paths.has_operation()) or
            (self.ipv4_multi_hop_node_location_summaries is not None and self.ipv4_multi_hop_node_location_summaries.has_operation()) or
            (self.ipv4_multi_hop_session_briefs is not None and self.ipv4_multi_hop_session_briefs.has_operation()) or
            (self.ipv4_multi_hop_session_details is not None and self.ipv4_multi_hop_session_details.has_operation()) or
            (self.ipv4_multi_hop_summary is not None and self.ipv4_multi_hop_summary.has_operation()) or
            (self.ipv4_single_hop_counters is not None and self.ipv4_single_hop_counters.has_operation()) or
            (self.ipv4_single_hop_location_summaries is not None and self.ipv4_single_hop_location_summaries.has_operation()) or
            (self.ipv4_single_hop_multi_paths is not None and self.ipv4_single_hop_multi_paths.has_operation()) or
            (self.ipv4_single_hop_node_location_summaries is not None and self.ipv4_single_hop_node_location_summaries.has_operation()) or
            (self.ipv4_single_hop_session_briefs is not None and self.ipv4_single_hop_session_briefs.has_operation()) or
            (self.ipv4_single_hop_session_details is not None and self.ipv4_single_hop_session_details.has_operation()) or
            (self.ipv4_single_hop_summary is not None and self.ipv4_single_hop_summary.has_operation()) or
            (self.ipv4bf_do_mplste_head_counters is not None and self.ipv4bf_do_mplste_head_counters.has_operation()) or
            (self.ipv4bf_do_mplste_head_multi_paths is not None and self.ipv4bf_do_mplste_head_multi_paths.has_operation()) or
            (self.ipv4bf_do_mplste_head_session_briefs is not None and self.ipv4bf_do_mplste_head_session_briefs.has_operation()) or
            (self.ipv4bf_do_mplste_head_session_details is not None and self.ipv4bf_do_mplste_head_session_details.has_operation()) or
            (self.ipv4bf_do_mplste_head_summary is not None and self.ipv4bf_do_mplste_head_summary.has_operation()) or
            (self.ipv4bf_do_mplste_tail_counters is not None and self.ipv4bf_do_mplste_tail_counters.has_operation()) or
            (self.ipv4bf_do_mplste_tail_multi_paths is not None and self.ipv4bf_do_mplste_tail_multi_paths.has_operation()) or
            (self.ipv4bf_do_mplste_tail_session_briefs is not None and self.ipv4bf_do_mplste_tail_session_briefs.has_operation()) or
            (self.ipv4bf_do_mplste_tail_session_details is not None and self.ipv4bf_do_mplste_tail_session_details.has_operation()) or
            (self.ipv4bf_do_mplste_tail_summary is not None and self.ipv4bf_do_mplste_tail_summary.has_operation()) or
            (self.ipv4bfd_mplste_head_summary_nodes is not None and self.ipv4bfd_mplste_head_summary_nodes.has_operation()) or
            (self.ipv4bfd_mplste_tail_node_summaries is not None and self.ipv4bfd_mplste_tail_node_summaries.has_operation()) or
            (self.ipv6_multi_hop_counters is not None and self.ipv6_multi_hop_counters.has_operation()) or
            (self.ipv6_multi_hop_multi_paths is not None and self.ipv6_multi_hop_multi_paths.has_operation()) or
            (self.ipv6_multi_hop_node_location_summaries is not None and self.ipv6_multi_hop_node_location_summaries.has_operation()) or
            (self.ipv6_multi_hop_session_briefs is not None and self.ipv6_multi_hop_session_briefs.has_operation()) or
            (self.ipv6_multi_hop_session_details is not None and self.ipv6_multi_hop_session_details.has_operation()) or
            (self.ipv6_multi_hop_summary is not None and self.ipv6_multi_hop_summary.has_operation()) or
            (self.ipv6_single_hop_counters is not None and self.ipv6_single_hop_counters.has_operation()) or
            (self.ipv6_single_hop_location_summaries is not None and self.ipv6_single_hop_location_summaries.has_operation()) or
            (self.ipv6_single_hop_multi_paths is not None and self.ipv6_single_hop_multi_paths.has_operation()) or
            (self.ipv6_single_hop_node_location_summaries is not None and self.ipv6_single_hop_node_location_summaries.has_operation()) or
            (self.ipv6_single_hop_session_briefs is not None and self.ipv6_single_hop_session_briefs.has_operation()) or
            (self.ipv6_single_hop_session_details is not None and self.ipv6_single_hop_session_details.has_operation()) or
            (self.ipv6_single_hop_summary is not None and self.ipv6_single_hop_summary.has_operation()) or
            (self.label_counters is not None and self.label_counters.has_operation()) or
            (self.label_multi_paths is not None and self.label_multi_paths.has_operation()) or
            (self.label_session_briefs is not None and self.label_session_briefs.has_operation()) or
            (self.label_session_details is not None and self.label_session_details.has_operation()) or
            (self.label_summary is not None and self.label_summary.has_operation()) or
            (self.label_summary_nodes is not None and self.label_summary_nodes.has_operation()) or
            (self.relation_briefs is not None and self.relation_briefs.has_operation()) or
            (self.relation_details is not None and self.relation_details.has_operation()) or
            (self.session_briefs is not None and self.session_briefs.has_operation()) or
            (self.session_details is not None and self.session_details.has_operation()) or
            (self.session_mibs is not None and self.session_mibs.has_operation()) or
            (self.summary is not None and self.summary.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-ip-bfd-oper:bfd" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "client-briefs"):
            if (self.client_briefs is None):
                self.client_briefs = Bfd.ClientBriefs()
                self.client_briefs.parent = self
                self._children_name_map["client_briefs"] = "client-briefs"
            return self.client_briefs

        if (child_yang_name == "client-details"):
            if (self.client_details is None):
                self.client_details = Bfd.ClientDetails()
                self.client_details.parent = self
                self._children_name_map["client_details"] = "client-details"
            return self.client_details

        if (child_yang_name == "counters"):
            if (self.counters is None):
                self.counters = Bfd.Counters()
                self.counters.parent = self
                self._children_name_map["counters"] = "counters"
            return self.counters

        if (child_yang_name == "generic-summaries"):
            if (self.generic_summaries is None):
                self.generic_summaries = Bfd.GenericSummaries()
                self.generic_summaries.parent = self
                self._children_name_map["generic_summaries"] = "generic-summaries"
            return self.generic_summaries

        if (child_yang_name == "ipv4-multi-hop-counters"):
            if (self.ipv4_multi_hop_counters is None):
                self.ipv4_multi_hop_counters = Bfd.Ipv4MultiHopCounters()
                self.ipv4_multi_hop_counters.parent = self
                self._children_name_map["ipv4_multi_hop_counters"] = "ipv4-multi-hop-counters"
            return self.ipv4_multi_hop_counters

        if (child_yang_name == "ipv4-multi-hop-multi-paths"):
            if (self.ipv4_multi_hop_multi_paths is None):
                self.ipv4_multi_hop_multi_paths = Bfd.Ipv4MultiHopMultiPaths()
                self.ipv4_multi_hop_multi_paths.parent = self
                self._children_name_map["ipv4_multi_hop_multi_paths"] = "ipv4-multi-hop-multi-paths"
            return self.ipv4_multi_hop_multi_paths

        if (child_yang_name == "ipv4-multi-hop-node-location-summaries"):
            if (self.ipv4_multi_hop_node_location_summaries is None):
                self.ipv4_multi_hop_node_location_summaries = Bfd.Ipv4MultiHopNodeLocationSummaries()
                self.ipv4_multi_hop_node_location_summaries.parent = self
                self._children_name_map["ipv4_multi_hop_node_location_summaries"] = "ipv4-multi-hop-node-location-summaries"
            return self.ipv4_multi_hop_node_location_summaries

        if (child_yang_name == "ipv4-multi-hop-session-briefs"):
            if (self.ipv4_multi_hop_session_briefs is None):
                self.ipv4_multi_hop_session_briefs = Bfd.Ipv4MultiHopSessionBriefs()
                self.ipv4_multi_hop_session_briefs.parent = self
                self._children_name_map["ipv4_multi_hop_session_briefs"] = "ipv4-multi-hop-session-briefs"
            return self.ipv4_multi_hop_session_briefs

        if (child_yang_name == "ipv4-multi-hop-session-details"):
            if (self.ipv4_multi_hop_session_details is None):
                self.ipv4_multi_hop_session_details = Bfd.Ipv4MultiHopSessionDetails()
                self.ipv4_multi_hop_session_details.parent = self
                self._children_name_map["ipv4_multi_hop_session_details"] = "ipv4-multi-hop-session-details"
            return self.ipv4_multi_hop_session_details

        if (child_yang_name == "ipv4-multi-hop-summary"):
            if (self.ipv4_multi_hop_summary is None):
                self.ipv4_multi_hop_summary = Bfd.Ipv4MultiHopSummary()
                self.ipv4_multi_hop_summary.parent = self
                self._children_name_map["ipv4_multi_hop_summary"] = "ipv4-multi-hop-summary"
            return self.ipv4_multi_hop_summary

        if (child_yang_name == "ipv4-single-hop-counters"):
            if (self.ipv4_single_hop_counters is None):
                self.ipv4_single_hop_counters = Bfd.Ipv4SingleHopCounters()
                self.ipv4_single_hop_counters.parent = self
                self._children_name_map["ipv4_single_hop_counters"] = "ipv4-single-hop-counters"
            return self.ipv4_single_hop_counters

        if (child_yang_name == "ipv4-single-hop-location-summaries"):
            if (self.ipv4_single_hop_location_summaries is None):
                self.ipv4_single_hop_location_summaries = Bfd.Ipv4SingleHopLocationSummaries()
                self.ipv4_single_hop_location_summaries.parent = self
                self._children_name_map["ipv4_single_hop_location_summaries"] = "ipv4-single-hop-location-summaries"
            return self.ipv4_single_hop_location_summaries

        if (child_yang_name == "ipv4-single-hop-multi-paths"):
            if (self.ipv4_single_hop_multi_paths is None):
                self.ipv4_single_hop_multi_paths = Bfd.Ipv4SingleHopMultiPaths()
                self.ipv4_single_hop_multi_paths.parent = self
                self._children_name_map["ipv4_single_hop_multi_paths"] = "ipv4-single-hop-multi-paths"
            return self.ipv4_single_hop_multi_paths

        if (child_yang_name == "ipv4-single-hop-node-location-summaries"):
            if (self.ipv4_single_hop_node_location_summaries is None):
                self.ipv4_single_hop_node_location_summaries = Bfd.Ipv4SingleHopNodeLocationSummaries()
                self.ipv4_single_hop_node_location_summaries.parent = self
                self._children_name_map["ipv4_single_hop_node_location_summaries"] = "ipv4-single-hop-node-location-summaries"
            return self.ipv4_single_hop_node_location_summaries

        if (child_yang_name == "ipv4-single-hop-session-briefs"):
            if (self.ipv4_single_hop_session_briefs is None):
                self.ipv4_single_hop_session_briefs = Bfd.Ipv4SingleHopSessionBriefs()
                self.ipv4_single_hop_session_briefs.parent = self
                self._children_name_map["ipv4_single_hop_session_briefs"] = "ipv4-single-hop-session-briefs"
            return self.ipv4_single_hop_session_briefs

        if (child_yang_name == "ipv4-single-hop-session-details"):
            if (self.ipv4_single_hop_session_details is None):
                self.ipv4_single_hop_session_details = Bfd.Ipv4SingleHopSessionDetails()
                self.ipv4_single_hop_session_details.parent = self
                self._children_name_map["ipv4_single_hop_session_details"] = "ipv4-single-hop-session-details"
            return self.ipv4_single_hop_session_details

        if (child_yang_name == "ipv4-single-hop-summary"):
            if (self.ipv4_single_hop_summary is None):
                self.ipv4_single_hop_summary = Bfd.Ipv4SingleHopSummary()
                self.ipv4_single_hop_summary.parent = self
                self._children_name_map["ipv4_single_hop_summary"] = "ipv4-single-hop-summary"
            return self.ipv4_single_hop_summary

        if (child_yang_name == "ipv4bf-do-mplste-head-counters"):
            if (self.ipv4bf_do_mplste_head_counters is None):
                self.ipv4bf_do_mplste_head_counters = Bfd.Ipv4BfDoMplsteHeadCounters()
                self.ipv4bf_do_mplste_head_counters.parent = self
                self._children_name_map["ipv4bf_do_mplste_head_counters"] = "ipv4bf-do-mplste-head-counters"
            return self.ipv4bf_do_mplste_head_counters

        if (child_yang_name == "ipv4bf-do-mplste-head-multi-paths"):
            if (self.ipv4bf_do_mplste_head_multi_paths is None):
                self.ipv4bf_do_mplste_head_multi_paths = Bfd.Ipv4BfDoMplsteHeadMultiPaths()
                self.ipv4bf_do_mplste_head_multi_paths.parent = self
                self._children_name_map["ipv4bf_do_mplste_head_multi_paths"] = "ipv4bf-do-mplste-head-multi-paths"
            return self.ipv4bf_do_mplste_head_multi_paths

        if (child_yang_name == "ipv4bf-do-mplste-head-session-briefs"):
            if (self.ipv4bf_do_mplste_head_session_briefs is None):
                self.ipv4bf_do_mplste_head_session_briefs = Bfd.Ipv4BfDoMplsteHeadSessionBriefs()
                self.ipv4bf_do_mplste_head_session_briefs.parent = self
                self._children_name_map["ipv4bf_do_mplste_head_session_briefs"] = "ipv4bf-do-mplste-head-session-briefs"
            return self.ipv4bf_do_mplste_head_session_briefs

        if (child_yang_name == "ipv4bf-do-mplste-head-session-details"):
            if (self.ipv4bf_do_mplste_head_session_details is None):
                self.ipv4bf_do_mplste_head_session_details = Bfd.Ipv4BfDoMplsteHeadSessionDetails()
                self.ipv4bf_do_mplste_head_session_details.parent = self
                self._children_name_map["ipv4bf_do_mplste_head_session_details"] = "ipv4bf-do-mplste-head-session-details"
            return self.ipv4bf_do_mplste_head_session_details

        if (child_yang_name == "ipv4bf-do-mplste-head-summary"):
            if (self.ipv4bf_do_mplste_head_summary is None):
                self.ipv4bf_do_mplste_head_summary = Bfd.Ipv4BfDoMplsteHeadSummary()
                self.ipv4bf_do_mplste_head_summary.parent = self
                self._children_name_map["ipv4bf_do_mplste_head_summary"] = "ipv4bf-do-mplste-head-summary"
            return self.ipv4bf_do_mplste_head_summary

        if (child_yang_name == "ipv4bf-do-mplste-tail-counters"):
            if (self.ipv4bf_do_mplste_tail_counters is None):
                self.ipv4bf_do_mplste_tail_counters = Bfd.Ipv4BfDoMplsteTailCounters()
                self.ipv4bf_do_mplste_tail_counters.parent = self
                self._children_name_map["ipv4bf_do_mplste_tail_counters"] = "ipv4bf-do-mplste-tail-counters"
            return self.ipv4bf_do_mplste_tail_counters

        if (child_yang_name == "ipv4bf-do-mplste-tail-multi-paths"):
            if (self.ipv4bf_do_mplste_tail_multi_paths is None):
                self.ipv4bf_do_mplste_tail_multi_paths = Bfd.Ipv4BfDoMplsteTailMultiPaths()
                self.ipv4bf_do_mplste_tail_multi_paths.parent = self
                self._children_name_map["ipv4bf_do_mplste_tail_multi_paths"] = "ipv4bf-do-mplste-tail-multi-paths"
            return self.ipv4bf_do_mplste_tail_multi_paths

        if (child_yang_name == "ipv4bf-do-mplste-tail-session-briefs"):
            if (self.ipv4bf_do_mplste_tail_session_briefs is None):
                self.ipv4bf_do_mplste_tail_session_briefs = Bfd.Ipv4BfDoMplsteTailSessionBriefs()
                self.ipv4bf_do_mplste_tail_session_briefs.parent = self
                self._children_name_map["ipv4bf_do_mplste_tail_session_briefs"] = "ipv4bf-do-mplste-tail-session-briefs"
            return self.ipv4bf_do_mplste_tail_session_briefs

        if (child_yang_name == "ipv4bf-do-mplste-tail-session-details"):
            if (self.ipv4bf_do_mplste_tail_session_details is None):
                self.ipv4bf_do_mplste_tail_session_details = Bfd.Ipv4BfDoMplsteTailSessionDetails()
                self.ipv4bf_do_mplste_tail_session_details.parent = self
                self._children_name_map["ipv4bf_do_mplste_tail_session_details"] = "ipv4bf-do-mplste-tail-session-details"
            return self.ipv4bf_do_mplste_tail_session_details

        if (child_yang_name == "ipv4bf-do-mplste-tail-summary"):
            if (self.ipv4bf_do_mplste_tail_summary is None):
                self.ipv4bf_do_mplste_tail_summary = Bfd.Ipv4BfDoMplsteTailSummary()
                self.ipv4bf_do_mplste_tail_summary.parent = self
                self._children_name_map["ipv4bf_do_mplste_tail_summary"] = "ipv4bf-do-mplste-tail-summary"
            return self.ipv4bf_do_mplste_tail_summary

        if (child_yang_name == "ipv4bfd-mplste-head-summary-nodes"):
            if (self.ipv4bfd_mplste_head_summary_nodes is None):
                self.ipv4bfd_mplste_head_summary_nodes = Bfd.Ipv4BfdMplsteHeadSummaryNodes()
                self.ipv4bfd_mplste_head_summary_nodes.parent = self
                self._children_name_map["ipv4bfd_mplste_head_summary_nodes"] = "ipv4bfd-mplste-head-summary-nodes"
            return self.ipv4bfd_mplste_head_summary_nodes

        if (child_yang_name == "ipv4bfd-mplste-tail-node-summaries"):
            if (self.ipv4bfd_mplste_tail_node_summaries is None):
                self.ipv4bfd_mplste_tail_node_summaries = Bfd.Ipv4BfdMplsteTailNodeSummaries()
                self.ipv4bfd_mplste_tail_node_summaries.parent = self
                self._children_name_map["ipv4bfd_mplste_tail_node_summaries"] = "ipv4bfd-mplste-tail-node-summaries"
            return self.ipv4bfd_mplste_tail_node_summaries

        if (child_yang_name == "ipv6-multi-hop-counters"):
            if (self.ipv6_multi_hop_counters is None):
                self.ipv6_multi_hop_counters = Bfd.Ipv6MultiHopCounters()
                self.ipv6_multi_hop_counters.parent = self
                self._children_name_map["ipv6_multi_hop_counters"] = "ipv6-multi-hop-counters"
            return self.ipv6_multi_hop_counters

        if (child_yang_name == "ipv6-multi-hop-multi-paths"):
            if (self.ipv6_multi_hop_multi_paths is None):
                self.ipv6_multi_hop_multi_paths = Bfd.Ipv6MultiHopMultiPaths()
                self.ipv6_multi_hop_multi_paths.parent = self
                self._children_name_map["ipv6_multi_hop_multi_paths"] = "ipv6-multi-hop-multi-paths"
            return self.ipv6_multi_hop_multi_paths

        if (child_yang_name == "ipv6-multi-hop-node-location-summaries"):
            if (self.ipv6_multi_hop_node_location_summaries is None):
                self.ipv6_multi_hop_node_location_summaries = Bfd.Ipv6MultiHopNodeLocationSummaries()
                self.ipv6_multi_hop_node_location_summaries.parent = self
                self._children_name_map["ipv6_multi_hop_node_location_summaries"] = "ipv6-multi-hop-node-location-summaries"
            return self.ipv6_multi_hop_node_location_summaries

        if (child_yang_name == "ipv6-multi-hop-session-briefs"):
            if (self.ipv6_multi_hop_session_briefs is None):
                self.ipv6_multi_hop_session_briefs = Bfd.Ipv6MultiHopSessionBriefs()
                self.ipv6_multi_hop_session_briefs.parent = self
                self._children_name_map["ipv6_multi_hop_session_briefs"] = "ipv6-multi-hop-session-briefs"
            return self.ipv6_multi_hop_session_briefs

        if (child_yang_name == "ipv6-multi-hop-session-details"):
            if (self.ipv6_multi_hop_session_details is None):
                self.ipv6_multi_hop_session_details = Bfd.Ipv6MultiHopSessionDetails()
                self.ipv6_multi_hop_session_details.parent = self
                self._children_name_map["ipv6_multi_hop_session_details"] = "ipv6-multi-hop-session-details"
            return self.ipv6_multi_hop_session_details

        if (child_yang_name == "ipv6-multi-hop-summary"):
            if (self.ipv6_multi_hop_summary is None):
                self.ipv6_multi_hop_summary = Bfd.Ipv6MultiHopSummary()
                self.ipv6_multi_hop_summary.parent = self
                self._children_name_map["ipv6_multi_hop_summary"] = "ipv6-multi-hop-summary"
            return self.ipv6_multi_hop_summary

        if (child_yang_name == "ipv6-single-hop-counters"):
            if (self.ipv6_single_hop_counters is None):
                self.ipv6_single_hop_counters = Bfd.Ipv6SingleHopCounters()
                self.ipv6_single_hop_counters.parent = self
                self._children_name_map["ipv6_single_hop_counters"] = "ipv6-single-hop-counters"
            return self.ipv6_single_hop_counters

        if (child_yang_name == "ipv6-single-hop-location-summaries"):
            if (self.ipv6_single_hop_location_summaries is None):
                self.ipv6_single_hop_location_summaries = Bfd.Ipv6SingleHopLocationSummaries()
                self.ipv6_single_hop_location_summaries.parent = self
                self._children_name_map["ipv6_single_hop_location_summaries"] = "ipv6-single-hop-location-summaries"
            return self.ipv6_single_hop_location_summaries

        if (child_yang_name == "ipv6-single-hop-multi-paths"):
            if (self.ipv6_single_hop_multi_paths is None):
                self.ipv6_single_hop_multi_paths = Bfd.Ipv6SingleHopMultiPaths()
                self.ipv6_single_hop_multi_paths.parent = self
                self._children_name_map["ipv6_single_hop_multi_paths"] = "ipv6-single-hop-multi-paths"
            return self.ipv6_single_hop_multi_paths

        if (child_yang_name == "ipv6-single-hop-node-location-summaries"):
            if (self.ipv6_single_hop_node_location_summaries is None):
                self.ipv6_single_hop_node_location_summaries = Bfd.Ipv6SingleHopNodeLocationSummaries()
                self.ipv6_single_hop_node_location_summaries.parent = self
                self._children_name_map["ipv6_single_hop_node_location_summaries"] = "ipv6-single-hop-node-location-summaries"
            return self.ipv6_single_hop_node_location_summaries

        if (child_yang_name == "ipv6-single-hop-session-briefs"):
            if (self.ipv6_single_hop_session_briefs is None):
                self.ipv6_single_hop_session_briefs = Bfd.Ipv6SingleHopSessionBriefs()
                self.ipv6_single_hop_session_briefs.parent = self
                self._children_name_map["ipv6_single_hop_session_briefs"] = "ipv6-single-hop-session-briefs"
            return self.ipv6_single_hop_session_briefs

        if (child_yang_name == "ipv6-single-hop-session-details"):
            if (self.ipv6_single_hop_session_details is None):
                self.ipv6_single_hop_session_details = Bfd.Ipv6SingleHopSessionDetails()
                self.ipv6_single_hop_session_details.parent = self
                self._children_name_map["ipv6_single_hop_session_details"] = "ipv6-single-hop-session-details"
            return self.ipv6_single_hop_session_details

        if (child_yang_name == "ipv6-single-hop-summary"):
            if (self.ipv6_single_hop_summary is None):
                self.ipv6_single_hop_summary = Bfd.Ipv6SingleHopSummary()
                self.ipv6_single_hop_summary.parent = self
                self._children_name_map["ipv6_single_hop_summary"] = "ipv6-single-hop-summary"
            return self.ipv6_single_hop_summary

        if (child_yang_name == "label-counters"):
            if (self.label_counters is None):
                self.label_counters = Bfd.LabelCounters()
                self.label_counters.parent = self
                self._children_name_map["label_counters"] = "label-counters"
            return self.label_counters

        if (child_yang_name == "label-multi-paths"):
            if (self.label_multi_paths is None):
                self.label_multi_paths = Bfd.LabelMultiPaths()
                self.label_multi_paths.parent = self
                self._children_name_map["label_multi_paths"] = "label-multi-paths"
            return self.label_multi_paths

        if (child_yang_name == "label-session-briefs"):
            if (self.label_session_briefs is None):
                self.label_session_briefs = Bfd.LabelSessionBriefs()
                self.label_session_briefs.parent = self
                self._children_name_map["label_session_briefs"] = "label-session-briefs"
            return self.label_session_briefs

        if (child_yang_name == "label-session-details"):
            if (self.label_session_details is None):
                self.label_session_details = Bfd.LabelSessionDetails()
                self.label_session_details.parent = self
                self._children_name_map["label_session_details"] = "label-session-details"
            return self.label_session_details

        if (child_yang_name == "label-summary"):
            if (self.label_summary is None):
                self.label_summary = Bfd.LabelSummary()
                self.label_summary.parent = self
                self._children_name_map["label_summary"] = "label-summary"
            return self.label_summary

        if (child_yang_name == "label-summary-nodes"):
            if (self.label_summary_nodes is None):
                self.label_summary_nodes = Bfd.LabelSummaryNodes()
                self.label_summary_nodes.parent = self
                self._children_name_map["label_summary_nodes"] = "label-summary-nodes"
            return self.label_summary_nodes

        if (child_yang_name == "relation-briefs"):
            if (self.relation_briefs is None):
                self.relation_briefs = Bfd.RelationBriefs()
                self.relation_briefs.parent = self
                self._children_name_map["relation_briefs"] = "relation-briefs"
            return self.relation_briefs

        if (child_yang_name == "relation-details"):
            if (self.relation_details is None):
                self.relation_details = Bfd.RelationDetails()
                self.relation_details.parent = self
                self._children_name_map["relation_details"] = "relation-details"
            return self.relation_details

        if (child_yang_name == "session-briefs"):
            if (self.session_briefs is None):
                self.session_briefs = Bfd.SessionBriefs()
                self.session_briefs.parent = self
                self._children_name_map["session_briefs"] = "session-briefs"
            return self.session_briefs

        if (child_yang_name == "session-details"):
            if (self.session_details is None):
                self.session_details = Bfd.SessionDetails()
                self.session_details.parent = self
                self._children_name_map["session_details"] = "session-details"
            return self.session_details

        if (child_yang_name == "session-mibs"):
            if (self.session_mibs is None):
                self.session_mibs = Bfd.SessionMibs()
                self.session_mibs.parent = self
                self._children_name_map["session_mibs"] = "session-mibs"
            return self.session_mibs

        if (child_yang_name == "summary"):
            if (self.summary is None):
                self.summary = Bfd.Summary()
                self.summary.parent = self
                self._children_name_map["summary"] = "summary"
            return self.summary

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "client-briefs" or name == "client-details" or name == "counters" or name == "generic-summaries" or name == "ipv4-multi-hop-counters" or name == "ipv4-multi-hop-multi-paths" or name == "ipv4-multi-hop-node-location-summaries" or name == "ipv4-multi-hop-session-briefs" or name == "ipv4-multi-hop-session-details" or name == "ipv4-multi-hop-summary" or name == "ipv4-single-hop-counters" or name == "ipv4-single-hop-location-summaries" or name == "ipv4-single-hop-multi-paths" or name == "ipv4-single-hop-node-location-summaries" or name == "ipv4-single-hop-session-briefs" or name == "ipv4-single-hop-session-details" or name == "ipv4-single-hop-summary" or name == "ipv4bf-do-mplste-head-counters" or name == "ipv4bf-do-mplste-head-multi-paths" or name == "ipv4bf-do-mplste-head-session-briefs" or name == "ipv4bf-do-mplste-head-session-details" or name == "ipv4bf-do-mplste-head-summary" or name == "ipv4bf-do-mplste-tail-counters" or name == "ipv4bf-do-mplste-tail-multi-paths" or name == "ipv4bf-do-mplste-tail-session-briefs" or name == "ipv4bf-do-mplste-tail-session-details" or name == "ipv4bf-do-mplste-tail-summary" or name == "ipv4bfd-mplste-head-summary-nodes" or name == "ipv4bfd-mplste-tail-node-summaries" or name == "ipv6-multi-hop-counters" or name == "ipv6-multi-hop-multi-paths" or name == "ipv6-multi-hop-node-location-summaries" or name == "ipv6-multi-hop-session-briefs" or name == "ipv6-multi-hop-session-details" or name == "ipv6-multi-hop-summary" or name == "ipv6-single-hop-counters" or name == "ipv6-single-hop-location-summaries" or name == "ipv6-single-hop-multi-paths" or name == "ipv6-single-hop-node-location-summaries" or name == "ipv6-single-hop-session-briefs" or name == "ipv6-single-hop-session-details" or name == "ipv6-single-hop-summary" or name == "label-counters" or name == "label-multi-paths" or name == "label-session-briefs" or name == "label-session-details" or name == "label-summary" or name == "label-summary-nodes" or name == "relation-briefs" or name == "relation-details" or name == "session-briefs" or name == "session-details" or name == "session-mibs" or name == "summary"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Bfd()
        return self._top_entity

