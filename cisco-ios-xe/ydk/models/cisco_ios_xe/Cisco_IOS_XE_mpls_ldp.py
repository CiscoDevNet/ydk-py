""" Cisco_IOS_XE_mpls_ldp 

This module contains a collection of YANG definitions
for the Cisco MPLS LDP configuration and operational data.


The configuration is held in the mpls\-ldp\-config container
which is broken into the following sections\:
  1) global\-cfg contains configuration applicable to the entire
       LSR.
  2) nbr\-table contains configuration for specific LDP neighbors
       or peers.
  3) passwords contains configuration regarding passwords, both
       local and those to be used with specific neighbors.
  4) label\-cfg contains the label allocation and advertisement
       configuration and filters.
  5) discovery contains the configuration for link\-hello and
       targetted hello protocol parameters including
       interface\-specific settings for transport.
  6) graceful\-restart contains the configuration for the
       graceful restart feature.
  7) logging contains the configuration for ldp\-specific logs.
  8) interfaces contains the configuration for each interface,
       including and routing interactions specific to that
       interface.

The operational state is held in the mpls\-ldp\-state container
which is broken the following sections\:
  1) oper\-summary contains the summarized global state.
  2) forwarding\-summary contains the summarized forwarding
       state.
  3) bindings\-summary contains the summarized forwarding state.
  4) vrf provides the detailed state on a per VRF basis.
  5) bindings\-advertise\-specs \- holds the advertisement
       specification filters
  6) discovery provides the LDP Discovery operational state.
  7) forwarding provides summary information regarding LDP
       forwarding setup and detailed information on the LDP
       forwarding rewrites
  8) bindings provides the detailed LDP Bindings of address to
       label.
  9) neighbors

The vrf\-table, provides the detailed state on a per VRF basis.
If the router only supports LDP in a single VRF then this table
will have a single entry using the vrf\-name 'default'.
Otherwise this table will have one entry for every VRF where
LDP is enabled on the device.

Each vrf includes\:
   A list parameters used by the VRF
   A capability table containing the capabilities exchanged with
     each neighbor.
   A table of backoff parameters used in this VRF.
   The graceful restart information used between the local
      device and the neighbors should any of them restart.
   An AF\-table which holds all information for a given Address
      Family. This is extensive and is described below.
   The LDP ID used by the device for this vrf.

The AF\-table holds information for a given Address Family
such as\:
     \- per\-interface state.
     \- IGP synchronization data.
     \- LDP bindings statistics.
     \- LDP forwarding statistics.


  Terms and Acronyms

  FRR \- Fast Re\-Reroute

  ICCP \- Inter\-Chassis Communication Protocol

  LACP \- Link Aggregation Control Protocol

  LDP \- Label Distribution Protocol

  LER \- Label Edge Router

  LFA \- Loop Free Alternative

  LIB \- Label Information Base

  LSR \- Label Switch Router

  MPLS \- Multi\-Protocol Label Switching

  PQ node \- A node which is a member of both the extended
      P\-space and the Q\-space as defined in
      draft\-ietf\-rtgwg\-rlfa\-node\-protection.

  VRF \- Virtual Route Forwarding

Copyright (c) 2014, 2017 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class AdjState(Enum):
    """
    AdjState

    The current state of the session, all of the

    states 0 to 5 are based on the state machine

    for LDP adjacency peer.

    .. data:: nonex = 0

    	LDP adjacency state: nonexistent.

    .. data:: unsol_op_pdg = 1

    	LDP session state: unsolicited open pending.

    .. data:: deferred = 2

    	LDP session state: deferred.

    .. data:: estab = 3

    	LDP session state: established

    .. data:: lib_exp_wait = 4

    	LDP session state: LIB expension wait.

    .. data:: destroyed = 5

    	LDP session state: destroyed.

    """

    nonex = Enum.YLeaf(0, "nonex")

    unsol_op_pdg = Enum.YLeaf(1, "unsol-op-pdg")

    deferred = Enum.YLeaf(2, "deferred")

    estab = Enum.YLeaf(3, "estab")

    lib_exp_wait = Enum.YLeaf(4, "lib-exp-wait")

    destroyed = Enum.YLeaf(5, "destroyed")


class AdvLabelType(Enum):
    """
    AdvLabelType

    This provides the configuration of the type of label to

    advertise for matching prefixes and peers.

    .. data:: use_lable = 1

    	Advertise the label for matching prefixes and peers.

    .. data:: use_explicit = 2

    	Advertise explicit null for matching prefixes and peers.

    .. data:: use_implicit = 3

    	Advertise imlicit null for matching prefixes and peers.

    .. data:: none = 4

    	Do not advertise labels for matching prefixes and peers.

    """

    use_lable = Enum.YLeaf(1, "use-lable")

    use_explicit = Enum.YLeaf(2, "use-explicit")

    use_implicit = Enum.YLeaf(3, "use-implicit")

    none = Enum.YLeaf(4, "none")


class Af(Enum):
    """
    Af

    LDP Address Family

    .. data:: ldp_af_none = 0

    	No Address Family

    .. data:: ldp_af_ipv4 = 1

    	IPv4 AFI

    .. data:: ldp_af_ipv6 = 2

    	IPv6 AFI

    .. data:: ldp_af_ipv4_ipv6 = 3

    	Both IPv4/IPv6 AFIs

    """

    ldp_af_none = Enum.YLeaf(0, "ldp-af-none")

    ldp_af_ipv4 = Enum.YLeaf(1, "ldp-af-ipv4")

    ldp_af_ipv6 = Enum.YLeaf(2, "ldp-af-ipv6")

    ldp_af_ipv4_ipv6 = Enum.YLeaf(3, "ldp-af-ipv4-ipv6")


class AfId(Enum):
    """
    AfId

    LDP AF type

    .. data:: ldp_af_id_none = 0

    	No Address Family

    .. data:: ldp_af_id_ipv4 = 1

    	IPv4 AFI

    .. data:: ldp_af_id_ipv6 = 2

    	IPv6 AFI

    """

    ldp_af_id_none = Enum.YLeaf(0, "ldp-af-id-none")

    ldp_af_id_ipv4 = Enum.YLeaf(1, "ldp-af-id-ipv4")

    ldp_af_id_ipv6 = Enum.YLeaf(2, "ldp-af-id-ipv6")


class DhcState(Enum):
    """
    DhcState

    This is the Directed Hello Control State Type.

    .. data:: none = 0

    	There is no current Directed Hello Control State.

    .. data:: dhc_active = 1

    	The Directed Hello is Active.

    .. data:: dhc_passive = 2

    	The Directed Hello is Passive.

    .. data:: dhc_active_passive = 3

    	The Directed Hello is both Active and Passive.

    """

    none = Enum.YLeaf(0, "none")

    dhc_active = Enum.YLeaf(1, "dhc-active")

    dhc_passive = Enum.YLeaf(2, "dhc-passive")

    dhc_active_passive = Enum.YLeaf(3, "dhc-active-passive")


class IccpState(Enum):
    """
    IccpState

    This enum describes the ICCP state as defined by the

    IETF in TBD.

    .. data:: nonexistent = 1

    	This state is the starting point for the state machine.

    	It indicates that no ICCP connection exists and that

    	there's no LDP session established between the PEs.

    .. data:: initialized = 2

    	This state indicates that an LDP session exists between

    	the PEs but LDP ICCP Capabilitiy have not yet been

    	exchanged between them.

    .. data:: capsent = 3

    	This state indicates that an LDP session exists between

    	the PEs and that the local PE has avertized LDP ICCP

    	Capability to its peer.

    .. data:: caprec = 4

    	This state indicates that an LDP session exists between

    	the PEs and that the local PE has both received and

    	advertized LDP ICCP Capability from/to its peer.

    .. data:: connecting = 5

    	This state indicates that the local PE has initiated an

    	ICCP connection to its peer, and is awaiting its

    	response.

    .. data:: operational = 6

    	This state indicates that the ICCP connection is

    	operational.

    """

    nonexistent = Enum.YLeaf(1, "nonexistent")

    initialized = Enum.YLeaf(2, "initialized")

    capsent = Enum.YLeaf(3, "capsent")

    caprec = Enum.YLeaf(4, "caprec")

    connecting = Enum.YLeaf(5, "connecting")

    operational = Enum.YLeaf(6, "operational")


class IgpSyncState(Enum):
    """
    IgpSyncState

    This is the IGP Synchronization State.

    .. data:: isync_ready = 0

    	Achieved

    .. data:: isync_not_ready = 1

    	Not achieved

    .. data:: isync_deferred = 2

    	Deferred due to interface delay or global

    	restart delay

    """

    isync_ready = Enum.YLeaf(0, "isync-ready")

    isync_not_ready = Enum.YLeaf(1, "isync-not-ready")

    isync_deferred = Enum.YLeaf(2, "isync-deferred")


class LocalLabelState(Enum):
    """
    LocalLabelState

    This id the MPLS LDP Local Label State Type.

    .. data:: local_label_state_none = 1

    	None

    .. data:: local_label_state_assigned = 2

    	Assigned

    .. data:: local_label_state_withdrawn = 3

    	Withdrawn

    """

    local_label_state_none = Enum.YLeaf(1, "local-label-state-none")

    local_label_state_assigned = Enum.YLeaf(2, "local-label-state-assigned")

    local_label_state_withdrawn = Enum.YLeaf(3, "local-label-state-withdrawn")


class LoopDetectionType(Enum):
    """
    LoopDetectionType

    This specifies the type of loop detection either supported by

    the LSR or enabled on the LSR.

    .. data:: none = 1

    	Loop Detection is not enabled on this LSR.

    .. data:: other = 2

    	Loop Detection is enabled but by a method

    	other than those defined.

    .. data:: hop_count = 3

    	Loop Detection is supported by Hop Count only.

    .. data:: path_vector = 4

    	Loop Detection is supported by Path Vector only.

    .. data:: hop_count_and_path_vector = 5

    	Loop Detection is supported by both Hop Count

    	and Path Vector.

    """

    none = Enum.YLeaf(1, "none")

    other = Enum.YLeaf(2, "other")

    hop_count = Enum.YLeaf(3, "hop-count")

    path_vector = Enum.YLeaf(4, "path-vector")

    hop_count_and_path_vector = Enum.YLeaf(5, "hop-count-and-path-vector")


class NbrBgpAdvtState(Enum):
    """
    NbrBgpAdvtState

    MPLS LDP Neighbor BGP Label Advertisement State

    Type.

    .. data:: not_applicable = 0

    	BGP Label Advertisement is not applicable.

    .. data:: permit = 1

    	BGP Label Advertisement is permitted.

    .. data:: deny = 2

    	BGP Label Advertisement denied.

    """

    not_applicable = Enum.YLeaf(0, "not-applicable")

    permit = Enum.YLeaf(1, "permit")

    deny = Enum.YLeaf(2, "deny")


class SessionState(Enum):
    """
    SessionState

    The current state of the session, all of the

    states 1 to 5 are based on the state machine

    for session negotiation behavior.

    .. data:: nonexistent = 1

    	LDP session state: nonexistent.

    .. data:: initialized = 2

    	LDP session state: initialized.

    .. data:: openrec = 3

    	LDP session state: openrec.

    .. data:: opensent = 4

    	LDP session state: opensent.

    .. data:: operational = 5

    	LDP session state: operational.

    """

    nonexistent = Enum.YLeaf(1, "nonexistent")

    initialized = Enum.YLeaf(2, "initialized")

    openrec = Enum.YLeaf(3, "openrec")

    opensent = Enum.YLeaf(4, "opensent")

    operational = Enum.YLeaf(5, "operational")



class NsrPeerSyncErr(Identity):
    """
    Base for MPLS LDP NSR peer synchronization error types.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErr, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err")


class IccpType(Identity):
    """
    Base identity from which ICCP types can be derived. As this is
    an extensible protocol, new types are expected.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IccpType, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:iccp-type")


class IcpmType(Identity):
    """
    Base identity from which ICPM types can be derived. As this is
    an extensible protocol, new types are expected.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IcpmType, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:icpm-type")


class LabelType(Identity):
    """
    Base type for LDP Label Type
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LabelType, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:label-type")


class RoutePathType(Identity):
    """
    Base type for Route path type.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathType, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-type")


class NsrStatus(Identity):
    """
    Base identity for Non\-Stop Routing State Type.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrStatus, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-status")


class NsrSyncNackRsn(Identity):
    """
    Base identity from which LDP Non\-Stop Routing peer LDP
    synchronization nack reason identities are derived.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsn, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn")


class IgpSyncDownReason(Identity):
    """
    Base identity reason IGP Sync was not achieved.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReason, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason")


class DownNbrReason(Identity):
    """
    Base identity for the reason a neighbor is down.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(DownNbrReason, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:down-nbr-reason")


class NsrPeerSyncState(Identity):
    """
    Base identity for LDP NSR Peer Synchronization State.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncState, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-state")


class RoutePathLblOwner(Identity):
    """
    Base Route path label owner type.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathLblOwner, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-lbl-owner")


class MplsLdp(Entity):
    """
    MPLS LDP configuration and operational data.
    
    .. attribute:: mpls_ldp_config
    
    	MPLS LDP Configuration
    	**type**\:   :py:class:`MplsLdpConfig <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig>`
    
    .. attribute:: mpls_ldp_state
    
    	MPLS LDP operational data
    	**type**\:   :py:class:`MplsLdpState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState>`
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(MplsLdp, self).__init__()
        self._top_entity = None

        self.yang_name = "mpls-ldp"
        self.yang_parent_name = "Cisco-IOS-XE-mpls-ldp"

        self.mpls_ldp_config = MplsLdp.MplsLdpConfig()
        self.mpls_ldp_config.parent = self
        self._children_name_map["mpls_ldp_config"] = "mpls-ldp-config"
        self._children_yang_names.add("mpls-ldp-config")

        self.mpls_ldp_state = MplsLdp.MplsLdpState()
        self.mpls_ldp_state.parent = self
        self._children_name_map["mpls_ldp_state"] = "mpls-ldp-state"
        self._children_yang_names.add("mpls-ldp-state")


    class MplsLdpState(Entity):
        """
        MPLS LDP operational data.
        
        .. attribute:: backoff_parameters
        
        	MPLS LDP Session Backoff Information
        	**type**\:   :py:class:`BackoffParameters <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.BackoffParameters>`
        
        .. attribute:: bindings
        
        	The detailed LDP Bindings
        	**type**\:   :py:class:`Bindings <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings>`
        
        .. attribute:: bindings_summary
        
        	Aggregate counters for the MPLS LDP LIB
        	**type**\:   :py:class:`BindingsSummary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.BindingsSummary>`
        
        .. attribute:: capabilities
        
        	LDP capability database information
        	**type**\:   :py:class:`Capabilities <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Capabilities>`
        
        .. attribute:: discovery
        
        	The LDP Discovery operational state
        	**type**\:   :py:class:`Discovery <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Discovery>`
        
        .. attribute:: forwarding
        
        	Summary information regarding LDP forwarding setup and detailed LDP Forwarding rewrites
        	**type**\:   :py:class:`Forwarding <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding>`
        
        .. attribute:: forwarding_summary
        
        	Summary information regarding LDP forwarding setup
        	**type**\:   :py:class:`ForwardingSummary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.ForwardingSummary>`
        
        .. attribute:: graceful_restart
        
        	MPLS LDP Graceful Restart Information
        	**type**\:   :py:class:`GracefulRestart <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.GracefulRestart>`
        
        .. attribute:: icpm_summary_all
        
        	Summary info for LDP ICPM/ICCP
        	**type**\:   :py:class:`IcpmSummaryAll <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll>`
        
        .. attribute:: label_ranges
        
        	This contaions holds all the label ranges in use by this LDP instance
        	**type**\:   :py:class:`LabelRanges <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.LabelRanges>`
        
        .. attribute:: neighbors
        
        	The LDP Neighbors Information
        	**type**\:   :py:class:`Neighbors <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors>`
        
        .. attribute:: nsr_summary_all
        
        	This is the LDP NSR summary for the device
        	**type**\:   :py:class:`NsrSummaryAll <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.NsrSummaryAll>`
        
        .. attribute:: oper_summary
        
        	LDP operational data summary
        	**type**\:   :py:class:`OperSummary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.OperSummary>`
        
        .. attribute:: parameters
        
        	MPLS LDP Global Parameters
        	**type**\:   :py:class:`Parameters <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Parameters>`
        
        .. attribute:: vrfs
        
        	MPLS LDP per\-VRF operational data
        	**type**\:   :py:class:`Vrfs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs>`
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(MplsLdp.MplsLdpState, self).__init__()

            self.yang_name = "mpls-ldp-state"
            self.yang_parent_name = "mpls-ldp"

            self.backoff_parameters = MplsLdp.MplsLdpState.BackoffParameters()
            self.backoff_parameters.parent = self
            self._children_name_map["backoff_parameters"] = "backoff-parameters"
            self._children_yang_names.add("backoff-parameters")

            self.bindings = MplsLdp.MplsLdpState.Bindings()
            self.bindings.parent = self
            self._children_name_map["bindings"] = "bindings"
            self._children_yang_names.add("bindings")

            self.bindings_summary = MplsLdp.MplsLdpState.BindingsSummary()
            self.bindings_summary.parent = self
            self._children_name_map["bindings_summary"] = "bindings-summary"
            self._children_yang_names.add("bindings-summary")

            self.capabilities = MplsLdp.MplsLdpState.Capabilities()
            self.capabilities.parent = self
            self._children_name_map["capabilities"] = "capabilities"
            self._children_yang_names.add("capabilities")

            self.discovery = MplsLdp.MplsLdpState.Discovery()
            self.discovery.parent = self
            self._children_name_map["discovery"] = "discovery"
            self._children_yang_names.add("discovery")

            self.forwarding = MplsLdp.MplsLdpState.Forwarding()
            self.forwarding.parent = self
            self._children_name_map["forwarding"] = "forwarding"
            self._children_yang_names.add("forwarding")

            self.forwarding_summary = MplsLdp.MplsLdpState.ForwardingSummary()
            self.forwarding_summary.parent = self
            self._children_name_map["forwarding_summary"] = "forwarding-summary"
            self._children_yang_names.add("forwarding-summary")

            self.graceful_restart = MplsLdp.MplsLdpState.GracefulRestart()
            self.graceful_restart.parent = self
            self._children_name_map["graceful_restart"] = "graceful-restart"
            self._children_yang_names.add("graceful-restart")

            self.icpm_summary_all = MplsLdp.MplsLdpState.IcpmSummaryAll()
            self.icpm_summary_all.parent = self
            self._children_name_map["icpm_summary_all"] = "icpm-summary-all"
            self._children_yang_names.add("icpm-summary-all")

            self.label_ranges = MplsLdp.MplsLdpState.LabelRanges()
            self.label_ranges.parent = self
            self._children_name_map["label_ranges"] = "label-ranges"
            self._children_yang_names.add("label-ranges")

            self.neighbors = MplsLdp.MplsLdpState.Neighbors()
            self.neighbors.parent = self
            self._children_name_map["neighbors"] = "neighbors"
            self._children_yang_names.add("neighbors")

            self.nsr_summary_all = MplsLdp.MplsLdpState.NsrSummaryAll()
            self.nsr_summary_all.parent = self
            self._children_name_map["nsr_summary_all"] = "nsr-summary-all"
            self._children_yang_names.add("nsr-summary-all")

            self.oper_summary = MplsLdp.MplsLdpState.OperSummary()
            self.oper_summary.parent = self
            self._children_name_map["oper_summary"] = "oper-summary"
            self._children_yang_names.add("oper-summary")

            self.parameters = MplsLdp.MplsLdpState.Parameters()
            self.parameters.parent = self
            self._children_name_map["parameters"] = "parameters"
            self._children_yang_names.add("parameters")

            self.vrfs = MplsLdp.MplsLdpState.Vrfs()
            self.vrfs.parent = self
            self._children_name_map["vrfs"] = "vrfs"
            self._children_yang_names.add("vrfs")


        class OperSummary(Entity):
            """
            LDP operational data summary
            
            .. attribute:: common
            
            	Common Summary information
            	**type**\:   :py:class:`Common <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.OperSummary.Common>`
            
            .. attribute:: no_of_ipv4_rib_tbl
            
            	Total number of ipv4 RIB tables
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: no_of_ipv4_rib_tbl_reg
            
            	Number of ipv4 RIB tables registered
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: number_of_autocfg_interfaces
            
            	Number of auto\-configured interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: number_of_fwd_ref_interfaces
            
            	Number of Forward Reference interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: number_of_interfaces
            
            	Number of known interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: number_of_vrf
            
            	Number of configured VRFs (including default)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: number_of_vrf_oper
            
            	Number of configured operational VRFs (including default)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.OperSummary, self).__init__()

                self.yang_name = "oper-summary"
                self.yang_parent_name = "mpls-ldp-state"

                self.no_of_ipv4_rib_tbl = YLeaf(YType.uint32, "no-of-ipv4-rib-tbl")

                self.no_of_ipv4_rib_tbl_reg = YLeaf(YType.uint32, "no-of-ipv4-rib-tbl-reg")

                self.number_of_autocfg_interfaces = YLeaf(YType.uint32, "number-of-autocfg-interfaces")

                self.number_of_fwd_ref_interfaces = YLeaf(YType.uint32, "number-of-fwd-ref-interfaces")

                self.number_of_interfaces = YLeaf(YType.uint32, "number-of-interfaces")

                self.number_of_vrf = YLeaf(YType.uint32, "number-of-vrf")

                self.number_of_vrf_oper = YLeaf(YType.uint32, "number-of-vrf-oper")

                self.common = MplsLdp.MplsLdpState.OperSummary.Common()
                self.common.parent = self
                self._children_name_map["common"] = "common"
                self._children_yang_names.add("common")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("no_of_ipv4_rib_tbl",
                                "no_of_ipv4_rib_tbl_reg",
                                "number_of_autocfg_interfaces",
                                "number_of_fwd_ref_interfaces",
                                "number_of_interfaces",
                                "number_of_vrf",
                                "number_of_vrf_oper") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.OperSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.OperSummary, self).__setattr__(name, value)


            class Common(Entity):
                """
                Common Summary information
                
                .. attribute:: address_families
                
                	Address Families enabled
                	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                
                .. attribute:: number_of_downstream_on_demand_neighbors
                
                	Number of Downstream\-On\-Demand neighbor
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: number_of_graceful_restart_neighbors
                
                	Number of Graceful Restart neighbor
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: number_of_ipv4_local_addresses
                
                	Number of IPv4 local addresses
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: number_of_ipv4_routes
                
                	Number of resolved IPv4 routes
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: number_of_ipv4ldp_interfaces
                
                	Number of LDP IPv4 configured interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: number_of_ldp_interfaces
                
                	Number of LDP configured interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: number_of_neighbors
                
                	Number of neighbor
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: numberof_ipv4_hello_adj
                
                	Number of LDP discovery IPv4 hello adjacencies
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.OperSummary.Common, self).__init__()

                    self.yang_name = "common"
                    self.yang_parent_name = "oper-summary"

                    self.address_families = YLeaf(YType.enumeration, "address-families")

                    self.number_of_downstream_on_demand_neighbors = YLeaf(YType.uint32, "number-of-downstream-on-demand-neighbors")

                    self.number_of_graceful_restart_neighbors = YLeaf(YType.uint32, "number-of-graceful-restart-neighbors")

                    self.number_of_ipv4_local_addresses = YLeaf(YType.uint32, "number-of-ipv4-local-addresses")

                    self.number_of_ipv4_routes = YLeaf(YType.uint32, "number-of-ipv4-routes")

                    self.number_of_ipv4ldp_interfaces = YLeaf(YType.uint32, "number-of-ipv4ldp-interfaces")

                    self.number_of_ldp_interfaces = YLeaf(YType.uint32, "number-of-ldp-interfaces")

                    self.number_of_neighbors = YLeaf(YType.uint32, "number-of-neighbors")

                    self.numberof_ipv4_hello_adj = YLeaf(YType.uint32, "numberof-ipv4-hello-adj")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("address_families",
                                    "number_of_downstream_on_demand_neighbors",
                                    "number_of_graceful_restart_neighbors",
                                    "number_of_ipv4_local_addresses",
                                    "number_of_ipv4_routes",
                                    "number_of_ipv4ldp_interfaces",
                                    "number_of_ldp_interfaces",
                                    "number_of_neighbors",
                                    "numberof_ipv4_hello_adj") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.OperSummary.Common, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.OperSummary.Common, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.address_families.is_set or
                        self.number_of_downstream_on_demand_neighbors.is_set or
                        self.number_of_graceful_restart_neighbors.is_set or
                        self.number_of_ipv4_local_addresses.is_set or
                        self.number_of_ipv4_routes.is_set or
                        self.number_of_ipv4ldp_interfaces.is_set or
                        self.number_of_ldp_interfaces.is_set or
                        self.number_of_neighbors.is_set or
                        self.numberof_ipv4_hello_adj.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.address_families.yfilter != YFilter.not_set or
                        self.number_of_downstream_on_demand_neighbors.yfilter != YFilter.not_set or
                        self.number_of_graceful_restart_neighbors.yfilter != YFilter.not_set or
                        self.number_of_ipv4_local_addresses.yfilter != YFilter.not_set or
                        self.number_of_ipv4_routes.yfilter != YFilter.not_set or
                        self.number_of_ipv4ldp_interfaces.yfilter != YFilter.not_set or
                        self.number_of_ldp_interfaces.yfilter != YFilter.not_set or
                        self.number_of_neighbors.yfilter != YFilter.not_set or
                        self.numberof_ipv4_hello_adj.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "common" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/oper-summary/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.address_families.is_set or self.address_families.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address_families.get_name_leafdata())
                    if (self.number_of_downstream_on_demand_neighbors.is_set or self.number_of_downstream_on_demand_neighbors.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_downstream_on_demand_neighbors.get_name_leafdata())
                    if (self.number_of_graceful_restart_neighbors.is_set or self.number_of_graceful_restart_neighbors.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_graceful_restart_neighbors.get_name_leafdata())
                    if (self.number_of_ipv4_local_addresses.is_set or self.number_of_ipv4_local_addresses.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_ipv4_local_addresses.get_name_leafdata())
                    if (self.number_of_ipv4_routes.is_set or self.number_of_ipv4_routes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_ipv4_routes.get_name_leafdata())
                    if (self.number_of_ipv4ldp_interfaces.is_set or self.number_of_ipv4ldp_interfaces.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_ipv4ldp_interfaces.get_name_leafdata())
                    if (self.number_of_ldp_interfaces.is_set or self.number_of_ldp_interfaces.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_ldp_interfaces.get_name_leafdata())
                    if (self.number_of_neighbors.is_set or self.number_of_neighbors.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.number_of_neighbors.get_name_leafdata())
                    if (self.numberof_ipv4_hello_adj.is_set or self.numberof_ipv4_hello_adj.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.numberof_ipv4_hello_adj.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "address-families" or name == "number-of-downstream-on-demand-neighbors" or name == "number-of-graceful-restart-neighbors" or name == "number-of-ipv4-local-addresses" or name == "number-of-ipv4-routes" or name == "number-of-ipv4ldp-interfaces" or name == "number-of-ldp-interfaces" or name == "number-of-neighbors" or name == "numberof-ipv4-hello-adj"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "address-families"):
                        self.address_families = value
                        self.address_families.value_namespace = name_space
                        self.address_families.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-downstream-on-demand-neighbors"):
                        self.number_of_downstream_on_demand_neighbors = value
                        self.number_of_downstream_on_demand_neighbors.value_namespace = name_space
                        self.number_of_downstream_on_demand_neighbors.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-graceful-restart-neighbors"):
                        self.number_of_graceful_restart_neighbors = value
                        self.number_of_graceful_restart_neighbors.value_namespace = name_space
                        self.number_of_graceful_restart_neighbors.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-ipv4-local-addresses"):
                        self.number_of_ipv4_local_addresses = value
                        self.number_of_ipv4_local_addresses.value_namespace = name_space
                        self.number_of_ipv4_local_addresses.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-ipv4-routes"):
                        self.number_of_ipv4_routes = value
                        self.number_of_ipv4_routes.value_namespace = name_space
                        self.number_of_ipv4_routes.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-ipv4ldp-interfaces"):
                        self.number_of_ipv4ldp_interfaces = value
                        self.number_of_ipv4ldp_interfaces.value_namespace = name_space
                        self.number_of_ipv4ldp_interfaces.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-ldp-interfaces"):
                        self.number_of_ldp_interfaces = value
                        self.number_of_ldp_interfaces.value_namespace = name_space
                        self.number_of_ldp_interfaces.value_namespace_prefix = name_space_prefix
                    if(value_path == "number-of-neighbors"):
                        self.number_of_neighbors = value
                        self.number_of_neighbors.value_namespace = name_space
                        self.number_of_neighbors.value_namespace_prefix = name_space_prefix
                    if(value_path == "numberof-ipv4-hello-adj"):
                        self.numberof_ipv4_hello_adj = value
                        self.numberof_ipv4_hello_adj.value_namespace = name_space
                        self.numberof_ipv4_hello_adj.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.no_of_ipv4_rib_tbl.is_set or
                    self.no_of_ipv4_rib_tbl_reg.is_set or
                    self.number_of_autocfg_interfaces.is_set or
                    self.number_of_fwd_ref_interfaces.is_set or
                    self.number_of_interfaces.is_set or
                    self.number_of_vrf.is_set or
                    self.number_of_vrf_oper.is_set or
                    (self.common is not None and self.common.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.no_of_ipv4_rib_tbl.yfilter != YFilter.not_set or
                    self.no_of_ipv4_rib_tbl_reg.yfilter != YFilter.not_set or
                    self.number_of_autocfg_interfaces.yfilter != YFilter.not_set or
                    self.number_of_fwd_ref_interfaces.yfilter != YFilter.not_set or
                    self.number_of_interfaces.yfilter != YFilter.not_set or
                    self.number_of_vrf.yfilter != YFilter.not_set or
                    self.number_of_vrf_oper.yfilter != YFilter.not_set or
                    (self.common is not None and self.common.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "oper-summary" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.no_of_ipv4_rib_tbl.is_set or self.no_of_ipv4_rib_tbl.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.no_of_ipv4_rib_tbl.get_name_leafdata())
                if (self.no_of_ipv4_rib_tbl_reg.is_set or self.no_of_ipv4_rib_tbl_reg.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.no_of_ipv4_rib_tbl_reg.get_name_leafdata())
                if (self.number_of_autocfg_interfaces.is_set or self.number_of_autocfg_interfaces.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.number_of_autocfg_interfaces.get_name_leafdata())
                if (self.number_of_fwd_ref_interfaces.is_set or self.number_of_fwd_ref_interfaces.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.number_of_fwd_ref_interfaces.get_name_leafdata())
                if (self.number_of_interfaces.is_set or self.number_of_interfaces.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.number_of_interfaces.get_name_leafdata())
                if (self.number_of_vrf.is_set or self.number_of_vrf.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.number_of_vrf.get_name_leafdata())
                if (self.number_of_vrf_oper.is_set or self.number_of_vrf_oper.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.number_of_vrf_oper.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "common"):
                    if (self.common is None):
                        self.common = MplsLdp.MplsLdpState.OperSummary.Common()
                        self.common.parent = self
                        self._children_name_map["common"] = "common"
                    return self.common

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "common" or name == "no-of-ipv4-rib-tbl" or name == "no-of-ipv4-rib-tbl-reg" or name == "number-of-autocfg-interfaces" or name == "number-of-fwd-ref-interfaces" or name == "number-of-interfaces" or name == "number-of-vrf" or name == "number-of-vrf-oper"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "no-of-ipv4-rib-tbl"):
                    self.no_of_ipv4_rib_tbl = value
                    self.no_of_ipv4_rib_tbl.value_namespace = name_space
                    self.no_of_ipv4_rib_tbl.value_namespace_prefix = name_space_prefix
                if(value_path == "no-of-ipv4-rib-tbl-reg"):
                    self.no_of_ipv4_rib_tbl_reg = value
                    self.no_of_ipv4_rib_tbl_reg.value_namespace = name_space
                    self.no_of_ipv4_rib_tbl_reg.value_namespace_prefix = name_space_prefix
                if(value_path == "number-of-autocfg-interfaces"):
                    self.number_of_autocfg_interfaces = value
                    self.number_of_autocfg_interfaces.value_namespace = name_space
                    self.number_of_autocfg_interfaces.value_namespace_prefix = name_space_prefix
                if(value_path == "number-of-fwd-ref-interfaces"):
                    self.number_of_fwd_ref_interfaces = value
                    self.number_of_fwd_ref_interfaces.value_namespace = name_space
                    self.number_of_fwd_ref_interfaces.value_namespace_prefix = name_space_prefix
                if(value_path == "number-of-interfaces"):
                    self.number_of_interfaces = value
                    self.number_of_interfaces.value_namespace = name_space
                    self.number_of_interfaces.value_namespace_prefix = name_space_prefix
                if(value_path == "number-of-vrf"):
                    self.number_of_vrf = value
                    self.number_of_vrf.value_namespace = name_space
                    self.number_of_vrf.value_namespace_prefix = name_space_prefix
                if(value_path == "number-of-vrf-oper"):
                    self.number_of_vrf_oper = value
                    self.number_of_vrf_oper.value_namespace = name_space
                    self.number_of_vrf_oper.value_namespace_prefix = name_space_prefix


        class ForwardingSummary(Entity):
            """
            Summary information regarding LDP forwarding
            setup
            
            .. attribute:: intfs_fwd_count
            
            	MPLS forwarding enabled interface count
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: local_lbls
            
            	Local label allocated count
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: nhs
            
            	MPLS LDP forwarding rewrite next\-hop/path summary
            	**type**\:   :py:class:`Nhs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.ForwardingSummary.Nhs>`
            
            .. attribute:: pfxs
            
            	MPLS LDP forwarding prefix rewrite summary
            	**type**\:   :py:class:`Pfxs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.ForwardingSummary.Pfxs>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.ForwardingSummary, self).__init__()

                self.yang_name = "forwarding-summary"
                self.yang_parent_name = "mpls-ldp-state"

                self.intfs_fwd_count = YLeaf(YType.uint16, "intfs-fwd-count")

                self.local_lbls = YLeaf(YType.uint16, "local-lbls")

                self.nhs = MplsLdp.MplsLdpState.ForwardingSummary.Nhs()
                self.nhs.parent = self
                self._children_name_map["nhs"] = "nhs"
                self._children_yang_names.add("nhs")

                self.pfxs = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs()
                self.pfxs.parent = self
                self._children_name_map["pfxs"] = "pfxs"
                self._children_yang_names.add("pfxs")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("intfs_fwd_count",
                                "local_lbls") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.ForwardingSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.ForwardingSummary, self).__setattr__(name, value)


            class Pfxs(Entity):
                """
                MPLS LDP forwarding prefix rewrite summary
                
                .. attribute:: ecmp_pfxs
                
                	Count of prefixes with ECMP
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: labeled_pfxs_aggr
                
                	Labeled prefix count for all paths
                	**type**\:   :py:class:`LabeledPfxsAggr <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsAggr>`
                
                .. attribute:: labeled_pfxs_backup
                
                	Labeled prefix count related to backup paths only
                	**type**\:   :py:class:`LabeledPfxsBackup <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsBackup>`
                
                .. attribute:: labeled_pfxs_primary
                
                	Labeled prefix count related to primary paths only
                	**type**\:   :py:class:`LabeledPfxsPrimary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsPrimary>`
                
                .. attribute:: protected_pfxs
                
                	Count of FRR protected prefixes
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: total_pfxs
                
                	Total Prefix count
                	**type**\:  int
                
                	**range:** 0..65535
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs, self).__init__()

                    self.yang_name = "pfxs"
                    self.yang_parent_name = "forwarding-summary"

                    self.ecmp_pfxs = YLeaf(YType.uint16, "ecmp-pfxs")

                    self.protected_pfxs = YLeaf(YType.uint16, "protected-pfxs")

                    self.total_pfxs = YLeaf(YType.uint16, "total-pfxs")

                    self.labeled_pfxs_aggr = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsAggr()
                    self.labeled_pfxs_aggr.parent = self
                    self._children_name_map["labeled_pfxs_aggr"] = "labeled-pfxs-aggr"
                    self._children_yang_names.add("labeled-pfxs-aggr")

                    self.labeled_pfxs_backup = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsBackup()
                    self.labeled_pfxs_backup.parent = self
                    self._children_name_map["labeled_pfxs_backup"] = "labeled-pfxs-backup"
                    self._children_yang_names.add("labeled-pfxs-backup")

                    self.labeled_pfxs_primary = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsPrimary()
                    self.labeled_pfxs_primary.parent = self
                    self._children_name_map["labeled_pfxs_primary"] = "labeled-pfxs-primary"
                    self._children_yang_names.add("labeled-pfxs-primary")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ecmp_pfxs",
                                    "protected_pfxs",
                                    "total_pfxs") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs, self).__setattr__(name, value)


                class LabeledPfxsAggr(Entity):
                    """
                    Labeled prefix count for all paths
                    
                    .. attribute:: labeled_pfxs
                    
                    	Count of labeled prefixes with 1 or more paths labeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: labeled_pfxs_partial
                    
                    	Count of labeled prefixes with some (but not ALL) paths labeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: unlabeled_pfxs
                    
                    	Count of labeled prefixes with ALL paths unlabeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsAggr, self).__init__()

                        self.yang_name = "labeled-pfxs-aggr"
                        self.yang_parent_name = "pfxs"

                        self.labeled_pfxs = YLeaf(YType.uint16, "labeled-pfxs")

                        self.labeled_pfxs_partial = YLeaf(YType.uint16, "labeled-pfxs-partial")

                        self.unlabeled_pfxs = YLeaf(YType.uint16, "unlabeled-pfxs")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("labeled_pfxs",
                                        "labeled_pfxs_partial",
                                        "unlabeled_pfxs") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsAggr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsAggr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.labeled_pfxs.is_set or
                            self.labeled_pfxs_partial.is_set or
                            self.unlabeled_pfxs.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.labeled_pfxs.yfilter != YFilter.not_set or
                            self.labeled_pfxs_partial.yfilter != YFilter.not_set or
                            self.unlabeled_pfxs.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "labeled-pfxs-aggr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding-summary/pfxs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.labeled_pfxs.is_set or self.labeled_pfxs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.labeled_pfxs.get_name_leafdata())
                        if (self.labeled_pfxs_partial.is_set or self.labeled_pfxs_partial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.labeled_pfxs_partial.get_name_leafdata())
                        if (self.unlabeled_pfxs.is_set or self.unlabeled_pfxs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unlabeled_pfxs.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "labeled-pfxs" or name == "labeled-pfxs-partial" or name == "unlabeled-pfxs"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "labeled-pfxs"):
                            self.labeled_pfxs = value
                            self.labeled_pfxs.value_namespace = name_space
                            self.labeled_pfxs.value_namespace_prefix = name_space_prefix
                        if(value_path == "labeled-pfxs-partial"):
                            self.labeled_pfxs_partial = value
                            self.labeled_pfxs_partial.value_namespace = name_space
                            self.labeled_pfxs_partial.value_namespace_prefix = name_space_prefix
                        if(value_path == "unlabeled-pfxs"):
                            self.unlabeled_pfxs = value
                            self.unlabeled_pfxs.value_namespace = name_space
                            self.unlabeled_pfxs.value_namespace_prefix = name_space_prefix


                class LabeledPfxsPrimary(Entity):
                    """
                    Labeled prefix count related to primary paths
                    only
                    
                    .. attribute:: labeled_pfxs
                    
                    	Count of labeled prefixes with 1 or more paths labeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: labeled_pfxs_partial
                    
                    	Count of labeled prefixes with some (but not ALL) paths labeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: unlabeled_pfxs
                    
                    	Count of labeled prefixes with ALL paths unlabeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsPrimary, self).__init__()

                        self.yang_name = "labeled-pfxs-primary"
                        self.yang_parent_name = "pfxs"

                        self.labeled_pfxs = YLeaf(YType.uint16, "labeled-pfxs")

                        self.labeled_pfxs_partial = YLeaf(YType.uint16, "labeled-pfxs-partial")

                        self.unlabeled_pfxs = YLeaf(YType.uint16, "unlabeled-pfxs")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("labeled_pfxs",
                                        "labeled_pfxs_partial",
                                        "unlabeled_pfxs") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsPrimary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsPrimary, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.labeled_pfxs.is_set or
                            self.labeled_pfxs_partial.is_set or
                            self.unlabeled_pfxs.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.labeled_pfxs.yfilter != YFilter.not_set or
                            self.labeled_pfxs_partial.yfilter != YFilter.not_set or
                            self.unlabeled_pfxs.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "labeled-pfxs-primary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding-summary/pfxs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.labeled_pfxs.is_set or self.labeled_pfxs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.labeled_pfxs.get_name_leafdata())
                        if (self.labeled_pfxs_partial.is_set or self.labeled_pfxs_partial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.labeled_pfxs_partial.get_name_leafdata())
                        if (self.unlabeled_pfxs.is_set or self.unlabeled_pfxs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unlabeled_pfxs.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "labeled-pfxs" or name == "labeled-pfxs-partial" or name == "unlabeled-pfxs"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "labeled-pfxs"):
                            self.labeled_pfxs = value
                            self.labeled_pfxs.value_namespace = name_space
                            self.labeled_pfxs.value_namespace_prefix = name_space_prefix
                        if(value_path == "labeled-pfxs-partial"):
                            self.labeled_pfxs_partial = value
                            self.labeled_pfxs_partial.value_namespace = name_space
                            self.labeled_pfxs_partial.value_namespace_prefix = name_space_prefix
                        if(value_path == "unlabeled-pfxs"):
                            self.unlabeled_pfxs = value
                            self.unlabeled_pfxs.value_namespace = name_space
                            self.unlabeled_pfxs.value_namespace_prefix = name_space_prefix


                class LabeledPfxsBackup(Entity):
                    """
                    Labeled prefix count related to backup paths
                    only
                    
                    .. attribute:: labeled_pfxs
                    
                    	Count of labeled prefixes with 1 or more paths labeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: labeled_pfxs_partial
                    
                    	Count of labeled prefixes with some (but not ALL) paths labeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: unlabeled_pfxs
                    
                    	Count of labeled prefixes with ALL paths unlabeled
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsBackup, self).__init__()

                        self.yang_name = "labeled-pfxs-backup"
                        self.yang_parent_name = "pfxs"

                        self.labeled_pfxs = YLeaf(YType.uint16, "labeled-pfxs")

                        self.labeled_pfxs_partial = YLeaf(YType.uint16, "labeled-pfxs-partial")

                        self.unlabeled_pfxs = YLeaf(YType.uint16, "unlabeled-pfxs")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("labeled_pfxs",
                                        "labeled_pfxs_partial",
                                        "unlabeled_pfxs") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsBackup, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsBackup, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.labeled_pfxs.is_set or
                            self.labeled_pfxs_partial.is_set or
                            self.unlabeled_pfxs.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.labeled_pfxs.yfilter != YFilter.not_set or
                            self.labeled_pfxs_partial.yfilter != YFilter.not_set or
                            self.unlabeled_pfxs.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "labeled-pfxs-backup" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding-summary/pfxs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.labeled_pfxs.is_set or self.labeled_pfxs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.labeled_pfxs.get_name_leafdata())
                        if (self.labeled_pfxs_partial.is_set or self.labeled_pfxs_partial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.labeled_pfxs_partial.get_name_leafdata())
                        if (self.unlabeled_pfxs.is_set or self.unlabeled_pfxs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unlabeled_pfxs.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "labeled-pfxs" or name == "labeled-pfxs-partial" or name == "unlabeled-pfxs"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "labeled-pfxs"):
                            self.labeled_pfxs = value
                            self.labeled_pfxs.value_namespace = name_space
                            self.labeled_pfxs.value_namespace_prefix = name_space_prefix
                        if(value_path == "labeled-pfxs-partial"):
                            self.labeled_pfxs_partial = value
                            self.labeled_pfxs_partial.value_namespace = name_space
                            self.labeled_pfxs_partial.value_namespace_prefix = name_space_prefix
                        if(value_path == "unlabeled-pfxs"):
                            self.unlabeled_pfxs = value
                            self.unlabeled_pfxs.value_namespace = name_space
                            self.unlabeled_pfxs.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.ecmp_pfxs.is_set or
                        self.protected_pfxs.is_set or
                        self.total_pfxs.is_set or
                        (self.labeled_pfxs_aggr is not None and self.labeled_pfxs_aggr.has_data()) or
                        (self.labeled_pfxs_backup is not None and self.labeled_pfxs_backup.has_data()) or
                        (self.labeled_pfxs_primary is not None and self.labeled_pfxs_primary.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ecmp_pfxs.yfilter != YFilter.not_set or
                        self.protected_pfxs.yfilter != YFilter.not_set or
                        self.total_pfxs.yfilter != YFilter.not_set or
                        (self.labeled_pfxs_aggr is not None and self.labeled_pfxs_aggr.has_operation()) or
                        (self.labeled_pfxs_backup is not None and self.labeled_pfxs_backup.has_operation()) or
                        (self.labeled_pfxs_primary is not None and self.labeled_pfxs_primary.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "pfxs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding-summary/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ecmp_pfxs.is_set or self.ecmp_pfxs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ecmp_pfxs.get_name_leafdata())
                    if (self.protected_pfxs.is_set or self.protected_pfxs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protected_pfxs.get_name_leafdata())
                    if (self.total_pfxs.is_set or self.total_pfxs.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_pfxs.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "labeled-pfxs-aggr"):
                        if (self.labeled_pfxs_aggr is None):
                            self.labeled_pfxs_aggr = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsAggr()
                            self.labeled_pfxs_aggr.parent = self
                            self._children_name_map["labeled_pfxs_aggr"] = "labeled-pfxs-aggr"
                        return self.labeled_pfxs_aggr

                    if (child_yang_name == "labeled-pfxs-backup"):
                        if (self.labeled_pfxs_backup is None):
                            self.labeled_pfxs_backup = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsBackup()
                            self.labeled_pfxs_backup.parent = self
                            self._children_name_map["labeled_pfxs_backup"] = "labeled-pfxs-backup"
                        return self.labeled_pfxs_backup

                    if (child_yang_name == "labeled-pfxs-primary"):
                        if (self.labeled_pfxs_primary is None):
                            self.labeled_pfxs_primary = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs.LabeledPfxsPrimary()
                            self.labeled_pfxs_primary.parent = self
                            self._children_name_map["labeled_pfxs_primary"] = "labeled-pfxs-primary"
                        return self.labeled_pfxs_primary

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "labeled-pfxs-aggr" or name == "labeled-pfxs-backup" or name == "labeled-pfxs-primary" or name == "ecmp-pfxs" or name == "protected-pfxs" or name == "total-pfxs"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ecmp-pfxs"):
                        self.ecmp_pfxs = value
                        self.ecmp_pfxs.value_namespace = name_space
                        self.ecmp_pfxs.value_namespace_prefix = name_space_prefix
                    if(value_path == "protected-pfxs"):
                        self.protected_pfxs = value
                        self.protected_pfxs.value_namespace = name_space
                        self.protected_pfxs.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-pfxs"):
                        self.total_pfxs = value
                        self.total_pfxs.value_namespace = name_space
                        self.total_pfxs.value_namespace_prefix = name_space_prefix


            class Nhs(Entity):
                """
                MPLS LDP forwarding rewrite next\-hop/path summary
                
                .. attribute:: backup_paths
                
                	Count of non\-primary backup paths
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: labeled_backup_paths
                
                	Count of labeled backup paths
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: labeled_paths
                
                	Count of all labeled paths
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: protected_paths
                
                	Count of FRR protected paths
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: remote_backup_paths
                
                	Count of non\-primary remote backup paths
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_paths
                
                	Total path count
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.ForwardingSummary.Nhs, self).__init__()

                    self.yang_name = "nhs"
                    self.yang_parent_name = "forwarding-summary"

                    self.backup_paths = YLeaf(YType.uint32, "backup-paths")

                    self.labeled_backup_paths = YLeaf(YType.uint32, "labeled-backup-paths")

                    self.labeled_paths = YLeaf(YType.uint32, "labeled-paths")

                    self.protected_paths = YLeaf(YType.uint32, "protected-paths")

                    self.remote_backup_paths = YLeaf(YType.uint32, "remote-backup-paths")

                    self.total_paths = YLeaf(YType.uint32, "total-paths")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("backup_paths",
                                    "labeled_backup_paths",
                                    "labeled_paths",
                                    "protected_paths",
                                    "remote_backup_paths",
                                    "total_paths") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.ForwardingSummary.Nhs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.ForwardingSummary.Nhs, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.backup_paths.is_set or
                        self.labeled_backup_paths.is_set or
                        self.labeled_paths.is_set or
                        self.protected_paths.is_set or
                        self.remote_backup_paths.is_set or
                        self.total_paths.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.backup_paths.yfilter != YFilter.not_set or
                        self.labeled_backup_paths.yfilter != YFilter.not_set or
                        self.labeled_paths.yfilter != YFilter.not_set or
                        self.protected_paths.yfilter != YFilter.not_set or
                        self.remote_backup_paths.yfilter != YFilter.not_set or
                        self.total_paths.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nhs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding-summary/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.backup_paths.is_set or self.backup_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.backup_paths.get_name_leafdata())
                    if (self.labeled_backup_paths.is_set or self.labeled_backup_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.labeled_backup_paths.get_name_leafdata())
                    if (self.labeled_paths.is_set or self.labeled_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.labeled_paths.get_name_leafdata())
                    if (self.protected_paths.is_set or self.protected_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protected_paths.get_name_leafdata())
                    if (self.remote_backup_paths.is_set or self.remote_backup_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.remote_backup_paths.get_name_leafdata())
                    if (self.total_paths.is_set or self.total_paths.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_paths.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "backup-paths" or name == "labeled-backup-paths" or name == "labeled-paths" or name == "protected-paths" or name == "remote-backup-paths" or name == "total-paths"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "backup-paths"):
                        self.backup_paths = value
                        self.backup_paths.value_namespace = name_space
                        self.backup_paths.value_namespace_prefix = name_space_prefix
                    if(value_path == "labeled-backup-paths"):
                        self.labeled_backup_paths = value
                        self.labeled_backup_paths.value_namespace = name_space
                        self.labeled_backup_paths.value_namespace_prefix = name_space_prefix
                    if(value_path == "labeled-paths"):
                        self.labeled_paths = value
                        self.labeled_paths.value_namespace = name_space
                        self.labeled_paths.value_namespace_prefix = name_space_prefix
                    if(value_path == "protected-paths"):
                        self.protected_paths = value
                        self.protected_paths.value_namespace = name_space
                        self.protected_paths.value_namespace_prefix = name_space_prefix
                    if(value_path == "remote-backup-paths"):
                        self.remote_backup_paths = value
                        self.remote_backup_paths.value_namespace = name_space
                        self.remote_backup_paths.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-paths"):
                        self.total_paths = value
                        self.total_paths.value_namespace = name_space
                        self.total_paths.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.intfs_fwd_count.is_set or
                    self.local_lbls.is_set or
                    (self.nhs is not None and self.nhs.has_data()) or
                    (self.pfxs is not None and self.pfxs.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.intfs_fwd_count.yfilter != YFilter.not_set or
                    self.local_lbls.yfilter != YFilter.not_set or
                    (self.nhs is not None and self.nhs.has_operation()) or
                    (self.pfxs is not None and self.pfxs.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "forwarding-summary" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.intfs_fwd_count.is_set or self.intfs_fwd_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.intfs_fwd_count.get_name_leafdata())
                if (self.local_lbls.is_set or self.local_lbls.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.local_lbls.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "nhs"):
                    if (self.nhs is None):
                        self.nhs = MplsLdp.MplsLdpState.ForwardingSummary.Nhs()
                        self.nhs.parent = self
                        self._children_name_map["nhs"] = "nhs"
                    return self.nhs

                if (child_yang_name == "pfxs"):
                    if (self.pfxs is None):
                        self.pfxs = MplsLdp.MplsLdpState.ForwardingSummary.Pfxs()
                        self.pfxs.parent = self
                        self._children_name_map["pfxs"] = "pfxs"
                    return self.pfxs

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "nhs" or name == "pfxs" or name == "intfs-fwd-count" or name == "local-lbls"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "intfs-fwd-count"):
                    self.intfs_fwd_count = value
                    self.intfs_fwd_count.value_namespace = name_space
                    self.intfs_fwd_count.value_namespace_prefix = name_space_prefix
                if(value_path == "local-lbls"):
                    self.local_lbls = value
                    self.local_lbls.value_namespace = name_space
                    self.local_lbls.value_namespace_prefix = name_space_prefix


        class BindingsSummary(Entity):
            """
            Aggregate counters for the MPLS LDP LIB.
            
            .. attribute:: binding_local
            
            	Number of local bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_local_explicit_null
            
            	Number of local explicit null bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_local_implicit_null
            
            	Number of local implicit null bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_local_no_route
            
            	Local bindings with no route
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_local_non_null
            
            	Number of local non\-null bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_local_null
            
            	Number of local null bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_local_oor
            
            	This is the number of local bindings needing label but which hit the Out\-Of\-Resource condition
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_no_route
            
            	Bindings with no route
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_remote
            
            	Number of remote bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: binding_total
            
            	Total bindings
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: highest_allocated_label
            
            	Highest allocated label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: lowest_allocated_label
            
            	Lowest allocated label
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.BindingsSummary, self).__init__()

                self.yang_name = "bindings-summary"
                self.yang_parent_name = "mpls-ldp-state"

                self.binding_local = YLeaf(YType.uint32, "binding-local")

                self.binding_local_explicit_null = YLeaf(YType.uint32, "binding-local-explicit-null")

                self.binding_local_implicit_null = YLeaf(YType.uint32, "binding-local-implicit-null")

                self.binding_local_no_route = YLeaf(YType.uint32, "binding-local-no-route")

                self.binding_local_non_null = YLeaf(YType.uint32, "binding-local-non-null")

                self.binding_local_null = YLeaf(YType.uint32, "binding-local-null")

                self.binding_local_oor = YLeaf(YType.uint32, "binding-local-oor")

                self.binding_no_route = YLeaf(YType.uint32, "binding-no-route")

                self.binding_remote = YLeaf(YType.uint32, "binding-remote")

                self.binding_total = YLeaf(YType.uint32, "binding-total")

                self.highest_allocated_label = YLeaf(YType.uint32, "highest-allocated-label")

                self.lowest_allocated_label = YLeaf(YType.uint32, "lowest-allocated-label")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("binding_local",
                                "binding_local_explicit_null",
                                "binding_local_implicit_null",
                                "binding_local_no_route",
                                "binding_local_non_null",
                                "binding_local_null",
                                "binding_local_oor",
                                "binding_no_route",
                                "binding_remote",
                                "binding_total",
                                "highest_allocated_label",
                                "lowest_allocated_label") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.BindingsSummary, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.BindingsSummary, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.binding_local.is_set or
                    self.binding_local_explicit_null.is_set or
                    self.binding_local_implicit_null.is_set or
                    self.binding_local_no_route.is_set or
                    self.binding_local_non_null.is_set or
                    self.binding_local_null.is_set or
                    self.binding_local_oor.is_set or
                    self.binding_no_route.is_set or
                    self.binding_remote.is_set or
                    self.binding_total.is_set or
                    self.highest_allocated_label.is_set or
                    self.lowest_allocated_label.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.binding_local.yfilter != YFilter.not_set or
                    self.binding_local_explicit_null.yfilter != YFilter.not_set or
                    self.binding_local_implicit_null.yfilter != YFilter.not_set or
                    self.binding_local_no_route.yfilter != YFilter.not_set or
                    self.binding_local_non_null.yfilter != YFilter.not_set or
                    self.binding_local_null.yfilter != YFilter.not_set or
                    self.binding_local_oor.yfilter != YFilter.not_set or
                    self.binding_no_route.yfilter != YFilter.not_set or
                    self.binding_remote.yfilter != YFilter.not_set or
                    self.binding_total.yfilter != YFilter.not_set or
                    self.highest_allocated_label.yfilter != YFilter.not_set or
                    self.lowest_allocated_label.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bindings-summary" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.binding_local.is_set or self.binding_local.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local.get_name_leafdata())
                if (self.binding_local_explicit_null.is_set or self.binding_local_explicit_null.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local_explicit_null.get_name_leafdata())
                if (self.binding_local_implicit_null.is_set or self.binding_local_implicit_null.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local_implicit_null.get_name_leafdata())
                if (self.binding_local_no_route.is_set or self.binding_local_no_route.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local_no_route.get_name_leafdata())
                if (self.binding_local_non_null.is_set or self.binding_local_non_null.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local_non_null.get_name_leafdata())
                if (self.binding_local_null.is_set or self.binding_local_null.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local_null.get_name_leafdata())
                if (self.binding_local_oor.is_set or self.binding_local_oor.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_local_oor.get_name_leafdata())
                if (self.binding_no_route.is_set or self.binding_no_route.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_no_route.get_name_leafdata())
                if (self.binding_remote.is_set or self.binding_remote.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_remote.get_name_leafdata())
                if (self.binding_total.is_set or self.binding_total.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.binding_total.get_name_leafdata())
                if (self.highest_allocated_label.is_set or self.highest_allocated_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.highest_allocated_label.get_name_leafdata())
                if (self.lowest_allocated_label.is_set or self.lowest_allocated_label.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.lowest_allocated_label.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "binding-local" or name == "binding-local-explicit-null" or name == "binding-local-implicit-null" or name == "binding-local-no-route" or name == "binding-local-non-null" or name == "binding-local-null" or name == "binding-local-oor" or name == "binding-no-route" or name == "binding-remote" or name == "binding-total" or name == "highest-allocated-label" or name == "lowest-allocated-label"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "binding-local"):
                    self.binding_local = value
                    self.binding_local.value_namespace = name_space
                    self.binding_local.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-local-explicit-null"):
                    self.binding_local_explicit_null = value
                    self.binding_local_explicit_null.value_namespace = name_space
                    self.binding_local_explicit_null.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-local-implicit-null"):
                    self.binding_local_implicit_null = value
                    self.binding_local_implicit_null.value_namespace = name_space
                    self.binding_local_implicit_null.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-local-no-route"):
                    self.binding_local_no_route = value
                    self.binding_local_no_route.value_namespace = name_space
                    self.binding_local_no_route.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-local-non-null"):
                    self.binding_local_non_null = value
                    self.binding_local_non_null.value_namespace = name_space
                    self.binding_local_non_null.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-local-null"):
                    self.binding_local_null = value
                    self.binding_local_null.value_namespace = name_space
                    self.binding_local_null.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-local-oor"):
                    self.binding_local_oor = value
                    self.binding_local_oor.value_namespace = name_space
                    self.binding_local_oor.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-no-route"):
                    self.binding_no_route = value
                    self.binding_no_route.value_namespace = name_space
                    self.binding_no_route.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-remote"):
                    self.binding_remote = value
                    self.binding_remote.value_namespace = name_space
                    self.binding_remote.value_namespace_prefix = name_space_prefix
                if(value_path == "binding-total"):
                    self.binding_total = value
                    self.binding_total.value_namespace = name_space
                    self.binding_total.value_namespace_prefix = name_space_prefix
                if(value_path == "highest-allocated-label"):
                    self.highest_allocated_label = value
                    self.highest_allocated_label.value_namespace = name_space
                    self.highest_allocated_label.value_namespace_prefix = name_space_prefix
                if(value_path == "lowest-allocated-label"):
                    self.lowest_allocated_label = value
                    self.lowest_allocated_label.value_namespace = name_space
                    self.lowest_allocated_label.value_namespace_prefix = name_space_prefix


        class NsrSummaryAll(Entity):
            """
            This is the LDP NSR summary for the device.
            
            .. attribute:: nsr_sum_in_label_reqs_created
            
            	In label Request Records created
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: nsr_sum_in_label_reqs_freed
            
            	In label Request Records freed
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: nsr_sum_in_label_withdraw_created
            
            	In label Withdraw Records created
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: nsr_sum_in_label_withdraw_freed
            
            	In label Withdraw Records freed
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: nsr_sum_lcl_addr_withdraw_cleared
            
            	Local Address Withdraw cleared
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: nsr_sum_lcl_addr_withdraw_set
            
            	Local Address Withdraw set
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.NsrSummaryAll, self).__init__()

                self.yang_name = "nsr-summary-all"
                self.yang_parent_name = "mpls-ldp-state"

                self.nsr_sum_in_label_reqs_created = YLeaf(YType.uint32, "nsr-sum-in-label-reqs-created")

                self.nsr_sum_in_label_reqs_freed = YLeaf(YType.uint32, "nsr-sum-in-label-reqs-freed")

                self.nsr_sum_in_label_withdraw_created = YLeaf(YType.uint32, "nsr-sum-in-label-withdraw-created")

                self.nsr_sum_in_label_withdraw_freed = YLeaf(YType.uint32, "nsr-sum-in-label-withdraw-freed")

                self.nsr_sum_lcl_addr_withdraw_cleared = YLeaf(YType.uint32, "nsr-sum-lcl-addr-withdraw-cleared")

                self.nsr_sum_lcl_addr_withdraw_set = YLeaf(YType.uint32, "nsr-sum-lcl-addr-withdraw-set")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("nsr_sum_in_label_reqs_created",
                                "nsr_sum_in_label_reqs_freed",
                                "nsr_sum_in_label_withdraw_created",
                                "nsr_sum_in_label_withdraw_freed",
                                "nsr_sum_lcl_addr_withdraw_cleared",
                                "nsr_sum_lcl_addr_withdraw_set") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.NsrSummaryAll, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.NsrSummaryAll, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.nsr_sum_in_label_reqs_created.is_set or
                    self.nsr_sum_in_label_reqs_freed.is_set or
                    self.nsr_sum_in_label_withdraw_created.is_set or
                    self.nsr_sum_in_label_withdraw_freed.is_set or
                    self.nsr_sum_lcl_addr_withdraw_cleared.is_set or
                    self.nsr_sum_lcl_addr_withdraw_set.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.nsr_sum_in_label_reqs_created.yfilter != YFilter.not_set or
                    self.nsr_sum_in_label_reqs_freed.yfilter != YFilter.not_set or
                    self.nsr_sum_in_label_withdraw_created.yfilter != YFilter.not_set or
                    self.nsr_sum_in_label_withdraw_freed.yfilter != YFilter.not_set or
                    self.nsr_sum_lcl_addr_withdraw_cleared.yfilter != YFilter.not_set or
                    self.nsr_sum_lcl_addr_withdraw_set.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "nsr-summary-all" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.nsr_sum_in_label_reqs_created.is_set or self.nsr_sum_in_label_reqs_created.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_sum_in_label_reqs_created.get_name_leafdata())
                if (self.nsr_sum_in_label_reqs_freed.is_set or self.nsr_sum_in_label_reqs_freed.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_sum_in_label_reqs_freed.get_name_leafdata())
                if (self.nsr_sum_in_label_withdraw_created.is_set or self.nsr_sum_in_label_withdraw_created.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_sum_in_label_withdraw_created.get_name_leafdata())
                if (self.nsr_sum_in_label_withdraw_freed.is_set or self.nsr_sum_in_label_withdraw_freed.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_sum_in_label_withdraw_freed.get_name_leafdata())
                if (self.nsr_sum_lcl_addr_withdraw_cleared.is_set or self.nsr_sum_lcl_addr_withdraw_cleared.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_sum_lcl_addr_withdraw_cleared.get_name_leafdata())
                if (self.nsr_sum_lcl_addr_withdraw_set.is_set or self.nsr_sum_lcl_addr_withdraw_set.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr_sum_lcl_addr_withdraw_set.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "nsr-sum-in-label-reqs-created" or name == "nsr-sum-in-label-reqs-freed" or name == "nsr-sum-in-label-withdraw-created" or name == "nsr-sum-in-label-withdraw-freed" or name == "nsr-sum-lcl-addr-withdraw-cleared" or name == "nsr-sum-lcl-addr-withdraw-set"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "nsr-sum-in-label-reqs-created"):
                    self.nsr_sum_in_label_reqs_created = value
                    self.nsr_sum_in_label_reqs_created.value_namespace = name_space
                    self.nsr_sum_in_label_reqs_created.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr-sum-in-label-reqs-freed"):
                    self.nsr_sum_in_label_reqs_freed = value
                    self.nsr_sum_in_label_reqs_freed.value_namespace = name_space
                    self.nsr_sum_in_label_reqs_freed.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr-sum-in-label-withdraw-created"):
                    self.nsr_sum_in_label_withdraw_created = value
                    self.nsr_sum_in_label_withdraw_created.value_namespace = name_space
                    self.nsr_sum_in_label_withdraw_created.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr-sum-in-label-withdraw-freed"):
                    self.nsr_sum_in_label_withdraw_freed = value
                    self.nsr_sum_in_label_withdraw_freed.value_namespace = name_space
                    self.nsr_sum_in_label_withdraw_freed.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr-sum-lcl-addr-withdraw-cleared"):
                    self.nsr_sum_lcl_addr_withdraw_cleared = value
                    self.nsr_sum_lcl_addr_withdraw_cleared.value_namespace = name_space
                    self.nsr_sum_lcl_addr_withdraw_cleared.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr-sum-lcl-addr-withdraw-set"):
                    self.nsr_sum_lcl_addr_withdraw_set = value
                    self.nsr_sum_lcl_addr_withdraw_set.value_namespace = name_space
                    self.nsr_sum_lcl_addr_withdraw_set.value_namespace_prefix = name_space_prefix


        class IcpmSummaryAll(Entity):
            """
            Summary info for LDP ICPM/ICCP.
            
            .. attribute:: iccp_rg_app_data_count
            
            	ICCP RG App Data count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: iccp_rg_conn_count
            
            	ICCP RG Connect count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: iccp_rg_disconn_count
            
            	ICCP RG Disconnect count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: iccp_rg_notif_count
            
            	ICCP RG Notif count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: icpm_rgid_table_info
            
            	This defines the ICPM RGID Table
            	**type**\:   :py:class:`IcpmRgidTableInfo <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo>`
            
            .. attribute:: icpm_session_table
            
            	This is a list of ICPM sessions
            	**type**\:   :py:class:`IcpmSessionTable <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.IcpmSummaryAll, self).__init__()

                self.yang_name = "icpm-summary-all"
                self.yang_parent_name = "mpls-ldp-state"

                self.iccp_rg_app_data_count = YLeaf(YType.uint32, "iccp-rg-app-data-count")

                self.iccp_rg_conn_count = YLeaf(YType.uint32, "iccp-rg-conn-count")

                self.iccp_rg_disconn_count = YLeaf(YType.uint32, "iccp-rg-disconn-count")

                self.iccp_rg_notif_count = YLeaf(YType.uint32, "iccp-rg-notif-count")

                self.icpm_rgid_table_info = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo()
                self.icpm_rgid_table_info.parent = self
                self._children_name_map["icpm_rgid_table_info"] = "icpm-rgid-table-info"
                self._children_yang_names.add("icpm-rgid-table-info")

                self.icpm_session_table = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable()
                self.icpm_session_table.parent = self
                self._children_name_map["icpm_session_table"] = "icpm-session-table"
                self._children_yang_names.add("icpm-session-table")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("iccp_rg_app_data_count",
                                "iccp_rg_conn_count",
                                "iccp_rg_disconn_count",
                                "iccp_rg_notif_count") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.IcpmSummaryAll, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.IcpmSummaryAll, self).__setattr__(name, value)


            class IcpmRgidTableInfo(Entity):
                """
                This defines the ICPM RGID Table
                
                .. attribute:: red_group
                
                	This is the data for an individual ICPM Rredundandy Group,
                	**type**\: list of    :py:class:`RedGroup <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo, self).__init__()

                    self.yang_name = "icpm-rgid-table-info"
                    self.yang_parent_name = "icpm-summary-all"

                    self.red_group = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo, self).__setattr__(name, value)


                class RedGroup(Entity):
                    """
                    This is the data for an individual ICPM Rredundandy
                    Group,
                    
                    .. attribute:: rg_id  <key>
                    
                    	This is the ICPM RG identifier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: icpm_protocols
                    
                    	This list contains all active icpm protocols
                    	**type**\: list of    :py:class:`IcpmProtocols <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup, self).__init__()

                        self.yang_name = "red-group"
                        self.yang_parent_name = "icpm-rgid-table-info"

                        self.rg_id = YLeaf(YType.uint32, "rg-id")

                        self.icpm_protocols = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("rg_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup, self).__setattr__(name, value)


                    class IcpmProtocols(Entity):
                        """
                        This list contains all active icpm protocols.
                        
                        .. attribute:: icpm_type  <key>
                        
                        	ICPM Type
                        	**type**\:   :py:class:`IcpmType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IcpmType>`
                        
                        .. attribute:: redun_groups
                        
                        	List of Redundancy Groups
                        	**type**\: list of    :py:class:`RedunGroups <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups>`
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols, self).__init__()

                            self.yang_name = "icpm-protocols"
                            self.yang_parent_name = "red-group"

                            self.icpm_type = YLeaf(YType.identityref, "icpm-type")

                            self.redun_groups = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("icpm_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols, self).__setattr__(name, value)


                        class RedunGroups(Entity):
                            """
                            List of Redundancy Groups
                            
                            .. attribute:: rg_id  <key>
                            
                            	Redundancy Group Identifier
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: client_id
                            
                            	Client Identifier
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: iccp_apps
                            
                            	List of apps
                            	**type**\: list of    :py:class:`IccpApps <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups.IccpApps>`
                            
                            .. attribute:: peer_id
                            
                            	LSR identifier
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: state
                            
                            	ICCP State
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups, self).__init__()

                                self.yang_name = "redun-groups"
                                self.yang_parent_name = "icpm-protocols"

                                self.rg_id = YLeaf(YType.uint32, "rg-id")

                                self.client_id = YLeaf(YType.uint32, "client_id")

                                self.peer_id = YLeaf(YType.str, "peer-id")

                                self.state = YLeaf(YType.str, "state")

                                self.iccp_apps = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rg_id",
                                                "client_id",
                                                "peer_id",
                                                "state") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups, self).__setattr__(name, value)


                            class IccpApps(Entity):
                                """
                                List of apps
                                
                                .. attribute:: iccp_app  <key>
                                
                                	ICCP App Type
                                	**type**\:   :py:class:`IccpType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IccpType>`
                                
                                .. attribute:: app_state
                                
                                	App State
                                	**type**\:   :py:class:`IccpState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IccpState>`
                                
                                .. attribute:: ptcl_ver
                                
                                	ICCP App Protocol Version
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'mpls-ldp-ios-xe-oper'
                                _revision = '2017-02-07'

                                def __init__(self):
                                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups.IccpApps, self).__init__()

                                    self.yang_name = "iccp-apps"
                                    self.yang_parent_name = "redun-groups"

                                    self.iccp_app = YLeaf(YType.identityref, "iccp-app")

                                    self.app_state = YLeaf(YType.enumeration, "app-state")

                                    self.ptcl_ver = YLeaf(YType.uint32, "ptcl-ver")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("iccp_app",
                                                    "app_state",
                                                    "ptcl_ver") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups.IccpApps, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups.IccpApps, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.iccp_app.is_set or
                                        self.app_state.is_set or
                                        self.ptcl_ver.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.iccp_app.yfilter != YFilter.not_set or
                                        self.app_state.yfilter != YFilter.not_set or
                                        self.ptcl_ver.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "iccp-apps" + "[iccp-app='" + self.iccp_app.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.iccp_app.is_set or self.iccp_app.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.iccp_app.get_name_leafdata())
                                    if (self.app_state.is_set or self.app_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.app_state.get_name_leafdata())
                                    if (self.ptcl_ver.is_set or self.ptcl_ver.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ptcl_ver.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "iccp-app" or name == "app-state" or name == "ptcl-ver"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "iccp-app"):
                                        self.iccp_app = value
                                        self.iccp_app.value_namespace = name_space
                                        self.iccp_app.value_namespace_prefix = name_space_prefix
                                    if(value_path == "app-state"):
                                        self.app_state = value
                                        self.app_state.value_namespace = name_space
                                        self.app_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ptcl-ver"):
                                        self.ptcl_ver = value
                                        self.ptcl_ver.value_namespace = name_space
                                        self.ptcl_ver.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.iccp_apps:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.rg_id.is_set or
                                    self.client_id.is_set or
                                    self.peer_id.is_set or
                                    self.state.is_set)

                            def has_operation(self):
                                for c in self.iccp_apps:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rg_id.yfilter != YFilter.not_set or
                                    self.client_id.yfilter != YFilter.not_set or
                                    self.peer_id.yfilter != YFilter.not_set or
                                    self.state.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "redun-groups" + "[rg-id='" + self.rg_id.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rg_id.is_set or self.rg_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rg_id.get_name_leafdata())
                                if (self.client_id.is_set or self.client_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.client_id.get_name_leafdata())
                                if (self.peer_id.is_set or self.peer_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.peer_id.get_name_leafdata())
                                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.state.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "iccp-apps"):
                                    for c in self.iccp_apps:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups.IccpApps()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.iccp_apps.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "iccp-apps" or name == "rg-id" or name == "client_id" or name == "peer-id" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rg-id"):
                                    self.rg_id = value
                                    self.rg_id.value_namespace = name_space
                                    self.rg_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "client_id"):
                                    self.client_id = value
                                    self.client_id.value_namespace = name_space
                                    self.client_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "peer-id"):
                                    self.peer_id = value
                                    self.peer_id.value_namespace = name_space
                                    self.peer_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "state"):
                                    self.state = value
                                    self.state.value_namespace = name_space
                                    self.state.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.redun_groups:
                                if (c.has_data()):
                                    return True
                            return self.icpm_type.is_set

                        def has_operation(self):
                            for c in self.redun_groups:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.icpm_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "icpm-protocols" + "[icpm-type='" + self.icpm_type.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.icpm_type.is_set or self.icpm_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.icpm_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "redun-groups"):
                                for c in self.redun_groups:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols.RedunGroups()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.redun_groups.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "redun-groups" or name == "icpm-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "icpm-type"):
                                self.icpm_type = value
                                self.icpm_type.value_namespace = name_space
                                self.icpm_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.icpm_protocols:
                            if (c.has_data()):
                                return True
                        return self.rg_id.is_set

                    def has_operation(self):
                        for c in self.icpm_protocols:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.rg_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "red-group" + "[rg-id='" + self.rg_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/icpm-summary-all/icpm-rgid-table-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.rg_id.is_set or self.rg_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rg_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "icpm-protocols"):
                            for c in self.icpm_protocols:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup.IcpmProtocols()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.icpm_protocols.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "icpm-protocols" or name == "rg-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "rg-id"):
                            self.rg_id = value
                            self.rg_id.value_namespace = name_space
                            self.rg_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.red_group:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.red_group:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "icpm-rgid-table-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/icpm-summary-all/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "red-group"):
                        for c in self.red_group:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo.RedGroup()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.red_group.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "red-group"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class IcpmSessionTable(Entity):
                """
                This is a list of ICPM sessions.
                
                .. attribute:: session_table
                
                	ICPM LDP Session Table
                	**type**\: list of    :py:class:`SessionTable <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable, self).__init__()

                    self.yang_name = "icpm-session-table"
                    self.yang_parent_name = "icpm-summary-all"

                    self.session_table = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable, self).__setattr__(name, value)


                class SessionTable(Entity):
                    """
                    ICPM LDP Session Table
                    
                    .. attribute:: session_id  <key>
                    
                    	This is the ICPM sesion identifier
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: icpm_protocols
                    
                    	This list contains all active icpm protocols
                    	**type**\: list of    :py:class:`IcpmProtocols <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable, self).__init__()

                        self.yang_name = "session-table"
                        self.yang_parent_name = "icpm-session-table"

                        self.session_id = YLeaf(YType.uint32, "session-id")

                        self.icpm_protocols = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("session_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable, self).__setattr__(name, value)


                    class IcpmProtocols(Entity):
                        """
                        This list contains all active icpm protocols.
                        
                        .. attribute:: icpm_type  <key>
                        
                        	ICPM Type
                        	**type**\:   :py:class:`IcpmType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IcpmType>`
                        
                        .. attribute:: redun_groups
                        
                        	List of Redundancy Groups
                        	**type**\: list of    :py:class:`RedunGroups <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups>`
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols, self).__init__()

                            self.yang_name = "icpm-protocols"
                            self.yang_parent_name = "session-table"

                            self.icpm_type = YLeaf(YType.identityref, "icpm-type")

                            self.redun_groups = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("icpm_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols, self).__setattr__(name, value)


                        class RedunGroups(Entity):
                            """
                            List of Redundancy Groups
                            
                            .. attribute:: rg_id  <key>
                            
                            	Redundancy Group Identifier
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: client_id
                            
                            	Client Identifier
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: iccp_apps
                            
                            	List of apps
                            	**type**\: list of    :py:class:`IccpApps <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups.IccpApps>`
                            
                            .. attribute:: peer_id
                            
                            	LSR identifier
                            	**type**\: one of the below types:
                            
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            	**type**\:  str
                            
                            	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                            
                            
                            ----
                            .. attribute:: state
                            
                            	ICCP State
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups, self).__init__()

                                self.yang_name = "redun-groups"
                                self.yang_parent_name = "icpm-protocols"

                                self.rg_id = YLeaf(YType.uint32, "rg-id")

                                self.client_id = YLeaf(YType.uint32, "client_id")

                                self.peer_id = YLeaf(YType.str, "peer-id")

                                self.state = YLeaf(YType.str, "state")

                                self.iccp_apps = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("rg_id",
                                                "client_id",
                                                "peer_id",
                                                "state") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups, self).__setattr__(name, value)


                            class IccpApps(Entity):
                                """
                                List of apps
                                
                                .. attribute:: iccp_app  <key>
                                
                                	ICCP App Type
                                	**type**\:   :py:class:`IccpType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IccpType>`
                                
                                .. attribute:: app_state
                                
                                	App State
                                	**type**\:   :py:class:`IccpState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IccpState>`
                                
                                .. attribute:: ptcl_ver
                                
                                	ICCP App Protocol Version
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'mpls-ldp-ios-xe-oper'
                                _revision = '2017-02-07'

                                def __init__(self):
                                    super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups.IccpApps, self).__init__()

                                    self.yang_name = "iccp-apps"
                                    self.yang_parent_name = "redun-groups"

                                    self.iccp_app = YLeaf(YType.identityref, "iccp-app")

                                    self.app_state = YLeaf(YType.enumeration, "app-state")

                                    self.ptcl_ver = YLeaf(YType.uint32, "ptcl-ver")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("iccp_app",
                                                    "app_state",
                                                    "ptcl_ver") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups.IccpApps, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups.IccpApps, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.iccp_app.is_set or
                                        self.app_state.is_set or
                                        self.ptcl_ver.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.iccp_app.yfilter != YFilter.not_set or
                                        self.app_state.yfilter != YFilter.not_set or
                                        self.ptcl_ver.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "iccp-apps" + "[iccp-app='" + self.iccp_app.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.iccp_app.is_set or self.iccp_app.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.iccp_app.get_name_leafdata())
                                    if (self.app_state.is_set or self.app_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.app_state.get_name_leafdata())
                                    if (self.ptcl_ver.is_set or self.ptcl_ver.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ptcl_ver.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "iccp-app" or name == "app-state" or name == "ptcl-ver"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "iccp-app"):
                                        self.iccp_app = value
                                        self.iccp_app.value_namespace = name_space
                                        self.iccp_app.value_namespace_prefix = name_space_prefix
                                    if(value_path == "app-state"):
                                        self.app_state = value
                                        self.app_state.value_namespace = name_space
                                        self.app_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ptcl-ver"):
                                        self.ptcl_ver = value
                                        self.ptcl_ver.value_namespace = name_space
                                        self.ptcl_ver.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.iccp_apps:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.rg_id.is_set or
                                    self.client_id.is_set or
                                    self.peer_id.is_set or
                                    self.state.is_set)

                            def has_operation(self):
                                for c in self.iccp_apps:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.rg_id.yfilter != YFilter.not_set or
                                    self.client_id.yfilter != YFilter.not_set or
                                    self.peer_id.yfilter != YFilter.not_set or
                                    self.state.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "redun-groups" + "[rg-id='" + self.rg_id.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.rg_id.is_set or self.rg_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rg_id.get_name_leafdata())
                                if (self.client_id.is_set or self.client_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.client_id.get_name_leafdata())
                                if (self.peer_id.is_set or self.peer_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.peer_id.get_name_leafdata())
                                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.state.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "iccp-apps"):
                                    for c in self.iccp_apps:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups.IccpApps()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.iccp_apps.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "iccp-apps" or name == "rg-id" or name == "client_id" or name == "peer-id" or name == "state"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "rg-id"):
                                    self.rg_id = value
                                    self.rg_id.value_namespace = name_space
                                    self.rg_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "client_id"):
                                    self.client_id = value
                                    self.client_id.value_namespace = name_space
                                    self.client_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "peer-id"):
                                    self.peer_id = value
                                    self.peer_id.value_namespace = name_space
                                    self.peer_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "state"):
                                    self.state = value
                                    self.state.value_namespace = name_space
                                    self.state.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.redun_groups:
                                if (c.has_data()):
                                    return True
                            return self.icpm_type.is_set

                        def has_operation(self):
                            for c in self.redun_groups:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.icpm_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "icpm-protocols" + "[icpm-type='" + self.icpm_type.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.icpm_type.is_set or self.icpm_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.icpm_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "redun-groups"):
                                for c in self.redun_groups:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols.RedunGroups()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.redun_groups.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "redun-groups" or name == "icpm-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "icpm-type"):
                                self.icpm_type = value
                                self.icpm_type.value_namespace = name_space
                                self.icpm_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.icpm_protocols:
                            if (c.has_data()):
                                return True
                        return self.session_id.is_set

                    def has_operation(self):
                        for c in self.icpm_protocols:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.session_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-table" + "[session-id='" + self.session_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/icpm-summary-all/icpm-session-table/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.session_id.is_set or self.session_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "icpm-protocols"):
                            for c in self.icpm_protocols:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable.IcpmProtocols()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.icpm_protocols.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "icpm-protocols" or name == "session-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "session-id"):
                            self.session_id = value
                            self.session_id.value_namespace = name_space
                            self.session_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.session_table:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.session_table:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "icpm-session-table" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/icpm-summary-all/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "session-table"):
                        for c in self.session_table:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable.SessionTable()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.session_table.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "session-table"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.iccp_rg_app_data_count.is_set or
                    self.iccp_rg_conn_count.is_set or
                    self.iccp_rg_disconn_count.is_set or
                    self.iccp_rg_notif_count.is_set or
                    (self.icpm_rgid_table_info is not None and self.icpm_rgid_table_info.has_data()) or
                    (self.icpm_session_table is not None and self.icpm_session_table.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.iccp_rg_app_data_count.yfilter != YFilter.not_set or
                    self.iccp_rg_conn_count.yfilter != YFilter.not_set or
                    self.iccp_rg_disconn_count.yfilter != YFilter.not_set or
                    self.iccp_rg_notif_count.yfilter != YFilter.not_set or
                    (self.icpm_rgid_table_info is not None and self.icpm_rgid_table_info.has_operation()) or
                    (self.icpm_session_table is not None and self.icpm_session_table.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "icpm-summary-all" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.iccp_rg_app_data_count.is_set or self.iccp_rg_app_data_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.iccp_rg_app_data_count.get_name_leafdata())
                if (self.iccp_rg_conn_count.is_set or self.iccp_rg_conn_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.iccp_rg_conn_count.get_name_leafdata())
                if (self.iccp_rg_disconn_count.is_set or self.iccp_rg_disconn_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.iccp_rg_disconn_count.get_name_leafdata())
                if (self.iccp_rg_notif_count.is_set or self.iccp_rg_notif_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.iccp_rg_notif_count.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "icpm-rgid-table-info"):
                    if (self.icpm_rgid_table_info is None):
                        self.icpm_rgid_table_info = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmRgidTableInfo()
                        self.icpm_rgid_table_info.parent = self
                        self._children_name_map["icpm_rgid_table_info"] = "icpm-rgid-table-info"
                    return self.icpm_rgid_table_info

                if (child_yang_name == "icpm-session-table"):
                    if (self.icpm_session_table is None):
                        self.icpm_session_table = MplsLdp.MplsLdpState.IcpmSummaryAll.IcpmSessionTable()
                        self.icpm_session_table.parent = self
                        self._children_name_map["icpm_session_table"] = "icpm-session-table"
                    return self.icpm_session_table

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "icpm-rgid-table-info" or name == "icpm-session-table" or name == "iccp-rg-app-data-count" or name == "iccp-rg-conn-count" or name == "iccp-rg-disconn-count" or name == "iccp-rg-notif-count"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "iccp-rg-app-data-count"):
                    self.iccp_rg_app_data_count = value
                    self.iccp_rg_app_data_count.value_namespace = name_space
                    self.iccp_rg_app_data_count.value_namespace_prefix = name_space_prefix
                if(value_path == "iccp-rg-conn-count"):
                    self.iccp_rg_conn_count = value
                    self.iccp_rg_conn_count.value_namespace = name_space
                    self.iccp_rg_conn_count.value_namespace_prefix = name_space_prefix
                if(value_path == "iccp-rg-disconn-count"):
                    self.iccp_rg_disconn_count = value
                    self.iccp_rg_disconn_count.value_namespace = name_space
                    self.iccp_rg_disconn_count.value_namespace_prefix = name_space_prefix
                if(value_path == "iccp-rg-notif-count"):
                    self.iccp_rg_notif_count = value
                    self.iccp_rg_notif_count.value_namespace = name_space
                    self.iccp_rg_notif_count.value_namespace_prefix = name_space_prefix


        class Parameters(Entity):
            """
            MPLS LDP Global Parameters
            
            .. attribute:: address_family_parameter
            
            	Per AF parameters
            	**type**\: list of    :py:class:`AddressFamilyParameter <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Parameters.AddressFamilyParameter>`
            
            .. attribute:: af_binding_withdraw_delay
            
            	Delay (sec) in Binding Withdrawal for an Address Family
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: discovery_quick_start_disabled_on_interfaces
            
            	Discovery quick\-start disabled on some enabled interfaces
            	**type**\:  bool
            
            .. attribute:: dod_max_hop
            
            	Maximum number of hops for Downstream\-on\-Demand
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: feature
            
            	This entry describes an LDP feature available on the device. This does not indicate whether the feature is enabled, just the raw ability to support the feature. The features may include, but are not limited to\: 'Auto\-Configuration', 'Basic', 'ICPM', 'IP\-over\-MPLS', 'IGP\-Sync', 'LLAF', 'TCP\-MD5\-Rollover', 'TDP', and 'NSR'
            	**type**\:  list of str
            
            .. attribute:: global_md5_password_enabled
            
            	Global MD5 password enabled
            	**type**\:  bool
            
            .. attribute:: keepalive_interval
            
            	Keepalive interval in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: le_no_route_timeout
            
            	LIB entry no route timeout in second
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: loop_detection
            
            	A indication of whether this LSR has enabled loop detection. Since Loop Detection is determined during Session Initialization, an individual session may not be running with loop detection.  This object simply gives an indication of whether or not the LSR has the ability enabled to support Loop Detection and which types
            	**type**\:   :py:class:`LoopDetectionType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.LoopDetectionType>`
            
            .. attribute:: max_intf_attached
            
            	Maximum number of LDP enabled attached interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: max_intf_te
            
            	Maximum number of LDP enabled TE interfaces
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: max_peer
            
            	Maximum number of LDP peers
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: out_of_mem_state
            
            	This is a counter of the number of times LDP attempted to create a label or binding and failed due a memory allocation failure
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: protocol_version
            
            	Protocol version
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: session_hold_time
            
            	Session hold time in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Parameters, self).__init__()

                self.yang_name = "parameters"
                self.yang_parent_name = "mpls-ldp-state"

                self.af_binding_withdraw_delay = YLeaf(YType.uint32, "af-binding-withdraw-delay")

                self.discovery_quick_start_disabled_on_interfaces = YLeaf(YType.boolean, "discovery-quick-start-disabled-on-interfaces")

                self.dod_max_hop = YLeaf(YType.uint32, "dod-max-hop")

                self.feature = YLeafList(YType.str, "feature")

                self.global_md5_password_enabled = YLeaf(YType.boolean, "global-md5-password-enabled")

                self.keepalive_interval = YLeaf(YType.uint32, "keepalive-interval")

                self.le_no_route_timeout = YLeaf(YType.uint32, "le-no-route-timeout")

                self.loop_detection = YLeaf(YType.enumeration, "loop-detection")

                self.max_intf_attached = YLeaf(YType.uint32, "max-intf-attached")

                self.max_intf_te = YLeaf(YType.uint32, "max-intf-te")

                self.max_peer = YLeaf(YType.uint32, "max-peer")

                self.out_of_mem_state = YLeaf(YType.uint32, "out-of-mem-state")

                self.protocol_version = YLeaf(YType.uint32, "protocol-version")

                self.session_hold_time = YLeaf(YType.uint32, "session-hold-time")

                self.address_family_parameter = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("af_binding_withdraw_delay",
                                "discovery_quick_start_disabled_on_interfaces",
                                "dod_max_hop",
                                "feature",
                                "global_md5_password_enabled",
                                "keepalive_interval",
                                "le_no_route_timeout",
                                "loop_detection",
                                "max_intf_attached",
                                "max_intf_te",
                                "max_peer",
                                "out_of_mem_state",
                                "protocol_version",
                                "session_hold_time") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.Parameters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.Parameters, self).__setattr__(name, value)


            class AddressFamilyParameter(Entity):
                """
                Per AF parameters
                
                .. attribute:: address_family  <key>
                
                	Address Family
                	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                
                .. attribute:: discovery_transport_address
                
                	This is the Discovery transport address
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: is_accepting_targeted_hellos
                
                	Accepting targeted Hellos
                	**type**\:  bool
                
                .. attribute:: targeted_hello_filter
                
                	This contains the filter name for targeted hellos. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Parameters.AddressFamilyParameter, self).__init__()

                    self.yang_name = "address-family-parameter"
                    self.yang_parent_name = "parameters"

                    self.address_family = YLeaf(YType.enumeration, "address-family")

                    self.discovery_transport_address = YLeaf(YType.str, "discovery-transport-address")

                    self.is_accepting_targeted_hellos = YLeaf(YType.boolean, "is-accepting-targeted-hellos")

                    self.targeted_hello_filter = YLeaf(YType.str, "targeted-hello-filter")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("address_family",
                                    "discovery_transport_address",
                                    "is_accepting_targeted_hellos",
                                    "targeted_hello_filter") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Parameters.AddressFamilyParameter, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Parameters.AddressFamilyParameter, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.address_family.is_set or
                        self.discovery_transport_address.is_set or
                        self.is_accepting_targeted_hellos.is_set or
                        self.targeted_hello_filter.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.address_family.yfilter != YFilter.not_set or
                        self.discovery_transport_address.yfilter != YFilter.not_set or
                        self.is_accepting_targeted_hellos.yfilter != YFilter.not_set or
                        self.targeted_hello_filter.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "address-family-parameter" + "[address-family='" + self.address_family.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/parameters/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.address_family.is_set or self.address_family.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address_family.get_name_leafdata())
                    if (self.discovery_transport_address.is_set or self.discovery_transport_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.discovery_transport_address.get_name_leafdata())
                    if (self.is_accepting_targeted_hellos.is_set or self.is_accepting_targeted_hellos.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_accepting_targeted_hellos.get_name_leafdata())
                    if (self.targeted_hello_filter.is_set or self.targeted_hello_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.targeted_hello_filter.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "address-family" or name == "discovery-transport-address" or name == "is-accepting-targeted-hellos" or name == "targeted-hello-filter"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "address-family"):
                        self.address_family = value
                        self.address_family.value_namespace = name_space
                        self.address_family.value_namespace_prefix = name_space_prefix
                    if(value_path == "discovery-transport-address"):
                        self.discovery_transport_address = value
                        self.discovery_transport_address.value_namespace = name_space
                        self.discovery_transport_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-accepting-targeted-hellos"):
                        self.is_accepting_targeted_hellos = value
                        self.is_accepting_targeted_hellos.value_namespace = name_space
                        self.is_accepting_targeted_hellos.value_namespace_prefix = name_space_prefix
                    if(value_path == "targeted-hello-filter"):
                        self.targeted_hello_filter = value
                        self.targeted_hello_filter.value_namespace = name_space
                        self.targeted_hello_filter.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.address_family_parameter:
                    if (c.has_data()):
                        return True
                for leaf in self.feature.getYLeafs():
                    if (leaf.yfilter != YFilter.not_set):
                        return True
                return (
                    self.af_binding_withdraw_delay.is_set or
                    self.discovery_quick_start_disabled_on_interfaces.is_set or
                    self.dod_max_hop.is_set or
                    self.global_md5_password_enabled.is_set or
                    self.keepalive_interval.is_set or
                    self.le_no_route_timeout.is_set or
                    self.loop_detection.is_set or
                    self.max_intf_attached.is_set or
                    self.max_intf_te.is_set or
                    self.max_peer.is_set or
                    self.out_of_mem_state.is_set or
                    self.protocol_version.is_set or
                    self.session_hold_time.is_set)

            def has_operation(self):
                for c in self.address_family_parameter:
                    if (c.has_operation()):
                        return True
                for leaf in self.feature.getYLeafs():
                    if (leaf.is_set):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.af_binding_withdraw_delay.yfilter != YFilter.not_set or
                    self.discovery_quick_start_disabled_on_interfaces.yfilter != YFilter.not_set or
                    self.dod_max_hop.yfilter != YFilter.not_set or
                    self.feature.yfilter != YFilter.not_set or
                    self.global_md5_password_enabled.yfilter != YFilter.not_set or
                    self.keepalive_interval.yfilter != YFilter.not_set or
                    self.le_no_route_timeout.yfilter != YFilter.not_set or
                    self.loop_detection.yfilter != YFilter.not_set or
                    self.max_intf_attached.yfilter != YFilter.not_set or
                    self.max_intf_te.yfilter != YFilter.not_set or
                    self.max_peer.yfilter != YFilter.not_set or
                    self.out_of_mem_state.yfilter != YFilter.not_set or
                    self.protocol_version.yfilter != YFilter.not_set or
                    self.session_hold_time.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "parameters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.af_binding_withdraw_delay.is_set or self.af_binding_withdraw_delay.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.af_binding_withdraw_delay.get_name_leafdata())
                if (self.discovery_quick_start_disabled_on_interfaces.is_set or self.discovery_quick_start_disabled_on_interfaces.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.discovery_quick_start_disabled_on_interfaces.get_name_leafdata())
                if (self.dod_max_hop.is_set or self.dod_max_hop.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.dod_max_hop.get_name_leafdata())
                if (self.global_md5_password_enabled.is_set or self.global_md5_password_enabled.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.global_md5_password_enabled.get_name_leafdata())
                if (self.keepalive_interval.is_set or self.keepalive_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.keepalive_interval.get_name_leafdata())
                if (self.le_no_route_timeout.is_set or self.le_no_route_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.le_no_route_timeout.get_name_leafdata())
                if (self.loop_detection.is_set or self.loop_detection.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.loop_detection.get_name_leafdata())
                if (self.max_intf_attached.is_set or self.max_intf_attached.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_intf_attached.get_name_leafdata())
                if (self.max_intf_te.is_set or self.max_intf_te.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_intf_te.get_name_leafdata())
                if (self.max_peer.is_set or self.max_peer.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_peer.get_name_leafdata())
                if (self.out_of_mem_state.is_set or self.out_of_mem_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.out_of_mem_state.get_name_leafdata())
                if (self.protocol_version.is_set or self.protocol_version.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol_version.get_name_leafdata())
                if (self.session_hold_time.is_set or self.session_hold_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_hold_time.get_name_leafdata())

                leaf_name_data.extend(self.feature.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "address-family-parameter"):
                    for c in self.address_family_parameter:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Parameters.AddressFamilyParameter()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.address_family_parameter.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "address-family-parameter" or name == "af-binding-withdraw-delay" or name == "discovery-quick-start-disabled-on-interfaces" or name == "dod-max-hop" or name == "feature" or name == "global-md5-password-enabled" or name == "keepalive-interval" or name == "le-no-route-timeout" or name == "loop-detection" or name == "max-intf-attached" or name == "max-intf-te" or name == "max-peer" or name == "out-of-mem-state" or name == "protocol-version" or name == "session-hold-time"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "af-binding-withdraw-delay"):
                    self.af_binding_withdraw_delay = value
                    self.af_binding_withdraw_delay.value_namespace = name_space
                    self.af_binding_withdraw_delay.value_namespace_prefix = name_space_prefix
                if(value_path == "discovery-quick-start-disabled-on-interfaces"):
                    self.discovery_quick_start_disabled_on_interfaces = value
                    self.discovery_quick_start_disabled_on_interfaces.value_namespace = name_space
                    self.discovery_quick_start_disabled_on_interfaces.value_namespace_prefix = name_space_prefix
                if(value_path == "dod-max-hop"):
                    self.dod_max_hop = value
                    self.dod_max_hop.value_namespace = name_space
                    self.dod_max_hop.value_namespace_prefix = name_space_prefix
                if(value_path == "feature"):
                    self.feature.append(value)
                if(value_path == "global-md5-password-enabled"):
                    self.global_md5_password_enabled = value
                    self.global_md5_password_enabled.value_namespace = name_space
                    self.global_md5_password_enabled.value_namespace_prefix = name_space_prefix
                if(value_path == "keepalive-interval"):
                    self.keepalive_interval = value
                    self.keepalive_interval.value_namespace = name_space
                    self.keepalive_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "le-no-route-timeout"):
                    self.le_no_route_timeout = value
                    self.le_no_route_timeout.value_namespace = name_space
                    self.le_no_route_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "loop-detection"):
                    self.loop_detection = value
                    self.loop_detection.value_namespace = name_space
                    self.loop_detection.value_namespace_prefix = name_space_prefix
                if(value_path == "max-intf-attached"):
                    self.max_intf_attached = value
                    self.max_intf_attached.value_namespace = name_space
                    self.max_intf_attached.value_namespace_prefix = name_space_prefix
                if(value_path == "max-intf-te"):
                    self.max_intf_te = value
                    self.max_intf_te.value_namespace = name_space
                    self.max_intf_te.value_namespace_prefix = name_space_prefix
                if(value_path == "max-peer"):
                    self.max_peer = value
                    self.max_peer.value_namespace = name_space
                    self.max_peer.value_namespace_prefix = name_space_prefix
                if(value_path == "out-of-mem-state"):
                    self.out_of_mem_state = value
                    self.out_of_mem_state.value_namespace = name_space
                    self.out_of_mem_state.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol-version"):
                    self.protocol_version = value
                    self.protocol_version.value_namespace = name_space
                    self.protocol_version.value_namespace_prefix = name_space_prefix
                if(value_path == "session-hold-time"):
                    self.session_hold_time = value
                    self.session_hold_time.value_namespace = name_space
                    self.session_hold_time.value_namespace_prefix = name_space_prefix


        class Capabilities(Entity):
            """
            LDP capability database information
            
            .. attribute:: capability
            
            	Information on LDP capability
            	**type**\: list of    :py:class:`Capability <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Capabilities.Capability>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Capabilities, self).__init__()

                self.yang_name = "capabilities"
                self.yang_parent_name = "mpls-ldp-state"

                self.capability = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.Capabilities, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.Capabilities, self).__setattr__(name, value)


            class Capability(Entity):
                """
                Information on LDP capability
                
                .. attribute:: cap_type  <key>
                
                	Capability type (IANA assigned)
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: cap_des
                
                	Capability description
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: capability_data
                
                	Capability data
                	**type**\:  str
                
                .. attribute:: capability_data_length
                
                	Capability data length
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: capability_owner
                
                	Capability owner
                	**type**\:  str
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Capabilities.Capability, self).__init__()

                    self.yang_name = "capability"
                    self.yang_parent_name = "capabilities"

                    self.cap_type = YLeaf(YType.uint16, "cap-type")

                    self.cap_des = YLeaf(YType.str, "cap-des")

                    self.capability_data = YLeaf(YType.str, "capability-data")

                    self.capability_data_length = YLeaf(YType.uint16, "capability-data-length")

                    self.capability_owner = YLeaf(YType.str, "capability-owner")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("cap_type",
                                    "cap_des",
                                    "capability_data",
                                    "capability_data_length",
                                    "capability_owner") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Capabilities.Capability, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Capabilities.Capability, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.cap_type.is_set or
                        self.cap_des.is_set or
                        self.capability_data.is_set or
                        self.capability_data_length.is_set or
                        self.capability_owner.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.cap_type.yfilter != YFilter.not_set or
                        self.cap_des.yfilter != YFilter.not_set or
                        self.capability_data.yfilter != YFilter.not_set or
                        self.capability_data_length.yfilter != YFilter.not_set or
                        self.capability_owner.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "capability" + "[cap-type='" + self.cap_type.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/capabilities/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.cap_type.is_set or self.cap_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cap_type.get_name_leafdata())
                    if (self.cap_des.is_set or self.cap_des.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cap_des.get_name_leafdata())
                    if (self.capability_data.is_set or self.capability_data.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_data.get_name_leafdata())
                    if (self.capability_data_length.is_set or self.capability_data_length.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_data_length.get_name_leafdata())
                    if (self.capability_owner.is_set or self.capability_owner.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.capability_owner.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "cap-type" or name == "cap-des" or name == "capability-data" or name == "capability-data-length" or name == "capability-owner"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "cap-type"):
                        self.cap_type = value
                        self.cap_type.value_namespace = name_space
                        self.cap_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "cap-des"):
                        self.cap_des = value
                        self.cap_des.value_namespace = name_space
                        self.cap_des.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-data"):
                        self.capability_data = value
                        self.capability_data.value_namespace = name_space
                        self.capability_data.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-data-length"):
                        self.capability_data_length = value
                        self.capability_data_length.value_namespace = name_space
                        self.capability_data_length.value_namespace_prefix = name_space_prefix
                    if(value_path == "capability-owner"):
                        self.capability_owner = value
                        self.capability_owner.value_namespace = name_space
                        self.capability_owner.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.capability:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.capability:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "capabilities" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "capability"):
                    for c in self.capability:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Capabilities.Capability()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.capability.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "capability"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class BackoffParameters(Entity):
            """
            MPLS LDP Session Backoff Information
            
            .. attribute:: backoff_seconds
            
            	Current backoff seconds count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: initial_seconds
            
            	Initial backoff value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: maximum_seconds
            
            	Maximum backoff value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: waiting_seconds
            
            	Current backoff waiting seconds count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.BackoffParameters, self).__init__()

                self.yang_name = "backoff-parameters"
                self.yang_parent_name = "mpls-ldp-state"

                self.backoff_seconds = YLeaf(YType.uint32, "backoff-seconds")

                self.initial_seconds = YLeaf(YType.uint32, "initial-seconds")

                self.maximum_seconds = YLeaf(YType.uint32, "maximum-seconds")

                self.waiting_seconds = YLeaf(YType.uint32, "waiting-seconds")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("backoff_seconds",
                                "initial_seconds",
                                "maximum_seconds",
                                "waiting_seconds") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.BackoffParameters, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.BackoffParameters, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.backoff_seconds.is_set or
                    self.initial_seconds.is_set or
                    self.maximum_seconds.is_set or
                    self.waiting_seconds.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.backoff_seconds.yfilter != YFilter.not_set or
                    self.initial_seconds.yfilter != YFilter.not_set or
                    self.maximum_seconds.yfilter != YFilter.not_set or
                    self.waiting_seconds.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "backoff-parameters" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.backoff_seconds.is_set or self.backoff_seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.backoff_seconds.get_name_leafdata())
                if (self.initial_seconds.is_set or self.initial_seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.initial_seconds.get_name_leafdata())
                if (self.maximum_seconds.is_set or self.maximum_seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.maximum_seconds.get_name_leafdata())
                if (self.waiting_seconds.is_set or self.waiting_seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.waiting_seconds.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "backoff-seconds" or name == "initial-seconds" or name == "maximum-seconds" or name == "waiting-seconds"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "backoff-seconds"):
                    self.backoff_seconds = value
                    self.backoff_seconds.value_namespace = name_space
                    self.backoff_seconds.value_namespace_prefix = name_space_prefix
                if(value_path == "initial-seconds"):
                    self.initial_seconds = value
                    self.initial_seconds.value_namespace = name_space
                    self.initial_seconds.value_namespace_prefix = name_space_prefix
                if(value_path == "maximum-seconds"):
                    self.maximum_seconds = value
                    self.maximum_seconds.value_namespace = name_space
                    self.maximum_seconds.value_namespace_prefix = name_space_prefix
                if(value_path == "waiting-seconds"):
                    self.waiting_seconds = value
                    self.waiting_seconds.value_namespace = name_space
                    self.waiting_seconds.value_namespace_prefix = name_space_prefix


        class GracefulRestart(Entity):
            """
            MPLS LDP Graceful Restart Information
            
            .. attribute:: forwarding_state_hold_timer_remaining_seconds
            
            	Forwarding state hold timer remaining time in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: graceful_restart_forwarding_state_hold_time
            
            	Graceful restart forward state hold time in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: graceful_restart_reconnect_timeout
            
            	Reconnect timeout value in seconds
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**units**\: seconds
            
            .. attribute:: is_forwarding_state_hold_timer_running
            
            	Is graceful restart forwarding state hold timer running
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: is_graceful_restart_configured
            
            	Is graceful restart configured
            	**type**\:  bool
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.GracefulRestart, self).__init__()

                self.yang_name = "graceful-restart"
                self.yang_parent_name = "mpls-ldp-state"

                self.forwarding_state_hold_timer_remaining_seconds = YLeaf(YType.uint32, "forwarding-state-hold-timer-remaining-seconds")

                self.graceful_restart_forwarding_state_hold_time = YLeaf(YType.uint32, "graceful-restart-forwarding-state-hold-time")

                self.graceful_restart_reconnect_timeout = YLeaf(YType.uint32, "graceful-restart-reconnect-timeout")

                self.is_forwarding_state_hold_timer_running = YLeaf(YType.empty, "is-forwarding-state-hold-timer-running")

                self.is_graceful_restart_configured = YLeaf(YType.boolean, "is-graceful-restart-configured")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("forwarding_state_hold_timer_remaining_seconds",
                                "graceful_restart_forwarding_state_hold_time",
                                "graceful_restart_reconnect_timeout",
                                "is_forwarding_state_hold_timer_running",
                                "is_graceful_restart_configured") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.GracefulRestart, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.GracefulRestart, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.forwarding_state_hold_timer_remaining_seconds.is_set or
                    self.graceful_restart_forwarding_state_hold_time.is_set or
                    self.graceful_restart_reconnect_timeout.is_set or
                    self.is_forwarding_state_hold_timer_running.is_set or
                    self.is_graceful_restart_configured.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.forwarding_state_hold_timer_remaining_seconds.yfilter != YFilter.not_set or
                    self.graceful_restart_forwarding_state_hold_time.yfilter != YFilter.not_set or
                    self.graceful_restart_reconnect_timeout.yfilter != YFilter.not_set or
                    self.is_forwarding_state_hold_timer_running.yfilter != YFilter.not_set or
                    self.is_graceful_restart_configured.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "graceful-restart" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.forwarding_state_hold_timer_remaining_seconds.is_set or self.forwarding_state_hold_timer_remaining_seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.forwarding_state_hold_timer_remaining_seconds.get_name_leafdata())
                if (self.graceful_restart_forwarding_state_hold_time.is_set or self.graceful_restart_forwarding_state_hold_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.graceful_restart_forwarding_state_hold_time.get_name_leafdata())
                if (self.graceful_restart_reconnect_timeout.is_set or self.graceful_restart_reconnect_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.graceful_restart_reconnect_timeout.get_name_leafdata())
                if (self.is_forwarding_state_hold_timer_running.is_set or self.is_forwarding_state_hold_timer_running.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_forwarding_state_hold_timer_running.get_name_leafdata())
                if (self.is_graceful_restart_configured.is_set or self.is_graceful_restart_configured.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_graceful_restart_configured.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "forwarding-state-hold-timer-remaining-seconds" or name == "graceful-restart-forwarding-state-hold-time" or name == "graceful-restart-reconnect-timeout" or name == "is-forwarding-state-hold-timer-running" or name == "is-graceful-restart-configured"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "forwarding-state-hold-timer-remaining-seconds"):
                    self.forwarding_state_hold_timer_remaining_seconds = value
                    self.forwarding_state_hold_timer_remaining_seconds.value_namespace = name_space
                    self.forwarding_state_hold_timer_remaining_seconds.value_namespace_prefix = name_space_prefix
                if(value_path == "graceful-restart-forwarding-state-hold-time"):
                    self.graceful_restart_forwarding_state_hold_time = value
                    self.graceful_restart_forwarding_state_hold_time.value_namespace = name_space
                    self.graceful_restart_forwarding_state_hold_time.value_namespace_prefix = name_space_prefix
                if(value_path == "graceful-restart-reconnect-timeout"):
                    self.graceful_restart_reconnect_timeout = value
                    self.graceful_restart_reconnect_timeout.value_namespace = name_space
                    self.graceful_restart_reconnect_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "is-forwarding-state-hold-timer-running"):
                    self.is_forwarding_state_hold_timer_running = value
                    self.is_forwarding_state_hold_timer_running.value_namespace = name_space
                    self.is_forwarding_state_hold_timer_running.value_namespace_prefix = name_space_prefix
                if(value_path == "is-graceful-restart-configured"):
                    self.is_graceful_restart_configured = value
                    self.is_graceful_restart_configured.value_namespace = name_space
                    self.is_graceful_restart_configured.value_namespace_prefix = name_space_prefix


        class Vrfs(Entity):
            """
            MPLS LDP per\-VRF operational data.
            
            .. attribute:: vrf
            
            	MPLS LDP Operational data for a given VRF
            	**type**\: list of    :py:class:`Vrf <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Vrfs, self).__init__()

                self.yang_name = "vrfs"
                self.yang_parent_name = "mpls-ldp-state"

                self.vrf = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.Vrfs, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.Vrfs, self).__setattr__(name, value)


            class Vrf(Entity):
                """
                MPLS LDP Operational data for a given VRF.
                
                .. attribute:: vrf_name  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: afs
                
                	Address Family specific operational data
                	**type**\:   :py:class:`Afs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.Afs>`
                
                .. attribute:: vrf_summary
                
                	MPLS LDP per VRF summarized Information
                	**type**\:   :py:class:`VrfSummary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.VrfSummary>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Vrfs.Vrf, self).__init__()

                    self.yang_name = "vrf"
                    self.yang_parent_name = "vrfs"

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                    self.afs = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs()
                    self.afs.parent = self
                    self._children_name_map["afs"] = "afs"
                    self._children_yang_names.add("afs")

                    self.vrf_summary = MplsLdp.MplsLdpState.Vrfs.Vrf.VrfSummary()
                    self.vrf_summary.parent = self
                    self._children_name_map["vrf_summary"] = "vrf-summary"
                    self._children_yang_names.add("vrf-summary")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Vrfs.Vrf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Vrfs.Vrf, self).__setattr__(name, value)


                class VrfSummary(Entity):
                    """
                    MPLS LDP per VRF summarized Information
                    
                    .. attribute:: address_families
                    
                    	Address Families enabled
                    	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                    
                    .. attribute:: number_of_downstream_on_demand_neighbors
                    
                    	Number of Downstream\-On\-Demand neighbor
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_graceful_restart_neighbors
                    
                    	Number of Graceful Restart neighbor
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_ipv4_local_addresses
                    
                    	Number of IPv4 local addresses
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_ipv4_routes
                    
                    	Number of resolved IPv4 routes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_ipv4ldp_interfaces
                    
                    	Number of LDP IPv4 configured interfaces
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_ldp_interfaces
                    
                    	Number of LDP configured interfaces
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_neighbors
                    
                    	Number of neighbor
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: numberof_ipv4_hello_adj
                    
                    	Number of LDP discovery IPv4 hello adjacencies
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Vrfs.Vrf.VrfSummary, self).__init__()

                        self.yang_name = "vrf-summary"
                        self.yang_parent_name = "vrf"

                        self.address_families = YLeaf(YType.enumeration, "address-families")

                        self.number_of_downstream_on_demand_neighbors = YLeaf(YType.uint32, "number-of-downstream-on-demand-neighbors")

                        self.number_of_graceful_restart_neighbors = YLeaf(YType.uint32, "number-of-graceful-restart-neighbors")

                        self.number_of_ipv4_local_addresses = YLeaf(YType.uint32, "number-of-ipv4-local-addresses")

                        self.number_of_ipv4_routes = YLeaf(YType.uint32, "number-of-ipv4-routes")

                        self.number_of_ipv4ldp_interfaces = YLeaf(YType.uint32, "number-of-ipv4ldp-interfaces")

                        self.number_of_ldp_interfaces = YLeaf(YType.uint32, "number-of-ldp-interfaces")

                        self.number_of_neighbors = YLeaf(YType.uint32, "number-of-neighbors")

                        self.numberof_ipv4_hello_adj = YLeaf(YType.uint32, "numberof-ipv4-hello-adj")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("address_families",
                                        "number_of_downstream_on_demand_neighbors",
                                        "number_of_graceful_restart_neighbors",
                                        "number_of_ipv4_local_addresses",
                                        "number_of_ipv4_routes",
                                        "number_of_ipv4ldp_interfaces",
                                        "number_of_ldp_interfaces",
                                        "number_of_neighbors",
                                        "numberof_ipv4_hello_adj") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Vrfs.Vrf.VrfSummary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Vrfs.Vrf.VrfSummary, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.address_families.is_set or
                            self.number_of_downstream_on_demand_neighbors.is_set or
                            self.number_of_graceful_restart_neighbors.is_set or
                            self.number_of_ipv4_local_addresses.is_set or
                            self.number_of_ipv4_routes.is_set or
                            self.number_of_ipv4ldp_interfaces.is_set or
                            self.number_of_ldp_interfaces.is_set or
                            self.number_of_neighbors.is_set or
                            self.numberof_ipv4_hello_adj.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.address_families.yfilter != YFilter.not_set or
                            self.number_of_downstream_on_demand_neighbors.yfilter != YFilter.not_set or
                            self.number_of_graceful_restart_neighbors.yfilter != YFilter.not_set or
                            self.number_of_ipv4_local_addresses.yfilter != YFilter.not_set or
                            self.number_of_ipv4_routes.yfilter != YFilter.not_set or
                            self.number_of_ipv4ldp_interfaces.yfilter != YFilter.not_set or
                            self.number_of_ldp_interfaces.yfilter != YFilter.not_set or
                            self.number_of_neighbors.yfilter != YFilter.not_set or
                            self.numberof_ipv4_hello_adj.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "vrf-summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.address_families.is_set or self.address_families.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address_families.get_name_leafdata())
                        if (self.number_of_downstream_on_demand_neighbors.is_set or self.number_of_downstream_on_demand_neighbors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_downstream_on_demand_neighbors.get_name_leafdata())
                        if (self.number_of_graceful_restart_neighbors.is_set or self.number_of_graceful_restart_neighbors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_graceful_restart_neighbors.get_name_leafdata())
                        if (self.number_of_ipv4_local_addresses.is_set or self.number_of_ipv4_local_addresses.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_ipv4_local_addresses.get_name_leafdata())
                        if (self.number_of_ipv4_routes.is_set or self.number_of_ipv4_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_ipv4_routes.get_name_leafdata())
                        if (self.number_of_ipv4ldp_interfaces.is_set or self.number_of_ipv4ldp_interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_ipv4ldp_interfaces.get_name_leafdata())
                        if (self.number_of_ldp_interfaces.is_set or self.number_of_ldp_interfaces.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_ldp_interfaces.get_name_leafdata())
                        if (self.number_of_neighbors.is_set or self.number_of_neighbors.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_neighbors.get_name_leafdata())
                        if (self.numberof_ipv4_hello_adj.is_set or self.numberof_ipv4_hello_adj.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.numberof_ipv4_hello_adj.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address-families" or name == "number-of-downstream-on-demand-neighbors" or name == "number-of-graceful-restart-neighbors" or name == "number-of-ipv4-local-addresses" or name == "number-of-ipv4-routes" or name == "number-of-ipv4ldp-interfaces" or name == "number-of-ldp-interfaces" or name == "number-of-neighbors" or name == "numberof-ipv4-hello-adj"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "address-families"):
                            self.address_families = value
                            self.address_families.value_namespace = name_space
                            self.address_families.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-downstream-on-demand-neighbors"):
                            self.number_of_downstream_on_demand_neighbors = value
                            self.number_of_downstream_on_demand_neighbors.value_namespace = name_space
                            self.number_of_downstream_on_demand_neighbors.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-graceful-restart-neighbors"):
                            self.number_of_graceful_restart_neighbors = value
                            self.number_of_graceful_restart_neighbors.value_namespace = name_space
                            self.number_of_graceful_restart_neighbors.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-ipv4-local-addresses"):
                            self.number_of_ipv4_local_addresses = value
                            self.number_of_ipv4_local_addresses.value_namespace = name_space
                            self.number_of_ipv4_local_addresses.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-ipv4-routes"):
                            self.number_of_ipv4_routes = value
                            self.number_of_ipv4_routes.value_namespace = name_space
                            self.number_of_ipv4_routes.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-ipv4ldp-interfaces"):
                            self.number_of_ipv4ldp_interfaces = value
                            self.number_of_ipv4ldp_interfaces.value_namespace = name_space
                            self.number_of_ipv4ldp_interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-ldp-interfaces"):
                            self.number_of_ldp_interfaces = value
                            self.number_of_ldp_interfaces.value_namespace = name_space
                            self.number_of_ldp_interfaces.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-neighbors"):
                            self.number_of_neighbors = value
                            self.number_of_neighbors.value_namespace = name_space
                            self.number_of_neighbors.value_namespace_prefix = name_space_prefix
                        if(value_path == "numberof-ipv4-hello-adj"):
                            self.numberof_ipv4_hello_adj = value
                            self.numberof_ipv4_hello_adj.value_namespace = name_space
                            self.numberof_ipv4_hello_adj.value_namespace_prefix = name_space_prefix


                class Afs(Entity):
                    """
                    Address Family specific operational data
                    
                    .. attribute:: af
                    
                    	MPLS LDP Operational data for this Address Family
                    	**type**\: list of    :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs, self).__init__()

                        self.yang_name = "afs"
                        self.yang_parent_name = "vrf"

                        self.af = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs, self).__setattr__(name, value)


                    class Af(Entity):
                        """
                        MPLS LDP Operational data for this Address Family.
                        
                        .. attribute:: af_name  <key>
                        
                        	Address Family name
                        	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                        
                        .. attribute:: igp
                        
                        	LDP IGP Synchronization related information
                        	**type**\:   :py:class:`Igp <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp>`
                        
                        .. attribute:: interface_summary
                        
                        	This container holds a summary of information across all interfaces in this AF,
                        	**type**\:   :py:class:`InterfaceSummary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.InterfaceSummary>`
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af, self).__init__()

                            self.yang_name = "af"
                            self.yang_parent_name = "afs"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.igp = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp()
                            self.igp.parent = self
                            self._children_name_map["igp"] = "igp"
                            self._children_yang_names.add("igp")

                            self.interface_summary = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.InterfaceSummary()
                            self.interface_summary.parent = self
                            self._children_name_map["interface_summary"] = "interface-summary"
                            self._children_yang_names.add("interface-summary")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af, self).__setattr__(name, value)


                        class InterfaceSummary(Entity):
                            """
                            This container holds a summary of information
                            across all interfaces in this AF,
                            
                            .. attribute:: auto_config
                            
                            	Auto\-configured interfaces
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: auto_config_disabled
                            
                            	Autoconfigure disabled
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: auto_config_forward_reference_interfaces
                            
                            	Auto\-configured forward references
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: configured_attached_interface
                            
                            	Number of attached interfaces configured in LDP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: configured_te_interface
                            
                            	Number of TE tunnel interfaces configured in LDP
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: forward_references
                            
                            	Number of forward referenced interfaces
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: known_ip_interface_count
                            
                            	Number of known IP Interfaces
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: known_ip_interface_ldp_enabled
                            
                            	Number of known IP Interfaces with LDP Enabled
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.InterfaceSummary, self).__init__()

                                self.yang_name = "interface-summary"
                                self.yang_parent_name = "af"

                                self.auto_config = YLeaf(YType.uint32, "auto-config")

                                self.auto_config_disabled = YLeaf(YType.uint32, "auto-config-disabled")

                                self.auto_config_forward_reference_interfaces = YLeaf(YType.uint32, "auto-config-forward-reference-interfaces")

                                self.configured_attached_interface = YLeaf(YType.uint32, "configured-attached-interface")

                                self.configured_te_interface = YLeaf(YType.uint32, "configured-te-interface")

                                self.forward_references = YLeaf(YType.uint32, "forward-references")

                                self.known_ip_interface_count = YLeaf(YType.uint32, "known-ip-interface-count")

                                self.known_ip_interface_ldp_enabled = YLeaf(YType.uint32, "known-ip-interface-ldp-enabled")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("auto_config",
                                                "auto_config_disabled",
                                                "auto_config_forward_reference_interfaces",
                                                "configured_attached_interface",
                                                "configured_te_interface",
                                                "forward_references",
                                                "known_ip_interface_count",
                                                "known_ip_interface_ldp_enabled") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.InterfaceSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.InterfaceSummary, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.auto_config.is_set or
                                    self.auto_config_disabled.is_set or
                                    self.auto_config_forward_reference_interfaces.is_set or
                                    self.configured_attached_interface.is_set or
                                    self.configured_te_interface.is_set or
                                    self.forward_references.is_set or
                                    self.known_ip_interface_count.is_set or
                                    self.known_ip_interface_ldp_enabled.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.auto_config.yfilter != YFilter.not_set or
                                    self.auto_config_disabled.yfilter != YFilter.not_set or
                                    self.auto_config_forward_reference_interfaces.yfilter != YFilter.not_set or
                                    self.configured_attached_interface.yfilter != YFilter.not_set or
                                    self.configured_te_interface.yfilter != YFilter.not_set or
                                    self.forward_references.yfilter != YFilter.not_set or
                                    self.known_ip_interface_count.yfilter != YFilter.not_set or
                                    self.known_ip_interface_ldp_enabled.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.auto_config.is_set or self.auto_config.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_config.get_name_leafdata())
                                if (self.auto_config_disabled.is_set or self.auto_config_disabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_config_disabled.get_name_leafdata())
                                if (self.auto_config_forward_reference_interfaces.is_set or self.auto_config_forward_reference_interfaces.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.auto_config_forward_reference_interfaces.get_name_leafdata())
                                if (self.configured_attached_interface.is_set or self.configured_attached_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.configured_attached_interface.get_name_leafdata())
                                if (self.configured_te_interface.is_set or self.configured_te_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.configured_te_interface.get_name_leafdata())
                                if (self.forward_references.is_set or self.forward_references.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.forward_references.get_name_leafdata())
                                if (self.known_ip_interface_count.is_set or self.known_ip_interface_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.known_ip_interface_count.get_name_leafdata())
                                if (self.known_ip_interface_ldp_enabled.is_set or self.known_ip_interface_ldp_enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.known_ip_interface_ldp_enabled.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "auto-config" or name == "auto-config-disabled" or name == "auto-config-forward-reference-interfaces" or name == "configured-attached-interface" or name == "configured-te-interface" or name == "forward-references" or name == "known-ip-interface-count" or name == "known-ip-interface-ldp-enabled"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "auto-config"):
                                    self.auto_config = value
                                    self.auto_config.value_namespace = name_space
                                    self.auto_config.value_namespace_prefix = name_space_prefix
                                if(value_path == "auto-config-disabled"):
                                    self.auto_config_disabled = value
                                    self.auto_config_disabled.value_namespace = name_space
                                    self.auto_config_disabled.value_namespace_prefix = name_space_prefix
                                if(value_path == "auto-config-forward-reference-interfaces"):
                                    self.auto_config_forward_reference_interfaces = value
                                    self.auto_config_forward_reference_interfaces.value_namespace = name_space
                                    self.auto_config_forward_reference_interfaces.value_namespace_prefix = name_space_prefix
                                if(value_path == "configured-attached-interface"):
                                    self.configured_attached_interface = value
                                    self.configured_attached_interface.value_namespace = name_space
                                    self.configured_attached_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "configured-te-interface"):
                                    self.configured_te_interface = value
                                    self.configured_te_interface.value_namespace = name_space
                                    self.configured_te_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "forward-references"):
                                    self.forward_references = value
                                    self.forward_references.value_namespace = name_space
                                    self.forward_references.value_namespace_prefix = name_space_prefix
                                if(value_path == "known-ip-interface-count"):
                                    self.known_ip_interface_count = value
                                    self.known_ip_interface_count.value_namespace = name_space
                                    self.known_ip_interface_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "known-ip-interface-ldp-enabled"):
                                    self.known_ip_interface_ldp_enabled = value
                                    self.known_ip_interface_ldp_enabled.value_namespace = name_space
                                    self.known_ip_interface_ldp_enabled.value_namespace_prefix = name_space_prefix


                        class Igp(Entity):
                            """
                            LDP IGP Synchronization related information
                            
                            .. attribute:: sync
                            
                            	LDP\-IGP Synchronization related information for an interface
                            	**type**\: list of    :py:class:`Sync <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync>`
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp, self).__init__()

                                self.yang_name = "igp"
                                self.yang_parent_name = "af"

                                self.sync = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp, self).__setattr__(name, value)


                            class Sync(Entity):
                                """
                                LDP\-IGP Synchronization related information
                                for an interface
                                
                                .. attribute:: interface  <key>
                                
                                	This leaf contains the interface name for the IGP Synchronization information
                                	**type**\:  str
                                
                                	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                                
                                .. attribute:: delay_timer_remaining
                                
                                	Remaining timer (seconds) until expiry of sync delay timer
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: seconds
                                
                                .. attribute:: igp_sync_down_reason
                                
                                	Reason IGP Sync Not Achieved
                                	**type**\:   :py:class:`IgpSyncDownReason <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IgpSyncDownReason>`
                                
                                .. attribute:: igp_sync_state
                                
                                	IGP Sync state
                                	**type**\:   :py:class:`IgpSyncState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.IgpSyncState>`
                                
                                .. attribute:: is_delay_timer_running
                                
                                	This is set when the sync delay timer running
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                .. attribute:: peers
                                
                                	MPLS LDP IGP Sync Interface Peer Information
                                	**type**\: list of    :py:class:`Peers <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync.Peers>`
                                
                                

                                """

                                _prefix = 'mpls-ldp-ios-xe-oper'
                                _revision = '2017-02-07'

                                def __init__(self):
                                    super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync, self).__init__()

                                    self.yang_name = "sync"
                                    self.yang_parent_name = "igp"

                                    self.interface = YLeaf(YType.str, "interface")

                                    self.delay_timer_remaining = YLeaf(YType.uint32, "delay-timer-remaining")

                                    self.igp_sync_down_reason = YLeaf(YType.identityref, "igp-sync-down-reason")

                                    self.igp_sync_state = YLeaf(YType.enumeration, "igp-sync-state")

                                    self.is_delay_timer_running = YLeaf(YType.empty, "is-delay-timer-running")

                                    self.peers = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface",
                                                    "delay_timer_remaining",
                                                    "igp_sync_down_reason",
                                                    "igp_sync_state",
                                                    "is_delay_timer_running") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync, self).__setattr__(name, value)


                                class Peers(Entity):
                                    """
                                    MPLS LDP IGP Sync Interface Peer Information
                                    
                                    .. attribute:: is_chkpt_created
                                    
                                    	This is set if this peer was created due to check\-pointing
                                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                    
                                    .. attribute:: is_gr_enabled
                                    
                                    	Is GR enabled session
                                    	**type**\:  bool
                                    
                                    .. attribute:: peer_id
                                    
                                    	Peer Identifier
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'mpls-ldp-ios-xe-oper'
                                    _revision = '2017-02-07'

                                    def __init__(self):
                                        super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync.Peers, self).__init__()

                                        self.yang_name = "peers"
                                        self.yang_parent_name = "sync"

                                        self.is_chkpt_created = YLeaf(YType.empty, "is-chkpt-created")

                                        self.is_gr_enabled = YLeaf(YType.boolean, "is-gr-enabled")

                                        self.peer_id = YLeaf(YType.str, "peer-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("is_chkpt_created",
                                                        "is_gr_enabled",
                                                        "peer_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync.Peers, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync.Peers, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.is_chkpt_created.is_set or
                                            self.is_gr_enabled.is_set or
                                            self.peer_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.is_chkpt_created.yfilter != YFilter.not_set or
                                            self.is_gr_enabled.yfilter != YFilter.not_set or
                                            self.peer_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "peers" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.is_chkpt_created.is_set or self.is_chkpt_created.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_chkpt_created.get_name_leafdata())
                                        if (self.is_gr_enabled.is_set or self.is_gr_enabled.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_gr_enabled.get_name_leafdata())
                                        if (self.peer_id.is_set or self.peer_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.peer_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "is-chkpt-created" or name == "is-gr-enabled" or name == "peer-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "is-chkpt-created"):
                                            self.is_chkpt_created = value
                                            self.is_chkpt_created.value_namespace = name_space
                                            self.is_chkpt_created.value_namespace_prefix = name_space_prefix
                                        if(value_path == "is-gr-enabled"):
                                            self.is_gr_enabled = value
                                            self.is_gr_enabled.value_namespace = name_space
                                            self.is_gr_enabled.value_namespace_prefix = name_space_prefix
                                        if(value_path == "peer-id"):
                                            self.peer_id = value
                                            self.peer_id.value_namespace = name_space
                                            self.peer_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.peers:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.interface.is_set or
                                        self.delay_timer_remaining.is_set or
                                        self.igp_sync_down_reason.is_set or
                                        self.igp_sync_state.is_set or
                                        self.is_delay_timer_running.is_set)

                                def has_operation(self):
                                    for c in self.peers:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface.yfilter != YFilter.not_set or
                                        self.delay_timer_remaining.yfilter != YFilter.not_set or
                                        self.igp_sync_down_reason.yfilter != YFilter.not_set or
                                        self.igp_sync_state.yfilter != YFilter.not_set or
                                        self.is_delay_timer_running.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sync" + "[interface='" + self.interface.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface.get_name_leafdata())
                                    if (self.delay_timer_remaining.is_set or self.delay_timer_remaining.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.delay_timer_remaining.get_name_leafdata())
                                    if (self.igp_sync_down_reason.is_set or self.igp_sync_down_reason.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.igp_sync_down_reason.get_name_leafdata())
                                    if (self.igp_sync_state.is_set or self.igp_sync_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.igp_sync_state.get_name_leafdata())
                                    if (self.is_delay_timer_running.is_set or self.is_delay_timer_running.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_delay_timer_running.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "peers"):
                                        for c in self.peers:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync.Peers()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.peers.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "peers" or name == "interface" or name == "delay-timer-remaining" or name == "igp-sync-down-reason" or name == "igp-sync-state" or name == "is-delay-timer-running"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface"):
                                        self.interface = value
                                        self.interface.value_namespace = name_space
                                        self.interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "delay-timer-remaining"):
                                        self.delay_timer_remaining = value
                                        self.delay_timer_remaining.value_namespace = name_space
                                        self.delay_timer_remaining.value_namespace_prefix = name_space_prefix
                                    if(value_path == "igp-sync-down-reason"):
                                        self.igp_sync_down_reason = value
                                        self.igp_sync_down_reason.value_namespace = name_space
                                        self.igp_sync_down_reason.value_namespace_prefix = name_space_prefix
                                    if(value_path == "igp-sync-state"):
                                        self.igp_sync_state = value
                                        self.igp_sync_state.value_namespace = name_space
                                        self.igp_sync_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-delay-timer-running"):
                                        self.is_delay_timer_running = value
                                        self.is_delay_timer_running.value_namespace = name_space
                                        self.is_delay_timer_running.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sync:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.sync:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "igp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sync"):
                                    for c in self.sync:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp.Sync()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sync.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sync"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                (self.igp is not None and self.igp.has_data()) or
                                (self.interface_summary is not None and self.interface_summary.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                (self.igp is not None and self.igp.has_operation()) or
                                (self.interface_summary is not None and self.interface_summary.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "af" + "[af-name='" + self.af_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "igp"):
                                if (self.igp is None):
                                    self.igp = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.Igp()
                                    self.igp.parent = self
                                    self._children_name_map["igp"] = "igp"
                                return self.igp

                            if (child_yang_name == "interface-summary"):
                                if (self.interface_summary is None):
                                    self.interface_summary = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af.InterfaceSummary()
                                    self.interface_summary.parent = self
                                    self._children_name_map["interface_summary"] = "interface-summary"
                                return self.interface_summary

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "igp" or name == "interface-summary" or name == "af-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.af:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.af:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "afs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "af"):
                            for c in self.af:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs.Af()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.af.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "af"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.vrf_name.is_set or
                        (self.afs is not None and self.afs.has_data()) or
                        (self.vrf_summary is not None and self.vrf_summary.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set or
                        (self.afs is not None and self.afs.has_operation()) or
                        (self.vrf_summary is not None and self.vrf_summary.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "vrf" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/vrfs/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "afs"):
                        if (self.afs is None):
                            self.afs = MplsLdp.MplsLdpState.Vrfs.Vrf.Afs()
                            self.afs.parent = self
                            self._children_name_map["afs"] = "afs"
                        return self.afs

                    if (child_yang_name == "vrf-summary"):
                        if (self.vrf_summary is None):
                            self.vrf_summary = MplsLdp.MplsLdpState.Vrfs.Vrf.VrfSummary()
                            self.vrf_summary.parent = self
                            self._children_name_map["vrf_summary"] = "vrf-summary"
                        return self.vrf_summary

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "afs" or name == "vrf-summary" or name == "vrf-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.vrf:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.vrf:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "vrfs" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "vrf"):
                    for c in self.vrf:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Vrfs.Vrf()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.vrf.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "vrf"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Discovery(Entity):
            """
            The LDP Discovery operational state
            
            .. attribute:: discovery_stats
            
            	MPLS LDP Discovery Summary Information
            	**type**\:   :py:class:`DiscoveryStats <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Discovery.DiscoveryStats>`
            
            .. attribute:: link_hello_state
            
            	This container holds information for LDP Discovery using non\-targeted Hellos. These are interface\-based hellos which form one or more adjacencies for each interface and also form adjacencies on multiple intefrfaces. Link Hellos can therefore form multiple adjacencies with the same peer
            	**type**\:   :py:class:`LinkHelloState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Discovery.LinkHelloState>`
            
            .. attribute:: targeted_hellos
            
            	The LDP Discovery Targeted Hello state
            	**type**\:   :py:class:`TargetedHellos <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Discovery.TargetedHellos>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Discovery, self).__init__()

                self.yang_name = "discovery"
                self.yang_parent_name = "mpls-ldp-state"

                self.discovery_stats = MplsLdp.MplsLdpState.Discovery.DiscoveryStats()
                self.discovery_stats.parent = self
                self._children_name_map["discovery_stats"] = "discovery-stats"
                self._children_yang_names.add("discovery-stats")

                self.link_hello_state = MplsLdp.MplsLdpState.Discovery.LinkHelloState()
                self.link_hello_state.parent = self
                self._children_name_map["link_hello_state"] = "link-hello-state"
                self._children_yang_names.add("link-hello-state")

                self.targeted_hellos = MplsLdp.MplsLdpState.Discovery.TargetedHellos()
                self.targeted_hellos.parent = self
                self._children_name_map["targeted_hellos"] = "targeted-hellos"
                self._children_yang_names.add("targeted-hellos")


            class DiscoveryStats(Entity):
                """
                MPLS LDP Discovery Summary Information
                
                .. attribute:: num_of_active_ldp_interfaces
                
                	Number of active LDP enabled interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_of_ldp_interfaces
                
                	Total Number of LDP configured interfaces
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_of_lnk_disc_recv
                
                	Number of link hello discoveries in recv state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_of_lnk_disc_xmit
                
                	Number of link hello discoveries in xmit state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_of_tgt_disc_recv
                
                	Number of targeted hello discoveries in recv state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: num_of_tgt_disc_xmit
                
                	Number of targeted hello discoveries in xmit state
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Discovery.DiscoveryStats, self).__init__()

                    self.yang_name = "discovery-stats"
                    self.yang_parent_name = "discovery"

                    self.num_of_active_ldp_interfaces = YLeaf(YType.uint32, "num-of-active-ldp-interfaces")

                    self.num_of_ldp_interfaces = YLeaf(YType.uint32, "num-of-ldp-interfaces")

                    self.num_of_lnk_disc_recv = YLeaf(YType.uint32, "num-of-lnk-disc-recv")

                    self.num_of_lnk_disc_xmit = YLeaf(YType.uint32, "num-of-lnk-disc-xmit")

                    self.num_of_tgt_disc_recv = YLeaf(YType.uint32, "num-of-tgt-disc-recv")

                    self.num_of_tgt_disc_xmit = YLeaf(YType.uint32, "num-of-tgt-disc-xmit")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("num_of_active_ldp_interfaces",
                                    "num_of_ldp_interfaces",
                                    "num_of_lnk_disc_recv",
                                    "num_of_lnk_disc_xmit",
                                    "num_of_tgt_disc_recv",
                                    "num_of_tgt_disc_xmit") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Discovery.DiscoveryStats, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Discovery.DiscoveryStats, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.num_of_active_ldp_interfaces.is_set or
                        self.num_of_ldp_interfaces.is_set or
                        self.num_of_lnk_disc_recv.is_set or
                        self.num_of_lnk_disc_xmit.is_set or
                        self.num_of_tgt_disc_recv.is_set or
                        self.num_of_tgt_disc_xmit.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.num_of_active_ldp_interfaces.yfilter != YFilter.not_set or
                        self.num_of_ldp_interfaces.yfilter != YFilter.not_set or
                        self.num_of_lnk_disc_recv.yfilter != YFilter.not_set or
                        self.num_of_lnk_disc_xmit.yfilter != YFilter.not_set or
                        self.num_of_tgt_disc_recv.yfilter != YFilter.not_set or
                        self.num_of_tgt_disc_xmit.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "discovery-stats" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.num_of_active_ldp_interfaces.is_set or self.num_of_active_ldp_interfaces.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_of_active_ldp_interfaces.get_name_leafdata())
                    if (self.num_of_ldp_interfaces.is_set or self.num_of_ldp_interfaces.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_of_ldp_interfaces.get_name_leafdata())
                    if (self.num_of_lnk_disc_recv.is_set or self.num_of_lnk_disc_recv.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_of_lnk_disc_recv.get_name_leafdata())
                    if (self.num_of_lnk_disc_xmit.is_set or self.num_of_lnk_disc_xmit.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_of_lnk_disc_xmit.get_name_leafdata())
                    if (self.num_of_tgt_disc_recv.is_set or self.num_of_tgt_disc_recv.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_of_tgt_disc_recv.get_name_leafdata())
                    if (self.num_of_tgt_disc_xmit.is_set or self.num_of_tgt_disc_xmit.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.num_of_tgt_disc_xmit.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "num-of-active-ldp-interfaces" or name == "num-of-ldp-interfaces" or name == "num-of-lnk-disc-recv" or name == "num-of-lnk-disc-xmit" or name == "num-of-tgt-disc-recv" or name == "num-of-tgt-disc-xmit"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "num-of-active-ldp-interfaces"):
                        self.num_of_active_ldp_interfaces = value
                        self.num_of_active_ldp_interfaces.value_namespace = name_space
                        self.num_of_active_ldp_interfaces.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-of-ldp-interfaces"):
                        self.num_of_ldp_interfaces = value
                        self.num_of_ldp_interfaces.value_namespace = name_space
                        self.num_of_ldp_interfaces.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-of-lnk-disc-recv"):
                        self.num_of_lnk_disc_recv = value
                        self.num_of_lnk_disc_recv.value_namespace = name_space
                        self.num_of_lnk_disc_recv.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-of-lnk-disc-xmit"):
                        self.num_of_lnk_disc_xmit = value
                        self.num_of_lnk_disc_xmit.value_namespace = name_space
                        self.num_of_lnk_disc_xmit.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-of-tgt-disc-recv"):
                        self.num_of_tgt_disc_recv = value
                        self.num_of_tgt_disc_recv.value_namespace = name_space
                        self.num_of_tgt_disc_recv.value_namespace_prefix = name_space_prefix
                    if(value_path == "num-of-tgt-disc-xmit"):
                        self.num_of_tgt_disc_xmit = value
                        self.num_of_tgt_disc_xmit.value_namespace = name_space
                        self.num_of_tgt_disc_xmit.value_namespace_prefix = name_space_prefix


            class LinkHelloState(Entity):
                """
                This container holds information for LDP Discovery
                using non\-targeted Hellos. These are interface\-based
                hellos which form one or more adjacencies for each
                interface and also form adjacencies on multiple
                intefrfaces. Link Hellos can therefore form multiple
                adjacencies with the same peer.
                
                .. attribute:: link_hellos
                
                	Each entry represents a single LDP Hello Adjacency. An LDP Session can have one or more Hello Adjacencies
                	**type**\: list of    :py:class:`LinkHellos <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Discovery.LinkHelloState.LinkHellos>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Discovery.LinkHelloState, self).__init__()

                    self.yang_name = "link-hello-state"
                    self.yang_parent_name = "discovery"

                    self.link_hellos = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Discovery.LinkHelloState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Discovery.LinkHelloState, self).__setattr__(name, value)


                class LinkHellos(Entity):
                    """
                    Each entry represents a single LDP Hello Adjacency.
                    An LDP Session can have one or more Hello
                    Adjacencies.
                    
                    .. attribute:: interface  <key>
                    
                    	The Discovery Interface
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                    
                    .. attribute:: nbr_transport_addr  <key>
                    
                    	This is the MPLS LDP Hello Neighbor transport address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: hello_interval
                    
                    	Hello interval in seconds. This is the value used to send hello messages
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: seconds
                    
                    .. attribute:: hold_time_remaining
                    
                    	This is the MPLS LDP Hello Discovery expiry time in seconds. If the value of this object is 65535, this means that the hold time is infinite (i.e., wait forever).  Otherwise, the time remaining for this Hello Adjacency to receive its next Hello Message.  This interval will change when the 'next' Hello Message which corresponds to this Hello Adjacency is received unless it is infinite
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: seconds
                    
                    .. attribute:: local_src_addr
                    
                    	MPLS LDP Discovery Local source address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: local_transport_addr
                    
                    	MPLS LDP Discovery Local transport address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: nbr_hold_time
                    
                    	The Hello hold time which is negotiated between the Entity and the Peer.  The entity associated with this Hello Adjacency issues a proposed Hello Hold Time value in the EntityHelloHoldTimer object.  The peer also proposes a value and this object represents the negotiated value.  A value of 0 means the default, which is 15 seconds for Link Hellos and 45 seconds for Targeted Hellos. A value of 65535 indicates an infinite hold time
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: nbr_ldp_id
                    
                    	Neighbor LDP Identifier
                    	**type**\:  str
                    
                    .. attribute:: nbr_src_addr
                    
                    	This is the MPLS LDP Hello Neighbor source address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: next_hello
                    
                    	Next hello due time in milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: milliseconds
                    
                    .. attribute:: session_up
                    
                    	Set when the session is up for this adjacency
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Discovery.LinkHelloState.LinkHellos, self).__init__()

                        self.yang_name = "link-hellos"
                        self.yang_parent_name = "link-hello-state"

                        self.interface = YLeaf(YType.str, "interface")

                        self.nbr_transport_addr = YLeaf(YType.str, "nbr-transport-addr")

                        self.hello_interval = YLeaf(YType.uint32, "hello-interval")

                        self.hold_time_remaining = YLeaf(YType.uint32, "hold-time-remaining")

                        self.local_src_addr = YLeaf(YType.str, "local-src-addr")

                        self.local_transport_addr = YLeaf(YType.str, "local-transport-addr")

                        self.nbr_hold_time = YLeaf(YType.uint32, "nbr-hold-time")

                        self.nbr_ldp_id = YLeaf(YType.str, "nbr-ldp-id")

                        self.nbr_src_addr = YLeaf(YType.str, "nbr-src-addr")

                        self.next_hello = YLeaf(YType.uint32, "next-hello")

                        self.session_up = YLeaf(YType.empty, "session-up")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("interface",
                                        "nbr_transport_addr",
                                        "hello_interval",
                                        "hold_time_remaining",
                                        "local_src_addr",
                                        "local_transport_addr",
                                        "nbr_hold_time",
                                        "nbr_ldp_id",
                                        "nbr_src_addr",
                                        "next_hello",
                                        "session_up") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Discovery.LinkHelloState.LinkHellos, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Discovery.LinkHelloState.LinkHellos, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.interface.is_set or
                            self.nbr_transport_addr.is_set or
                            self.hello_interval.is_set or
                            self.hold_time_remaining.is_set or
                            self.local_src_addr.is_set or
                            self.local_transport_addr.is_set or
                            self.nbr_hold_time.is_set or
                            self.nbr_ldp_id.is_set or
                            self.nbr_src_addr.is_set or
                            self.next_hello.is_set or
                            self.session_up.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.nbr_transport_addr.yfilter != YFilter.not_set or
                            self.hello_interval.yfilter != YFilter.not_set or
                            self.hold_time_remaining.yfilter != YFilter.not_set or
                            self.local_src_addr.yfilter != YFilter.not_set or
                            self.local_transport_addr.yfilter != YFilter.not_set or
                            self.nbr_hold_time.yfilter != YFilter.not_set or
                            self.nbr_ldp_id.yfilter != YFilter.not_set or
                            self.nbr_src_addr.yfilter != YFilter.not_set or
                            self.next_hello.yfilter != YFilter.not_set or
                            self.session_up.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "link-hellos" + "[interface='" + self.interface.get() + "']" + "[nbr-transport-addr='" + self.nbr_transport_addr.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/discovery/link-hello-state/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.nbr_transport_addr.is_set or self.nbr_transport_addr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nbr_transport_addr.get_name_leafdata())
                        if (self.hello_interval.is_set or self.hello_interval.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hello_interval.get_name_leafdata())
                        if (self.hold_time_remaining.is_set or self.hold_time_remaining.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_time_remaining.get_name_leafdata())
                        if (self.local_src_addr.is_set or self.local_src_addr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_src_addr.get_name_leafdata())
                        if (self.local_transport_addr.is_set or self.local_transport_addr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_transport_addr.get_name_leafdata())
                        if (self.nbr_hold_time.is_set or self.nbr_hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nbr_hold_time.get_name_leafdata())
                        if (self.nbr_ldp_id.is_set or self.nbr_ldp_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nbr_ldp_id.get_name_leafdata())
                        if (self.nbr_src_addr.is_set or self.nbr_src_addr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nbr_src_addr.get_name_leafdata())
                        if (self.next_hello.is_set or self.next_hello.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hello.get_name_leafdata())
                        if (self.session_up.is_set or self.session_up.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_up.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interface" or name == "nbr-transport-addr" or name == "hello-interval" or name == "hold-time-remaining" or name == "local-src-addr" or name == "local-transport-addr" or name == "nbr-hold-time" or name == "nbr-ldp-id" or name == "nbr-src-addr" or name == "next-hello" or name == "session-up"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "nbr-transport-addr"):
                            self.nbr_transport_addr = value
                            self.nbr_transport_addr.value_namespace = name_space
                            self.nbr_transport_addr.value_namespace_prefix = name_space_prefix
                        if(value_path == "hello-interval"):
                            self.hello_interval = value
                            self.hello_interval.value_namespace = name_space
                            self.hello_interval.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-time-remaining"):
                            self.hold_time_remaining = value
                            self.hold_time_remaining.value_namespace = name_space
                            self.hold_time_remaining.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-src-addr"):
                            self.local_src_addr = value
                            self.local_src_addr.value_namespace = name_space
                            self.local_src_addr.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-transport-addr"):
                            self.local_transport_addr = value
                            self.local_transport_addr.value_namespace = name_space
                            self.local_transport_addr.value_namespace_prefix = name_space_prefix
                        if(value_path == "nbr-hold-time"):
                            self.nbr_hold_time = value
                            self.nbr_hold_time.value_namespace = name_space
                            self.nbr_hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "nbr-ldp-id"):
                            self.nbr_ldp_id = value
                            self.nbr_ldp_id.value_namespace = name_space
                            self.nbr_ldp_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "nbr-src-addr"):
                            self.nbr_src_addr = value
                            self.nbr_src_addr.value_namespace = name_space
                            self.nbr_src_addr.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hello"):
                            self.next_hello = value
                            self.next_hello.value_namespace = name_space
                            self.next_hello.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-up"):
                            self.session_up = value
                            self.session_up.value_namespace = name_space
                            self.session_up.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.link_hellos:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.link_hellos:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "link-hello-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "link-hellos"):
                        for c in self.link_hellos:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Discovery.LinkHelloState.LinkHellos()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.link_hellos.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "link-hellos"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class TargetedHellos(Entity):
                """
                The LDP Discovery Targeted Hello state.
                
                .. attribute:: targeted_hello
                
                	The LDP targeted discovery information for a specific target. Targetted discovery creates a single adjacency between two addresses and not indiviual adjacencies across physical interfaces
                	**type**\: list of    :py:class:`TargetedHello <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Discovery.TargetedHellos.TargetedHello>`
                
                .. attribute:: targeted_hello_hold_time
                
                	Local Targeted hold time in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                .. attribute:: targeted_hello_interval
                
                	Local Targeted Hello interval in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Discovery.TargetedHellos, self).__init__()

                    self.yang_name = "targeted-hellos"
                    self.yang_parent_name = "discovery"

                    self.targeted_hello_hold_time = YLeaf(YType.uint32, "targeted-hello-hold-time")

                    self.targeted_hello_interval = YLeaf(YType.uint32, "targeted-hello-interval")

                    self.targeted_hello = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("targeted_hello_hold_time",
                                    "targeted_hello_interval") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Discovery.TargetedHellos, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Discovery.TargetedHellos, self).__setattr__(name, value)


                class TargetedHello(Entity):
                    """
                    The LDP targeted discovery information for a specific
                    target. Targetted discovery creates a single adjacency
                    between two addresses and not indiviual adjacencies
                    across physical interfaces.
                    
                    .. attribute:: vrf_name  <key>
                    
                    	This contains the VRF Name, where 'default' is used for the default vrf
                    	**type**\:  str
                    
                    .. attribute:: target_address  <key>
                    
                    	The target IP Address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: hold_time_remaining
                    
                    	This is the MPLS LDP Hello Discovery expiry time in seconds. If the value of this object is 65535, this means that the hold time is infinite (i.e., wait forever).  Otherwise, the time remaining for this Hello Adjacency to receive its next Hello Message.  This interval will change when the 'next' Hello Message which corresponds to this Hello Adjacency is received unless it is infinite
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**units**\: seconds
                    
                    .. attribute:: local_address
                    
                    	Local IP Address
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: nbr_hold_time
                    
                    	The Hello hold time which is negotiated between the Entity and the Peer.  The entity associated with this Hello Adjacency issues a proposed Hello Hold Time value in the EntityHelloHoldTimer object.  The peer also proposes a value and this object represents the negotiated value.  A value of 0 means the default, which is 15 seconds for Link Hellos and 45 seconds for Targeted Hellos. A value of 65535 indicates an infinite hold time
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: neighbor_ldp_identifier
                    
                    	Neighbor LDP Identifier
                    	**type**\:  str
                    
                    .. attribute:: next_hello
                    
                    	Next hello due time in milliseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: milliseconds
                    
                    .. attribute:: state
                    
                    	This is the MPLS LDP Targeted Hello state
                    	**type**\:   :py:class:`DhcState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.DhcState>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Discovery.TargetedHellos.TargetedHello, self).__init__()

                        self.yang_name = "targeted-hello"
                        self.yang_parent_name = "targeted-hellos"

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.target_address = YLeaf(YType.str, "target-address")

                        self.hold_time_remaining = YLeaf(YType.uint32, "hold-time-remaining")

                        self.local_address = YLeaf(YType.str, "local-address")

                        self.nbr_hold_time = YLeaf(YType.uint32, "nbr-hold-time")

                        self.neighbor_ldp_identifier = YLeaf(YType.str, "neighbor-ldp-identifier")

                        self.next_hello = YLeaf(YType.uint32, "next-hello")

                        self.state = YLeaf(YType.enumeration, "state")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("vrf_name",
                                        "target_address",
                                        "hold_time_remaining",
                                        "local_address",
                                        "nbr_hold_time",
                                        "neighbor_ldp_identifier",
                                        "next_hello",
                                        "state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Discovery.TargetedHellos.TargetedHello, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Discovery.TargetedHellos.TargetedHello, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.vrf_name.is_set or
                            self.target_address.is_set or
                            self.hold_time_remaining.is_set or
                            self.local_address.is_set or
                            self.nbr_hold_time.is_set or
                            self.neighbor_ldp_identifier.is_set or
                            self.next_hello.is_set or
                            self.state.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            self.target_address.yfilter != YFilter.not_set or
                            self.hold_time_remaining.yfilter != YFilter.not_set or
                            self.local_address.yfilter != YFilter.not_set or
                            self.nbr_hold_time.yfilter != YFilter.not_set or
                            self.neighbor_ldp_identifier.yfilter != YFilter.not_set or
                            self.next_hello.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "targeted-hello" + "[vrf-name='" + self.vrf_name.get() + "']" + "[target-address='" + self.target_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/discovery/targeted-hellos/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())
                        if (self.target_address.is_set or self.target_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.target_address.get_name_leafdata())
                        if (self.hold_time_remaining.is_set or self.hold_time_remaining.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.hold_time_remaining.get_name_leafdata())
                        if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_address.get_name_leafdata())
                        if (self.nbr_hold_time.is_set or self.nbr_hold_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.nbr_hold_time.get_name_leafdata())
                        if (self.neighbor_ldp_identifier.is_set or self.neighbor_ldp_identifier.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.neighbor_ldp_identifier.get_name_leafdata())
                        if (self.next_hello.is_set or self.next_hello.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hello.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vrf-name" or name == "target-address" or name == "hold-time-remaining" or name == "local-address" or name == "nbr-hold-time" or name == "neighbor-ldp-identifier" or name == "next-hello" or name == "state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "target-address"):
                            self.target_address = value
                            self.target_address.value_namespace = name_space
                            self.target_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "hold-time-remaining"):
                            self.hold_time_remaining = value
                            self.hold_time_remaining.value_namespace = name_space
                            self.hold_time_remaining.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-address"):
                            self.local_address = value
                            self.local_address.value_namespace = name_space
                            self.local_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "nbr-hold-time"):
                            self.nbr_hold_time = value
                            self.nbr_hold_time.value_namespace = name_space
                            self.nbr_hold_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "neighbor-ldp-identifier"):
                            self.neighbor_ldp_identifier = value
                            self.neighbor_ldp_identifier.value_namespace = name_space
                            self.neighbor_ldp_identifier.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hello"):
                            self.next_hello = value
                            self.next_hello.value_namespace = name_space
                            self.next_hello.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.targeted_hello:
                        if (c.has_data()):
                            return True
                    return (
                        self.targeted_hello_hold_time.is_set or
                        self.targeted_hello_interval.is_set)

                def has_operation(self):
                    for c in self.targeted_hello:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.targeted_hello_hold_time.yfilter != YFilter.not_set or
                        self.targeted_hello_interval.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "targeted-hellos" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.targeted_hello_hold_time.is_set or self.targeted_hello_hold_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.targeted_hello_hold_time.get_name_leafdata())
                    if (self.targeted_hello_interval.is_set or self.targeted_hello_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.targeted_hello_interval.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "targeted-hello"):
                        for c in self.targeted_hello:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Discovery.TargetedHellos.TargetedHello()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.targeted_hello.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "targeted-hello" or name == "targeted-hello-hold-time" or name == "targeted-hello-interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "targeted-hello-hold-time"):
                        self.targeted_hello_hold_time = value
                        self.targeted_hello_hold_time.value_namespace = name_space
                        self.targeted_hello_hold_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "targeted-hello-interval"):
                        self.targeted_hello_interval = value
                        self.targeted_hello_interval.value_namespace = name_space
                        self.targeted_hello_interval.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.discovery_stats is not None and self.discovery_stats.has_data()) or
                    (self.link_hello_state is not None and self.link_hello_state.has_data()) or
                    (self.targeted_hellos is not None and self.targeted_hellos.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.discovery_stats is not None and self.discovery_stats.has_operation()) or
                    (self.link_hello_state is not None and self.link_hello_state.has_operation()) or
                    (self.targeted_hellos is not None and self.targeted_hellos.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "discovery" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "discovery-stats"):
                    if (self.discovery_stats is None):
                        self.discovery_stats = MplsLdp.MplsLdpState.Discovery.DiscoveryStats()
                        self.discovery_stats.parent = self
                        self._children_name_map["discovery_stats"] = "discovery-stats"
                    return self.discovery_stats

                if (child_yang_name == "link-hello-state"):
                    if (self.link_hello_state is None):
                        self.link_hello_state = MplsLdp.MplsLdpState.Discovery.LinkHelloState()
                        self.link_hello_state.parent = self
                        self._children_name_map["link_hello_state"] = "link-hello-state"
                    return self.link_hello_state

                if (child_yang_name == "targeted-hellos"):
                    if (self.targeted_hellos is None):
                        self.targeted_hellos = MplsLdp.MplsLdpState.Discovery.TargetedHellos()
                        self.targeted_hellos.parent = self
                        self._children_name_map["targeted_hellos"] = "targeted-hellos"
                    return self.targeted_hellos

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "discovery-stats" or name == "link-hello-state" or name == "targeted-hellos"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Forwarding(Entity):
            """
            Summary information regarding LDP forwarding
            setup and detailed LDP Forwarding rewrites
            
            .. attribute:: forwarding_detail
            
            	This leaf contain the individual LDP forwarding rewrite for a single prefix
            	**type**\: list of    :py:class:`ForwardingDetail <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail>`
            
            .. attribute:: forwarding_vrf_summs
            
            	Summary of forwarding info for this VRF
            	**type**\:   :py:class:`ForwardingVrfSumms <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Forwarding, self).__init__()

                self.yang_name = "forwarding"
                self.yang_parent_name = "mpls-ldp-state"

                self.forwarding_vrf_summs = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms()
                self.forwarding_vrf_summs.parent = self
                self._children_name_map["forwarding_vrf_summs"] = "forwarding-vrf-summs"
                self._children_yang_names.add("forwarding-vrf-summs")

                self.forwarding_detail = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.Forwarding, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.Forwarding, self).__setattr__(name, value)


            class ForwardingVrfSumms(Entity):
                """
                Summary of forwarding info for this VRF.
                
                .. attribute:: forwarding_vrf_summ
                
                	Summary of forwarding info for this VRF
                	**type**\: list of    :py:class:`ForwardingVrfSumm <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms, self).__init__()

                    self.yang_name = "forwarding-vrf-summs"
                    self.yang_parent_name = "forwarding"

                    self.forwarding_vrf_summ = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms, self).__setattr__(name, value)


                class ForwardingVrfSumm(Entity):
                    """
                    Summary of forwarding info for this VRF.
                    
                    .. attribute:: vrf_name  <key>
                    
                    	This contains the VRF Name, where 'default' is used for the default vrf
                    	**type**\:  str
                    
                    .. attribute:: intfs_fwd_count
                    
                    	MPLS forwarding enabled interface count
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: local_lbls
                    
                    	Local label allocated count
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: nhs
                    
                    	MPLS LDP forwarding rewrite next\-hop/path summary
                    	**type**\:   :py:class:`Nhs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Nhs>`
                    
                    .. attribute:: pfxs
                    
                    	MPLS LDP forwarding prefix rewrite summary
                    	**type**\:   :py:class:`Pfxs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm, self).__init__()

                        self.yang_name = "forwarding-vrf-summ"
                        self.yang_parent_name = "forwarding-vrf-summs"

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.intfs_fwd_count = YLeaf(YType.uint16, "intfs-fwd-count")

                        self.local_lbls = YLeaf(YType.uint16, "local-lbls")

                        self.nhs = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Nhs()
                        self.nhs.parent = self
                        self._children_name_map["nhs"] = "nhs"
                        self._children_yang_names.add("nhs")

                        self.pfxs = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs()
                        self.pfxs.parent = self
                        self._children_name_map["pfxs"] = "pfxs"
                        self._children_yang_names.add("pfxs")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("vrf_name",
                                        "intfs_fwd_count",
                                        "local_lbls") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm, self).__setattr__(name, value)


                    class Pfxs(Entity):
                        """
                        MPLS LDP forwarding prefix rewrite summary
                        
                        .. attribute:: ecmp_pfxs
                        
                        	Count of prefixes with ECMP
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: labeled_pfxs_aggr
                        
                        	Labeled prefix count for all paths
                        	**type**\:   :py:class:`LabeledPfxsAggr <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsAggr>`
                        
                        .. attribute:: labeled_pfxs_backup
                        
                        	Labeled prefix count related to backup paths only
                        	**type**\:   :py:class:`LabeledPfxsBackup <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsBackup>`
                        
                        .. attribute:: labeled_pfxs_primary
                        
                        	Labeled prefix count related to primary paths only
                        	**type**\:   :py:class:`LabeledPfxsPrimary <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsPrimary>`
                        
                        .. attribute:: protected_pfxs
                        
                        	Count of FRR protected prefixes
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: total_pfxs
                        
                        	Total Prefix count
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs, self).__init__()

                            self.yang_name = "pfxs"
                            self.yang_parent_name = "forwarding-vrf-summ"

                            self.ecmp_pfxs = YLeaf(YType.uint16, "ecmp-pfxs")

                            self.protected_pfxs = YLeaf(YType.uint16, "protected-pfxs")

                            self.total_pfxs = YLeaf(YType.uint16, "total-pfxs")

                            self.labeled_pfxs_aggr = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsAggr()
                            self.labeled_pfxs_aggr.parent = self
                            self._children_name_map["labeled_pfxs_aggr"] = "labeled-pfxs-aggr"
                            self._children_yang_names.add("labeled-pfxs-aggr")

                            self.labeled_pfxs_backup = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsBackup()
                            self.labeled_pfxs_backup.parent = self
                            self._children_name_map["labeled_pfxs_backup"] = "labeled-pfxs-backup"
                            self._children_yang_names.add("labeled-pfxs-backup")

                            self.labeled_pfxs_primary = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsPrimary()
                            self.labeled_pfxs_primary.parent = self
                            self._children_name_map["labeled_pfxs_primary"] = "labeled-pfxs-primary"
                            self._children_yang_names.add("labeled-pfxs-primary")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("ecmp_pfxs",
                                            "protected_pfxs",
                                            "total_pfxs") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs, self).__setattr__(name, value)


                        class LabeledPfxsAggr(Entity):
                            """
                            Labeled prefix count for all paths
                            
                            .. attribute:: labeled_pfxs
                            
                            	Count of labeled prefixes with 1 or more paths labeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: labeled_pfxs_partial
                            
                            	Count of labeled prefixes with some (but not ALL) paths labeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: unlabeled_pfxs
                            
                            	Count of labeled prefixes with ALL paths unlabeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsAggr, self).__init__()

                                self.yang_name = "labeled-pfxs-aggr"
                                self.yang_parent_name = "pfxs"

                                self.labeled_pfxs = YLeaf(YType.uint16, "labeled-pfxs")

                                self.labeled_pfxs_partial = YLeaf(YType.uint16, "labeled-pfxs-partial")

                                self.unlabeled_pfxs = YLeaf(YType.uint16, "unlabeled-pfxs")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("labeled_pfxs",
                                                "labeled_pfxs_partial",
                                                "unlabeled_pfxs") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsAggr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsAggr, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.labeled_pfxs.is_set or
                                    self.labeled_pfxs_partial.is_set or
                                    self.unlabeled_pfxs.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.labeled_pfxs.yfilter != YFilter.not_set or
                                    self.labeled_pfxs_partial.yfilter != YFilter.not_set or
                                    self.unlabeled_pfxs.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "labeled-pfxs-aggr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.labeled_pfxs.is_set or self.labeled_pfxs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.labeled_pfxs.get_name_leafdata())
                                if (self.labeled_pfxs_partial.is_set or self.labeled_pfxs_partial.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.labeled_pfxs_partial.get_name_leafdata())
                                if (self.unlabeled_pfxs.is_set or self.unlabeled_pfxs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unlabeled_pfxs.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "labeled-pfxs" or name == "labeled-pfxs-partial" or name == "unlabeled-pfxs"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "labeled-pfxs"):
                                    self.labeled_pfxs = value
                                    self.labeled_pfxs.value_namespace = name_space
                                    self.labeled_pfxs.value_namespace_prefix = name_space_prefix
                                if(value_path == "labeled-pfxs-partial"):
                                    self.labeled_pfxs_partial = value
                                    self.labeled_pfxs_partial.value_namespace = name_space
                                    self.labeled_pfxs_partial.value_namespace_prefix = name_space_prefix
                                if(value_path == "unlabeled-pfxs"):
                                    self.unlabeled_pfxs = value
                                    self.unlabeled_pfxs.value_namespace = name_space
                                    self.unlabeled_pfxs.value_namespace_prefix = name_space_prefix


                        class LabeledPfxsPrimary(Entity):
                            """
                            Labeled prefix count related to primary paths
                            only
                            
                            .. attribute:: labeled_pfxs
                            
                            	Count of labeled prefixes with 1 or more paths labeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: labeled_pfxs_partial
                            
                            	Count of labeled prefixes with some (but not ALL) paths labeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: unlabeled_pfxs
                            
                            	Count of labeled prefixes with ALL paths unlabeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsPrimary, self).__init__()

                                self.yang_name = "labeled-pfxs-primary"
                                self.yang_parent_name = "pfxs"

                                self.labeled_pfxs = YLeaf(YType.uint16, "labeled-pfxs")

                                self.labeled_pfxs_partial = YLeaf(YType.uint16, "labeled-pfxs-partial")

                                self.unlabeled_pfxs = YLeaf(YType.uint16, "unlabeled-pfxs")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("labeled_pfxs",
                                                "labeled_pfxs_partial",
                                                "unlabeled_pfxs") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsPrimary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsPrimary, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.labeled_pfxs.is_set or
                                    self.labeled_pfxs_partial.is_set or
                                    self.unlabeled_pfxs.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.labeled_pfxs.yfilter != YFilter.not_set or
                                    self.labeled_pfxs_partial.yfilter != YFilter.not_set or
                                    self.unlabeled_pfxs.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "labeled-pfxs-primary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.labeled_pfxs.is_set or self.labeled_pfxs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.labeled_pfxs.get_name_leafdata())
                                if (self.labeled_pfxs_partial.is_set or self.labeled_pfxs_partial.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.labeled_pfxs_partial.get_name_leafdata())
                                if (self.unlabeled_pfxs.is_set or self.unlabeled_pfxs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unlabeled_pfxs.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "labeled-pfxs" or name == "labeled-pfxs-partial" or name == "unlabeled-pfxs"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "labeled-pfxs"):
                                    self.labeled_pfxs = value
                                    self.labeled_pfxs.value_namespace = name_space
                                    self.labeled_pfxs.value_namespace_prefix = name_space_prefix
                                if(value_path == "labeled-pfxs-partial"):
                                    self.labeled_pfxs_partial = value
                                    self.labeled_pfxs_partial.value_namespace = name_space
                                    self.labeled_pfxs_partial.value_namespace_prefix = name_space_prefix
                                if(value_path == "unlabeled-pfxs"):
                                    self.unlabeled_pfxs = value
                                    self.unlabeled_pfxs.value_namespace = name_space
                                    self.unlabeled_pfxs.value_namespace_prefix = name_space_prefix


                        class LabeledPfxsBackup(Entity):
                            """
                            Labeled prefix count related to backup paths
                            only
                            
                            .. attribute:: labeled_pfxs
                            
                            	Count of labeled prefixes with 1 or more paths labeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: labeled_pfxs_partial
                            
                            	Count of labeled prefixes with some (but not ALL) paths labeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: unlabeled_pfxs
                            
                            	Count of labeled prefixes with ALL paths unlabeled
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsBackup, self).__init__()

                                self.yang_name = "labeled-pfxs-backup"
                                self.yang_parent_name = "pfxs"

                                self.labeled_pfxs = YLeaf(YType.uint16, "labeled-pfxs")

                                self.labeled_pfxs_partial = YLeaf(YType.uint16, "labeled-pfxs-partial")

                                self.unlabeled_pfxs = YLeaf(YType.uint16, "unlabeled-pfxs")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("labeled_pfxs",
                                                "labeled_pfxs_partial",
                                                "unlabeled_pfxs") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsBackup, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsBackup, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.labeled_pfxs.is_set or
                                    self.labeled_pfxs_partial.is_set or
                                    self.unlabeled_pfxs.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.labeled_pfxs.yfilter != YFilter.not_set or
                                    self.labeled_pfxs_partial.yfilter != YFilter.not_set or
                                    self.unlabeled_pfxs.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "labeled-pfxs-backup" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.labeled_pfxs.is_set or self.labeled_pfxs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.labeled_pfxs.get_name_leafdata())
                                if (self.labeled_pfxs_partial.is_set or self.labeled_pfxs_partial.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.labeled_pfxs_partial.get_name_leafdata())
                                if (self.unlabeled_pfxs.is_set or self.unlabeled_pfxs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unlabeled_pfxs.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "labeled-pfxs" or name == "labeled-pfxs-partial" or name == "unlabeled-pfxs"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "labeled-pfxs"):
                                    self.labeled_pfxs = value
                                    self.labeled_pfxs.value_namespace = name_space
                                    self.labeled_pfxs.value_namespace_prefix = name_space_prefix
                                if(value_path == "labeled-pfxs-partial"):
                                    self.labeled_pfxs_partial = value
                                    self.labeled_pfxs_partial.value_namespace = name_space
                                    self.labeled_pfxs_partial.value_namespace_prefix = name_space_prefix
                                if(value_path == "unlabeled-pfxs"):
                                    self.unlabeled_pfxs = value
                                    self.unlabeled_pfxs.value_namespace = name_space
                                    self.unlabeled_pfxs.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.ecmp_pfxs.is_set or
                                self.protected_pfxs.is_set or
                                self.total_pfxs.is_set or
                                (self.labeled_pfxs_aggr is not None and self.labeled_pfxs_aggr.has_data()) or
                                (self.labeled_pfxs_backup is not None and self.labeled_pfxs_backup.has_data()) or
                                (self.labeled_pfxs_primary is not None and self.labeled_pfxs_primary.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.ecmp_pfxs.yfilter != YFilter.not_set or
                                self.protected_pfxs.yfilter != YFilter.not_set or
                                self.total_pfxs.yfilter != YFilter.not_set or
                                (self.labeled_pfxs_aggr is not None and self.labeled_pfxs_aggr.has_operation()) or
                                (self.labeled_pfxs_backup is not None and self.labeled_pfxs_backup.has_operation()) or
                                (self.labeled_pfxs_primary is not None and self.labeled_pfxs_primary.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "pfxs" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.ecmp_pfxs.is_set or self.ecmp_pfxs.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ecmp_pfxs.get_name_leafdata())
                            if (self.protected_pfxs.is_set or self.protected_pfxs.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protected_pfxs.get_name_leafdata())
                            if (self.total_pfxs.is_set or self.total_pfxs.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_pfxs.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "labeled-pfxs-aggr"):
                                if (self.labeled_pfxs_aggr is None):
                                    self.labeled_pfxs_aggr = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsAggr()
                                    self.labeled_pfxs_aggr.parent = self
                                    self._children_name_map["labeled_pfxs_aggr"] = "labeled-pfxs-aggr"
                                return self.labeled_pfxs_aggr

                            if (child_yang_name == "labeled-pfxs-backup"):
                                if (self.labeled_pfxs_backup is None):
                                    self.labeled_pfxs_backup = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsBackup()
                                    self.labeled_pfxs_backup.parent = self
                                    self._children_name_map["labeled_pfxs_backup"] = "labeled-pfxs-backup"
                                return self.labeled_pfxs_backup

                            if (child_yang_name == "labeled-pfxs-primary"):
                                if (self.labeled_pfxs_primary is None):
                                    self.labeled_pfxs_primary = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs.LabeledPfxsPrimary()
                                    self.labeled_pfxs_primary.parent = self
                                    self._children_name_map["labeled_pfxs_primary"] = "labeled-pfxs-primary"
                                return self.labeled_pfxs_primary

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "labeled-pfxs-aggr" or name == "labeled-pfxs-backup" or name == "labeled-pfxs-primary" or name == "ecmp-pfxs" or name == "protected-pfxs" or name == "total-pfxs"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "ecmp-pfxs"):
                                self.ecmp_pfxs = value
                                self.ecmp_pfxs.value_namespace = name_space
                                self.ecmp_pfxs.value_namespace_prefix = name_space_prefix
                            if(value_path == "protected-pfxs"):
                                self.protected_pfxs = value
                                self.protected_pfxs.value_namespace = name_space
                                self.protected_pfxs.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-pfxs"):
                                self.total_pfxs = value
                                self.total_pfxs.value_namespace = name_space
                                self.total_pfxs.value_namespace_prefix = name_space_prefix


                    class Nhs(Entity):
                        """
                        MPLS LDP forwarding rewrite next\-hop/path summary
                        
                        .. attribute:: backup_paths
                        
                        	Count of non\-primary backup paths
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: labeled_backup_paths
                        
                        	Count of labeled backup paths
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: labeled_paths
                        
                        	Count of all labeled paths
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: protected_paths
                        
                        	Count of FRR protected paths
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_backup_paths
                        
                        	Count of non\-primary remote backup paths
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_paths
                        
                        	Total path count
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Nhs, self).__init__()

                            self.yang_name = "nhs"
                            self.yang_parent_name = "forwarding-vrf-summ"

                            self.backup_paths = YLeaf(YType.uint32, "backup-paths")

                            self.labeled_backup_paths = YLeaf(YType.uint32, "labeled-backup-paths")

                            self.labeled_paths = YLeaf(YType.uint32, "labeled-paths")

                            self.protected_paths = YLeaf(YType.uint32, "protected-paths")

                            self.remote_backup_paths = YLeaf(YType.uint32, "remote-backup-paths")

                            self.total_paths = YLeaf(YType.uint32, "total-paths")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("backup_paths",
                                            "labeled_backup_paths",
                                            "labeled_paths",
                                            "protected_paths",
                                            "remote_backup_paths",
                                            "total_paths") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Nhs, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Nhs, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.backup_paths.is_set or
                                self.labeled_backup_paths.is_set or
                                self.labeled_paths.is_set or
                                self.protected_paths.is_set or
                                self.remote_backup_paths.is_set or
                                self.total_paths.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.backup_paths.yfilter != YFilter.not_set or
                                self.labeled_backup_paths.yfilter != YFilter.not_set or
                                self.labeled_paths.yfilter != YFilter.not_set or
                                self.protected_paths.yfilter != YFilter.not_set or
                                self.remote_backup_paths.yfilter != YFilter.not_set or
                                self.total_paths.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "nhs" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.backup_paths.is_set or self.backup_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.backup_paths.get_name_leafdata())
                            if (self.labeled_backup_paths.is_set or self.labeled_backup_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.labeled_backup_paths.get_name_leafdata())
                            if (self.labeled_paths.is_set or self.labeled_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.labeled_paths.get_name_leafdata())
                            if (self.protected_paths.is_set or self.protected_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protected_paths.get_name_leafdata())
                            if (self.remote_backup_paths.is_set or self.remote_backup_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_backup_paths.get_name_leafdata())
                            if (self.total_paths.is_set or self.total_paths.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_paths.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "backup-paths" or name == "labeled-backup-paths" or name == "labeled-paths" or name == "protected-paths" or name == "remote-backup-paths" or name == "total-paths"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "backup-paths"):
                                self.backup_paths = value
                                self.backup_paths.value_namespace = name_space
                                self.backup_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "labeled-backup-paths"):
                                self.labeled_backup_paths = value
                                self.labeled_backup_paths.value_namespace = name_space
                                self.labeled_backup_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "labeled-paths"):
                                self.labeled_paths = value
                                self.labeled_paths.value_namespace = name_space
                                self.labeled_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "protected-paths"):
                                self.protected_paths = value
                                self.protected_paths.value_namespace = name_space
                                self.protected_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-backup-paths"):
                                self.remote_backup_paths = value
                                self.remote_backup_paths.value_namespace = name_space
                                self.remote_backup_paths.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-paths"):
                                self.total_paths = value
                                self.total_paths.value_namespace = name_space
                                self.total_paths.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.vrf_name.is_set or
                            self.intfs_fwd_count.is_set or
                            self.local_lbls.is_set or
                            (self.nhs is not None and self.nhs.has_data()) or
                            (self.pfxs is not None and self.pfxs.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            self.intfs_fwd_count.yfilter != YFilter.not_set or
                            self.local_lbls.yfilter != YFilter.not_set or
                            (self.nhs is not None and self.nhs.has_operation()) or
                            (self.pfxs is not None and self.pfxs.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "forwarding-vrf-summ" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding/forwarding-vrf-summs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())
                        if (self.intfs_fwd_count.is_set or self.intfs_fwd_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.intfs_fwd_count.get_name_leafdata())
                        if (self.local_lbls.is_set or self.local_lbls.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_lbls.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "nhs"):
                            if (self.nhs is None):
                                self.nhs = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Nhs()
                                self.nhs.parent = self
                                self._children_name_map["nhs"] = "nhs"
                            return self.nhs

                        if (child_yang_name == "pfxs"):
                            if (self.pfxs is None):
                                self.pfxs = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm.Pfxs()
                                self.pfxs.parent = self
                                self._children_name_map["pfxs"] = "pfxs"
                            return self.pfxs

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "nhs" or name == "pfxs" or name == "vrf-name" or name == "intfs-fwd-count" or name == "local-lbls"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "intfs-fwd-count"):
                            self.intfs_fwd_count = value
                            self.intfs_fwd_count.value_namespace = name_space
                            self.intfs_fwd_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-lbls"):
                            self.local_lbls = value
                            self.local_lbls.value_namespace = name_space
                            self.local_lbls.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.forwarding_vrf_summ:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.forwarding_vrf_summ:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "forwarding-vrf-summs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "forwarding-vrf-summ"):
                        for c in self.forwarding_vrf_summ:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms.ForwardingVrfSumm()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.forwarding_vrf_summ.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "forwarding-vrf-summ"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class ForwardingDetail(Entity):
                """
                This leaf contain the individual LDP forwarding rewrite
                for a single prefix.
                
                .. attribute:: vrf_name  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: prefix  <key>
                
                	The IP Prefix
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                
                
                ----
                .. attribute:: fwd_prefix
                
                	This is the MPLS LDP Forward IP Prefix
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: paths
                
                	MPLS LDP Forwarding Path info
                	**type**\: list of    :py:class:`Paths <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths>`
                
                .. attribute:: prefix_length
                
                	Prefix length
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: route
                
                	MPLS LDP Forwarding Route information
                	**type**\:   :py:class:`Route <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Route>`
                
                .. attribute:: table_id
                
                	Table ID associated with IP prefix
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail, self).__init__()

                    self.yang_name = "forwarding-detail"
                    self.yang_parent_name = "forwarding"

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                    self.prefix = YLeaf(YType.str, "prefix")

                    self.fwd_prefix = YLeaf(YType.str, "fwd-prefix")

                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                    self.table_id = YLeaf(YType.uint32, "table-id")

                    self.route = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Route()
                    self.route.parent = self
                    self._children_name_map["route"] = "route"
                    self._children_yang_names.add("route")

                    self.paths = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf_name",
                                    "prefix",
                                    "fwd_prefix",
                                    "prefix_length",
                                    "table_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail, self).__setattr__(name, value)


                class Route(Entity):
                    """
                    MPLS LDP Forwarding Route information
                    
                    .. attribute:: forwarding_update_age
                    
                    	Last Forwarding update nanosec age
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: nanoseconds
                    
                    .. attribute:: forwarding_update_count
                    
                    	Number of forwarding updates
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: forwarding_update_timestamp
                    
                    	Last Forwarding update nanosec timestamp
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: nanoseconds
                    
                    .. attribute:: is_local_vrf_leaked
                    
                    	Is this route leaked across local VRFs?
                    	**type**\:  bool
                    
                    .. attribute:: local_label
                    
                    	Local label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: metric
                    
                    	Route metric
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: priority
                    
                    	Route priority
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    .. attribute:: routing_update_age
                    
                    	Last Routing update nanosec age
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: nanoseconds
                    
                    .. attribute:: routing_update_count
                    
                    	Number of routing updates
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: routing_update_timestamp
                    
                    	Last Routing update nanosec timestamp
                    	**type**\:  int
                    
                    	**range:** 0..18446744073709551615
                    
                    	**units**\: nanoseconds
                    
                    .. attribute:: source
                    
                    	Route source protocol Id
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: type
                    
                    	Route type
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: version
                    
                    	Route RIB version
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Route, self).__init__()

                        self.yang_name = "route"
                        self.yang_parent_name = "forwarding-detail"

                        self.forwarding_update_age = YLeaf(YType.uint64, "forwarding-update-age")

                        self.forwarding_update_count = YLeaf(YType.uint32, "forwarding-update-count")

                        self.forwarding_update_timestamp = YLeaf(YType.uint64, "forwarding-update-timestamp")

                        self.is_local_vrf_leaked = YLeaf(YType.boolean, "is-local-vrf-leaked")

                        self.local_label = YLeaf(YType.uint32, "local-label")

                        self.metric = YLeaf(YType.uint32, "metric")

                        self.priority = YLeaf(YType.uint8, "priority")

                        self.routing_update_age = YLeaf(YType.uint64, "routing-update-age")

                        self.routing_update_count = YLeaf(YType.uint32, "routing-update-count")

                        self.routing_update_timestamp = YLeaf(YType.uint64, "routing-update-timestamp")

                        self.source = YLeaf(YType.uint16, "source")

                        self.type = YLeaf(YType.uint16, "type")

                        self.version = YLeaf(YType.uint32, "version")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("forwarding_update_age",
                                        "forwarding_update_count",
                                        "forwarding_update_timestamp",
                                        "is_local_vrf_leaked",
                                        "local_label",
                                        "metric",
                                        "priority",
                                        "routing_update_age",
                                        "routing_update_count",
                                        "routing_update_timestamp",
                                        "source",
                                        "type",
                                        "version") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Route, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Route, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.forwarding_update_age.is_set or
                            self.forwarding_update_count.is_set or
                            self.forwarding_update_timestamp.is_set or
                            self.is_local_vrf_leaked.is_set or
                            self.local_label.is_set or
                            self.metric.is_set or
                            self.priority.is_set or
                            self.routing_update_age.is_set or
                            self.routing_update_count.is_set or
                            self.routing_update_timestamp.is_set or
                            self.source.is_set or
                            self.type.is_set or
                            self.version.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.forwarding_update_age.yfilter != YFilter.not_set or
                            self.forwarding_update_count.yfilter != YFilter.not_set or
                            self.forwarding_update_timestamp.yfilter != YFilter.not_set or
                            self.is_local_vrf_leaked.yfilter != YFilter.not_set or
                            self.local_label.yfilter != YFilter.not_set or
                            self.metric.yfilter != YFilter.not_set or
                            self.priority.yfilter != YFilter.not_set or
                            self.routing_update_age.yfilter != YFilter.not_set or
                            self.routing_update_count.yfilter != YFilter.not_set or
                            self.routing_update_timestamp.yfilter != YFilter.not_set or
                            self.source.yfilter != YFilter.not_set or
                            self.type.yfilter != YFilter.not_set or
                            self.version.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "route" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.forwarding_update_age.is_set or self.forwarding_update_age.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forwarding_update_age.get_name_leafdata())
                        if (self.forwarding_update_count.is_set or self.forwarding_update_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forwarding_update_count.get_name_leafdata())
                        if (self.forwarding_update_timestamp.is_set or self.forwarding_update_timestamp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forwarding_update_timestamp.get_name_leafdata())
                        if (self.is_local_vrf_leaked.is_set or self.is_local_vrf_leaked.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_local_vrf_leaked.get_name_leafdata())
                        if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_label.get_name_leafdata())
                        if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.metric.get_name_leafdata())
                        if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.priority.get_name_leafdata())
                        if (self.routing_update_age.is_set or self.routing_update_age.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.routing_update_age.get_name_leafdata())
                        if (self.routing_update_count.is_set or self.routing_update_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.routing_update_count.get_name_leafdata())
                        if (self.routing_update_timestamp.is_set or self.routing_update_timestamp.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.routing_update_timestamp.get_name_leafdata())
                        if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.source.get_name_leafdata())
                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.type.get_name_leafdata())
                        if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.version.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "forwarding-update-age" or name == "forwarding-update-count" or name == "forwarding-update-timestamp" or name == "is-local-vrf-leaked" or name == "local-label" or name == "metric" or name == "priority" or name == "routing-update-age" or name == "routing-update-count" or name == "routing-update-timestamp" or name == "source" or name == "type" or name == "version"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "forwarding-update-age"):
                            self.forwarding_update_age = value
                            self.forwarding_update_age.value_namespace = name_space
                            self.forwarding_update_age.value_namespace_prefix = name_space_prefix
                        if(value_path == "forwarding-update-count"):
                            self.forwarding_update_count = value
                            self.forwarding_update_count.value_namespace = name_space
                            self.forwarding_update_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "forwarding-update-timestamp"):
                            self.forwarding_update_timestamp = value
                            self.forwarding_update_timestamp.value_namespace = name_space
                            self.forwarding_update_timestamp.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-local-vrf-leaked"):
                            self.is_local_vrf_leaked = value
                            self.is_local_vrf_leaked.value_namespace = name_space
                            self.is_local_vrf_leaked.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-label"):
                            self.local_label = value
                            self.local_label.value_namespace = name_space
                            self.local_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "metric"):
                            self.metric = value
                            self.metric.value_namespace = name_space
                            self.metric.value_namespace_prefix = name_space_prefix
                        if(value_path == "priority"):
                            self.priority = value
                            self.priority.value_namespace = name_space
                            self.priority.value_namespace_prefix = name_space_prefix
                        if(value_path == "routing-update-age"):
                            self.routing_update_age = value
                            self.routing_update_age.value_namespace = name_space
                            self.routing_update_age.value_namespace_prefix = name_space_prefix
                        if(value_path == "routing-update-count"):
                            self.routing_update_count = value
                            self.routing_update_count.value_namespace = name_space
                            self.routing_update_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "routing-update-timestamp"):
                            self.routing_update_timestamp = value
                            self.routing_update_timestamp.value_namespace = name_space
                            self.routing_update_timestamp.value_namespace_prefix = name_space_prefix
                        if(value_path == "source"):
                            self.source = value
                            self.source.value_namespace = name_space
                            self.source.value_namespace_prefix = name_space_prefix
                        if(value_path == "type"):
                            self.type = value
                            self.type.value_namespace = name_space
                            self.type.value_namespace_prefix = name_space_prefix
                        if(value_path == "version"):
                            self.version = value
                            self.version.value_namespace = name_space
                            self.version.value_namespace_prefix = name_space_prefix


                class Paths(Entity):
                    """
                    MPLS LDP Forwarding Path info
                    
                    .. attribute:: mpls
                    
                    	MPLS LDP Forwarding Path MPLS information
                    	**type**\:   :py:class:`Mpls <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls>`
                    
                    .. attribute:: routing
                    
                    	MPLS LDP Forwarding Path IP Routing information
                    	**type**\:   :py:class:`Routing <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Routing>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths, self).__init__()

                        self.yang_name = "paths"
                        self.yang_parent_name = "forwarding-detail"

                        self.mpls = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls()
                        self.mpls.parent = self
                        self._children_name_map["mpls"] = "mpls"
                        self._children_yang_names.add("mpls")

                        self.routing = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Routing()
                        self.routing.parent = self
                        self._children_name_map["routing"] = "routing"
                        self._children_yang_names.add("routing")


                    class Routing(Entity):
                        """
                        MPLS LDP Forwarding Path IP Routing information
                        
                        .. attribute:: bkup_path_id
                        
                        	Backup path Id
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: has_remote_lfa_bkup
                        
                        	This is true if the path has a remote LFA backup
                        	**type**\:  bool
                        
                        .. attribute:: interface
                        
                        	This is the interface
                        	**type**\:  str
                        
                        	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                        
                        .. attribute:: load_metric
                        
                        	Path's load metric for load balancing
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: next_hop
                        
                        	This is the Next Hop address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        .. attribute:: next_hop_table_id
                        
                        	Table ID for nexthop address
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: nexthop_id
                        
                        	Nexthop Identifier
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: nh_is_overriden
                        
                        	This is set when the nexthop is overriden by LDP
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: path_id
                        
                        	path Id
                        	**type**\:  int
                        
                        	**range:** 0..255
                        
                        .. attribute:: path_type
                        
                        	Routing path type
                        	**type**\:   :py:class:`RoutePathType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.RoutePathType>`
                        
                        .. attribute:: remote_node_id
                        
                        	This is the Remote/PQ node address
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Routing, self).__init__()

                            self.yang_name = "routing"
                            self.yang_parent_name = "paths"

                            self.bkup_path_id = YLeaf(YType.uint8, "bkup-path-id")

                            self.has_remote_lfa_bkup = YLeaf(YType.boolean, "has-remote-lfa-bkup")

                            self.interface = YLeaf(YType.str, "interface")

                            self.load_metric = YLeaf(YType.uint32, "load-metric")

                            self.next_hop = YLeaf(YType.str, "next-hop")

                            self.next_hop_table_id = YLeaf(YType.uint32, "next-hop-table-id")

                            self.nexthop_id = YLeaf(YType.uint32, "nexthop-id")

                            self.nh_is_overriden = YLeaf(YType.empty, "nh-is-overriden")

                            self.path_id = YLeaf(YType.uint8, "path-id")

                            self.path_type = YLeaf(YType.identityref, "path-type")

                            self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bkup_path_id",
                                            "has_remote_lfa_bkup",
                                            "interface",
                                            "load_metric",
                                            "next_hop",
                                            "next_hop_table_id",
                                            "nexthop_id",
                                            "nh_is_overriden",
                                            "path_id",
                                            "path_type",
                                            "remote_node_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Routing, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Routing, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bkup_path_id.is_set or
                                self.has_remote_lfa_bkup.is_set or
                                self.interface.is_set or
                                self.load_metric.is_set or
                                self.next_hop.is_set or
                                self.next_hop_table_id.is_set or
                                self.nexthop_id.is_set or
                                self.nh_is_overriden.is_set or
                                self.path_id.is_set or
                                self.path_type.is_set or
                                self.remote_node_id.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bkup_path_id.yfilter != YFilter.not_set or
                                self.has_remote_lfa_bkup.yfilter != YFilter.not_set or
                                self.interface.yfilter != YFilter.not_set or
                                self.load_metric.yfilter != YFilter.not_set or
                                self.next_hop.yfilter != YFilter.not_set or
                                self.next_hop_table_id.yfilter != YFilter.not_set or
                                self.nexthop_id.yfilter != YFilter.not_set or
                                self.nh_is_overriden.yfilter != YFilter.not_set or
                                self.path_id.yfilter != YFilter.not_set or
                                self.path_type.yfilter != YFilter.not_set or
                                self.remote_node_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "routing" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bkup_path_id.is_set or self.bkup_path_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bkup_path_id.get_name_leafdata())
                            if (self.has_remote_lfa_bkup.is_set or self.has_remote_lfa_bkup.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.has_remote_lfa_bkup.get_name_leafdata())
                            if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface.get_name_leafdata())
                            if (self.load_metric.is_set or self.load_metric.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.load_metric.get_name_leafdata())
                            if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop.get_name_leafdata())
                            if (self.next_hop_table_id.is_set or self.next_hop_table_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop_table_id.get_name_leafdata())
                            if (self.nexthop_id.is_set or self.nexthop_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nexthop_id.get_name_leafdata())
                            if (self.nh_is_overriden.is_set or self.nh_is_overriden.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nh_is_overriden.get_name_leafdata())
                            if (self.path_id.is_set or self.path_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_id.get_name_leafdata())
                            if (self.path_type.is_set or self.path_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_type.get_name_leafdata())
                            if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bkup-path-id" or name == "has-remote-lfa-bkup" or name == "interface" or name == "load-metric" or name == "next-hop" or name == "next-hop-table-id" or name == "nexthop-id" or name == "nh-is-overriden" or name == "path-id" or name == "path-type" or name == "remote-node-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bkup-path-id"):
                                self.bkup_path_id = value
                                self.bkup_path_id.value_namespace = name_space
                                self.bkup_path_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "has-remote-lfa-bkup"):
                                self.has_remote_lfa_bkup = value
                                self.has_remote_lfa_bkup.value_namespace = name_space
                                self.has_remote_lfa_bkup.value_namespace_prefix = name_space_prefix
                            if(value_path == "interface"):
                                self.interface = value
                                self.interface.value_namespace = name_space
                                self.interface.value_namespace_prefix = name_space_prefix
                            if(value_path == "load-metric"):
                                self.load_metric = value
                                self.load_metric.value_namespace = name_space
                                self.load_metric.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop"):
                                self.next_hop = value
                                self.next_hop.value_namespace = name_space
                                self.next_hop.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop-table-id"):
                                self.next_hop_table_id = value
                                self.next_hop_table_id.value_namespace = name_space
                                self.next_hop_table_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "nexthop-id"):
                                self.nexthop_id = value
                                self.nexthop_id.value_namespace = name_space
                                self.nexthop_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "nh-is-overriden"):
                                self.nh_is_overriden = value
                                self.nh_is_overriden.value_namespace = name_space
                                self.nh_is_overriden.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-id"):
                                self.path_id = value
                                self.path_id.value_namespace = name_space
                                self.path_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-type"):
                                self.path_type = value
                                self.path_type.value_namespace = name_space
                                self.path_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "remote-node-id"):
                                self.remote_node_id = value
                                self.remote_node_id.value_namespace = name_space
                                self.remote_node_id.value_namespace_prefix = name_space_prefix


                    class Mpls(Entity):
                        """
                        MPLS LDP Forwarding Path MPLS information
                        
                        .. attribute:: mpls_outgoing_info
                        
                        	MPLS nexthop info
                        	**type**\:   :py:class:`MplsOutgoingInfo <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo>`
                        
                        .. attribute:: remote_lfa
                        
                        	MPLS LDP Forwarding Path Remote LFA\-FRR backup MPLS info
                        	**type**\:   :py:class:`RemoteLfa <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa>`
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls, self).__init__()

                            self.yang_name = "mpls"
                            self.yang_parent_name = "paths"

                            self.mpls_outgoing_info = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo()
                            self.mpls_outgoing_info.parent = self
                            self._children_name_map["mpls_outgoing_info"] = "mpls-outgoing-info"
                            self._children_yang_names.add("mpls-outgoing-info")

                            self.remote_lfa = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa()
                            self.remote_lfa.parent = self
                            self._children_name_map["remote_lfa"] = "remote-lfa"
                            self._children_yang_names.add("remote-lfa")


                        class MplsOutgoingInfo(Entity):
                            """
                            MPLS nexthop info
                            
                            .. attribute:: is_from_graceful_restartable_neighbor
                            
                            	Is from a GR neighbor
                            	**type**\:  bool
                            
                            .. attribute:: is_stale
                            
                            	Is the entry stale? This may happen during a graceful restart
                            	**type**\:  bool
                            
                            .. attribute:: nexthop_peer_ldp_ident
                            
                            	Nexthop LDP peer
                            	**type**\:   :py:class:`NexthopPeerLdpIdent <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo.NexthopPeerLdpIdent>`
                            
                            .. attribute:: out_label
                            
                            	Outgoing label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: out_label_owner
                            
                            	Outgoing label owner
                            	**type**\:   :py:class:`RoutePathLblOwner <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.RoutePathLblOwner>`
                            
                            .. attribute:: out_label_type
                            
                            	Outgoing Label Type
                            	**type**\:   :py:class:`LabelType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.LabelType>`
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo, self).__init__()

                                self.yang_name = "mpls-outgoing-info"
                                self.yang_parent_name = "mpls"

                                self.is_from_graceful_restartable_neighbor = YLeaf(YType.boolean, "is-from-graceful-restartable-neighbor")

                                self.is_stale = YLeaf(YType.boolean, "is-stale")

                                self.out_label = YLeaf(YType.uint32, "out-label")

                                self.out_label_owner = YLeaf(YType.identityref, "out-label-owner")

                                self.out_label_type = YLeaf(YType.identityref, "out-label-type")

                                self.nexthop_peer_ldp_ident = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo.NexthopPeerLdpIdent()
                                self.nexthop_peer_ldp_ident.parent = self
                                self._children_name_map["nexthop_peer_ldp_ident"] = "nexthop-peer-ldp-ident"
                                self._children_yang_names.add("nexthop-peer-ldp-ident")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("is_from_graceful_restartable_neighbor",
                                                "is_stale",
                                                "out_label",
                                                "out_label_owner",
                                                "out_label_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo, self).__setattr__(name, value)


                            class NexthopPeerLdpIdent(Entity):
                                """
                                Nexthop LDP peer
                                
                                .. attribute:: label_space_id
                                
                                	Label space identifier
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: lsr_id
                                
                                	LSR identifier
                                	**type**\: one of the below types:
                                
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                	**type**\:  str
                                
                                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                
                                
                                ----
                                

                                """

                                _prefix = 'mpls-ldp-ios-xe-oper'
                                _revision = '2017-02-07'

                                def __init__(self):
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo.NexthopPeerLdpIdent, self).__init__()

                                    self.yang_name = "nexthop-peer-ldp-ident"
                                    self.yang_parent_name = "mpls-outgoing-info"

                                    self.label_space_id = YLeaf(YType.uint16, "label-space-id")

                                    self.lsr_id = YLeaf(YType.str, "lsr-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("label_space_id",
                                                    "lsr_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo.NexthopPeerLdpIdent, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo.NexthopPeerLdpIdent, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.label_space_id.is_set or
                                        self.lsr_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.label_space_id.yfilter != YFilter.not_set or
                                        self.lsr_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "nexthop-peer-ldp-ident" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.label_space_id.is_set or self.label_space_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_space_id.get_name_leafdata())
                                    if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsr_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "label-space-id" or name == "lsr-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "label-space-id"):
                                        self.label_space_id = value
                                        self.label_space_id.value_namespace = name_space
                                        self.label_space_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsr-id"):
                                        self.lsr_id = value
                                        self.lsr_id.value_namespace = name_space
                                        self.lsr_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.is_from_graceful_restartable_neighbor.is_set or
                                    self.is_stale.is_set or
                                    self.out_label.is_set or
                                    self.out_label_owner.is_set or
                                    self.out_label_type.is_set or
                                    (self.nexthop_peer_ldp_ident is not None and self.nexthop_peer_ldp_ident.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.is_from_graceful_restartable_neighbor.yfilter != YFilter.not_set or
                                    self.is_stale.yfilter != YFilter.not_set or
                                    self.out_label.yfilter != YFilter.not_set or
                                    self.out_label_owner.yfilter != YFilter.not_set or
                                    self.out_label_type.yfilter != YFilter.not_set or
                                    (self.nexthop_peer_ldp_ident is not None and self.nexthop_peer_ldp_ident.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-outgoing-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.is_from_graceful_restartable_neighbor.is_set or self.is_from_graceful_restartable_neighbor.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_from_graceful_restartable_neighbor.get_name_leafdata())
                                if (self.is_stale.is_set or self.is_stale.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_stale.get_name_leafdata())
                                if (self.out_label.is_set or self.out_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_label.get_name_leafdata())
                                if (self.out_label_owner.is_set or self.out_label_owner.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_label_owner.get_name_leafdata())
                                if (self.out_label_type.is_set or self.out_label_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.out_label_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "nexthop-peer-ldp-ident"):
                                    if (self.nexthop_peer_ldp_ident is None):
                                        self.nexthop_peer_ldp_ident = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo.NexthopPeerLdpIdent()
                                        self.nexthop_peer_ldp_ident.parent = self
                                        self._children_name_map["nexthop_peer_ldp_ident"] = "nexthop-peer-ldp-ident"
                                    return self.nexthop_peer_ldp_ident

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "nexthop-peer-ldp-ident" or name == "is-from-graceful-restartable-neighbor" or name == "is-stale" or name == "out-label" or name == "out-label-owner" or name == "out-label-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "is-from-graceful-restartable-neighbor"):
                                    self.is_from_graceful_restartable_neighbor = value
                                    self.is_from_graceful_restartable_neighbor.value_namespace = name_space
                                    self.is_from_graceful_restartable_neighbor.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-stale"):
                                    self.is_stale = value
                                    self.is_stale.value_namespace = name_space
                                    self.is_stale.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-label"):
                                    self.out_label = value
                                    self.out_label.value_namespace = name_space
                                    self.out_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-label-owner"):
                                    self.out_label_owner = value
                                    self.out_label_owner.value_namespace = name_space
                                    self.out_label_owner.value_namespace_prefix = name_space_prefix
                                if(value_path == "out-label-type"):
                                    self.out_label_type = value
                                    self.out_label_type.value_namespace = name_space
                                    self.out_label_type.value_namespace_prefix = name_space_prefix


                        class RemoteLfa(Entity):
                            """
                            MPLS LDP Forwarding Path Remote LFA\-FRR backup
                            MPLS info
                            
                            .. attribute:: has_remote_lfa_bkup
                            
                            	Whether path has remote LFA backup
                            	**type**\:  bool
                            
                            .. attribute:: mpls_outgoing_info
                            
                            	Remote LFA MPLS nexthop info
                            	**type**\:   :py:class:`MplsOutgoingInfo <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo>`
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa, self).__init__()

                                self.yang_name = "remote-lfa"
                                self.yang_parent_name = "mpls"

                                self.has_remote_lfa_bkup = YLeaf(YType.boolean, "has-remote-lfa-bkup")

                                self.mpls_outgoing_info = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo()
                                self.mpls_outgoing_info.parent = self
                                self._children_name_map["mpls_outgoing_info"] = "mpls-outgoing-info"
                                self._children_yang_names.add("mpls-outgoing-info")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("has_remote_lfa_bkup") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa, self).__setattr__(name, value)


                            class MplsOutgoingInfo(Entity):
                                """
                                Remote LFA MPLS nexthop info
                                
                                .. attribute:: is_from_graceful_restartable_neighbor
                                
                                	Is from a GR neighbor
                                	**type**\:  bool
                                
                                .. attribute:: is_stale
                                
                                	Is the entry stale? This may happen during a graceful restart
                                	**type**\:  bool
                                
                                .. attribute:: nexthop_peer_ldp_ident
                                
                                	Nexthop LDP peer
                                	**type**\:   :py:class:`NexthopPeerLdpIdent <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo.NexthopPeerLdpIdent>`
                                
                                .. attribute:: out_label
                                
                                	Outgoing label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: out_label_owner
                                
                                	Outgoing label owner
                                	**type**\:   :py:class:`RoutePathLblOwner <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.RoutePathLblOwner>`
                                
                                .. attribute:: out_label_type
                                
                                	Outgoing Label Type
                                	**type**\:   :py:class:`LabelType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.LabelType>`
                                
                                

                                """

                                _prefix = 'mpls-ldp-ios-xe-oper'
                                _revision = '2017-02-07'

                                def __init__(self):
                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo, self).__init__()

                                    self.yang_name = "mpls-outgoing-info"
                                    self.yang_parent_name = "remote-lfa"

                                    self.is_from_graceful_restartable_neighbor = YLeaf(YType.boolean, "is-from-graceful-restartable-neighbor")

                                    self.is_stale = YLeaf(YType.boolean, "is-stale")

                                    self.out_label = YLeaf(YType.uint32, "out-label")

                                    self.out_label_owner = YLeaf(YType.identityref, "out-label-owner")

                                    self.out_label_type = YLeaf(YType.identityref, "out-label-type")

                                    self.nexthop_peer_ldp_ident = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo.NexthopPeerLdpIdent()
                                    self.nexthop_peer_ldp_ident.parent = self
                                    self._children_name_map["nexthop_peer_ldp_ident"] = "nexthop-peer-ldp-ident"
                                    self._children_yang_names.add("nexthop-peer-ldp-ident")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("is_from_graceful_restartable_neighbor",
                                                    "is_stale",
                                                    "out_label",
                                                    "out_label_owner",
                                                    "out_label_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo, self).__setattr__(name, value)


                                class NexthopPeerLdpIdent(Entity):
                                    """
                                    Nexthop LDP peer
                                    
                                    .. attribute:: label_space_id
                                    
                                    	Label space identifier
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: lsr_id
                                    
                                    	LSR identifier
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    

                                    """

                                    _prefix = 'mpls-ldp-ios-xe-oper'
                                    _revision = '2017-02-07'

                                    def __init__(self):
                                        super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo.NexthopPeerLdpIdent, self).__init__()

                                        self.yang_name = "nexthop-peer-ldp-ident"
                                        self.yang_parent_name = "mpls-outgoing-info"

                                        self.label_space_id = YLeaf(YType.uint16, "label-space-id")

                                        self.lsr_id = YLeaf(YType.str, "lsr-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("label_space_id",
                                                        "lsr_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo.NexthopPeerLdpIdent, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo.NexthopPeerLdpIdent, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.label_space_id.is_set or
                                            self.lsr_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.label_space_id.yfilter != YFilter.not_set or
                                            self.lsr_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "nexthop-peer-ldp-ident" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.label_space_id.is_set or self.label_space_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.label_space_id.get_name_leafdata())
                                        if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lsr_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "label-space-id" or name == "lsr-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "label-space-id"):
                                            self.label_space_id = value
                                            self.label_space_id.value_namespace = name_space
                                            self.label_space_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "lsr-id"):
                                            self.lsr_id = value
                                            self.lsr_id.value_namespace = name_space
                                            self.lsr_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.is_from_graceful_restartable_neighbor.is_set or
                                        self.is_stale.is_set or
                                        self.out_label.is_set or
                                        self.out_label_owner.is_set or
                                        self.out_label_type.is_set or
                                        (self.nexthop_peer_ldp_ident is not None and self.nexthop_peer_ldp_ident.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.is_from_graceful_restartable_neighbor.yfilter != YFilter.not_set or
                                        self.is_stale.yfilter != YFilter.not_set or
                                        self.out_label.yfilter != YFilter.not_set or
                                        self.out_label_owner.yfilter != YFilter.not_set or
                                        self.out_label_type.yfilter != YFilter.not_set or
                                        (self.nexthop_peer_ldp_ident is not None and self.nexthop_peer_ldp_ident.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "mpls-outgoing-info" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.is_from_graceful_restartable_neighbor.is_set or self.is_from_graceful_restartable_neighbor.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_from_graceful_restartable_neighbor.get_name_leafdata())
                                    if (self.is_stale.is_set or self.is_stale.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_stale.get_name_leafdata())
                                    if (self.out_label.is_set or self.out_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.out_label.get_name_leafdata())
                                    if (self.out_label_owner.is_set or self.out_label_owner.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.out_label_owner.get_name_leafdata())
                                    if (self.out_label_type.is_set or self.out_label_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.out_label_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "nexthop-peer-ldp-ident"):
                                        if (self.nexthop_peer_ldp_ident is None):
                                            self.nexthop_peer_ldp_ident = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo.NexthopPeerLdpIdent()
                                            self.nexthop_peer_ldp_ident.parent = self
                                            self._children_name_map["nexthop_peer_ldp_ident"] = "nexthop-peer-ldp-ident"
                                        return self.nexthop_peer_ldp_ident

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "nexthop-peer-ldp-ident" or name == "is-from-graceful-restartable-neighbor" or name == "is-stale" or name == "out-label" or name == "out-label-owner" or name == "out-label-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "is-from-graceful-restartable-neighbor"):
                                        self.is_from_graceful_restartable_neighbor = value
                                        self.is_from_graceful_restartable_neighbor.value_namespace = name_space
                                        self.is_from_graceful_restartable_neighbor.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-stale"):
                                        self.is_stale = value
                                        self.is_stale.value_namespace = name_space
                                        self.is_stale.value_namespace_prefix = name_space_prefix
                                    if(value_path == "out-label"):
                                        self.out_label = value
                                        self.out_label.value_namespace = name_space
                                        self.out_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "out-label-owner"):
                                        self.out_label_owner = value
                                        self.out_label_owner.value_namespace = name_space
                                        self.out_label_owner.value_namespace_prefix = name_space_prefix
                                    if(value_path == "out-label-type"):
                                        self.out_label_type = value
                                        self.out_label_type.value_namespace = name_space
                                        self.out_label_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.has_remote_lfa_bkup.is_set or
                                    (self.mpls_outgoing_info is not None and self.mpls_outgoing_info.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.has_remote_lfa_bkup.yfilter != YFilter.not_set or
                                    (self.mpls_outgoing_info is not None and self.mpls_outgoing_info.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "remote-lfa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.has_remote_lfa_bkup.is_set or self.has_remote_lfa_bkup.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.has_remote_lfa_bkup.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "mpls-outgoing-info"):
                                    if (self.mpls_outgoing_info is None):
                                        self.mpls_outgoing_info = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa.MplsOutgoingInfo()
                                        self.mpls_outgoing_info.parent = self
                                        self._children_name_map["mpls_outgoing_info"] = "mpls-outgoing-info"
                                    return self.mpls_outgoing_info

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mpls-outgoing-info" or name == "has-remote-lfa-bkup"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "has-remote-lfa-bkup"):
                                    self.has_remote_lfa_bkup = value
                                    self.has_remote_lfa_bkup.value_namespace = name_space
                                    self.has_remote_lfa_bkup.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.mpls_outgoing_info is not None and self.mpls_outgoing_info.has_data()) or
                                (self.remote_lfa is not None and self.remote_lfa.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.mpls_outgoing_info is not None and self.mpls_outgoing_info.has_operation()) or
                                (self.remote_lfa is not None and self.remote_lfa.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "mpls" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "mpls-outgoing-info"):
                                if (self.mpls_outgoing_info is None):
                                    self.mpls_outgoing_info = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.MplsOutgoingInfo()
                                    self.mpls_outgoing_info.parent = self
                                    self._children_name_map["mpls_outgoing_info"] = "mpls-outgoing-info"
                                return self.mpls_outgoing_info

                            if (child_yang_name == "remote-lfa"):
                                if (self.remote_lfa is None):
                                    self.remote_lfa = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls.RemoteLfa()
                                    self.remote_lfa.parent = self
                                    self._children_name_map["remote_lfa"] = "remote-lfa"
                                return self.remote_lfa

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mpls-outgoing-info" or name == "remote-lfa"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.mpls is not None and self.mpls.has_data()) or
                            (self.routing is not None and self.routing.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.mpls is not None and self.mpls.has_operation()) or
                            (self.routing is not None and self.routing.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "paths" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "mpls"):
                            if (self.mpls is None):
                                self.mpls = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Mpls()
                                self.mpls.parent = self
                                self._children_name_map["mpls"] = "mpls"
                            return self.mpls

                        if (child_yang_name == "routing"):
                            if (self.routing is None):
                                self.routing = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths.Routing()
                                self.routing.parent = self
                                self._children_name_map["routing"] = "routing"
                            return self.routing

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mpls" or name == "routing"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    for c in self.paths:
                        if (c.has_data()):
                            return True
                    return (
                        self.vrf_name.is_set or
                        self.prefix.is_set or
                        self.fwd_prefix.is_set or
                        self.prefix_length.is_set or
                        self.table_id.is_set or
                        (self.route is not None and self.route.has_data()))

                def has_operation(self):
                    for c in self.paths:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set or
                        self.prefix.yfilter != YFilter.not_set or
                        self.fwd_prefix.yfilter != YFilter.not_set or
                        self.prefix_length.yfilter != YFilter.not_set or
                        self.table_id.yfilter != YFilter.not_set or
                        (self.route is not None and self.route.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "forwarding-detail" + "[vrf-name='" + self.vrf_name.get() + "']" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/forwarding/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())
                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.prefix.get_name_leafdata())
                    if (self.fwd_prefix.is_set or self.fwd_prefix.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fwd_prefix.get_name_leafdata())
                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.prefix_length.get_name_leafdata())
                    if (self.table_id.is_set or self.table_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.table_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "paths"):
                        for c in self.paths:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Paths()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.paths.append(c)
                        return c

                    if (child_yang_name == "route"):
                        if (self.route is None):
                            self.route = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail.Route()
                            self.route.parent = self
                            self._children_name_map["route"] = "route"
                        return self.route

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "paths" or name == "route" or name == "vrf-name" or name == "prefix" or name == "fwd-prefix" or name == "prefix-length" or name == "table-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "prefix"):
                        self.prefix = value
                        self.prefix.value_namespace = name_space
                        self.prefix.value_namespace_prefix = name_space_prefix
                    if(value_path == "fwd-prefix"):
                        self.fwd_prefix = value
                        self.fwd_prefix.value_namespace = name_space
                        self.fwd_prefix.value_namespace_prefix = name_space_prefix
                    if(value_path == "prefix-length"):
                        self.prefix_length = value
                        self.prefix_length.value_namespace = name_space
                        self.prefix_length.value_namespace_prefix = name_space_prefix
                    if(value_path == "table-id"):
                        self.table_id = value
                        self.table_id.value_namespace = name_space
                        self.table_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.forwarding_detail:
                    if (c.has_data()):
                        return True
                return (self.forwarding_vrf_summs is not None and self.forwarding_vrf_summs.has_data())

            def has_operation(self):
                for c in self.forwarding_detail:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    (self.forwarding_vrf_summs is not None and self.forwarding_vrf_summs.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "forwarding" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "forwarding-detail"):
                    for c in self.forwarding_detail:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Forwarding.ForwardingDetail()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.forwarding_detail.append(c)
                    return c

                if (child_yang_name == "forwarding-vrf-summs"):
                    if (self.forwarding_vrf_summs is None):
                        self.forwarding_vrf_summs = MplsLdp.MplsLdpState.Forwarding.ForwardingVrfSumms()
                        self.forwarding_vrf_summs.parent = self
                        self._children_name_map["forwarding_vrf_summs"] = "forwarding-vrf-summs"
                    return self.forwarding_vrf_summs

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "forwarding-detail" or name == "forwarding-vrf-summs"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Bindings(Entity):
            """
            The detailed LDP Bindings.
            
            .. attribute:: binding
            
            	This list contains the MPLS LDP Label Bindings for each IP Prefix. Label bindings provide the local MPLS Label, a list of remote labels, any filters affecting advertisment of that filter, and a list of neighbors to which the label has been advertised
            	**type**\: list of    :py:class:`Binding <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings.Binding>`
            
            .. attribute:: bindings_sum_afs
            
            	This container holds the bindings specific to this VRF and AF
            	**type**\:   :py:class:`BindingsSumAfs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings.BindingsSumAfs>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Bindings, self).__init__()

                self.yang_name = "bindings"
                self.yang_parent_name = "mpls-ldp-state"

                self.bindings_sum_afs = MplsLdp.MplsLdpState.Bindings.BindingsSumAfs()
                self.bindings_sum_afs.parent = self
                self._children_name_map["bindings_sum_afs"] = "bindings-sum-afs"
                self._children_yang_names.add("bindings-sum-afs")

                self.binding = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.Bindings, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.Bindings, self).__setattr__(name, value)


            class BindingsSumAfs(Entity):
                """
                This container holds the bindings specific to this VRF
                and AF.
                
                .. attribute:: binding_sum_af
                
                	Counters for the LDP Label Information Base for this VRF/AF
                	**type**\: list of    :py:class:`BindingSumAf <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings.BindingsSumAfs.BindingSumAf>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Bindings.BindingsSumAfs, self).__init__()

                    self.yang_name = "bindings-sum-afs"
                    self.yang_parent_name = "bindings"

                    self.binding_sum_af = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Bindings.BindingsSumAfs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Bindings.BindingsSumAfs, self).__setattr__(name, value)


                class BindingSumAf(Entity):
                    """
                    Counters for the LDP Label Information Base for this
                    VRF/AF.
                    
                    .. attribute:: vrf_name  <key>
                    
                    	This contains the VRF Name, where 'default' is used for the default vrf
                    	**type**\:  str
                    
                    .. attribute:: af_name  <key>
                    
                    	Address Family name
                    	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                    
                    .. attribute:: binding_local
                    
                    	Number of local bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_local_explicit_null
                    
                    	Number of local explicit null bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_local_implicit_null
                    
                    	Number of local implicit null bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_local_no_route
                    
                    	Local bindings with no route
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_local_non_null
                    
                    	Number of local non\-null bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_local_null
                    
                    	Number of local null bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_local_oor
                    
                    	This is the number of local bindings needing label but which hit the Out\-Of\-Resource condition
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_no_route
                    
                    	Bindings with no route
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_remote
                    
                    	Number of remote bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: binding_total
                    
                    	Total bindings
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: highest_allocated_label
                    
                    	Highest allocated label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: lowest_allocated_label
                    
                    	Lowest allocated label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Bindings.BindingsSumAfs.BindingSumAf, self).__init__()

                        self.yang_name = "binding-sum-af"
                        self.yang_parent_name = "bindings-sum-afs"

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.binding_local = YLeaf(YType.uint32, "binding-local")

                        self.binding_local_explicit_null = YLeaf(YType.uint32, "binding-local-explicit-null")

                        self.binding_local_implicit_null = YLeaf(YType.uint32, "binding-local-implicit-null")

                        self.binding_local_no_route = YLeaf(YType.uint32, "binding-local-no-route")

                        self.binding_local_non_null = YLeaf(YType.uint32, "binding-local-non-null")

                        self.binding_local_null = YLeaf(YType.uint32, "binding-local-null")

                        self.binding_local_oor = YLeaf(YType.uint32, "binding-local-oor")

                        self.binding_no_route = YLeaf(YType.uint32, "binding-no-route")

                        self.binding_remote = YLeaf(YType.uint32, "binding-remote")

                        self.binding_total = YLeaf(YType.uint32, "binding-total")

                        self.highest_allocated_label = YLeaf(YType.uint32, "highest-allocated-label")

                        self.lowest_allocated_label = YLeaf(YType.uint32, "lowest-allocated-label")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("vrf_name",
                                        "af_name",
                                        "binding_local",
                                        "binding_local_explicit_null",
                                        "binding_local_implicit_null",
                                        "binding_local_no_route",
                                        "binding_local_non_null",
                                        "binding_local_null",
                                        "binding_local_oor",
                                        "binding_no_route",
                                        "binding_remote",
                                        "binding_total",
                                        "highest_allocated_label",
                                        "lowest_allocated_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Bindings.BindingsSumAfs.BindingSumAf, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Bindings.BindingsSumAfs.BindingSumAf, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.vrf_name.is_set or
                            self.af_name.is_set or
                            self.binding_local.is_set or
                            self.binding_local_explicit_null.is_set or
                            self.binding_local_implicit_null.is_set or
                            self.binding_local_no_route.is_set or
                            self.binding_local_non_null.is_set or
                            self.binding_local_null.is_set or
                            self.binding_local_oor.is_set or
                            self.binding_no_route.is_set or
                            self.binding_remote.is_set or
                            self.binding_total.is_set or
                            self.highest_allocated_label.is_set or
                            self.lowest_allocated_label.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.binding_local.yfilter != YFilter.not_set or
                            self.binding_local_explicit_null.yfilter != YFilter.not_set or
                            self.binding_local_implicit_null.yfilter != YFilter.not_set or
                            self.binding_local_no_route.yfilter != YFilter.not_set or
                            self.binding_local_non_null.yfilter != YFilter.not_set or
                            self.binding_local_null.yfilter != YFilter.not_set or
                            self.binding_local_oor.yfilter != YFilter.not_set or
                            self.binding_no_route.yfilter != YFilter.not_set or
                            self.binding_remote.yfilter != YFilter.not_set or
                            self.binding_total.yfilter != YFilter.not_set or
                            self.highest_allocated_label.yfilter != YFilter.not_set or
                            self.lowest_allocated_label.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "binding-sum-af" + "[vrf-name='" + self.vrf_name.get() + "']" + "[af-name='" + self.af_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/bindings/bindings-sum-afs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.binding_local.is_set or self.binding_local.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local.get_name_leafdata())
                        if (self.binding_local_explicit_null.is_set or self.binding_local_explicit_null.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local_explicit_null.get_name_leafdata())
                        if (self.binding_local_implicit_null.is_set or self.binding_local_implicit_null.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local_implicit_null.get_name_leafdata())
                        if (self.binding_local_no_route.is_set or self.binding_local_no_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local_no_route.get_name_leafdata())
                        if (self.binding_local_non_null.is_set or self.binding_local_non_null.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local_non_null.get_name_leafdata())
                        if (self.binding_local_null.is_set or self.binding_local_null.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local_null.get_name_leafdata())
                        if (self.binding_local_oor.is_set or self.binding_local_oor.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_local_oor.get_name_leafdata())
                        if (self.binding_no_route.is_set or self.binding_no_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_no_route.get_name_leafdata())
                        if (self.binding_remote.is_set or self.binding_remote.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_remote.get_name_leafdata())
                        if (self.binding_total.is_set or self.binding_total.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.binding_total.get_name_leafdata())
                        if (self.highest_allocated_label.is_set or self.highest_allocated_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.highest_allocated_label.get_name_leafdata())
                        if (self.lowest_allocated_label.is_set or self.lowest_allocated_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lowest_allocated_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vrf-name" or name == "af-name" or name == "binding-local" or name == "binding-local-explicit-null" or name == "binding-local-implicit-null" or name == "binding-local-no-route" or name == "binding-local-non-null" or name == "binding-local-null" or name == "binding-local-oor" or name == "binding-no-route" or name == "binding-remote" or name == "binding-total" or name == "highest-allocated-label" or name == "lowest-allocated-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local"):
                            self.binding_local = value
                            self.binding_local.value_namespace = name_space
                            self.binding_local.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local-explicit-null"):
                            self.binding_local_explicit_null = value
                            self.binding_local_explicit_null.value_namespace = name_space
                            self.binding_local_explicit_null.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local-implicit-null"):
                            self.binding_local_implicit_null = value
                            self.binding_local_implicit_null.value_namespace = name_space
                            self.binding_local_implicit_null.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local-no-route"):
                            self.binding_local_no_route = value
                            self.binding_local_no_route.value_namespace = name_space
                            self.binding_local_no_route.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local-non-null"):
                            self.binding_local_non_null = value
                            self.binding_local_non_null.value_namespace = name_space
                            self.binding_local_non_null.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local-null"):
                            self.binding_local_null = value
                            self.binding_local_null.value_namespace = name_space
                            self.binding_local_null.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-local-oor"):
                            self.binding_local_oor = value
                            self.binding_local_oor.value_namespace = name_space
                            self.binding_local_oor.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-no-route"):
                            self.binding_no_route = value
                            self.binding_no_route.value_namespace = name_space
                            self.binding_no_route.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-remote"):
                            self.binding_remote = value
                            self.binding_remote.value_namespace = name_space
                            self.binding_remote.value_namespace_prefix = name_space_prefix
                        if(value_path == "binding-total"):
                            self.binding_total = value
                            self.binding_total.value_namespace = name_space
                            self.binding_total.value_namespace_prefix = name_space_prefix
                        if(value_path == "highest-allocated-label"):
                            self.highest_allocated_label = value
                            self.highest_allocated_label.value_namespace = name_space
                            self.highest_allocated_label.value_namespace_prefix = name_space_prefix
                        if(value_path == "lowest-allocated-label"):
                            self.lowest_allocated_label = value
                            self.lowest_allocated_label.value_namespace = name_space
                            self.lowest_allocated_label.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.binding_sum_af:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.binding_sum_af:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "bindings-sum-afs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/bindings/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "binding-sum-af"):
                        for c in self.binding_sum_af:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Bindings.BindingsSumAfs.BindingSumAf()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.binding_sum_af.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "binding-sum-af"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Binding(Entity):
                """
                This list contains the MPLS LDP Label Bindings for each
                IP Prefix. Label bindings provide the local MPLS Label,
                a list of remote labels, any filters affecting
                advertisment of that filter, and a list of neighbors to
                which the label has been advertised.
                
                .. attribute:: vrf_name  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: prefix  <key>
                
                	This leaf contains the IP Prefix being bound
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                
                
                ----
                .. attribute:: advertise_lsr_filter
                
                	This contains the filter name for this binding's Advertise LSR. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                .. attribute:: advertise_prefix_filter
                
                	This contains the filter name for this binding's prefix. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                .. attribute:: config_enforced_local_label_value
                
                	Config/User enforced local label value
                	**type**\:  bool
                
                .. attribute:: fwd_prefix
                
                	This is the MPLS LDP Binding IP Prefix
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: is_no_route
                
                	This is true if the MPLS LDP Binding has no route
                	**type**\:  bool
                
                .. attribute:: label_oor
                
                	This is true if the MPLS LDP Binding Label space is depleted, Out Of Resource. No new labels can be allocated
                	**type**\:  bool
                
                .. attribute:: le_local_binding_revision
                
                	This is the MPLS LDP Binding Local Binding revision
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: le_local_label_state
                
                	This is the MPLS LDP Binding Local label state
                	**type**\:   :py:class:`LocalLabelState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.LocalLabelState>`
                
                .. attribute:: local_label
                
                	This is the MPLS LDP Binding Local label
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: peers_advertised_to
                
                	Peers to which this entry is advertised
                	**type**\: list of    :py:class:`PeersAdvertisedTo <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings.Binding.PeersAdvertisedTo>`
                
                .. attribute:: prefix_length
                
                	This is the MPLS LDP Binding Prefix Length
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: remote_binding
                
                	MPLS LDP Remote Binding Information
                	**type**\: list of    :py:class:`RemoteBinding <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Bindings.Binding, self).__init__()

                    self.yang_name = "binding"
                    self.yang_parent_name = "bindings"

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                    self.prefix = YLeaf(YType.str, "prefix")

                    self.advertise_lsr_filter = YLeaf(YType.str, "advertise-lsr-filter")

                    self.advertise_prefix_filter = YLeaf(YType.str, "advertise-prefix-filter")

                    self.config_enforced_local_label_value = YLeaf(YType.boolean, "config-enforced-local-label-value")

                    self.fwd_prefix = YLeaf(YType.str, "fwd-prefix")

                    self.is_no_route = YLeaf(YType.boolean, "is-no-route")

                    self.label_oor = YLeaf(YType.boolean, "label-oor")

                    self.le_local_binding_revision = YLeaf(YType.uint32, "le-local-binding-revision")

                    self.le_local_label_state = YLeaf(YType.enumeration, "le-local-label-state")

                    self.local_label = YLeaf(YType.uint32, "local-label")

                    self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                    self.peers_advertised_to = YList(self)
                    self.remote_binding = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf_name",
                                    "prefix",
                                    "advertise_lsr_filter",
                                    "advertise_prefix_filter",
                                    "config_enforced_local_label_value",
                                    "fwd_prefix",
                                    "is_no_route",
                                    "label_oor",
                                    "le_local_binding_revision",
                                    "le_local_label_state",
                                    "local_label",
                                    "prefix_length") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Bindings.Binding, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Bindings.Binding, self).__setattr__(name, value)


                class RemoteBinding(Entity):
                    """
                    MPLS LDP Remote Binding Information
                    
                    .. attribute:: assigning_peer_ldp_ident
                    
                    	Assigning peer
                    	**type**\:   :py:class:`AssigningPeerLdpIdent <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding.AssigningPeerLdpIdent>`
                    
                    .. attribute:: is_stale
                    
                    	Is the entry stale
                    	**type**\:  bool
                    
                    .. attribute:: remote_label
                    
                    	This is the remote Label
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding, self).__init__()

                        self.yang_name = "remote-binding"
                        self.yang_parent_name = "binding"

                        self.is_stale = YLeaf(YType.boolean, "is-stale")

                        self.remote_label = YLeaf(YType.uint32, "remote-label")

                        self.assigning_peer_ldp_ident = MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding.AssigningPeerLdpIdent()
                        self.assigning_peer_ldp_ident.parent = self
                        self._children_name_map["assigning_peer_ldp_ident"] = "assigning-peer-ldp-ident"
                        self._children_yang_names.add("assigning-peer-ldp-ident")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("is_stale",
                                        "remote_label") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding, self).__setattr__(name, value)


                    class AssigningPeerLdpIdent(Entity):
                        """
                        Assigning peer
                        
                        .. attribute:: label_space_id
                        
                        	Label space identifier
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: lsr_id
                        
                        	LSR identifier
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                        
                        
                        ----
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding.AssigningPeerLdpIdent, self).__init__()

                            self.yang_name = "assigning-peer-ldp-ident"
                            self.yang_parent_name = "remote-binding"

                            self.label_space_id = YLeaf(YType.uint16, "label-space-id")

                            self.lsr_id = YLeaf(YType.str, "lsr-id")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("label_space_id",
                                            "lsr_id") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding.AssigningPeerLdpIdent, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding.AssigningPeerLdpIdent, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.label_space_id.is_set or
                                self.lsr_id.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.label_space_id.yfilter != YFilter.not_set or
                                self.lsr_id.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "assigning-peer-ldp-ident" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.label_space_id.is_set or self.label_space_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.label_space_id.get_name_leafdata())
                            if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lsr_id.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "label-space-id" or name == "lsr-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "label-space-id"):
                                self.label_space_id = value
                                self.label_space_id.value_namespace = name_space
                                self.label_space_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "lsr-id"):
                                self.lsr_id = value
                                self.lsr_id.value_namespace = name_space
                                self.lsr_id.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.is_stale.is_set or
                            self.remote_label.is_set or
                            (self.assigning_peer_ldp_ident is not None and self.assigning_peer_ldp_ident.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.is_stale.yfilter != YFilter.not_set or
                            self.remote_label.yfilter != YFilter.not_set or
                            (self.assigning_peer_ldp_ident is not None and self.assigning_peer_ldp_ident.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-binding" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.is_stale.is_set or self.is_stale.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_stale.get_name_leafdata())
                        if (self.remote_label.is_set or self.remote_label.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "assigning-peer-ldp-ident"):
                            if (self.assigning_peer_ldp_ident is None):
                                self.assigning_peer_ldp_ident = MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding.AssigningPeerLdpIdent()
                                self.assigning_peer_ldp_ident.parent = self
                                self._children_name_map["assigning_peer_ldp_ident"] = "assigning-peer-ldp-ident"
                            return self.assigning_peer_ldp_ident

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "assigning-peer-ldp-ident" or name == "is-stale" or name == "remote-label"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "is-stale"):
                            self.is_stale = value
                            self.is_stale.value_namespace = name_space
                            self.is_stale.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label"):
                            self.remote_label = value
                            self.remote_label.value_namespace = name_space
                            self.remote_label.value_namespace_prefix = name_space_prefix


                class PeersAdvertisedTo(Entity):
                    """
                    Peers to which this entry is advertised.
                    
                    .. attribute:: label_space_id
                    
                    	Label space identifier
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: lsr_id
                    
                    	LSR identifier
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Bindings.Binding.PeersAdvertisedTo, self).__init__()

                        self.yang_name = "peers-advertised-to"
                        self.yang_parent_name = "binding"

                        self.label_space_id = YLeaf(YType.uint16, "label-space-id")

                        self.lsr_id = YLeaf(YType.str, "lsr-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("label_space_id",
                                        "lsr_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Bindings.Binding.PeersAdvertisedTo, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Bindings.Binding.PeersAdvertisedTo, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.label_space_id.is_set or
                            self.lsr_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.label_space_id.yfilter != YFilter.not_set or
                            self.lsr_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "peers-advertised-to" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.label_space_id.is_set or self.label_space_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_space_id.get_name_leafdata())
                        if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsr_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "label-space-id" or name == "lsr-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "label-space-id"):
                            self.label_space_id = value
                            self.label_space_id.value_namespace = name_space
                            self.label_space_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsr-id"):
                            self.lsr_id = value
                            self.lsr_id.value_namespace = name_space
                            self.lsr_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.peers_advertised_to:
                        if (c.has_data()):
                            return True
                    for c in self.remote_binding:
                        if (c.has_data()):
                            return True
                    return (
                        self.vrf_name.is_set or
                        self.prefix.is_set or
                        self.advertise_lsr_filter.is_set or
                        self.advertise_prefix_filter.is_set or
                        self.config_enforced_local_label_value.is_set or
                        self.fwd_prefix.is_set or
                        self.is_no_route.is_set or
                        self.label_oor.is_set or
                        self.le_local_binding_revision.is_set or
                        self.le_local_label_state.is_set or
                        self.local_label.is_set or
                        self.prefix_length.is_set)

                def has_operation(self):
                    for c in self.peers_advertised_to:
                        if (c.has_operation()):
                            return True
                    for c in self.remote_binding:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set or
                        self.prefix.yfilter != YFilter.not_set or
                        self.advertise_lsr_filter.yfilter != YFilter.not_set or
                        self.advertise_prefix_filter.yfilter != YFilter.not_set or
                        self.config_enforced_local_label_value.yfilter != YFilter.not_set or
                        self.fwd_prefix.yfilter != YFilter.not_set or
                        self.is_no_route.yfilter != YFilter.not_set or
                        self.label_oor.yfilter != YFilter.not_set or
                        self.le_local_binding_revision.yfilter != YFilter.not_set or
                        self.le_local_label_state.yfilter != YFilter.not_set or
                        self.local_label.yfilter != YFilter.not_set or
                        self.prefix_length.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "binding" + "[vrf-name='" + self.vrf_name.get() + "']" + "[prefix='" + self.prefix.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/bindings/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())
                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.prefix.get_name_leafdata())
                    if (self.advertise_lsr_filter.is_set or self.advertise_lsr_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.advertise_lsr_filter.get_name_leafdata())
                    if (self.advertise_prefix_filter.is_set or self.advertise_prefix_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.advertise_prefix_filter.get_name_leafdata())
                    if (self.config_enforced_local_label_value.is_set or self.config_enforced_local_label_value.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.config_enforced_local_label_value.get_name_leafdata())
                    if (self.fwd_prefix.is_set or self.fwd_prefix.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fwd_prefix.get_name_leafdata())
                    if (self.is_no_route.is_set or self.is_no_route.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.is_no_route.get_name_leafdata())
                    if (self.label_oor.is_set or self.label_oor.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.label_oor.get_name_leafdata())
                    if (self.le_local_binding_revision.is_set or self.le_local_binding_revision.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.le_local_binding_revision.get_name_leafdata())
                    if (self.le_local_label_state.is_set or self.le_local_label_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.le_local_label_state.get_name_leafdata())
                    if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_label.get_name_leafdata())
                    if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.prefix_length.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "peers-advertised-to"):
                        for c in self.peers_advertised_to:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Bindings.Binding.PeersAdvertisedTo()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.peers_advertised_to.append(c)
                        return c

                    if (child_yang_name == "remote-binding"):
                        for c in self.remote_binding:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpState.Bindings.Binding.RemoteBinding()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.remote_binding.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "peers-advertised-to" or name == "remote-binding" or name == "vrf-name" or name == "prefix" or name == "advertise-lsr-filter" or name == "advertise-prefix-filter" or name == "config-enforced-local-label-value" or name == "fwd-prefix" or name == "is-no-route" or name == "label-oor" or name == "le-local-binding-revision" or name == "le-local-label-state" or name == "local-label" or name == "prefix-length"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "prefix"):
                        self.prefix = value
                        self.prefix.value_namespace = name_space
                        self.prefix.value_namespace_prefix = name_space_prefix
                    if(value_path == "advertise-lsr-filter"):
                        self.advertise_lsr_filter = value
                        self.advertise_lsr_filter.value_namespace = name_space
                        self.advertise_lsr_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "advertise-prefix-filter"):
                        self.advertise_prefix_filter = value
                        self.advertise_prefix_filter.value_namespace = name_space
                        self.advertise_prefix_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "config-enforced-local-label-value"):
                        self.config_enforced_local_label_value = value
                        self.config_enforced_local_label_value.value_namespace = name_space
                        self.config_enforced_local_label_value.value_namespace_prefix = name_space_prefix
                    if(value_path == "fwd-prefix"):
                        self.fwd_prefix = value
                        self.fwd_prefix.value_namespace = name_space
                        self.fwd_prefix.value_namespace_prefix = name_space_prefix
                    if(value_path == "is-no-route"):
                        self.is_no_route = value
                        self.is_no_route.value_namespace = name_space
                        self.is_no_route.value_namespace_prefix = name_space_prefix
                    if(value_path == "label-oor"):
                        self.label_oor = value
                        self.label_oor.value_namespace = name_space
                        self.label_oor.value_namespace_prefix = name_space_prefix
                    if(value_path == "le-local-binding-revision"):
                        self.le_local_binding_revision = value
                        self.le_local_binding_revision.value_namespace = name_space
                        self.le_local_binding_revision.value_namespace_prefix = name_space_prefix
                    if(value_path == "le-local-label-state"):
                        self.le_local_label_state = value
                        self.le_local_label_state.value_namespace = name_space
                        self.le_local_label_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-label"):
                        self.local_label = value
                        self.local_label.value_namespace = name_space
                        self.local_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "prefix-length"):
                        self.prefix_length = value
                        self.prefix_length.value_namespace = name_space
                        self.prefix_length.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.binding:
                    if (c.has_data()):
                        return True
                return (self.bindings_sum_afs is not None and self.bindings_sum_afs.has_data())

            def has_operation(self):
                for c in self.binding:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    (self.bindings_sum_afs is not None and self.bindings_sum_afs.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bindings" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "binding"):
                    for c in self.binding:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Bindings.Binding()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.binding.append(c)
                    return c

                if (child_yang_name == "bindings-sum-afs"):
                    if (self.bindings_sum_afs is None):
                        self.bindings_sum_afs = MplsLdp.MplsLdpState.Bindings.BindingsSumAfs()
                        self.bindings_sum_afs.parent = self
                        self._children_name_map["bindings_sum_afs"] = "bindings-sum-afs"
                    return self.bindings_sum_afs

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "binding" or name == "bindings-sum-afs"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Neighbors(Entity):
            """
            The LDP Neighbors Information
            
            .. attribute:: backoffs
            
            	LDP Backoff Information
            	**type**\:   :py:class:`Backoffs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Backoffs>`
            
            .. attribute:: nbr_adjs
            
            	For this Neighbor, this is the list of adjacencies between the neighbor and the local node
            	**type**\: list of    :py:class:`NbrAdjs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.NbrAdjs>`
            
            .. attribute:: neighbor
            
            	Information on a particular LDP neighbor
            	**type**\: list of    :py:class:`Neighbor <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor>`
            
            .. attribute:: nsr_nbr_detail
            
            	This is the LDP NSR state for this neighbor
            	**type**\:   :py:class:`NsrNbrDetail <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail>`
            
            .. attribute:: stats_info
            
            	MPLS LDP Statistics Information
            	**type**\:   :py:class:`StatsInfo <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.StatsInfo>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.Neighbors, self).__init__()

                self.yang_name = "neighbors"
                self.yang_parent_name = "mpls-ldp-state"

                self.backoffs = MplsLdp.MplsLdpState.Neighbors.Backoffs()
                self.backoffs.parent = self
                self._children_name_map["backoffs"] = "backoffs"
                self._children_yang_names.add("backoffs")

                self.nsr_nbr_detail = MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail()
                self.nsr_nbr_detail.parent = self
                self._children_name_map["nsr_nbr_detail"] = "nsr-nbr-detail"
                self._children_yang_names.add("nsr-nbr-detail")

                self.stats_info = MplsLdp.MplsLdpState.Neighbors.StatsInfo()
                self.stats_info.parent = self
                self._children_name_map["stats_info"] = "stats-info"
                self._children_yang_names.add("stats-info")

                self.nbr_adjs = YList(self)
                self.neighbor = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.Neighbors, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.Neighbors, self).__setattr__(name, value)


            class Neighbor(Entity):
                """
                Information on a particular LDP neighbor
                
                .. attribute:: vrf_name  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: lsr_id  <key>
                
                	LSR ID of neighbor
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: advertise_bgp_prefixes
                
                	True if BGP labeled prefixes are advertised to the neighbor
                	**type**\:  bool
                
                .. attribute:: bgp_advertisement_state
                
                	BGP labeled prefixes advertisement state
                	**type**\:   :py:class:`NbrBgpAdvtState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.NbrBgpAdvtState>`
                
                .. attribute:: capabilities
                
                	Capabilities sent to and received from neighbor
                	**type**\:   :py:class:`Capabilities <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities>`
                
                .. attribute:: client
                
                	Targeted Session clients
                	**type**\:  list of str
                
                .. attribute:: downstream_on_demand
                
                	Is Label advertisement mode in Downstream On Demand mode or not?
                	**type**\:  bool
                
                .. attribute:: duplicate_address
                
                	Duplicate IPv4/IPv6 address bound to this peer
                	**type**\: one of the below types:
                
                	**type**\:  list of str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  list of str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: graceful_restart_adjacency
                
                	This container holds the graceful restart information for this adjacency
                	**type**\:   :py:class:`GracefulRestartAdjacency <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.GracefulRestartAdjacency>`
                
                .. attribute:: has_sp
                
                	Session Protection enabled
                	**type**\:  bool
                
                .. attribute:: inbound_ipv4
                
                	This contains the IPv4 Inbound accept filter name. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: inbound_ipv6_filter
                
                	This contains the IPv6 Inbound accept filter name. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: label_space_id
                
                	Label space ID of neighbor
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: nbr_bound_address
                
                	This is the MPLS LDP Neighbor Bound IPv4/IPv6 Address
                	**type**\: one of the below types:
                
                	**type**\:  list of str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  list of str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: nbr_path_vector_limit
                
                	If the value of this object is 0 (zero) then Loop Dection for Path Vectors for this neighor is disabled.  Otherwise, if this object has a value greater than zero, then Loop Dection for Path  Vectors for this neighbor is enabled and the Path Vector Limit is this value
                	**type**\:  int
                
                	**range:** 0..255
                
                .. attribute:: nbr_stats
                
                	Neighbor Statistics
                	**type**\:   :py:class:`NbrStats <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.NbrStats>`
                
                .. attribute:: outbound_ipv4_filter
                
                	This contains the IPv4 Outbound advertise filter name. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: outbound_ipv6_filter
                
                	This contains the IPv6 Outbound advertise filter name. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: peer_hold_time
                
                	Session holdtime value in seconds from the peer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                .. attribute:: peer_keep_alive_interval
                
                	Session keepalive interval in seconds from the peer
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                .. attribute:: peer_state
                
                	LDP adjacency peer state
                	**type**\:   :py:class:`AdjState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.AdjState>`
                
                .. attribute:: session_prot_ver
                
                	The version of the LDP Protocol which this session is using.  This is the version of the LDP protocol which has been negotiated during session initialization
                	**type**\:  int
                
                	**range:** 1..65535
                
                .. attribute:: session_role
                
                	During session establishment the LSR/LER takes either the active role or the passive role based on address comparisons.  This object indicates whether this LSR/LER was behaving in an active role or passive role during this session's establishment.  The value of unknown(1), indicates that the role is not able to be determined at the present time
                	**type**\:   :py:class:`SessionRole <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.SessionRole>`
                
                .. attribute:: sp_duration
                
                	Session protection holdup time duration in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                .. attribute:: sp_filter
                
                	This contains the Session Protection filter name. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: sp_has_duration
                
                	Session Protection has non\-default duration
                	**type**\:  bool
                
                .. attribute:: sp_state
                
                	Session Protection state
                	**type**\:  str
                
                	**length:** 0..80
                
                .. attribute:: spht_remaining
                
                	Session Protection holdup time remaining value in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                .. attribute:: spht_running
                
                	Session Protection holdup timer is running
                	**type**\:  bool
                
                .. attribute:: tcp_information
                
                	MPLS LDP Neighbor TCP Information
                	**type**\:   :py:class:`TcpInformation <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.TcpInformation>`
                
                .. attribute:: up_time_seconds
                
                	Up time in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor, self).__init__()

                    self.yang_name = "neighbor"
                    self.yang_parent_name = "neighbors"

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                    self.lsr_id = YLeaf(YType.str, "lsr-id")

                    self.advertise_bgp_prefixes = YLeaf(YType.boolean, "advertise-bgp-prefixes")

                    self.bgp_advertisement_state = YLeaf(YType.enumeration, "bgp-advertisement-state")

                    self.client = YLeafList(YType.str, "client")

                    self.downstream_on_demand = YLeaf(YType.boolean, "downstream-on-demand")

                    self.duplicate_address = YLeafList(YType.str, "duplicate-address")

                    self.has_sp = YLeaf(YType.boolean, "has-sp")

                    self.inbound_ipv4 = YLeaf(YType.str, "inbound-ipv4")

                    self.inbound_ipv6_filter = YLeaf(YType.str, "inbound-ipv6-filter")

                    self.label_space_id = YLeaf(YType.uint32, "label-space-id")

                    self.nbr_bound_address = YLeafList(YType.str, "nbr-bound-address")

                    self.nbr_path_vector_limit = YLeaf(YType.int32, "nbr-path-vector-limit")

                    self.outbound_ipv4_filter = YLeaf(YType.str, "outbound-ipv4-filter")

                    self.outbound_ipv6_filter = YLeaf(YType.str, "outbound-ipv6-filter")

                    self.peer_hold_time = YLeaf(YType.uint32, "peer-hold-time")

                    self.peer_keep_alive_interval = YLeaf(YType.uint32, "peer-keep-alive-interval")

                    self.peer_state = YLeaf(YType.enumeration, "peer-state")

                    self.session_prot_ver = YLeaf(YType.uint32, "session-prot-ver")

                    self.session_role = YLeaf(YType.enumeration, "session-role")

                    self.sp_duration = YLeaf(YType.uint32, "sp-duration")

                    self.sp_filter = YLeaf(YType.str, "sp-filter")

                    self.sp_has_duration = YLeaf(YType.boolean, "sp-has-duration")

                    self.sp_state = YLeaf(YType.str, "sp-state")

                    self.spht_remaining = YLeaf(YType.uint32, "spht-remaining")

                    self.spht_running = YLeaf(YType.boolean, "spht-running")

                    self.up_time_seconds = YLeaf(YType.uint32, "up-time-seconds")

                    self.capabilities = MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities()
                    self.capabilities.parent = self
                    self._children_name_map["capabilities"] = "capabilities"
                    self._children_yang_names.add("capabilities")

                    self.graceful_restart_adjacency = MplsLdp.MplsLdpState.Neighbors.Neighbor.GracefulRestartAdjacency()
                    self.graceful_restart_adjacency.parent = self
                    self._children_name_map["graceful_restart_adjacency"] = "graceful-restart-adjacency"
                    self._children_yang_names.add("graceful-restart-adjacency")

                    self.nbr_stats = MplsLdp.MplsLdpState.Neighbors.Neighbor.NbrStats()
                    self.nbr_stats.parent = self
                    self._children_name_map["nbr_stats"] = "nbr-stats"
                    self._children_yang_names.add("nbr-stats")

                    self.tcp_information = MplsLdp.MplsLdpState.Neighbors.Neighbor.TcpInformation()
                    self.tcp_information.parent = self
                    self._children_name_map["tcp_information"] = "tcp-information"
                    self._children_yang_names.add("tcp-information")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf_name",
                                    "lsr_id",
                                    "advertise_bgp_prefixes",
                                    "bgp_advertisement_state",
                                    "client",
                                    "downstream_on_demand",
                                    "duplicate_address",
                                    "has_sp",
                                    "inbound_ipv4",
                                    "inbound_ipv6_filter",
                                    "label_space_id",
                                    "nbr_bound_address",
                                    "nbr_path_vector_limit",
                                    "outbound_ipv4_filter",
                                    "outbound_ipv6_filter",
                                    "peer_hold_time",
                                    "peer_keep_alive_interval",
                                    "peer_state",
                                    "session_prot_ver",
                                    "session_role",
                                    "sp_duration",
                                    "sp_filter",
                                    "sp_has_duration",
                                    "sp_state",
                                    "spht_remaining",
                                    "spht_running",
                                    "up_time_seconds") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Neighbors.Neighbor, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Neighbors.Neighbor, self).__setattr__(name, value)

                class SessionRole(Enum):
                    """
                    SessionRole

                    During session establishment the LSR/LER takes either

                    the active role or the passive role based on address

                    comparisons.  This object indicates whether this

                    LSR/LER was behaving in an active role or passive role

                    during this session's establishment.

                    The value of unknown(1), indicates that the role is not

                    able to be determined at the present time.

                    .. data:: unknown = 1

                    	The role of this LSR in the session is unknown.

                    .. data:: active = 2

                    	The role of this LSR in the session is active.

                    .. data:: passive = 3

                    	The role of this LSR in the session is passive.

                    """

                    unknown = Enum.YLeaf(1, "unknown")

                    active = Enum.YLeaf(2, "active")

                    passive = Enum.YLeaf(3, "passive")



                class NbrStats(Entity):
                    """
                    Neighbor Statistics.
                    
                    .. attribute:: num_of_nbr_ipv4_addresses
                    
                    	Number of IPv4 addresses for which the neighbor is advertising labels
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_of_nbr_ipv4_discovery
                    
                    	Number of neighbor IPv4 discovery sources
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_of_nbr_ipv4_lbl
                    
                    	Number of IPv4 labels the neighbor is advertising
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_of_nbr_ipv6_addresses
                    
                    	Number of IPv6 addresses for which the neighbor is advertising labels
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_of_nbr_ipv6_discovery
                    
                    	Number of neighbor IPv6 discovery sources
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: num_of_nbr_ipv6_lbl
                    
                    	Number of IPv6 labels the neighbor is advertising
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ta_pies_rcvd
                    
                    	Number of MPLS LDP messages received from this neighbor
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ta_pies_sent
                    
                    	Number of MPLS LDP messages sent to this neighbor
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.Neighbor.NbrStats, self).__init__()

                        self.yang_name = "nbr-stats"
                        self.yang_parent_name = "neighbor"

                        self.num_of_nbr_ipv4_addresses = YLeaf(YType.uint32, "num-of-nbr-ipv4-addresses")

                        self.num_of_nbr_ipv4_discovery = YLeaf(YType.uint32, "num-of-nbr-ipv4-discovery")

                        self.num_of_nbr_ipv4_lbl = YLeaf(YType.uint32, "num-of-nbr-ipv4-lbl")

                        self.num_of_nbr_ipv6_addresses = YLeaf(YType.uint32, "num-of-nbr-ipv6-addresses")

                        self.num_of_nbr_ipv6_discovery = YLeaf(YType.uint32, "num-of-nbr-ipv6-discovery")

                        self.num_of_nbr_ipv6_lbl = YLeaf(YType.uint32, "num-of-nbr-ipv6-lbl")

                        self.ta_pies_rcvd = YLeaf(YType.uint32, "ta-pies-rcvd")

                        self.ta_pies_sent = YLeaf(YType.uint32, "ta-pies-sent")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("num_of_nbr_ipv4_addresses",
                                        "num_of_nbr_ipv4_discovery",
                                        "num_of_nbr_ipv4_lbl",
                                        "num_of_nbr_ipv6_addresses",
                                        "num_of_nbr_ipv6_discovery",
                                        "num_of_nbr_ipv6_lbl",
                                        "ta_pies_rcvd",
                                        "ta_pies_sent") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor.NbrStats, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.Neighbor.NbrStats, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.num_of_nbr_ipv4_addresses.is_set or
                            self.num_of_nbr_ipv4_discovery.is_set or
                            self.num_of_nbr_ipv4_lbl.is_set or
                            self.num_of_nbr_ipv6_addresses.is_set or
                            self.num_of_nbr_ipv6_discovery.is_set or
                            self.num_of_nbr_ipv6_lbl.is_set or
                            self.ta_pies_rcvd.is_set or
                            self.ta_pies_sent.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.num_of_nbr_ipv4_addresses.yfilter != YFilter.not_set or
                            self.num_of_nbr_ipv4_discovery.yfilter != YFilter.not_set or
                            self.num_of_nbr_ipv4_lbl.yfilter != YFilter.not_set or
                            self.num_of_nbr_ipv6_addresses.yfilter != YFilter.not_set or
                            self.num_of_nbr_ipv6_discovery.yfilter != YFilter.not_set or
                            self.num_of_nbr_ipv6_lbl.yfilter != YFilter.not_set or
                            self.ta_pies_rcvd.yfilter != YFilter.not_set or
                            self.ta_pies_sent.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "nbr-stats" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.num_of_nbr_ipv4_addresses.is_set or self.num_of_nbr_ipv4_addresses.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_of_nbr_ipv4_addresses.get_name_leafdata())
                        if (self.num_of_nbr_ipv4_discovery.is_set or self.num_of_nbr_ipv4_discovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_of_nbr_ipv4_discovery.get_name_leafdata())
                        if (self.num_of_nbr_ipv4_lbl.is_set or self.num_of_nbr_ipv4_lbl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_of_nbr_ipv4_lbl.get_name_leafdata())
                        if (self.num_of_nbr_ipv6_addresses.is_set or self.num_of_nbr_ipv6_addresses.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_of_nbr_ipv6_addresses.get_name_leafdata())
                        if (self.num_of_nbr_ipv6_discovery.is_set or self.num_of_nbr_ipv6_discovery.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_of_nbr_ipv6_discovery.get_name_leafdata())
                        if (self.num_of_nbr_ipv6_lbl.is_set or self.num_of_nbr_ipv6_lbl.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.num_of_nbr_ipv6_lbl.get_name_leafdata())
                        if (self.ta_pies_rcvd.is_set or self.ta_pies_rcvd.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ta_pies_rcvd.get_name_leafdata())
                        if (self.ta_pies_sent.is_set or self.ta_pies_sent.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ta_pies_sent.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "num-of-nbr-ipv4-addresses" or name == "num-of-nbr-ipv4-discovery" or name == "num-of-nbr-ipv4-lbl" or name == "num-of-nbr-ipv6-addresses" or name == "num-of-nbr-ipv6-discovery" or name == "num-of-nbr-ipv6-lbl" or name == "ta-pies-rcvd" or name == "ta-pies-sent"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "num-of-nbr-ipv4-addresses"):
                            self.num_of_nbr_ipv4_addresses = value
                            self.num_of_nbr_ipv4_addresses.value_namespace = name_space
                            self.num_of_nbr_ipv4_addresses.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-of-nbr-ipv4-discovery"):
                            self.num_of_nbr_ipv4_discovery = value
                            self.num_of_nbr_ipv4_discovery.value_namespace = name_space
                            self.num_of_nbr_ipv4_discovery.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-of-nbr-ipv4-lbl"):
                            self.num_of_nbr_ipv4_lbl = value
                            self.num_of_nbr_ipv4_lbl.value_namespace = name_space
                            self.num_of_nbr_ipv4_lbl.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-of-nbr-ipv6-addresses"):
                            self.num_of_nbr_ipv6_addresses = value
                            self.num_of_nbr_ipv6_addresses.value_namespace = name_space
                            self.num_of_nbr_ipv6_addresses.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-of-nbr-ipv6-discovery"):
                            self.num_of_nbr_ipv6_discovery = value
                            self.num_of_nbr_ipv6_discovery.value_namespace = name_space
                            self.num_of_nbr_ipv6_discovery.value_namespace_prefix = name_space_prefix
                        if(value_path == "num-of-nbr-ipv6-lbl"):
                            self.num_of_nbr_ipv6_lbl = value
                            self.num_of_nbr_ipv6_lbl.value_namespace = name_space
                            self.num_of_nbr_ipv6_lbl.value_namespace_prefix = name_space_prefix
                        if(value_path == "ta-pies-rcvd"):
                            self.ta_pies_rcvd = value
                            self.ta_pies_rcvd.value_namespace = name_space
                            self.ta_pies_rcvd.value_namespace_prefix = name_space_prefix
                        if(value_path == "ta-pies-sent"):
                            self.ta_pies_sent = value
                            self.ta_pies_sent.value_namespace = name_space
                            self.ta_pies_sent.value_namespace_prefix = name_space_prefix


                class GracefulRestartAdjacency(Entity):
                    """
                    This container holds the graceful restart information
                    for this adjacency.
                    
                    .. attribute:: down_nbr_down_reason
                    
                    	This identity provides the reason that the LDP Session with this neighbor is down. The reason does not persist if the session was down but is now recovered
                    	**type**\:   :py:class:`DownNbrReason <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.DownNbrReason>`
                    
                    .. attribute:: down_nbr_flap_count
                    
                    	This is the current count of back\-to\-back flaps
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: is_graceful_restartable
                    
                    	Is this neighbor graceful restartable?
                    	**type**\:  bool
                    
                    .. attribute:: is_liveness_timer_running
                    
                    	This is set if the liveness timer is running
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: is_recovery_timer_running
                    
                    	This is set if the recovery timer is running
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: liveness_timer_remaining_seconds
                    
                    	Remaining time from liveness timer in seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: seconds
                    
                    .. attribute:: reconnect_timeout
                    
                    	This leaf is the reconnect timeout in microseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microseconds
                    
                    .. attribute:: recovery_time
                    
                    	This leaf is the recovery time in microseconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: microseconds
                    
                    .. attribute:: recovery_timer_remaining_seconds
                    
                    	Recovery timer remaining time in seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: seconds
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.Neighbor.GracefulRestartAdjacency, self).__init__()

                        self.yang_name = "graceful-restart-adjacency"
                        self.yang_parent_name = "neighbor"

                        self.down_nbr_down_reason = YLeaf(YType.identityref, "down-nbr-down-reason")

                        self.down_nbr_flap_count = YLeaf(YType.uint32, "down-nbr-flap-count")

                        self.is_graceful_restartable = YLeaf(YType.boolean, "is-graceful-restartable")

                        self.is_liveness_timer_running = YLeaf(YType.empty, "is-liveness-timer-running")

                        self.is_recovery_timer_running = YLeaf(YType.empty, "is-recovery-timer-running")

                        self.liveness_timer_remaining_seconds = YLeaf(YType.uint32, "liveness-timer-remaining-seconds")

                        self.reconnect_timeout = YLeaf(YType.uint32, "reconnect-timeout")

                        self.recovery_time = YLeaf(YType.uint32, "recovery-time")

                        self.recovery_timer_remaining_seconds = YLeaf(YType.uint32, "recovery-timer-remaining-seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("down_nbr_down_reason",
                                        "down_nbr_flap_count",
                                        "is_graceful_restartable",
                                        "is_liveness_timer_running",
                                        "is_recovery_timer_running",
                                        "liveness_timer_remaining_seconds",
                                        "reconnect_timeout",
                                        "recovery_time",
                                        "recovery_timer_remaining_seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor.GracefulRestartAdjacency, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.Neighbor.GracefulRestartAdjacency, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.down_nbr_down_reason.is_set or
                            self.down_nbr_flap_count.is_set or
                            self.is_graceful_restartable.is_set or
                            self.is_liveness_timer_running.is_set or
                            self.is_recovery_timer_running.is_set or
                            self.liveness_timer_remaining_seconds.is_set or
                            self.reconnect_timeout.is_set or
                            self.recovery_time.is_set or
                            self.recovery_timer_remaining_seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.down_nbr_down_reason.yfilter != YFilter.not_set or
                            self.down_nbr_flap_count.yfilter != YFilter.not_set or
                            self.is_graceful_restartable.yfilter != YFilter.not_set or
                            self.is_liveness_timer_running.yfilter != YFilter.not_set or
                            self.is_recovery_timer_running.yfilter != YFilter.not_set or
                            self.liveness_timer_remaining_seconds.yfilter != YFilter.not_set or
                            self.reconnect_timeout.yfilter != YFilter.not_set or
                            self.recovery_time.yfilter != YFilter.not_set or
                            self.recovery_timer_remaining_seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "graceful-restart-adjacency" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.down_nbr_down_reason.is_set or self.down_nbr_down_reason.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.down_nbr_down_reason.get_name_leafdata())
                        if (self.down_nbr_flap_count.is_set or self.down_nbr_flap_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.down_nbr_flap_count.get_name_leafdata())
                        if (self.is_graceful_restartable.is_set or self.is_graceful_restartable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_graceful_restartable.get_name_leafdata())
                        if (self.is_liveness_timer_running.is_set or self.is_liveness_timer_running.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_liveness_timer_running.get_name_leafdata())
                        if (self.is_recovery_timer_running.is_set or self.is_recovery_timer_running.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_recovery_timer_running.get_name_leafdata())
                        if (self.liveness_timer_remaining_seconds.is_set or self.liveness_timer_remaining_seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.liveness_timer_remaining_seconds.get_name_leafdata())
                        if (self.reconnect_timeout.is_set or self.reconnect_timeout.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reconnect_timeout.get_name_leafdata())
                        if (self.recovery_time.is_set or self.recovery_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recovery_time.get_name_leafdata())
                        if (self.recovery_timer_remaining_seconds.is_set or self.recovery_timer_remaining_seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.recovery_timer_remaining_seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "down-nbr-down-reason" or name == "down-nbr-flap-count" or name == "is-graceful-restartable" or name == "is-liveness-timer-running" or name == "is-recovery-timer-running" or name == "liveness-timer-remaining-seconds" or name == "reconnect-timeout" or name == "recovery-time" or name == "recovery-timer-remaining-seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "down-nbr-down-reason"):
                            self.down_nbr_down_reason = value
                            self.down_nbr_down_reason.value_namespace = name_space
                            self.down_nbr_down_reason.value_namespace_prefix = name_space_prefix
                        if(value_path == "down-nbr-flap-count"):
                            self.down_nbr_flap_count = value
                            self.down_nbr_flap_count.value_namespace = name_space
                            self.down_nbr_flap_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-graceful-restartable"):
                            self.is_graceful_restartable = value
                            self.is_graceful_restartable.value_namespace = name_space
                            self.is_graceful_restartable.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-liveness-timer-running"):
                            self.is_liveness_timer_running = value
                            self.is_liveness_timer_running.value_namespace = name_space
                            self.is_liveness_timer_running.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-recovery-timer-running"):
                            self.is_recovery_timer_running = value
                            self.is_recovery_timer_running.value_namespace = name_space
                            self.is_recovery_timer_running.value_namespace_prefix = name_space_prefix
                        if(value_path == "liveness-timer-remaining-seconds"):
                            self.liveness_timer_remaining_seconds = value
                            self.liveness_timer_remaining_seconds.value_namespace = name_space
                            self.liveness_timer_remaining_seconds.value_namespace_prefix = name_space_prefix
                        if(value_path == "reconnect-timeout"):
                            self.reconnect_timeout = value
                            self.reconnect_timeout.value_namespace = name_space
                            self.reconnect_timeout.value_namespace_prefix = name_space_prefix
                        if(value_path == "recovery-time"):
                            self.recovery_time = value
                            self.recovery_time.value_namespace = name_space
                            self.recovery_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "recovery-timer-remaining-seconds"):
                            self.recovery_timer_remaining_seconds = value
                            self.recovery_timer_remaining_seconds.value_namespace = name_space
                            self.recovery_timer_remaining_seconds.value_namespace_prefix = name_space_prefix


                class TcpInformation(Entity):
                    """
                    MPLS LDP Neighbor TCP Information
                    
                    .. attribute:: foreign_host
                    
                    	This is the foreign host address used by TCP
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: foreign_port
                    
                    	Foreign port number
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: is_md5_on
                    
                    	Is MD5 Digest on
                    	**type**\:  bool
                    
                    .. attribute:: local_host
                    
                    	This is the local host address used by TCP
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    .. attribute:: local_port
                    
                    	Local port number
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: up_time
                    
                    	up time
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.Neighbor.TcpInformation, self).__init__()

                        self.yang_name = "tcp-information"
                        self.yang_parent_name = "neighbor"

                        self.foreign_host = YLeaf(YType.str, "foreign-host")

                        self.foreign_port = YLeaf(YType.uint16, "foreign-port")

                        self.is_md5_on = YLeaf(YType.boolean, "is-md5-on")

                        self.local_host = YLeaf(YType.str, "local-host")

                        self.local_port = YLeaf(YType.uint16, "local-port")

                        self.up_time = YLeaf(YType.str, "up-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("foreign_host",
                                        "foreign_port",
                                        "is_md5_on",
                                        "local_host",
                                        "local_port",
                                        "up_time") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor.TcpInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.Neighbor.TcpInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.foreign_host.is_set or
                            self.foreign_port.is_set or
                            self.is_md5_on.is_set or
                            self.local_host.is_set or
                            self.local_port.is_set or
                            self.up_time.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.foreign_host.yfilter != YFilter.not_set or
                            self.foreign_port.yfilter != YFilter.not_set or
                            self.is_md5_on.yfilter != YFilter.not_set or
                            self.local_host.yfilter != YFilter.not_set or
                            self.local_port.yfilter != YFilter.not_set or
                            self.up_time.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tcp-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.foreign_host.is_set or self.foreign_host.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.foreign_host.get_name_leafdata())
                        if (self.foreign_port.is_set or self.foreign_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.foreign_port.get_name_leafdata())
                        if (self.is_md5_on.is_set or self.is_md5_on.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.is_md5_on.get_name_leafdata())
                        if (self.local_host.is_set or self.local_host.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_host.get_name_leafdata())
                        if (self.local_port.is_set or self.local_port.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.local_port.get_name_leafdata())
                        if (self.up_time.is_set or self.up_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.up_time.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "foreign-host" or name == "foreign-port" or name == "is-md5-on" or name == "local-host" or name == "local-port" or name == "up-time"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "foreign-host"):
                            self.foreign_host = value
                            self.foreign_host.value_namespace = name_space
                            self.foreign_host.value_namespace_prefix = name_space_prefix
                        if(value_path == "foreign-port"):
                            self.foreign_port = value
                            self.foreign_port.value_namespace = name_space
                            self.foreign_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "is-md5-on"):
                            self.is_md5_on = value
                            self.is_md5_on.value_namespace = name_space
                            self.is_md5_on.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-host"):
                            self.local_host = value
                            self.local_host.value_namespace = name_space
                            self.local_host.value_namespace_prefix = name_space_prefix
                        if(value_path == "local-port"):
                            self.local_port = value
                            self.local_port.value_namespace = name_space
                            self.local_port.value_namespace_prefix = name_space_prefix
                        if(value_path == "up-time"):
                            self.up_time = value
                            self.up_time.value_namespace = name_space
                            self.up_time.value_namespace_prefix = name_space_prefix


                class Capabilities(Entity):
                    """
                    Capabilities sent to and received from neighbor
                    
                    .. attribute:: received_caps
                    
                    	List of received capabilities
                    	**type**\: list of    :py:class:`ReceivedCaps <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.ReceivedCaps>`
                    
                    .. attribute:: sent_caps
                    
                    	List of sent capabilities
                    	**type**\: list of    :py:class:`SentCaps <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.SentCaps>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities, self).__init__()

                        self.yang_name = "capabilities"
                        self.yang_parent_name = "neighbor"

                        self.received_caps = YList(self)
                        self.sent_caps = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities, self).__setattr__(name, value)


                    class SentCaps(Entity):
                        """
                        List of sent capabilities
                        
                        .. attribute:: cap_type  <key>
                        
                        	Capability type (IANA assigned)
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: cap_des
                        
                        	Capability description
                        	**type**\:  str
                        
                        	**length:** 0..80
                        
                        .. attribute:: capability_data
                        
                        	Capability data
                        	**type**\:  str
                        
                        .. attribute:: capability_data_length
                        
                        	Capability data length
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.SentCaps, self).__init__()

                            self.yang_name = "sent-caps"
                            self.yang_parent_name = "capabilities"

                            self.cap_type = YLeaf(YType.uint16, "cap-type")

                            self.cap_des = YLeaf(YType.str, "cap-des")

                            self.capability_data = YLeaf(YType.str, "capability-data")

                            self.capability_data_length = YLeaf(YType.uint16, "capability-data-length")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("cap_type",
                                            "cap_des",
                                            "capability_data",
                                            "capability_data_length") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.SentCaps, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.SentCaps, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.cap_type.is_set or
                                self.cap_des.is_set or
                                self.capability_data.is_set or
                                self.capability_data_length.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.cap_type.yfilter != YFilter.not_set or
                                self.cap_des.yfilter != YFilter.not_set or
                                self.capability_data.yfilter != YFilter.not_set or
                                self.capability_data_length.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sent-caps" + "[cap-type='" + self.cap_type.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.cap_type.is_set or self.cap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cap_type.get_name_leafdata())
                            if (self.cap_des.is_set or self.cap_des.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cap_des.get_name_leafdata())
                            if (self.capability_data.is_set or self.capability_data.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.capability_data.get_name_leafdata())
                            if (self.capability_data_length.is_set or self.capability_data_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.capability_data_length.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "cap-type" or name == "cap-des" or name == "capability-data" or name == "capability-data-length"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "cap-type"):
                                self.cap_type = value
                                self.cap_type.value_namespace = name_space
                                self.cap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cap-des"):
                                self.cap_des = value
                                self.cap_des.value_namespace = name_space
                                self.cap_des.value_namespace_prefix = name_space_prefix
                            if(value_path == "capability-data"):
                                self.capability_data = value
                                self.capability_data.value_namespace = name_space
                                self.capability_data.value_namespace_prefix = name_space_prefix
                            if(value_path == "capability-data-length"):
                                self.capability_data_length = value
                                self.capability_data_length.value_namespace = name_space
                                self.capability_data_length.value_namespace_prefix = name_space_prefix


                    class ReceivedCaps(Entity):
                        """
                        List of received capabilities
                        
                        .. attribute:: cap_type  <key>
                        
                        	Capability type (IANA assigned)
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        .. attribute:: cap_des
                        
                        	Capability description
                        	**type**\:  str
                        
                        	**length:** 0..80
                        
                        .. attribute:: capability_data
                        
                        	Capability data
                        	**type**\:  str
                        
                        .. attribute:: capability_data_length
                        
                        	Capability data length
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.ReceivedCaps, self).__init__()

                            self.yang_name = "received-caps"
                            self.yang_parent_name = "capabilities"

                            self.cap_type = YLeaf(YType.uint16, "cap-type")

                            self.cap_des = YLeaf(YType.str, "cap-des")

                            self.capability_data = YLeaf(YType.str, "capability-data")

                            self.capability_data_length = YLeaf(YType.uint16, "capability-data-length")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("cap_type",
                                            "cap_des",
                                            "capability_data",
                                            "capability_data_length") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.ReceivedCaps, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.ReceivedCaps, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.cap_type.is_set or
                                self.cap_des.is_set or
                                self.capability_data.is_set or
                                self.capability_data_length.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.cap_type.yfilter != YFilter.not_set or
                                self.cap_des.yfilter != YFilter.not_set or
                                self.capability_data.yfilter != YFilter.not_set or
                                self.capability_data_length.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "received-caps" + "[cap-type='" + self.cap_type.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.cap_type.is_set or self.cap_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cap_type.get_name_leafdata())
                            if (self.cap_des.is_set or self.cap_des.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cap_des.get_name_leafdata())
                            if (self.capability_data.is_set or self.capability_data.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.capability_data.get_name_leafdata())
                            if (self.capability_data_length.is_set or self.capability_data_length.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.capability_data_length.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "cap-type" or name == "cap-des" or name == "capability-data" or name == "capability-data-length"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "cap-type"):
                                self.cap_type = value
                                self.cap_type.value_namespace = name_space
                                self.cap_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cap-des"):
                                self.cap_des = value
                                self.cap_des.value_namespace = name_space
                                self.cap_des.value_namespace_prefix = name_space_prefix
                            if(value_path == "capability-data"):
                                self.capability_data = value
                                self.capability_data.value_namespace = name_space
                                self.capability_data.value_namespace_prefix = name_space_prefix
                            if(value_path == "capability-data-length"):
                                self.capability_data_length = value
                                self.capability_data_length.value_namespace = name_space
                                self.capability_data_length.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.received_caps:
                            if (c.has_data()):
                                return True
                        for c in self.sent_caps:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.received_caps:
                            if (c.has_operation()):
                                return True
                        for c in self.sent_caps:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "capabilities" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "received-caps"):
                            for c in self.received_caps:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.ReceivedCaps()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.received_caps.append(c)
                            return c

                        if (child_yang_name == "sent-caps"):
                            for c in self.sent_caps:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities.SentCaps()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.sent_caps.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "received-caps" or name == "sent-caps"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    for leaf in self.client.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.duplicate_address.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    for leaf in self.nbr_bound_address.getYLeafs():
                        if (leaf.yfilter != YFilter.not_set):
                            return True
                    return (
                        self.vrf_name.is_set or
                        self.lsr_id.is_set or
                        self.advertise_bgp_prefixes.is_set or
                        self.bgp_advertisement_state.is_set or
                        self.downstream_on_demand.is_set or
                        self.has_sp.is_set or
                        self.inbound_ipv4.is_set or
                        self.inbound_ipv6_filter.is_set or
                        self.label_space_id.is_set or
                        self.nbr_path_vector_limit.is_set or
                        self.outbound_ipv4_filter.is_set or
                        self.outbound_ipv6_filter.is_set or
                        self.peer_hold_time.is_set or
                        self.peer_keep_alive_interval.is_set or
                        self.peer_state.is_set or
                        self.session_prot_ver.is_set or
                        self.session_role.is_set or
                        self.sp_duration.is_set or
                        self.sp_filter.is_set or
                        self.sp_has_duration.is_set or
                        self.sp_state.is_set or
                        self.spht_remaining.is_set or
                        self.spht_running.is_set or
                        self.up_time_seconds.is_set or
                        (self.capabilities is not None and self.capabilities.has_data()) or
                        (self.graceful_restart_adjacency is not None and self.graceful_restart_adjacency.has_data()) or
                        (self.nbr_stats is not None and self.nbr_stats.has_data()) or
                        (self.tcp_information is not None and self.tcp_information.has_data()))

                def has_operation(self):
                    for leaf in self.client.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.duplicate_address.getYLeafs():
                        if (leaf.is_set):
                            return True
                    for leaf in self.nbr_bound_address.getYLeafs():
                        if (leaf.is_set):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set or
                        self.lsr_id.yfilter != YFilter.not_set or
                        self.advertise_bgp_prefixes.yfilter != YFilter.not_set or
                        self.bgp_advertisement_state.yfilter != YFilter.not_set or
                        self.client.yfilter != YFilter.not_set or
                        self.downstream_on_demand.yfilter != YFilter.not_set or
                        self.duplicate_address.yfilter != YFilter.not_set or
                        self.has_sp.yfilter != YFilter.not_set or
                        self.inbound_ipv4.yfilter != YFilter.not_set or
                        self.inbound_ipv6_filter.yfilter != YFilter.not_set or
                        self.label_space_id.yfilter != YFilter.not_set or
                        self.nbr_bound_address.yfilter != YFilter.not_set or
                        self.nbr_path_vector_limit.yfilter != YFilter.not_set or
                        self.outbound_ipv4_filter.yfilter != YFilter.not_set or
                        self.outbound_ipv6_filter.yfilter != YFilter.not_set or
                        self.peer_hold_time.yfilter != YFilter.not_set or
                        self.peer_keep_alive_interval.yfilter != YFilter.not_set or
                        self.peer_state.yfilter != YFilter.not_set or
                        self.session_prot_ver.yfilter != YFilter.not_set or
                        self.session_role.yfilter != YFilter.not_set or
                        self.sp_duration.yfilter != YFilter.not_set or
                        self.sp_filter.yfilter != YFilter.not_set or
                        self.sp_has_duration.yfilter != YFilter.not_set or
                        self.sp_state.yfilter != YFilter.not_set or
                        self.spht_remaining.yfilter != YFilter.not_set or
                        self.spht_running.yfilter != YFilter.not_set or
                        self.up_time_seconds.yfilter != YFilter.not_set or
                        (self.capabilities is not None and self.capabilities.has_operation()) or
                        (self.graceful_restart_adjacency is not None and self.graceful_restart_adjacency.has_operation()) or
                        (self.nbr_stats is not None and self.nbr_stats.has_operation()) or
                        (self.tcp_information is not None and self.tcp_information.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "neighbor" + "[vrf-name='" + self.vrf_name.get() + "']" + "[lsr-id='" + self.lsr_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())
                    if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsr_id.get_name_leafdata())
                    if (self.advertise_bgp_prefixes.is_set or self.advertise_bgp_prefixes.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.advertise_bgp_prefixes.get_name_leafdata())
                    if (self.bgp_advertisement_state.is_set or self.bgp_advertisement_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bgp_advertisement_state.get_name_leafdata())
                    if (self.downstream_on_demand.is_set or self.downstream_on_demand.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.downstream_on_demand.get_name_leafdata())
                    if (self.has_sp.is_set or self.has_sp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.has_sp.get_name_leafdata())
                    if (self.inbound_ipv4.is_set or self.inbound_ipv4.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.inbound_ipv4.get_name_leafdata())
                    if (self.inbound_ipv6_filter.is_set or self.inbound_ipv6_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.inbound_ipv6_filter.get_name_leafdata())
                    if (self.label_space_id.is_set or self.label_space_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.label_space_id.get_name_leafdata())
                    if (self.nbr_path_vector_limit.is_set or self.nbr_path_vector_limit.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nbr_path_vector_limit.get_name_leafdata())
                    if (self.outbound_ipv4_filter.is_set or self.outbound_ipv4_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.outbound_ipv4_filter.get_name_leafdata())
                    if (self.outbound_ipv6_filter.is_set or self.outbound_ipv6_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.outbound_ipv6_filter.get_name_leafdata())
                    if (self.peer_hold_time.is_set or self.peer_hold_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_hold_time.get_name_leafdata())
                    if (self.peer_keep_alive_interval.is_set or self.peer_keep_alive_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_keep_alive_interval.get_name_leafdata())
                    if (self.peer_state.is_set or self.peer_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.peer_state.get_name_leafdata())
                    if (self.session_prot_ver.is_set or self.session_prot_ver.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_prot_ver.get_name_leafdata())
                    if (self.session_role.is_set or self.session_role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_role.get_name_leafdata())
                    if (self.sp_duration.is_set or self.sp_duration.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sp_duration.get_name_leafdata())
                    if (self.sp_filter.is_set or self.sp_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sp_filter.get_name_leafdata())
                    if (self.sp_has_duration.is_set or self.sp_has_duration.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sp_has_duration.get_name_leafdata())
                    if (self.sp_state.is_set or self.sp_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sp_state.get_name_leafdata())
                    if (self.spht_remaining.is_set or self.spht_remaining.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.spht_remaining.get_name_leafdata())
                    if (self.spht_running.is_set or self.spht_running.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.spht_running.get_name_leafdata())
                    if (self.up_time_seconds.is_set or self.up_time_seconds.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_time_seconds.get_name_leafdata())

                    leaf_name_data.extend(self.client.get_name_leafdata())

                    leaf_name_data.extend(self.duplicate_address.get_name_leafdata())

                    leaf_name_data.extend(self.nbr_bound_address.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "capabilities"):
                        if (self.capabilities is None):
                            self.capabilities = MplsLdp.MplsLdpState.Neighbors.Neighbor.Capabilities()
                            self.capabilities.parent = self
                            self._children_name_map["capabilities"] = "capabilities"
                        return self.capabilities

                    if (child_yang_name == "graceful-restart-adjacency"):
                        if (self.graceful_restart_adjacency is None):
                            self.graceful_restart_adjacency = MplsLdp.MplsLdpState.Neighbors.Neighbor.GracefulRestartAdjacency()
                            self.graceful_restart_adjacency.parent = self
                            self._children_name_map["graceful_restart_adjacency"] = "graceful-restart-adjacency"
                        return self.graceful_restart_adjacency

                    if (child_yang_name == "nbr-stats"):
                        if (self.nbr_stats is None):
                            self.nbr_stats = MplsLdp.MplsLdpState.Neighbors.Neighbor.NbrStats()
                            self.nbr_stats.parent = self
                            self._children_name_map["nbr_stats"] = "nbr-stats"
                        return self.nbr_stats

                    if (child_yang_name == "tcp-information"):
                        if (self.tcp_information is None):
                            self.tcp_information = MplsLdp.MplsLdpState.Neighbors.Neighbor.TcpInformation()
                            self.tcp_information.parent = self
                            self._children_name_map["tcp_information"] = "tcp-information"
                        return self.tcp_information

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "capabilities" or name == "graceful-restart-adjacency" or name == "nbr-stats" or name == "tcp-information" or name == "vrf-name" or name == "lsr-id" or name == "advertise-bgp-prefixes" or name == "bgp-advertisement-state" or name == "client" or name == "downstream-on-demand" or name == "duplicate-address" or name == "has-sp" or name == "inbound-ipv4" or name == "inbound-ipv6-filter" or name == "label-space-id" or name == "nbr-bound-address" or name == "nbr-path-vector-limit" or name == "outbound-ipv4-filter" or name == "outbound-ipv6-filter" or name == "peer-hold-time" or name == "peer-keep-alive-interval" or name == "peer-state" or name == "session-prot-ver" or name == "session-role" or name == "sp-duration" or name == "sp-filter" or name == "sp-has-duration" or name == "sp-state" or name == "spht-remaining" or name == "spht-running" or name == "up-time-seconds"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsr-id"):
                        self.lsr_id = value
                        self.lsr_id.value_namespace = name_space
                        self.lsr_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "advertise-bgp-prefixes"):
                        self.advertise_bgp_prefixes = value
                        self.advertise_bgp_prefixes.value_namespace = name_space
                        self.advertise_bgp_prefixes.value_namespace_prefix = name_space_prefix
                    if(value_path == "bgp-advertisement-state"):
                        self.bgp_advertisement_state = value
                        self.bgp_advertisement_state.value_namespace = name_space
                        self.bgp_advertisement_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "client"):
                        self.client.append(value)
                    if(value_path == "downstream-on-demand"):
                        self.downstream_on_demand = value
                        self.downstream_on_demand.value_namespace = name_space
                        self.downstream_on_demand.value_namespace_prefix = name_space_prefix
                    if(value_path == "duplicate-address"):
                        self.duplicate_address.append(value)
                    if(value_path == "has-sp"):
                        self.has_sp = value
                        self.has_sp.value_namespace = name_space
                        self.has_sp.value_namespace_prefix = name_space_prefix
                    if(value_path == "inbound-ipv4"):
                        self.inbound_ipv4 = value
                        self.inbound_ipv4.value_namespace = name_space
                        self.inbound_ipv4.value_namespace_prefix = name_space_prefix
                    if(value_path == "inbound-ipv6-filter"):
                        self.inbound_ipv6_filter = value
                        self.inbound_ipv6_filter.value_namespace = name_space
                        self.inbound_ipv6_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "label-space-id"):
                        self.label_space_id = value
                        self.label_space_id.value_namespace = name_space
                        self.label_space_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "nbr-bound-address"):
                        self.nbr_bound_address.append(value)
                    if(value_path == "nbr-path-vector-limit"):
                        self.nbr_path_vector_limit = value
                        self.nbr_path_vector_limit.value_namespace = name_space
                        self.nbr_path_vector_limit.value_namespace_prefix = name_space_prefix
                    if(value_path == "outbound-ipv4-filter"):
                        self.outbound_ipv4_filter = value
                        self.outbound_ipv4_filter.value_namespace = name_space
                        self.outbound_ipv4_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "outbound-ipv6-filter"):
                        self.outbound_ipv6_filter = value
                        self.outbound_ipv6_filter.value_namespace = name_space
                        self.outbound_ipv6_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-hold-time"):
                        self.peer_hold_time = value
                        self.peer_hold_time.value_namespace = name_space
                        self.peer_hold_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-keep-alive-interval"):
                        self.peer_keep_alive_interval = value
                        self.peer_keep_alive_interval.value_namespace = name_space
                        self.peer_keep_alive_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "peer-state"):
                        self.peer_state = value
                        self.peer_state.value_namespace = name_space
                        self.peer_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-prot-ver"):
                        self.session_prot_ver = value
                        self.session_prot_ver.value_namespace = name_space
                        self.session_prot_ver.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-role"):
                        self.session_role = value
                        self.session_role.value_namespace = name_space
                        self.session_role.value_namespace_prefix = name_space_prefix
                    if(value_path == "sp-duration"):
                        self.sp_duration = value
                        self.sp_duration.value_namespace = name_space
                        self.sp_duration.value_namespace_prefix = name_space_prefix
                    if(value_path == "sp-filter"):
                        self.sp_filter = value
                        self.sp_filter.value_namespace = name_space
                        self.sp_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "sp-has-duration"):
                        self.sp_has_duration = value
                        self.sp_has_duration.value_namespace = name_space
                        self.sp_has_duration.value_namespace_prefix = name_space_prefix
                    if(value_path == "sp-state"):
                        self.sp_state = value
                        self.sp_state.value_namespace = name_space
                        self.sp_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "spht-remaining"):
                        self.spht_remaining = value
                        self.spht_remaining.value_namespace = name_space
                        self.spht_remaining.value_namespace_prefix = name_space_prefix
                    if(value_path == "spht-running"):
                        self.spht_running = value
                        self.spht_running.value_namespace = name_space
                        self.spht_running.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-time-seconds"):
                        self.up_time_seconds = value
                        self.up_time_seconds.value_namespace = name_space
                        self.up_time_seconds.value_namespace_prefix = name_space_prefix


            class NbrAdjs(Entity):
                """
                For this Neighbor, this is the list of adjacencies
                between the neighbor and the local node.
                
                .. attribute:: interface
                
                	This is the interface used by MPLS LDP Link Hello
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                
                .. attribute:: local_address
                
                	This is the local address used to send the Targeted Hello
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: target_address
                
                	This is the destination address used to send the Targeted Hello
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: target_state
                
                	This is the state of this Targeted Hello instance
                	**type**\:   :py:class:`DhcState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.DhcState>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Neighbors.NbrAdjs, self).__init__()

                    self.yang_name = "nbr-adjs"
                    self.yang_parent_name = "neighbors"

                    self.interface = YLeaf(YType.str, "interface")

                    self.local_address = YLeaf(YType.str, "local-address")

                    self.target_address = YLeaf(YType.str, "target-address")

                    self.target_state = YLeaf(YType.enumeration, "target-state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interface",
                                    "local_address",
                                    "target_address",
                                    "target_state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Neighbors.NbrAdjs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Neighbors.NbrAdjs, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interface.is_set or
                        self.local_address.is_set or
                        self.target_address.is_set or
                        self.target_state.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.local_address.yfilter != YFilter.not_set or
                        self.target_address.yfilter != YFilter.not_set or
                        self.target_state.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nbr-adjs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.local_address.is_set or self.local_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.local_address.get_name_leafdata())
                    if (self.target_address.is_set or self.target_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.target_address.get_name_leafdata())
                    if (self.target_state.is_set or self.target_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.target_state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interface" or name == "local-address" or name == "target-address" or name == "target-state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "local-address"):
                        self.local_address = value
                        self.local_address.value_namespace = name_space
                        self.local_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "target-address"):
                        self.target_address = value
                        self.target_address.value_namespace = name_space
                        self.target_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "target-state"):
                        self.target_state = value
                        self.target_state.value_namespace = name_space
                        self.target_state.value_namespace_prefix = name_space_prefix


            class StatsInfo(Entity):
                """
                MPLS LDP Statistics Information
                
                .. attribute:: bad_ldpid
                
                	This object counts the number of Bad LDP Identifier Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: bad_msg_len
                
                	This object counts the number of Bad Message Length Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: bad_pdu_len
                
                	This object counts the number of Bad PDU Length Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: bad_tlv_len
                
                	This object counts the number of Bad TLV Length Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: discon_time
                
                	The value of sysUpTime on the most recent occasion at which any one or more of this entity's counters suffered a discontinuity.  The relevant counters are the specific instances associated with this entity of any counter32 object contained in the 'EntityStatsTable'.  If no such discontinuities have occurred since the last re\-initialization of the local management subsystem, then this object contains a zero value
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: keep_alive_exp
                
                	This object counts the number of Session Keep Alive Timer Expired Errors detected by the session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: malformed_tlv_val
                
                	This object counts the number of Malformed TLV Value Fatal Errors detected by the session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: message_in
                
                	MPLS LDP message received counters from this neighbor
                	**type**\:   :py:class:`MessageIn <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageIn>`
                
                .. attribute:: message_out
                
                	MPLS LDP message sent counters to this neighbor
                	**type**\:   :py:class:`MessageOut <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageOut>`
                
                .. attribute:: sess_rej_ad
                
                	A count of the Session Rejected/Parameters Advertisement Mode Error Notification Messages sent or received by this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: sess_rej_lr
                
                	A count of the Session Rejected/Parameters Label Range Notification Messages sent or received by this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: sess_rej_max_pdu
                
                	A count of the Session Rejected/Parameters  Max Pdu Length Error Notification Messages sent or received by this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: sess_reject_no_hello
                
                	A count of the Session Rejected/No Hello Error Notification Messages sent or received by this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: session_attempts
                
                	A count of the Session Initialization messages which were sent or received by this LDP Entity and were NAK'd.   In other words, this counter counts the number of session initializations that failed.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: shutdow_notif_sent
                
                	This object counts the number of Shutdown Notfications sent related to session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of  discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: shutdown_notif_rec
                
                	This object counts the number of Shutdown Notifications received related to session(s) (past and present) associated with this LDP Entity.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Neighbors.StatsInfo, self).__init__()

                    self.yang_name = "stats-info"
                    self.yang_parent_name = "neighbors"

                    self.bad_ldpid = YLeaf(YType.uint32, "bad-ldpid")

                    self.bad_msg_len = YLeaf(YType.uint32, "bad-msg-len")

                    self.bad_pdu_len = YLeaf(YType.uint32, "bad-pdu-len")

                    self.bad_tlv_len = YLeaf(YType.uint32, "bad-tlv-len")

                    self.discon_time = YLeaf(YType.uint32, "discon-time")

                    self.keep_alive_exp = YLeaf(YType.uint32, "keep-alive-exp")

                    self.malformed_tlv_val = YLeaf(YType.uint32, "malformed-tlv-val")

                    self.sess_rej_ad = YLeaf(YType.uint32, "sess-rej-ad")

                    self.sess_rej_lr = YLeaf(YType.uint32, "sess-rej-lr")

                    self.sess_rej_max_pdu = YLeaf(YType.uint32, "sess-rej-max-pdu")

                    self.sess_reject_no_hello = YLeaf(YType.uint32, "sess-reject-no-hello")

                    self.session_attempts = YLeaf(YType.uint32, "session-attempts")

                    self.shutdow_notif_sent = YLeaf(YType.uint32, "shutdow-notif-sent")

                    self.shutdown_notif_rec = YLeaf(YType.uint32, "shutdown-notif-rec")

                    self.message_in = MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageIn()
                    self.message_in.parent = self
                    self._children_name_map["message_in"] = "message-in"
                    self._children_yang_names.add("message-in")

                    self.message_out = MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageOut()
                    self.message_out.parent = self
                    self._children_name_map["message_out"] = "message-out"
                    self._children_yang_names.add("message-out")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("bad_ldpid",
                                    "bad_msg_len",
                                    "bad_pdu_len",
                                    "bad_tlv_len",
                                    "discon_time",
                                    "keep_alive_exp",
                                    "malformed_tlv_val",
                                    "sess_rej_ad",
                                    "sess_rej_lr",
                                    "sess_rej_max_pdu",
                                    "sess_reject_no_hello",
                                    "session_attempts",
                                    "shutdow_notif_sent",
                                    "shutdown_notif_rec") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Neighbors.StatsInfo, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Neighbors.StatsInfo, self).__setattr__(name, value)


                class MessageOut(Entity):
                    """
                    MPLS LDP message sent counters to this neighbor.
                    
                    .. attribute:: address_count
                    
                    	Address message count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: address_withdraw_count
                    
                    	Address withdraw count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_app_data_count
                    
                    	ICCP RG App Data count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_conn_count
                    
                    	ICCP RG Connect count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_disconn_count
                    
                    	ICCP RG Disconnect count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_notif_count
                    
                    	ICCP RG Notify count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: init_count
                    
                    	Init message count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: keep_alive_count
                    
                    	Keepalive count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_abort_request_count
                    
                    	Label abort request count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_map_count
                    
                    	Label map count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_release_count
                    
                    	Label release count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_request_count
                    
                    	Label request count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_withdraw_count
                    
                    	Label withdraw count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: notification_count
                    
                    	Notification count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_count
                    
                    	Total count of all messages
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageOut, self).__init__()

                        self.yang_name = "message-out"
                        self.yang_parent_name = "stats-info"

                        self.address_count = YLeaf(YType.uint32, "address-count")

                        self.address_withdraw_count = YLeaf(YType.uint32, "address-withdraw-count")

                        self.iccp_rg_app_data_count = YLeaf(YType.uint32, "iccp-rg-app-data-count")

                        self.iccp_rg_conn_count = YLeaf(YType.uint32, "iccp-rg-conn-count")

                        self.iccp_rg_disconn_count = YLeaf(YType.uint32, "iccp-rg-disconn-count")

                        self.iccp_rg_notif_count = YLeaf(YType.uint32, "iccp-rg-notif-count")

                        self.init_count = YLeaf(YType.uint32, "init-count")

                        self.keep_alive_count = YLeaf(YType.uint32, "keep-alive-count")

                        self.label_abort_request_count = YLeaf(YType.uint32, "label-abort-request-count")

                        self.label_map_count = YLeaf(YType.uint32, "label-map-count")

                        self.label_release_count = YLeaf(YType.uint32, "label-release-count")

                        self.label_request_count = YLeaf(YType.uint32, "label-request-count")

                        self.label_withdraw_count = YLeaf(YType.uint32, "label-withdraw-count")

                        self.notification_count = YLeaf(YType.uint32, "notification-count")

                        self.total_count = YLeaf(YType.uint32, "total-count")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("address_count",
                                        "address_withdraw_count",
                                        "iccp_rg_app_data_count",
                                        "iccp_rg_conn_count",
                                        "iccp_rg_disconn_count",
                                        "iccp_rg_notif_count",
                                        "init_count",
                                        "keep_alive_count",
                                        "label_abort_request_count",
                                        "label_map_count",
                                        "label_release_count",
                                        "label_request_count",
                                        "label_withdraw_count",
                                        "notification_count",
                                        "total_count") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageOut, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageOut, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.address_count.is_set or
                            self.address_withdraw_count.is_set or
                            self.iccp_rg_app_data_count.is_set or
                            self.iccp_rg_conn_count.is_set or
                            self.iccp_rg_disconn_count.is_set or
                            self.iccp_rg_notif_count.is_set or
                            self.init_count.is_set or
                            self.keep_alive_count.is_set or
                            self.label_abort_request_count.is_set or
                            self.label_map_count.is_set or
                            self.label_release_count.is_set or
                            self.label_request_count.is_set or
                            self.label_withdraw_count.is_set or
                            self.notification_count.is_set or
                            self.total_count.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.address_count.yfilter != YFilter.not_set or
                            self.address_withdraw_count.yfilter != YFilter.not_set or
                            self.iccp_rg_app_data_count.yfilter != YFilter.not_set or
                            self.iccp_rg_conn_count.yfilter != YFilter.not_set or
                            self.iccp_rg_disconn_count.yfilter != YFilter.not_set or
                            self.iccp_rg_notif_count.yfilter != YFilter.not_set or
                            self.init_count.yfilter != YFilter.not_set or
                            self.keep_alive_count.yfilter != YFilter.not_set or
                            self.label_abort_request_count.yfilter != YFilter.not_set or
                            self.label_map_count.yfilter != YFilter.not_set or
                            self.label_release_count.yfilter != YFilter.not_set or
                            self.label_request_count.yfilter != YFilter.not_set or
                            self.label_withdraw_count.yfilter != YFilter.not_set or
                            self.notification_count.yfilter != YFilter.not_set or
                            self.total_count.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "message-out" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/stats-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.address_count.is_set or self.address_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address_count.get_name_leafdata())
                        if (self.address_withdraw_count.is_set or self.address_withdraw_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address_withdraw_count.get_name_leafdata())
                        if (self.iccp_rg_app_data_count.is_set or self.iccp_rg_app_data_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_app_data_count.get_name_leafdata())
                        if (self.iccp_rg_conn_count.is_set or self.iccp_rg_conn_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_conn_count.get_name_leafdata())
                        if (self.iccp_rg_disconn_count.is_set or self.iccp_rg_disconn_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_disconn_count.get_name_leafdata())
                        if (self.iccp_rg_notif_count.is_set or self.iccp_rg_notif_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_notif_count.get_name_leafdata())
                        if (self.init_count.is_set or self.init_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.init_count.get_name_leafdata())
                        if (self.keep_alive_count.is_set or self.keep_alive_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_count.get_name_leafdata())
                        if (self.label_abort_request_count.is_set or self.label_abort_request_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_abort_request_count.get_name_leafdata())
                        if (self.label_map_count.is_set or self.label_map_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_map_count.get_name_leafdata())
                        if (self.label_release_count.is_set or self.label_release_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_release_count.get_name_leafdata())
                        if (self.label_request_count.is_set or self.label_request_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_request_count.get_name_leafdata())
                        if (self.label_withdraw_count.is_set or self.label_withdraw_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_withdraw_count.get_name_leafdata())
                        if (self.notification_count.is_set or self.notification_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.notification_count.get_name_leafdata())
                        if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_count.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address-count" or name == "address-withdraw-count" or name == "iccp-rg-app-data-count" or name == "iccp-rg-conn-count" or name == "iccp-rg-disconn-count" or name == "iccp-rg-notif-count" or name == "init-count" or name == "keep-alive-count" or name == "label-abort-request-count" or name == "label-map-count" or name == "label-release-count" or name == "label-request-count" or name == "label-withdraw-count" or name == "notification-count" or name == "total-count"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "address-count"):
                            self.address_count = value
                            self.address_count.value_namespace = name_space
                            self.address_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "address-withdraw-count"):
                            self.address_withdraw_count = value
                            self.address_withdraw_count.value_namespace = name_space
                            self.address_withdraw_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-app-data-count"):
                            self.iccp_rg_app_data_count = value
                            self.iccp_rg_app_data_count.value_namespace = name_space
                            self.iccp_rg_app_data_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-conn-count"):
                            self.iccp_rg_conn_count = value
                            self.iccp_rg_conn_count.value_namespace = name_space
                            self.iccp_rg_conn_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-disconn-count"):
                            self.iccp_rg_disconn_count = value
                            self.iccp_rg_disconn_count.value_namespace = name_space
                            self.iccp_rg_disconn_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-notif-count"):
                            self.iccp_rg_notif_count = value
                            self.iccp_rg_notif_count.value_namespace = name_space
                            self.iccp_rg_notif_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "init-count"):
                            self.init_count = value
                            self.init_count.value_namespace = name_space
                            self.init_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-count"):
                            self.keep_alive_count = value
                            self.keep_alive_count.value_namespace = name_space
                            self.keep_alive_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-abort-request-count"):
                            self.label_abort_request_count = value
                            self.label_abort_request_count.value_namespace = name_space
                            self.label_abort_request_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-map-count"):
                            self.label_map_count = value
                            self.label_map_count.value_namespace = name_space
                            self.label_map_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-release-count"):
                            self.label_release_count = value
                            self.label_release_count.value_namespace = name_space
                            self.label_release_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-request-count"):
                            self.label_request_count = value
                            self.label_request_count.value_namespace = name_space
                            self.label_request_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-withdraw-count"):
                            self.label_withdraw_count = value
                            self.label_withdraw_count.value_namespace = name_space
                            self.label_withdraw_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "notification-count"):
                            self.notification_count = value
                            self.notification_count.value_namespace = name_space
                            self.notification_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-count"):
                            self.total_count = value
                            self.total_count.value_namespace = name_space
                            self.total_count.value_namespace_prefix = name_space_prefix


                class MessageIn(Entity):
                    """
                    MPLS LDP message received counters from this
                    neighbor.
                    
                    .. attribute:: address_count
                    
                    	Address message count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: address_withdraw_count
                    
                    	Address withdraw count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_app_data_count
                    
                    	ICCP RG App Data count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_conn_count
                    
                    	ICCP RG Connect count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_disconn_count
                    
                    	ICCP RG Disconnect count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: iccp_rg_notif_count
                    
                    	ICCP RG Notify count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: init_count
                    
                    	Init message count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: keep_alive_count
                    
                    	Keepalive count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_abort_request_count
                    
                    	Label abort request count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_map_count
                    
                    	Label map count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_release_count
                    
                    	Label release count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_request_count
                    
                    	Label request count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: label_withdraw_count
                    
                    	Label withdraw count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: notification_count
                    
                    	Notification count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_count
                    
                    	Total count of all messages
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageIn, self).__init__()

                        self.yang_name = "message-in"
                        self.yang_parent_name = "stats-info"

                        self.address_count = YLeaf(YType.uint32, "address-count")

                        self.address_withdraw_count = YLeaf(YType.uint32, "address-withdraw-count")

                        self.iccp_rg_app_data_count = YLeaf(YType.uint32, "iccp-rg-app-data-count")

                        self.iccp_rg_conn_count = YLeaf(YType.uint32, "iccp-rg-conn-count")

                        self.iccp_rg_disconn_count = YLeaf(YType.uint32, "iccp-rg-disconn-count")

                        self.iccp_rg_notif_count = YLeaf(YType.uint32, "iccp-rg-notif-count")

                        self.init_count = YLeaf(YType.uint32, "init-count")

                        self.keep_alive_count = YLeaf(YType.uint32, "keep-alive-count")

                        self.label_abort_request_count = YLeaf(YType.uint32, "label-abort-request-count")

                        self.label_map_count = YLeaf(YType.uint32, "label-map-count")

                        self.label_release_count = YLeaf(YType.uint32, "label-release-count")

                        self.label_request_count = YLeaf(YType.uint32, "label-request-count")

                        self.label_withdraw_count = YLeaf(YType.uint32, "label-withdraw-count")

                        self.notification_count = YLeaf(YType.uint32, "notification-count")

                        self.total_count = YLeaf(YType.uint32, "total-count")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("address_count",
                                        "address_withdraw_count",
                                        "iccp_rg_app_data_count",
                                        "iccp_rg_conn_count",
                                        "iccp_rg_disconn_count",
                                        "iccp_rg_notif_count",
                                        "init_count",
                                        "keep_alive_count",
                                        "label_abort_request_count",
                                        "label_map_count",
                                        "label_release_count",
                                        "label_request_count",
                                        "label_withdraw_count",
                                        "notification_count",
                                        "total_count") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageIn, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageIn, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.address_count.is_set or
                            self.address_withdraw_count.is_set or
                            self.iccp_rg_app_data_count.is_set or
                            self.iccp_rg_conn_count.is_set or
                            self.iccp_rg_disconn_count.is_set or
                            self.iccp_rg_notif_count.is_set or
                            self.init_count.is_set or
                            self.keep_alive_count.is_set or
                            self.label_abort_request_count.is_set or
                            self.label_map_count.is_set or
                            self.label_release_count.is_set or
                            self.label_request_count.is_set or
                            self.label_withdraw_count.is_set or
                            self.notification_count.is_set or
                            self.total_count.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.address_count.yfilter != YFilter.not_set or
                            self.address_withdraw_count.yfilter != YFilter.not_set or
                            self.iccp_rg_app_data_count.yfilter != YFilter.not_set or
                            self.iccp_rg_conn_count.yfilter != YFilter.not_set or
                            self.iccp_rg_disconn_count.yfilter != YFilter.not_set or
                            self.iccp_rg_notif_count.yfilter != YFilter.not_set or
                            self.init_count.yfilter != YFilter.not_set or
                            self.keep_alive_count.yfilter != YFilter.not_set or
                            self.label_abort_request_count.yfilter != YFilter.not_set or
                            self.label_map_count.yfilter != YFilter.not_set or
                            self.label_release_count.yfilter != YFilter.not_set or
                            self.label_request_count.yfilter != YFilter.not_set or
                            self.label_withdraw_count.yfilter != YFilter.not_set or
                            self.notification_count.yfilter != YFilter.not_set or
                            self.total_count.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "message-in" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/stats-info/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.address_count.is_set or self.address_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address_count.get_name_leafdata())
                        if (self.address_withdraw_count.is_set or self.address_withdraw_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address_withdraw_count.get_name_leafdata())
                        if (self.iccp_rg_app_data_count.is_set or self.iccp_rg_app_data_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_app_data_count.get_name_leafdata())
                        if (self.iccp_rg_conn_count.is_set or self.iccp_rg_conn_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_conn_count.get_name_leafdata())
                        if (self.iccp_rg_disconn_count.is_set or self.iccp_rg_disconn_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_disconn_count.get_name_leafdata())
                        if (self.iccp_rg_notif_count.is_set or self.iccp_rg_notif_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.iccp_rg_notif_count.get_name_leafdata())
                        if (self.init_count.is_set or self.init_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.init_count.get_name_leafdata())
                        if (self.keep_alive_count.is_set or self.keep_alive_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_count.get_name_leafdata())
                        if (self.label_abort_request_count.is_set or self.label_abort_request_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_abort_request_count.get_name_leafdata())
                        if (self.label_map_count.is_set or self.label_map_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_map_count.get_name_leafdata())
                        if (self.label_release_count.is_set or self.label_release_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_release_count.get_name_leafdata())
                        if (self.label_request_count.is_set or self.label_request_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_request_count.get_name_leafdata())
                        if (self.label_withdraw_count.is_set or self.label_withdraw_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_withdraw_count.get_name_leafdata())
                        if (self.notification_count.is_set or self.notification_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.notification_count.get_name_leafdata())
                        if (self.total_count.is_set or self.total_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_count.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "address-count" or name == "address-withdraw-count" or name == "iccp-rg-app-data-count" or name == "iccp-rg-conn-count" or name == "iccp-rg-disconn-count" or name == "iccp-rg-notif-count" or name == "init-count" or name == "keep-alive-count" or name == "label-abort-request-count" or name == "label-map-count" or name == "label-release-count" or name == "label-request-count" or name == "label-withdraw-count" or name == "notification-count" or name == "total-count"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "address-count"):
                            self.address_count = value
                            self.address_count.value_namespace = name_space
                            self.address_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "address-withdraw-count"):
                            self.address_withdraw_count = value
                            self.address_withdraw_count.value_namespace = name_space
                            self.address_withdraw_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-app-data-count"):
                            self.iccp_rg_app_data_count = value
                            self.iccp_rg_app_data_count.value_namespace = name_space
                            self.iccp_rg_app_data_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-conn-count"):
                            self.iccp_rg_conn_count = value
                            self.iccp_rg_conn_count.value_namespace = name_space
                            self.iccp_rg_conn_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-disconn-count"):
                            self.iccp_rg_disconn_count = value
                            self.iccp_rg_disconn_count.value_namespace = name_space
                            self.iccp_rg_disconn_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "iccp-rg-notif-count"):
                            self.iccp_rg_notif_count = value
                            self.iccp_rg_notif_count.value_namespace = name_space
                            self.iccp_rg_notif_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "init-count"):
                            self.init_count = value
                            self.init_count.value_namespace = name_space
                            self.init_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-count"):
                            self.keep_alive_count = value
                            self.keep_alive_count.value_namespace = name_space
                            self.keep_alive_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-abort-request-count"):
                            self.label_abort_request_count = value
                            self.label_abort_request_count.value_namespace = name_space
                            self.label_abort_request_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-map-count"):
                            self.label_map_count = value
                            self.label_map_count.value_namespace = name_space
                            self.label_map_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-release-count"):
                            self.label_release_count = value
                            self.label_release_count.value_namespace = name_space
                            self.label_release_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-request-count"):
                            self.label_request_count = value
                            self.label_request_count.value_namespace = name_space
                            self.label_request_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "label-withdraw-count"):
                            self.label_withdraw_count = value
                            self.label_withdraw_count.value_namespace = name_space
                            self.label_withdraw_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "notification-count"):
                            self.notification_count = value
                            self.notification_count.value_namespace = name_space
                            self.notification_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-count"):
                            self.total_count = value
                            self.total_count.value_namespace = name_space
                            self.total_count.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.bad_ldpid.is_set or
                        self.bad_msg_len.is_set or
                        self.bad_pdu_len.is_set or
                        self.bad_tlv_len.is_set or
                        self.discon_time.is_set or
                        self.keep_alive_exp.is_set or
                        self.malformed_tlv_val.is_set or
                        self.sess_rej_ad.is_set or
                        self.sess_rej_lr.is_set or
                        self.sess_rej_max_pdu.is_set or
                        self.sess_reject_no_hello.is_set or
                        self.session_attempts.is_set or
                        self.shutdow_notif_sent.is_set or
                        self.shutdown_notif_rec.is_set or
                        (self.message_in is not None and self.message_in.has_data()) or
                        (self.message_out is not None and self.message_out.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.bad_ldpid.yfilter != YFilter.not_set or
                        self.bad_msg_len.yfilter != YFilter.not_set or
                        self.bad_pdu_len.yfilter != YFilter.not_set or
                        self.bad_tlv_len.yfilter != YFilter.not_set or
                        self.discon_time.yfilter != YFilter.not_set or
                        self.keep_alive_exp.yfilter != YFilter.not_set or
                        self.malformed_tlv_val.yfilter != YFilter.not_set or
                        self.sess_rej_ad.yfilter != YFilter.not_set or
                        self.sess_rej_lr.yfilter != YFilter.not_set or
                        self.sess_rej_max_pdu.yfilter != YFilter.not_set or
                        self.sess_reject_no_hello.yfilter != YFilter.not_set or
                        self.session_attempts.yfilter != YFilter.not_set or
                        self.shutdow_notif_sent.yfilter != YFilter.not_set or
                        self.shutdown_notif_rec.yfilter != YFilter.not_set or
                        (self.message_in is not None and self.message_in.has_operation()) or
                        (self.message_out is not None and self.message_out.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "stats-info" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.bad_ldpid.is_set or self.bad_ldpid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bad_ldpid.get_name_leafdata())
                    if (self.bad_msg_len.is_set or self.bad_msg_len.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bad_msg_len.get_name_leafdata())
                    if (self.bad_pdu_len.is_set or self.bad_pdu_len.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bad_pdu_len.get_name_leafdata())
                    if (self.bad_tlv_len.is_set or self.bad_tlv_len.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bad_tlv_len.get_name_leafdata())
                    if (self.discon_time.is_set or self.discon_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.discon_time.get_name_leafdata())
                    if (self.keep_alive_exp.is_set or self.keep_alive_exp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.keep_alive_exp.get_name_leafdata())
                    if (self.malformed_tlv_val.is_set or self.malformed_tlv_val.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.malformed_tlv_val.get_name_leafdata())
                    if (self.sess_rej_ad.is_set or self.sess_rej_ad.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sess_rej_ad.get_name_leafdata())
                    if (self.sess_rej_lr.is_set or self.sess_rej_lr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sess_rej_lr.get_name_leafdata())
                    if (self.sess_rej_max_pdu.is_set or self.sess_rej_max_pdu.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sess_rej_max_pdu.get_name_leafdata())
                    if (self.sess_reject_no_hello.is_set or self.sess_reject_no_hello.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sess_reject_no_hello.get_name_leafdata())
                    if (self.session_attempts.is_set or self.session_attempts.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.session_attempts.get_name_leafdata())
                    if (self.shutdow_notif_sent.is_set or self.shutdow_notif_sent.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.shutdow_notif_sent.get_name_leafdata())
                    if (self.shutdown_notif_rec.is_set or self.shutdown_notif_rec.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.shutdown_notif_rec.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "message-in"):
                        if (self.message_in is None):
                            self.message_in = MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageIn()
                            self.message_in.parent = self
                            self._children_name_map["message_in"] = "message-in"
                        return self.message_in

                    if (child_yang_name == "message-out"):
                        if (self.message_out is None):
                            self.message_out = MplsLdp.MplsLdpState.Neighbors.StatsInfo.MessageOut()
                            self.message_out.parent = self
                            self._children_name_map["message_out"] = "message-out"
                        return self.message_out

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "message-in" or name == "message-out" or name == "bad-ldpid" or name == "bad-msg-len" or name == "bad-pdu-len" or name == "bad-tlv-len" or name == "discon-time" or name == "keep-alive-exp" or name == "malformed-tlv-val" or name == "sess-rej-ad" or name == "sess-rej-lr" or name == "sess-rej-max-pdu" or name == "sess-reject-no-hello" or name == "session-attempts" or name == "shutdow-notif-sent" or name == "shutdown-notif-rec"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "bad-ldpid"):
                        self.bad_ldpid = value
                        self.bad_ldpid.value_namespace = name_space
                        self.bad_ldpid.value_namespace_prefix = name_space_prefix
                    if(value_path == "bad-msg-len"):
                        self.bad_msg_len = value
                        self.bad_msg_len.value_namespace = name_space
                        self.bad_msg_len.value_namespace_prefix = name_space_prefix
                    if(value_path == "bad-pdu-len"):
                        self.bad_pdu_len = value
                        self.bad_pdu_len.value_namespace = name_space
                        self.bad_pdu_len.value_namespace_prefix = name_space_prefix
                    if(value_path == "bad-tlv-len"):
                        self.bad_tlv_len = value
                        self.bad_tlv_len.value_namespace = name_space
                        self.bad_tlv_len.value_namespace_prefix = name_space_prefix
                    if(value_path == "discon-time"):
                        self.discon_time = value
                        self.discon_time.value_namespace = name_space
                        self.discon_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "keep-alive-exp"):
                        self.keep_alive_exp = value
                        self.keep_alive_exp.value_namespace = name_space
                        self.keep_alive_exp.value_namespace_prefix = name_space_prefix
                    if(value_path == "malformed-tlv-val"):
                        self.malformed_tlv_val = value
                        self.malformed_tlv_val.value_namespace = name_space
                        self.malformed_tlv_val.value_namespace_prefix = name_space_prefix
                    if(value_path == "sess-rej-ad"):
                        self.sess_rej_ad = value
                        self.sess_rej_ad.value_namespace = name_space
                        self.sess_rej_ad.value_namespace_prefix = name_space_prefix
                    if(value_path == "sess-rej-lr"):
                        self.sess_rej_lr = value
                        self.sess_rej_lr.value_namespace = name_space
                        self.sess_rej_lr.value_namespace_prefix = name_space_prefix
                    if(value_path == "sess-rej-max-pdu"):
                        self.sess_rej_max_pdu = value
                        self.sess_rej_max_pdu.value_namespace = name_space
                        self.sess_rej_max_pdu.value_namespace_prefix = name_space_prefix
                    if(value_path == "sess-reject-no-hello"):
                        self.sess_reject_no_hello = value
                        self.sess_reject_no_hello.value_namespace = name_space
                        self.sess_reject_no_hello.value_namespace_prefix = name_space_prefix
                    if(value_path == "session-attempts"):
                        self.session_attempts = value
                        self.session_attempts.value_namespace = name_space
                        self.session_attempts.value_namespace_prefix = name_space_prefix
                    if(value_path == "shutdow-notif-sent"):
                        self.shutdow_notif_sent = value
                        self.shutdow_notif_sent.value_namespace = name_space
                        self.shutdow_notif_sent.value_namespace_prefix = name_space_prefix
                    if(value_path == "shutdown-notif-rec"):
                        self.shutdown_notif_rec = value
                        self.shutdown_notif_rec.value_namespace = name_space
                        self.shutdown_notif_rec.value_namespace_prefix = name_space_prefix


            class Backoffs(Entity):
                """
                LDP Backoff Information
                
                .. attribute:: backoff_seconds
                
                	Current neighbor backoff count in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                .. attribute:: waiting_seconds
                
                	Current neighbor backoff waiting count in seconds
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Neighbors.Backoffs, self).__init__()

                    self.yang_name = "backoffs"
                    self.yang_parent_name = "neighbors"

                    self.backoff_seconds = YLeaf(YType.uint32, "backoff-seconds")

                    self.waiting_seconds = YLeaf(YType.uint32, "waiting-seconds")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("backoff_seconds",
                                    "waiting_seconds") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Neighbors.Backoffs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Neighbors.Backoffs, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.backoff_seconds.is_set or
                        self.waiting_seconds.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.backoff_seconds.yfilter != YFilter.not_set or
                        self.waiting_seconds.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "backoffs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.backoff_seconds.is_set or self.backoff_seconds.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.backoff_seconds.get_name_leafdata())
                    if (self.waiting_seconds.is_set or self.waiting_seconds.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.waiting_seconds.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "backoff-seconds" or name == "waiting-seconds"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "backoff-seconds"):
                        self.backoff_seconds = value
                        self.backoff_seconds.value_namespace = name_space
                        self.backoff_seconds.value_namespace_prefix = name_space_prefix
                    if(value_path == "waiting-seconds"):
                        self.waiting_seconds = value
                        self.waiting_seconds.value_namespace = name_space
                        self.waiting_seconds.value_namespace_prefix = name_space_prefix


            class NsrNbrDetail(Entity):
                """
                This is the LDP NSR state for this neighbor.
                
                .. attribute:: nbr_sess
                
                	This container holds session information about the sessions between these two neighbors
                	**type**\:   :py:class:`NbrSess <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess>`
                
                .. attribute:: nsr_nbr_in_label_reqs_created
                
                	In label Request Records created
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_in_label_reqs_freed
                
                	In label Request Records freed
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_in_label_withdraw_created
                
                	In label Withdraw Records created
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_in_label_withdraw_freed
                
                	In label Withdraw Records freed
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_last_sync_error
                
                	This is the last NSR sync error recieved. It indicates the last reason the sync failed even if the sync has now succeeded. This allows this information to be viewed when the state is flapping, even if the syncronization is successful at the time of the query
                	**type**\:   :py:class:`NsrPeerSyncErr <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.NsrPeerSyncErr>`
                
                .. attribute:: nsr_nbr_last_sync_nack_reason
                
                	Last NSR sync NACK reason
                	**type**\:   :py:class:`NsrSyncNackRsn <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.NsrSyncNackRsn>`
                
                .. attribute:: nsr_nbr_lcl_addr_withdraw_cleared
                
                	Local Address Withdraw cleared
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_lcl_addr_withdraw_set
                
                	Local Address Withdraw set
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_pend_label_req_resps
                
                	Pending Label\-Request responses
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_pend_label_withdraw_resps
                
                	Pending Label\-Withdraw responses
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_pend_lcl_addr_withdraw_acks
                
                	Pending Local Address Withdraw Acks\:
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_sync_state
                
                	NSR Sync State
                	**type**\:   :py:class:`NsrPeerSyncState <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.NsrPeerSyncState>`
                
                .. attribute:: nsr_nbr_xmit_ctxt_deq
                
                	Transmit contexts dequeued
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_nbr_xmit_ctxt_enq
                
                	Transmit contexts enqueued
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: nsr_state
                
                	Non\-Stop Routing State
                	**type**\:   :py:class:`NsrStatus <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.NsrStatus>`
                
                .. attribute:: path_vector_limit
                
                	If the value of this object is 0 (zero) then Loop Dection for Path Vectors for this Peer is disabled.  Otherwise, if this object has a value greater than zero, then Loop Dection for Path  Vectors for this Peer is enabled and the Path Vector Limit is this value
                	**type**\:  int
                
                	**range:** 0..255
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail, self).__init__()

                    self.yang_name = "nsr-nbr-detail"
                    self.yang_parent_name = "neighbors"

                    self.nsr_nbr_in_label_reqs_created = YLeaf(YType.uint32, "nsr-nbr-in-label-reqs-created")

                    self.nsr_nbr_in_label_reqs_freed = YLeaf(YType.uint32, "nsr-nbr-in-label-reqs-freed")

                    self.nsr_nbr_in_label_withdraw_created = YLeaf(YType.uint32, "nsr-nbr-in-label-withdraw-created")

                    self.nsr_nbr_in_label_withdraw_freed = YLeaf(YType.uint32, "nsr-nbr-in-label-withdraw-freed")

                    self.nsr_nbr_last_sync_error = YLeaf(YType.identityref, "nsr-nbr-last-sync-error")

                    self.nsr_nbr_last_sync_nack_reason = YLeaf(YType.identityref, "nsr-nbr-last-sync-nack-reason")

                    self.nsr_nbr_lcl_addr_withdraw_cleared = YLeaf(YType.uint32, "nsr-nbr-lcl-addr-withdraw-cleared")

                    self.nsr_nbr_lcl_addr_withdraw_set = YLeaf(YType.uint32, "nsr-nbr-lcl-addr-withdraw-set")

                    self.nsr_nbr_pend_label_req_resps = YLeaf(YType.uint32, "nsr-nbr-pend-label-req-resps")

                    self.nsr_nbr_pend_label_withdraw_resps = YLeaf(YType.uint32, "nsr-nbr-pend-label-withdraw-resps")

                    self.nsr_nbr_pend_lcl_addr_withdraw_acks = YLeaf(YType.uint32, "nsr-nbr-pend-lcl-addr-withdraw-acks")

                    self.nsr_nbr_sync_state = YLeaf(YType.identityref, "nsr-nbr-sync-state")

                    self.nsr_nbr_xmit_ctxt_deq = YLeaf(YType.uint32, "nsr-nbr-xmit-ctxt-deq")

                    self.nsr_nbr_xmit_ctxt_enq = YLeaf(YType.uint32, "nsr-nbr-xmit-ctxt-enq")

                    self.nsr_state = YLeaf(YType.identityref, "nsr-state")

                    self.path_vector_limit = YLeaf(YType.int32, "path-vector-limit")

                    self.nbr_sess = MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess()
                    self.nbr_sess.parent = self
                    self._children_name_map["nbr_sess"] = "nbr-sess"
                    self._children_yang_names.add("nbr-sess")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("nsr_nbr_in_label_reqs_created",
                                    "nsr_nbr_in_label_reqs_freed",
                                    "nsr_nbr_in_label_withdraw_created",
                                    "nsr_nbr_in_label_withdraw_freed",
                                    "nsr_nbr_last_sync_error",
                                    "nsr_nbr_last_sync_nack_reason",
                                    "nsr_nbr_lcl_addr_withdraw_cleared",
                                    "nsr_nbr_lcl_addr_withdraw_set",
                                    "nsr_nbr_pend_label_req_resps",
                                    "nsr_nbr_pend_label_withdraw_resps",
                                    "nsr_nbr_pend_lcl_addr_withdraw_acks",
                                    "nsr_nbr_sync_state",
                                    "nsr_nbr_xmit_ctxt_deq",
                                    "nsr_nbr_xmit_ctxt_enq",
                                    "nsr_state",
                                    "path_vector_limit") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail, self).__setattr__(name, value)


                class NbrSess(Entity):
                    """
                    This container holds session information about the
                    sessions between these two neighbors.
                    
                    .. attribute:: discon_time
                    
                    	The value of sysUpTime on the most recent occasion at which any one or more of this session's counters suffered a discontinuity.  The relevant counters are the specific instances associated with this session of any counter32 object contained in the session\-stats table.  The initial value of this object is the value of sysUpTime when the entry was created in this table.  Also, a command generator can distinguish when a session between a given Entity and Peer goes away and a new session is established.  This value would change and thus indicate to the command generator that this is a different session
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: keep_alive_remain
                    
                    	The keep alive hold time remaining for this session in seconds
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: seconds
                    
                    .. attribute:: keep_alive_time
                    
                    	The negotiated KeepAlive Time which represents the amount of seconds between keep alive messages.  The EntityKeepAliveHoldTimer related to this Session is the value that was proposed as the KeepAlive Time for this session.  This value is negotiated during session initialization between the entity's proposed value (i.e., the value configured in EntityKeepAliveHoldTimer) and the peer's proposed KeepAlive Hold Timer value. This value is the smaller of the two proposed values
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**units**\: seconds
                    
                    .. attribute:: last_stat_change
                    
                    	The value of sysUpTime at the time this Session entered its current state as denoted by the SessionState object
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: max_pdu
                    
                    	The value of maximum allowable length for LDP PDUs this session.  This value may have been negotiated for during the Session Initialization.  This object is related to the EntityMaxPduLength object.  The EntityMaxPduLength object specifies the requested LDP PDU length, and this object reflects the negotiated LDP PDU length between the Entity and the Peer
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    	**units**\: octets
                    
                    .. attribute:: state
                    
                    	The current state of the session, all of the states 1 to 5 are based on the state machine for session negotiation behavior
                    	**type**\:   :py:class:`State <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess.State>`
                    
                    .. attribute:: unknown_mess_err
                    
                    	This object counts the number of Unknown Message Type Errors detected by this LSR/LER during this session.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: unknown_tlv
                    
                    	This object counts the number of Unknown TLV Errors detected by this LSR/LER during this session.  Discontinuities in the value of this counter can occur at re\-initialization of the management system, and at other times as indicated by the value of discon\-time
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess, self).__init__()

                        self.yang_name = "nbr-sess"
                        self.yang_parent_name = "nsr-nbr-detail"

                        self.discon_time = YLeaf(YType.uint32, "discon-time")

                        self.keep_alive_remain = YLeaf(YType.uint32, "keep-alive-remain")

                        self.keep_alive_time = YLeaf(YType.uint32, "keep-alive-time")

                        self.last_stat_change = YLeaf(YType.uint32, "last-stat-change")

                        self.max_pdu = YLeaf(YType.uint32, "max-pdu")

                        self.state = YLeaf(YType.enumeration, "state")

                        self.unknown_mess_err = YLeaf(YType.uint32, "unknown-mess-err")

                        self.unknown_tlv = YLeaf(YType.uint32, "unknown-tlv")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("discon_time",
                                        "keep_alive_remain",
                                        "keep_alive_time",
                                        "last_stat_change",
                                        "max_pdu",
                                        "state",
                                        "unknown_mess_err",
                                        "unknown_tlv") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess, self).__setattr__(name, value)

                    class State(Enum):
                        """
                        State

                        The current state of the session, all of the

                        states 1 to 5 are based on the state machine

                        for session negotiation behavior.

                        .. data:: nonexistent = 1

                        	State: nonexistent.

                        .. data:: initialized = 2

                        	State: initialized.

                        .. data:: openrec = 3

                        	State: openrec.

                        .. data:: opensent = 4

                        	State: opensent.

                        .. data:: operational = 5

                        	State: operational.

                        """

                        nonexistent = Enum.YLeaf(1, "nonexistent")

                        initialized = Enum.YLeaf(2, "initialized")

                        openrec = Enum.YLeaf(3, "openrec")

                        opensent = Enum.YLeaf(4, "opensent")

                        operational = Enum.YLeaf(5, "operational")


                    def has_data(self):
                        return (
                            self.discon_time.is_set or
                            self.keep_alive_remain.is_set or
                            self.keep_alive_time.is_set or
                            self.last_stat_change.is_set or
                            self.max_pdu.is_set or
                            self.state.is_set or
                            self.unknown_mess_err.is_set or
                            self.unknown_tlv.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.discon_time.yfilter != YFilter.not_set or
                            self.keep_alive_remain.yfilter != YFilter.not_set or
                            self.keep_alive_time.yfilter != YFilter.not_set or
                            self.last_stat_change.yfilter != YFilter.not_set or
                            self.max_pdu.yfilter != YFilter.not_set or
                            self.state.yfilter != YFilter.not_set or
                            self.unknown_mess_err.yfilter != YFilter.not_set or
                            self.unknown_tlv.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "nbr-sess" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/nsr-nbr-detail/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.discon_time.is_set or self.discon_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.discon_time.get_name_leafdata())
                        if (self.keep_alive_remain.is_set or self.keep_alive_remain.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_remain.get_name_leafdata())
                        if (self.keep_alive_time.is_set or self.keep_alive_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keep_alive_time.get_name_leafdata())
                        if (self.last_stat_change.is_set or self.last_stat_change.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_stat_change.get_name_leafdata())
                        if (self.max_pdu.is_set or self.max_pdu.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_pdu.get_name_leafdata())
                        if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state.get_name_leafdata())
                        if (self.unknown_mess_err.is_set or self.unknown_mess_err.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unknown_mess_err.get_name_leafdata())
                        if (self.unknown_tlv.is_set or self.unknown_tlv.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.unknown_tlv.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "discon-time" or name == "keep-alive-remain" or name == "keep-alive-time" or name == "last-stat-change" or name == "max-pdu" or name == "state" or name == "unknown-mess-err" or name == "unknown-tlv"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "discon-time"):
                            self.discon_time = value
                            self.discon_time.value_namespace = name_space
                            self.discon_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-remain"):
                            self.keep_alive_remain = value
                            self.keep_alive_remain.value_namespace = name_space
                            self.keep_alive_remain.value_namespace_prefix = name_space_prefix
                        if(value_path == "keep-alive-time"):
                            self.keep_alive_time = value
                            self.keep_alive_time.value_namespace = name_space
                            self.keep_alive_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-stat-change"):
                            self.last_stat_change = value
                            self.last_stat_change.value_namespace = name_space
                            self.last_stat_change.value_namespace_prefix = name_space_prefix
                        if(value_path == "max-pdu"):
                            self.max_pdu = value
                            self.max_pdu.value_namespace = name_space
                            self.max_pdu.value_namespace_prefix = name_space_prefix
                        if(value_path == "state"):
                            self.state = value
                            self.state.value_namespace = name_space
                            self.state.value_namespace_prefix = name_space_prefix
                        if(value_path == "unknown-mess-err"):
                            self.unknown_mess_err = value
                            self.unknown_mess_err.value_namespace = name_space
                            self.unknown_mess_err.value_namespace_prefix = name_space_prefix
                        if(value_path == "unknown-tlv"):
                            self.unknown_tlv = value
                            self.unknown_tlv.value_namespace = name_space
                            self.unknown_tlv.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.nsr_nbr_in_label_reqs_created.is_set or
                        self.nsr_nbr_in_label_reqs_freed.is_set or
                        self.nsr_nbr_in_label_withdraw_created.is_set or
                        self.nsr_nbr_in_label_withdraw_freed.is_set or
                        self.nsr_nbr_last_sync_error.is_set or
                        self.nsr_nbr_last_sync_nack_reason.is_set or
                        self.nsr_nbr_lcl_addr_withdraw_cleared.is_set or
                        self.nsr_nbr_lcl_addr_withdraw_set.is_set or
                        self.nsr_nbr_pend_label_req_resps.is_set or
                        self.nsr_nbr_pend_label_withdraw_resps.is_set or
                        self.nsr_nbr_pend_lcl_addr_withdraw_acks.is_set or
                        self.nsr_nbr_sync_state.is_set or
                        self.nsr_nbr_xmit_ctxt_deq.is_set or
                        self.nsr_nbr_xmit_ctxt_enq.is_set or
                        self.nsr_state.is_set or
                        self.path_vector_limit.is_set or
                        (self.nbr_sess is not None and self.nbr_sess.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.nsr_nbr_in_label_reqs_created.yfilter != YFilter.not_set or
                        self.nsr_nbr_in_label_reqs_freed.yfilter != YFilter.not_set or
                        self.nsr_nbr_in_label_withdraw_created.yfilter != YFilter.not_set or
                        self.nsr_nbr_in_label_withdraw_freed.yfilter != YFilter.not_set or
                        self.nsr_nbr_last_sync_error.yfilter != YFilter.not_set or
                        self.nsr_nbr_last_sync_nack_reason.yfilter != YFilter.not_set or
                        self.nsr_nbr_lcl_addr_withdraw_cleared.yfilter != YFilter.not_set or
                        self.nsr_nbr_lcl_addr_withdraw_set.yfilter != YFilter.not_set or
                        self.nsr_nbr_pend_label_req_resps.yfilter != YFilter.not_set or
                        self.nsr_nbr_pend_label_withdraw_resps.yfilter != YFilter.not_set or
                        self.nsr_nbr_pend_lcl_addr_withdraw_acks.yfilter != YFilter.not_set or
                        self.nsr_nbr_sync_state.yfilter != YFilter.not_set or
                        self.nsr_nbr_xmit_ctxt_deq.yfilter != YFilter.not_set or
                        self.nsr_nbr_xmit_ctxt_enq.yfilter != YFilter.not_set or
                        self.nsr_state.yfilter != YFilter.not_set or
                        self.path_vector_limit.yfilter != YFilter.not_set or
                        (self.nbr_sess is not None and self.nbr_sess.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nsr-nbr-detail" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/neighbors/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.nsr_nbr_in_label_reqs_created.is_set or self.nsr_nbr_in_label_reqs_created.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_in_label_reqs_created.get_name_leafdata())
                    if (self.nsr_nbr_in_label_reqs_freed.is_set or self.nsr_nbr_in_label_reqs_freed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_in_label_reqs_freed.get_name_leafdata())
                    if (self.nsr_nbr_in_label_withdraw_created.is_set or self.nsr_nbr_in_label_withdraw_created.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_in_label_withdraw_created.get_name_leafdata())
                    if (self.nsr_nbr_in_label_withdraw_freed.is_set or self.nsr_nbr_in_label_withdraw_freed.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_in_label_withdraw_freed.get_name_leafdata())
                    if (self.nsr_nbr_last_sync_error.is_set or self.nsr_nbr_last_sync_error.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_last_sync_error.get_name_leafdata())
                    if (self.nsr_nbr_last_sync_nack_reason.is_set or self.nsr_nbr_last_sync_nack_reason.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_last_sync_nack_reason.get_name_leafdata())
                    if (self.nsr_nbr_lcl_addr_withdraw_cleared.is_set or self.nsr_nbr_lcl_addr_withdraw_cleared.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_lcl_addr_withdraw_cleared.get_name_leafdata())
                    if (self.nsr_nbr_lcl_addr_withdraw_set.is_set or self.nsr_nbr_lcl_addr_withdraw_set.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_lcl_addr_withdraw_set.get_name_leafdata())
                    if (self.nsr_nbr_pend_label_req_resps.is_set or self.nsr_nbr_pend_label_req_resps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_pend_label_req_resps.get_name_leafdata())
                    if (self.nsr_nbr_pend_label_withdraw_resps.is_set or self.nsr_nbr_pend_label_withdraw_resps.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_pend_label_withdraw_resps.get_name_leafdata())
                    if (self.nsr_nbr_pend_lcl_addr_withdraw_acks.is_set or self.nsr_nbr_pend_lcl_addr_withdraw_acks.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_pend_lcl_addr_withdraw_acks.get_name_leafdata())
                    if (self.nsr_nbr_sync_state.is_set or self.nsr_nbr_sync_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_sync_state.get_name_leafdata())
                    if (self.nsr_nbr_xmit_ctxt_deq.is_set or self.nsr_nbr_xmit_ctxt_deq.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_xmit_ctxt_deq.get_name_leafdata())
                    if (self.nsr_nbr_xmit_ctxt_enq.is_set or self.nsr_nbr_xmit_ctxt_enq.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_nbr_xmit_ctxt_enq.get_name_leafdata())
                    if (self.nsr_state.is_set or self.nsr_state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nsr_state.get_name_leafdata())
                    if (self.path_vector_limit.is_set or self.path_vector_limit.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.path_vector_limit.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "nbr-sess"):
                        if (self.nbr_sess is None):
                            self.nbr_sess = MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail.NbrSess()
                            self.nbr_sess.parent = self
                            self._children_name_map["nbr_sess"] = "nbr-sess"
                        return self.nbr_sess

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "nbr-sess" or name == "nsr-nbr-in-label-reqs-created" or name == "nsr-nbr-in-label-reqs-freed" or name == "nsr-nbr-in-label-withdraw-created" or name == "nsr-nbr-in-label-withdraw-freed" or name == "nsr-nbr-last-sync-error" or name == "nsr-nbr-last-sync-nack-reason" or name == "nsr-nbr-lcl-addr-withdraw-cleared" or name == "nsr-nbr-lcl-addr-withdraw-set" or name == "nsr-nbr-pend-label-req-resps" or name == "nsr-nbr-pend-label-withdraw-resps" or name == "nsr-nbr-pend-lcl-addr-withdraw-acks" or name == "nsr-nbr-sync-state" or name == "nsr-nbr-xmit-ctxt-deq" or name == "nsr-nbr-xmit-ctxt-enq" or name == "nsr-state" or name == "path-vector-limit"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "nsr-nbr-in-label-reqs-created"):
                        self.nsr_nbr_in_label_reqs_created = value
                        self.nsr_nbr_in_label_reqs_created.value_namespace = name_space
                        self.nsr_nbr_in_label_reqs_created.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-in-label-reqs-freed"):
                        self.nsr_nbr_in_label_reqs_freed = value
                        self.nsr_nbr_in_label_reqs_freed.value_namespace = name_space
                        self.nsr_nbr_in_label_reqs_freed.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-in-label-withdraw-created"):
                        self.nsr_nbr_in_label_withdraw_created = value
                        self.nsr_nbr_in_label_withdraw_created.value_namespace = name_space
                        self.nsr_nbr_in_label_withdraw_created.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-in-label-withdraw-freed"):
                        self.nsr_nbr_in_label_withdraw_freed = value
                        self.nsr_nbr_in_label_withdraw_freed.value_namespace = name_space
                        self.nsr_nbr_in_label_withdraw_freed.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-last-sync-error"):
                        self.nsr_nbr_last_sync_error = value
                        self.nsr_nbr_last_sync_error.value_namespace = name_space
                        self.nsr_nbr_last_sync_error.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-last-sync-nack-reason"):
                        self.nsr_nbr_last_sync_nack_reason = value
                        self.nsr_nbr_last_sync_nack_reason.value_namespace = name_space
                        self.nsr_nbr_last_sync_nack_reason.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-lcl-addr-withdraw-cleared"):
                        self.nsr_nbr_lcl_addr_withdraw_cleared = value
                        self.nsr_nbr_lcl_addr_withdraw_cleared.value_namespace = name_space
                        self.nsr_nbr_lcl_addr_withdraw_cleared.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-lcl-addr-withdraw-set"):
                        self.nsr_nbr_lcl_addr_withdraw_set = value
                        self.nsr_nbr_lcl_addr_withdraw_set.value_namespace = name_space
                        self.nsr_nbr_lcl_addr_withdraw_set.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-pend-label-req-resps"):
                        self.nsr_nbr_pend_label_req_resps = value
                        self.nsr_nbr_pend_label_req_resps.value_namespace = name_space
                        self.nsr_nbr_pend_label_req_resps.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-pend-label-withdraw-resps"):
                        self.nsr_nbr_pend_label_withdraw_resps = value
                        self.nsr_nbr_pend_label_withdraw_resps.value_namespace = name_space
                        self.nsr_nbr_pend_label_withdraw_resps.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-pend-lcl-addr-withdraw-acks"):
                        self.nsr_nbr_pend_lcl_addr_withdraw_acks = value
                        self.nsr_nbr_pend_lcl_addr_withdraw_acks.value_namespace = name_space
                        self.nsr_nbr_pend_lcl_addr_withdraw_acks.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-sync-state"):
                        self.nsr_nbr_sync_state = value
                        self.nsr_nbr_sync_state.value_namespace = name_space
                        self.nsr_nbr_sync_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-xmit-ctxt-deq"):
                        self.nsr_nbr_xmit_ctxt_deq = value
                        self.nsr_nbr_xmit_ctxt_deq.value_namespace = name_space
                        self.nsr_nbr_xmit_ctxt_deq.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-nbr-xmit-ctxt-enq"):
                        self.nsr_nbr_xmit_ctxt_enq = value
                        self.nsr_nbr_xmit_ctxt_enq.value_namespace = name_space
                        self.nsr_nbr_xmit_ctxt_enq.value_namespace_prefix = name_space_prefix
                    if(value_path == "nsr-state"):
                        self.nsr_state = value
                        self.nsr_state.value_namespace = name_space
                        self.nsr_state.value_namespace_prefix = name_space_prefix
                    if(value_path == "path-vector-limit"):
                        self.path_vector_limit = value
                        self.path_vector_limit.value_namespace = name_space
                        self.path_vector_limit.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.nbr_adjs:
                    if (c.has_data()):
                        return True
                for c in self.neighbor:
                    if (c.has_data()):
                        return True
                return (
                    (self.backoffs is not None and self.backoffs.has_data()) or
                    (self.nsr_nbr_detail is not None and self.nsr_nbr_detail.has_data()) or
                    (self.stats_info is not None and self.stats_info.has_data()))

            def has_operation(self):
                for c in self.nbr_adjs:
                    if (c.has_operation()):
                        return True
                for c in self.neighbor:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    (self.backoffs is not None and self.backoffs.has_operation()) or
                    (self.nsr_nbr_detail is not None and self.nsr_nbr_detail.has_operation()) or
                    (self.stats_info is not None and self.stats_info.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "neighbors" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "backoffs"):
                    if (self.backoffs is None):
                        self.backoffs = MplsLdp.MplsLdpState.Neighbors.Backoffs()
                        self.backoffs.parent = self
                        self._children_name_map["backoffs"] = "backoffs"
                    return self.backoffs

                if (child_yang_name == "nbr-adjs"):
                    for c in self.nbr_adjs:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Neighbors.NbrAdjs()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.nbr_adjs.append(c)
                    return c

                if (child_yang_name == "neighbor"):
                    for c in self.neighbor:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.Neighbors.Neighbor()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.neighbor.append(c)
                    return c

                if (child_yang_name == "nsr-nbr-detail"):
                    if (self.nsr_nbr_detail is None):
                        self.nsr_nbr_detail = MplsLdp.MplsLdpState.Neighbors.NsrNbrDetail()
                        self.nsr_nbr_detail.parent = self
                        self._children_name_map["nsr_nbr_detail"] = "nsr-nbr-detail"
                    return self.nsr_nbr_detail

                if (child_yang_name == "stats-info"):
                    if (self.stats_info is None):
                        self.stats_info = MplsLdp.MplsLdpState.Neighbors.StatsInfo()
                        self.stats_info.parent = self
                        self._children_name_map["stats_info"] = "stats-info"
                    return self.stats_info

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "backoffs" or name == "nbr-adjs" or name == "neighbor" or name == "nsr-nbr-detail" or name == "stats-info"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class LabelRanges(Entity):
            """
            This contaions holds all the label ranges in use
            by this LDP instance.
            
            .. attribute:: label_range
            
            	This entry contains a single range of labels represented by the configured Upper and Lower Bounds pairs.  NOTE\: there is NO corresponding LDP message which relates to the information in this table, however, this table does provide a way for a user to 'reserve' a generic label range.  NOTE\:  The ranges for a specific LDP Entity are UNIQUE and non\-overlapping
            	**type**\: list of    :py:class:`LabelRange <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpState.LabelRanges.LabelRange>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpState.LabelRanges, self).__init__()

                self.yang_name = "label-ranges"
                self.yang_parent_name = "mpls-ldp-state"

                self.label_range = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpState.LabelRanges, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpState.LabelRanges, self).__setattr__(name, value)


            class LabelRange(Entity):
                """
                This entry contains a single range of labels
                represented by the configured Upper and Lower
                Bounds pairs.  NOTE\: there is NO corresponding
                LDP message which relates to the information
                in this table, however, this table does provide
                a way for a user to 'reserve' a generic label
                range.
                
                NOTE\:  The ranges for a specific LDP Entity
                are UNIQUE and non\-overlapping.
                
                .. attribute:: lr_min  <key>
                
                	The minimum label configured for this range
                	**type**\:  int
                
                	**range:** 0..1048575
                
                .. attribute:: lr_max  <key>
                
                	The maximum label configured for this range
                	**type**\:  int
                
                	**range:** 0..1048575
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpState.LabelRanges.LabelRange, self).__init__()

                    self.yang_name = "label-range"
                    self.yang_parent_name = "label-ranges"

                    self.lr_min = YLeaf(YType.uint32, "lr-min")

                    self.lr_max = YLeaf(YType.uint32, "lr-max")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("lr_min",
                                    "lr_max") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpState.LabelRanges.LabelRange, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpState.LabelRanges.LabelRange, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.lr_min.is_set or
                        self.lr_max.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.lr_min.yfilter != YFilter.not_set or
                        self.lr_max.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "label-range" + "[lr-min='" + self.lr_min.get() + "']" + "[lr-max='" + self.lr_max.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/label-ranges/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.lr_min.is_set or self.lr_min.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lr_min.get_name_leafdata())
                    if (self.lr_max.is_set or self.lr_max.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lr_max.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "lr-min" or name == "lr-max"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "lr-min"):
                        self.lr_min = value
                        self.lr_min.value_namespace = name_space
                        self.lr_min.value_namespace_prefix = name_space_prefix
                    if(value_path == "lr-max"):
                        self.lr_max = value
                        self.lr_max.value_namespace = name_space
                        self.lr_max.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.label_range:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.label_range:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-ranges" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-state/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "label-range"):
                    for c in self.label_range:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpState.LabelRanges.LabelRange()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.label_range.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "label-range"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.backoff_parameters is not None and self.backoff_parameters.has_data()) or
                (self.bindings is not None and self.bindings.has_data()) or
                (self.bindings_summary is not None and self.bindings_summary.has_data()) or
                (self.capabilities is not None and self.capabilities.has_data()) or
                (self.discovery is not None and self.discovery.has_data()) or
                (self.forwarding is not None and self.forwarding.has_data()) or
                (self.forwarding_summary is not None and self.forwarding_summary.has_data()) or
                (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                (self.icpm_summary_all is not None and self.icpm_summary_all.has_data()) or
                (self.label_ranges is not None and self.label_ranges.has_data()) or
                (self.neighbors is not None and self.neighbors.has_data()) or
                (self.nsr_summary_all is not None and self.nsr_summary_all.has_data()) or
                (self.oper_summary is not None and self.oper_summary.has_data()) or
                (self.parameters is not None and self.parameters.has_data()) or
                (self.vrfs is not None and self.vrfs.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.backoff_parameters is not None and self.backoff_parameters.has_operation()) or
                (self.bindings is not None and self.bindings.has_operation()) or
                (self.bindings_summary is not None and self.bindings_summary.has_operation()) or
                (self.capabilities is not None and self.capabilities.has_operation()) or
                (self.discovery is not None and self.discovery.has_operation()) or
                (self.forwarding is not None and self.forwarding.has_operation()) or
                (self.forwarding_summary is not None and self.forwarding_summary.has_operation()) or
                (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                (self.icpm_summary_all is not None and self.icpm_summary_all.has_operation()) or
                (self.label_ranges is not None and self.label_ranges.has_operation()) or
                (self.neighbors is not None and self.neighbors.has_operation()) or
                (self.nsr_summary_all is not None and self.nsr_summary_all.has_operation()) or
                (self.oper_summary is not None and self.oper_summary.has_operation()) or
                (self.parameters is not None and self.parameters.has_operation()) or
                (self.vrfs is not None and self.vrfs.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "mpls-ldp-state" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "backoff-parameters"):
                if (self.backoff_parameters is None):
                    self.backoff_parameters = MplsLdp.MplsLdpState.BackoffParameters()
                    self.backoff_parameters.parent = self
                    self._children_name_map["backoff_parameters"] = "backoff-parameters"
                return self.backoff_parameters

            if (child_yang_name == "bindings"):
                if (self.bindings is None):
                    self.bindings = MplsLdp.MplsLdpState.Bindings()
                    self.bindings.parent = self
                    self._children_name_map["bindings"] = "bindings"
                return self.bindings

            if (child_yang_name == "bindings-summary"):
                if (self.bindings_summary is None):
                    self.bindings_summary = MplsLdp.MplsLdpState.BindingsSummary()
                    self.bindings_summary.parent = self
                    self._children_name_map["bindings_summary"] = "bindings-summary"
                return self.bindings_summary

            if (child_yang_name == "capabilities"):
                if (self.capabilities is None):
                    self.capabilities = MplsLdp.MplsLdpState.Capabilities()
                    self.capabilities.parent = self
                    self._children_name_map["capabilities"] = "capabilities"
                return self.capabilities

            if (child_yang_name == "discovery"):
                if (self.discovery is None):
                    self.discovery = MplsLdp.MplsLdpState.Discovery()
                    self.discovery.parent = self
                    self._children_name_map["discovery"] = "discovery"
                return self.discovery

            if (child_yang_name == "forwarding"):
                if (self.forwarding is None):
                    self.forwarding = MplsLdp.MplsLdpState.Forwarding()
                    self.forwarding.parent = self
                    self._children_name_map["forwarding"] = "forwarding"
                return self.forwarding

            if (child_yang_name == "forwarding-summary"):
                if (self.forwarding_summary is None):
                    self.forwarding_summary = MplsLdp.MplsLdpState.ForwardingSummary()
                    self.forwarding_summary.parent = self
                    self._children_name_map["forwarding_summary"] = "forwarding-summary"
                return self.forwarding_summary

            if (child_yang_name == "graceful-restart"):
                if (self.graceful_restart is None):
                    self.graceful_restart = MplsLdp.MplsLdpState.GracefulRestart()
                    self.graceful_restart.parent = self
                    self._children_name_map["graceful_restart"] = "graceful-restart"
                return self.graceful_restart

            if (child_yang_name == "icpm-summary-all"):
                if (self.icpm_summary_all is None):
                    self.icpm_summary_all = MplsLdp.MplsLdpState.IcpmSummaryAll()
                    self.icpm_summary_all.parent = self
                    self._children_name_map["icpm_summary_all"] = "icpm-summary-all"
                return self.icpm_summary_all

            if (child_yang_name == "label-ranges"):
                if (self.label_ranges is None):
                    self.label_ranges = MplsLdp.MplsLdpState.LabelRanges()
                    self.label_ranges.parent = self
                    self._children_name_map["label_ranges"] = "label-ranges"
                return self.label_ranges

            if (child_yang_name == "neighbors"):
                if (self.neighbors is None):
                    self.neighbors = MplsLdp.MplsLdpState.Neighbors()
                    self.neighbors.parent = self
                    self._children_name_map["neighbors"] = "neighbors"
                return self.neighbors

            if (child_yang_name == "nsr-summary-all"):
                if (self.nsr_summary_all is None):
                    self.nsr_summary_all = MplsLdp.MplsLdpState.NsrSummaryAll()
                    self.nsr_summary_all.parent = self
                    self._children_name_map["nsr_summary_all"] = "nsr-summary-all"
                return self.nsr_summary_all

            if (child_yang_name == "oper-summary"):
                if (self.oper_summary is None):
                    self.oper_summary = MplsLdp.MplsLdpState.OperSummary()
                    self.oper_summary.parent = self
                    self._children_name_map["oper_summary"] = "oper-summary"
                return self.oper_summary

            if (child_yang_name == "parameters"):
                if (self.parameters is None):
                    self.parameters = MplsLdp.MplsLdpState.Parameters()
                    self.parameters.parent = self
                    self._children_name_map["parameters"] = "parameters"
                return self.parameters

            if (child_yang_name == "vrfs"):
                if (self.vrfs is None):
                    self.vrfs = MplsLdp.MplsLdpState.Vrfs()
                    self.vrfs.parent = self
                    self._children_name_map["vrfs"] = "vrfs"
                return self.vrfs

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "backoff-parameters" or name == "bindings" or name == "bindings-summary" or name == "capabilities" or name == "discovery" or name == "forwarding" or name == "forwarding-summary" or name == "graceful-restart" or name == "icpm-summary-all" or name == "label-ranges" or name == "neighbors" or name == "nsr-summary-all" or name == "oper-summary" or name == "parameters" or name == "vrfs"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class MplsLdpConfig(Entity):
        """
        MPLS LDP Configuration.
        
        .. attribute:: discovery
        
        	LDP discovery
        	**type**\:   :py:class:`Discovery <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Discovery>`
        
        .. attribute:: dual_stack
        
        	This container holds the configuration of dual IPv4 and IPv6 stack peers
        	**type**\:   :py:class:`DualStack <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.DualStack>`
        
        .. attribute:: global_cfg
        
        	This contains hold all MPLS LDP Configuration with Global scope. These values affect the entire LSR unless overiddden by a parameter with a more localized scope
        	**type**\:   :py:class:`GlobalCfg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg>`
        
        .. attribute:: graceful_restart
        
        	Configure LDP Graceful Restart
        	**type**\:   :py:class:`GracefulRestart <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GracefulRestart>`
        
        .. attribute:: interfaces
        
        	MPLS LDP Interface configuration commands
        	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Interfaces>`
        
        .. attribute:: label_cfg
        
        	This container holds the label allocation and advertisement configuration for the LDP Label Information Base. These control what prefixes may be allocated and advertised to peers
        	**type**\:   :py:class:`LabelCfg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.LabelCfg>`
        
        .. attribute:: logging
        
        	Enable LDP logging
        	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Logging>`
        
        .. attribute:: nbr_table
        
        	This container holds the list of neighbor configuration parameters
        	**type**\:   :py:class:`NbrTable <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.NbrTable>`
        
        .. attribute:: passwords
        
        	This holds the MPLS LDP password configuration for use with LDP neighbors
        	**type**\:   :py:class:`Passwords <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Passwords>`
        
        .. attribute:: routing
        
        	This containter provides the MPLS LDP config for routing protocols from which it can obtain addresses to associate with labels
        	**type**\:   :py:class:`Routing <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Routing>`
        
        .. attribute:: session
        
        	Configure session parameters
        	**type**\:   :py:class:`Session <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Session>`
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(MplsLdp.MplsLdpConfig, self).__init__()

            self.yang_name = "mpls-ldp-config"
            self.yang_parent_name = "mpls-ldp"

            self.discovery = MplsLdp.MplsLdpConfig.Discovery()
            self.discovery.parent = self
            self._children_name_map["discovery"] = "discovery"
            self._children_yang_names.add("discovery")

            self.dual_stack = MplsLdp.MplsLdpConfig.DualStack()
            self.dual_stack.parent = self
            self._children_name_map["dual_stack"] = "dual-stack"
            self._children_yang_names.add("dual-stack")

            self.global_cfg = MplsLdp.MplsLdpConfig.GlobalCfg()
            self.global_cfg.parent = self
            self._children_name_map["global_cfg"] = "global-cfg"
            self._children_yang_names.add("global-cfg")

            self.graceful_restart = MplsLdp.MplsLdpConfig.GracefulRestart()
            self.graceful_restart.parent = self
            self._children_name_map["graceful_restart"] = "graceful-restart"
            self._children_yang_names.add("graceful-restart")

            self.interfaces = MplsLdp.MplsLdpConfig.Interfaces()
            self.interfaces.parent = self
            self._children_name_map["interfaces"] = "interfaces"
            self._children_yang_names.add("interfaces")

            self.label_cfg = MplsLdp.MplsLdpConfig.LabelCfg()
            self.label_cfg.parent = self
            self._children_name_map["label_cfg"] = "label-cfg"
            self._children_yang_names.add("label-cfg")

            self.logging = MplsLdp.MplsLdpConfig.Logging()
            self.logging.parent = self
            self._children_name_map["logging"] = "logging"
            self._children_yang_names.add("logging")

            self.nbr_table = MplsLdp.MplsLdpConfig.NbrTable()
            self.nbr_table.parent = self
            self._children_name_map["nbr_table"] = "nbr-table"
            self._children_yang_names.add("nbr-table")

            self.passwords = MplsLdp.MplsLdpConfig.Passwords()
            self.passwords.parent = self
            self._children_name_map["passwords"] = "passwords"
            self._children_yang_names.add("passwords")

            self.routing = MplsLdp.MplsLdpConfig.Routing()
            self.routing.parent = self
            self._children_name_map["routing"] = "routing"
            self._children_yang_names.add("routing")

            self.session = MplsLdp.MplsLdpConfig.Session()
            self.session.parent = self
            self._children_name_map["session"] = "session"
            self._children_yang_names.add("session")


        class GlobalCfg(Entity):
            """
            This contains hold all MPLS LDP Configuration with Global
            scope. These values affect the entire LSR unless
            overiddden by a parameter with a more localized scope.
            
            .. attribute:: admin_status
            
            	This leaf controls the administrative status of LDP for this LSR. If set to disable, then all LDP activity will be disabled and all LDP sessions with peers will terminate. The LDP configuration will remain intact.  When the admin status is set back to 'enable', then LDP will resume operations and attempt to establish new sessions with the peers
            	**type**\:   :py:class:`AdminStatus <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.AdminStatus>`
            
            .. attribute:: dcsp_val
            
            	This sets the 6\-bit Differentiated Services Code Point (DSCP) value in the TCP packets for LDP messages being sent from the LSR
            	**type**\:  int
            
            	**range:** 0..63
            
            .. attribute:: disable_delay
            
            	This choice causes IGP sync up immediately upon session up
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: disable_delay_proc
            
            	This choice causes IGP sync up immediately upon session up
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: disable_quick_start
            
            	When set to true, disable LDP discovery's quick start mode for this LSR
            	**type**\:  bool
            
            .. attribute:: enable_nsr
            
            	This leaf controls whether Non\-Stop\-Routing should be enabled to include MPLS LDP
            	**type**\:  bool
            
            .. attribute:: high_priority
            
            	This sets the priority within the LSR for TCP packets for LDP messages being sent from the LSR. They are given a higher transmission priorty and will avoid being queued behind lower priority messages
            	**type**\:  bool
            
            .. attribute:: init_sess_thresh
            
            	When attempting to establish a session with a given Peer, the given LDP Entity should send out the YANG notification, 'init\-sess\-thresh\-ex', when the number of Session Initialization messages sent exceeds this threshold.  The notification is used to notify an operator when this Entity and its Peer are possibly engaged in an endless sequence of messages as each NAKs the other's  Initialization messages with Error Notification messages.  Setting this threshold which triggers the notification is one way to notify the operator.  The notification should be generated each time this threshold is exceeded and for every subsequent Initialization message which is NAK'd with an Error Notification message after this threshold is exceeded.  A value of 0 (zero) for this object indicates that the threshold is infinity, thus the YANG notification will never be generated
            	**type**\:  int
            
            	**range:** 0..100
            
            .. attribute:: loop_detection
            
            	This leaf enables or disables Loop Detection globally for the LSR
            	**type**\:  bool
            
            .. attribute:: per_af
            
            	This container holds the global per address family configuration
            	**type**\:   :py:class:`PerAf <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.PerAf>`
            
            .. attribute:: protocol
            
            	This leaf defines the protocol to be used. The default is LDP
            	**type**\:   :py:class:`Protocol <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.Protocol>`
            
            .. attribute:: router_id
            
            	Configuration for LDP Router ID (LDP ID)
            	**type**\: list of    :py:class:`RouterId <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.RouterId>`
            
            .. attribute:: seconds
            
            	Time in seconds to delay IGP sync after session comes up
            	**type**\:  int
            
            	**range:** 5..300
            
            	**units**\: second
            
            .. attribute:: seconds_delay_proc
            
            	Time in seconds to delay IGP sync after session comes up
            	**type**\:  int
            
            	**range:** 5..300
            
            	**units**\: second
            
            .. attribute:: session
            
            	Configure session parameters. Session parameters effect the session between LDP peers once the session has been established
            	**type**\:   :py:class:`Session <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.Session>`
            
            .. attribute:: shutdown
            
            	Writing this leaf tears down all LDP sessions, withdraws all outgoing labels from the forwarding plane, and frees all local labels that have been allocated
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.GlobalCfg, self).__init__()

                self.yang_name = "global-cfg"
                self.yang_parent_name = "mpls-ldp-config"

                self.admin_status = YLeaf(YType.enumeration, "admin-status")

                self.dcsp_val = YLeaf(YType.uint32, "dcsp-val")

                self.disable_delay = YLeaf(YType.empty, "disable-delay")

                self.disable_delay_proc = YLeaf(YType.empty, "disable-delay-proc")

                self.disable_quick_start = YLeaf(YType.boolean, "disable-quick-start")

                self.enable_nsr = YLeaf(YType.boolean, "enable-nsr")

                self.high_priority = YLeaf(YType.boolean, "high-priority")

                self.init_sess_thresh = YLeaf(YType.int32, "init-sess-thresh")

                self.loop_detection = YLeaf(YType.boolean, "loop-detection")

                self.protocol = YLeaf(YType.enumeration, "protocol")

                self.seconds = YLeaf(YType.uint32, "seconds")

                self.seconds_delay_proc = YLeaf(YType.uint32, "seconds-delay-proc")

                self.shutdown = YLeaf(YType.empty, "shutdown")

                self.per_af = MplsLdp.MplsLdpConfig.GlobalCfg.PerAf()
                self.per_af.parent = self
                self._children_name_map["per_af"] = "per-af"
                self._children_yang_names.add("per-af")

                self.session = MplsLdp.MplsLdpConfig.GlobalCfg.Session()
                self.session.parent = self
                self._children_name_map["session"] = "session"
                self._children_yang_names.add("session")

                self.router_id = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("admin_status",
                                "dcsp_val",
                                "disable_delay",
                                "disable_delay_proc",
                                "disable_quick_start",
                                "enable_nsr",
                                "high_priority",
                                "init_sess_thresh",
                                "loop_detection",
                                "protocol",
                                "seconds",
                                "seconds_delay_proc",
                                "shutdown") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.GlobalCfg, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.GlobalCfg, self).__setattr__(name, value)

            class AdminStatus(Enum):
                """
                AdminStatus

                This leaf controls the administrative status of LDP for

                this LSR. If set to disable, then all LDP activity will

                be disabled and all LDP sessions with peers will

                terminate. The LDP configuration will remain intact.

                When the admin status is set back to 'enable', then

                LDP will resume operations and attempt to establish new

                sessions with the peers.

                .. data:: enable = 1

                	Enable LDP globablly on this LSR.

                .. data:: disable = 2

                	Disable LDP globablly on this LSR.

                """

                enable = Enum.YLeaf(1, "enable")

                disable = Enum.YLeaf(2, "disable")


            class Protocol(Enum):
                """
                Protocol

                This leaf defines the protocol to be used. The default

                is LDP.

                .. data:: ldp = 1

                	This LSR should use the LDP tagging protocol.

                .. data:: tdp = 2

                	This LSR should use the TDP tagging protocol.

                .. data:: both = 3

                	This LSR should use the both LDP and TDP tagging

                	protocol.

                """

                ldp = Enum.YLeaf(1, "ldp")

                tdp = Enum.YLeaf(2, "tdp")

                both = Enum.YLeaf(3, "both")



            class RouterId(Entity):
                """
                Configuration for LDP Router ID (LDP ID)
                
                .. attribute:: vrf_name  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: force
                
                	Force the router to use the specified identifier as the router ID more quickly
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: lsr_id_if
                
                	This defines the interface to use for the LDP LSR identifier address for all sessions. The IP address of this interface will be used as the identifier
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                
                .. attribute:: lsr_id_ip
                
                	This is the IP address to be used as the LDP LSR ID for all sessions
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.GlobalCfg.RouterId, self).__init__()

                    self.yang_name = "router-id"
                    self.yang_parent_name = "global-cfg"

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                    self.force = YLeaf(YType.empty, "force")

                    self.lsr_id_if = YLeaf(YType.str, "lsr-id-if")

                    self.lsr_id_ip = YLeaf(YType.str, "lsr-id-ip")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf_name",
                                    "force",
                                    "lsr_id_if",
                                    "lsr_id_ip") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.GlobalCfg.RouterId, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.GlobalCfg.RouterId, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.vrf_name.is_set or
                        self.force.is_set or
                        self.lsr_id_if.is_set or
                        self.lsr_id_ip.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set or
                        self.force.yfilter != YFilter.not_set or
                        self.lsr_id_if.yfilter != YFilter.not_set or
                        self.lsr_id_ip.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "router-id" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/global-cfg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())
                    if (self.force.is_set or self.force.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.force.get_name_leafdata())
                    if (self.lsr_id_if.is_set or self.lsr_id_if.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsr_id_if.get_name_leafdata())
                    if (self.lsr_id_ip.is_set or self.lsr_id_ip.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsr_id_ip.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "vrf-name" or name == "force" or name == "lsr-id-if" or name == "lsr-id-ip"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "force"):
                        self.force = value
                        self.force.value_namespace = name_space
                        self.force.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsr-id-if"):
                        self.lsr_id_if = value
                        self.lsr_id_if.value_namespace = name_space
                        self.lsr_id_if.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsr-id-ip"):
                        self.lsr_id_ip = value
                        self.lsr_id_ip.value_namespace = name_space
                        self.lsr_id_ip.value_namespace_prefix = name_space_prefix


            class Session(Entity):
                """
                Configure session parameters. Session parameters effect
                the session between LDP peers once the session has been
                established.
                
                .. attribute:: backoff_init
                
                	Initial session backoff time (seconds). The LDP backoff mechanism prevents two incompatibly configured label switch routers (LSRs) from engaging in an unthrottled sequence of session setup failures.  For example, an incompatibility arises when two neighboring routers attempt to perform LC\-ATM (label\-controlled ATM) but the two are using different ranges of VPI/VCI values for labels.  If a session setup attempt fails due to an incompatibility, each LSR delays its next attempt (that is, backs off), increasing the delay exponentially with each successive failure until the maximum backoff delay is reached.  The default settings correspond to the lowest settings for initial and maximum backoff values defined by the LDP protocol specification. You should change the settings from the default values only if such settings result in undesirable behavior
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                	**default value**\: 15
                
                .. attribute:: backoff_max
                
                	The maximum session backoff time (seconds) The LDP backoff mechanism prevents two incompatibly configured label switch routers (LSRs) from engaging in an unthrottled sequence of session setup failures.  For example, an incompatibility arises when two neighboring routers attempt to perform LC\-ATM (label\-controlled ATM) but the two are using different ranges of VPI/VCI values for labels.  If a session setup attempt fails due to an incompatibility, each LSR delays its next attempt (that is, backs off), increasing the delay exponentially with each successive failure until the maximum backoff delay is reached.  The default settings correspond to the lowest settings for initial and maximum backoff values defined by the LDP protocol specification. You should change the settings from the default values only if such settings result in undesirable behavior
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: seconds
                
                	**default value**\: 15
                
                .. attribute:: downstream_on_demand
                
                	This container holds config for Downstream on Demand. For it to be enabled, the Downstream on demand feature has to be configured on both peers of the session. If only one peer in the session has downstream\-on\-demand feature configured, then the session does not use downstream\-on\-demand mode. If, after, a label request is sent, and no remote label is received from the peer, the router will periodically resend the label request. After the peer advertises a label after receiving the label request, it will automatically readvertise the label if any label attribute changes subsequently
                	**type**\: list of    :py:class:`DownstreamOnDemand <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.Session.DownstreamOnDemand>`
                
                .. attribute:: infinite
                
                	If set to true, the session is held indefinitely in the absence of LDP messages from the peer
                	**type**\:  bool
                
                .. attribute:: protection
                
                	Configure Session Protection parameters
                	**type**\:   :py:class:`Protection <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.Session.Protection>`
                
                .. attribute:: seconds
                
                	Number from 15 to 2147483, that defines the time, in seconds, an LDP session is maintained in the absence of LDP messages from the session peer
                	**type**\:  int
                
                	**range:** 0..65535
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.GlobalCfg.Session, self).__init__()

                    self.yang_name = "session"
                    self.yang_parent_name = "global-cfg"

                    self.backoff_init = YLeaf(YType.uint32, "backoff-init")

                    self.backoff_max = YLeaf(YType.uint32, "backoff-max")

                    self.infinite = YLeaf(YType.boolean, "infinite")

                    self.seconds = YLeaf(YType.uint16, "seconds")

                    self.protection = MplsLdp.MplsLdpConfig.GlobalCfg.Session.Protection()
                    self.protection.parent = self
                    self._children_name_map["protection"] = "protection"
                    self._children_yang_names.add("protection")

                    self.downstream_on_demand = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("backoff_init",
                                    "backoff_max",
                                    "infinite",
                                    "seconds") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.GlobalCfg.Session, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.GlobalCfg.Session, self).__setattr__(name, value)


                class DownstreamOnDemand(Entity):
                    """
                    This container holds config for Downstream on Demand.
                    For it to be enabled, the Downstream on demand
                    feature has to be configured on both peers of the
                    session. If only one peer in the session has
                    downstream\-on\-demand feature configured, then the
                    session does not use downstream\-on\-demand mode.
                    If, after, a label request is sent, and no remote
                    label is received from the peer, the router will
                    periodically resend the label request. After the
                    peer advertises a label after receiving the label
                    request, it will automatically readvertise the label
                    if any label attribute changes subsequently.
                    
                    .. attribute:: vrf_name  <key>
                    
                    	This contains the VRF Name, where 'default' is used for the default vrf
                    	**type**\:  str
                    
                    .. attribute:: enabled
                    
                    	Enable Downstream on Demand for this LSR. In this mode a label is not advertised to a peer, unless the peer explicitly requests it. At the same time, since the peer does not automatically advertise labels, the label request is sent whenever the next\-hop points out to a peer that no remote label has been assigned
                    	**type**\:  bool
                    
                    .. attribute:: filter
                    
                    	This filter contains a list of peer IDs that are configured for downstream\-on\-demand mode. When the filter is changed or configured, the list of established neighbors is traversed. If a session's downstream\-on\-demand configuration has changed, the session is reset in order that the new down\-stream\-on\-demand mode can be configured. The reason for resetting the session is to ensure that the labels are properly advertised between the peers. When a new session is established, the ACL is verified to determine whether the session should negotiate for downstream\-on\-demand mode. If the filter string is configured and the corresponding filter does not exist or is empty, then downstream\-on\-demand mode is not configured for any neighbor. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.GlobalCfg.Session.DownstreamOnDemand, self).__init__()

                        self.yang_name = "downstream-on-demand"
                        self.yang_parent_name = "session"

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.enabled = YLeaf(YType.boolean, "enabled")

                        self.filter = YLeaf(YType.str, "filter")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("vrf_name",
                                        "enabled",
                                        "filter") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.GlobalCfg.Session.DownstreamOnDemand, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.GlobalCfg.Session.DownstreamOnDemand, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.vrf_name.is_set or
                            self.enabled.is_set or
                            self.filter.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            self.enabled.yfilter != YFilter.not_set or
                            self.filter.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "downstream-on-demand" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/global-cfg/session/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())
                        if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enabled.get_name_leafdata())
                        if (self.filter.is_set or self.filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.filter.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vrf-name" or name == "enabled" or name == "filter"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enabled"):
                            self.enabled = value
                            self.enabled.value_namespace = name_space
                            self.enabled.value_namespace_prefix = name_space_prefix
                        if(value_path == "filter"):
                            self.filter = value
                            self.filter.value_namespace = name_space
                            self.filter.value_namespace_prefix = name_space_prefix


                class Protection(Entity):
                    """
                    Configure Session Protection parameters
                    
                    .. attribute:: enable_prot
                    
                    	This is set true to enable session protection
                    	**type**\:  bool
                    
                    .. attribute:: inf
                    
                    	This sessiom holdup duration is infinite
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: peer_filter
                    
                    	This is an optional filter to restrict session protection. If the string is null or unconfigured then session protection applied to all peers. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                    	**type**\:  str
                    
                    .. attribute:: seconds
                    
                    	This is the sessiom holdup duration in seconds
                    	**type**\:  int
                    
                    	**range:** 30..2147483
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.GlobalCfg.Session.Protection, self).__init__()

                        self.yang_name = "protection"
                        self.yang_parent_name = "session"

                        self.enable_prot = YLeaf(YType.boolean, "enable-prot")

                        self.inf = YLeaf(YType.empty, "inf")

                        self.peer_filter = YLeaf(YType.str, "peer-filter")

                        self.seconds = YLeaf(YType.uint32, "seconds")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable_prot",
                                        "inf",
                                        "peer_filter",
                                        "seconds") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.GlobalCfg.Session.Protection, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.GlobalCfg.Session.Protection, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable_prot.is_set or
                            self.inf.is_set or
                            self.peer_filter.is_set or
                            self.seconds.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable_prot.yfilter != YFilter.not_set or
                            self.inf.yfilter != YFilter.not_set or
                            self.peer_filter.yfilter != YFilter.not_set or
                            self.seconds.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "protection" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/global-cfg/session/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable_prot.is_set or self.enable_prot.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable_prot.get_name_leafdata())
                        if (self.inf.is_set or self.inf.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inf.get_name_leafdata())
                        if (self.peer_filter.is_set or self.peer_filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_filter.get_name_leafdata())
                        if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.seconds.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable-prot" or name == "inf" or name == "peer-filter" or name == "seconds"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable-prot"):
                            self.enable_prot = value
                            self.enable_prot.value_namespace = name_space
                            self.enable_prot.value_namespace_prefix = name_space_prefix
                        if(value_path == "inf"):
                            self.inf = value
                            self.inf.value_namespace = name_space
                            self.inf.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-filter"):
                            self.peer_filter = value
                            self.peer_filter.value_namespace = name_space
                            self.peer_filter.value_namespace_prefix = name_space_prefix
                        if(value_path == "seconds"):
                            self.seconds = value
                            self.seconds.value_namespace = name_space
                            self.seconds.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.downstream_on_demand:
                        if (c.has_data()):
                            return True
                    return (
                        self.backoff_init.is_set or
                        self.backoff_max.is_set or
                        self.infinite.is_set or
                        self.seconds.is_set or
                        (self.protection is not None and self.protection.has_data()))

                def has_operation(self):
                    for c in self.downstream_on_demand:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.backoff_init.yfilter != YFilter.not_set or
                        self.backoff_max.yfilter != YFilter.not_set or
                        self.infinite.yfilter != YFilter.not_set or
                        self.seconds.yfilter != YFilter.not_set or
                        (self.protection is not None and self.protection.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/global-cfg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.backoff_init.is_set or self.backoff_init.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.backoff_init.get_name_leafdata())
                    if (self.backoff_max.is_set or self.backoff_max.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.backoff_max.get_name_leafdata())
                    if (self.infinite.is_set or self.infinite.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.infinite.get_name_leafdata())
                    if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.seconds.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "downstream-on-demand"):
                        for c in self.downstream_on_demand:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpConfig.GlobalCfg.Session.DownstreamOnDemand()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.downstream_on_demand.append(c)
                        return c

                    if (child_yang_name == "protection"):
                        if (self.protection is None):
                            self.protection = MplsLdp.MplsLdpConfig.GlobalCfg.Session.Protection()
                            self.protection.parent = self
                            self._children_name_map["protection"] = "protection"
                        return self.protection

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "downstream-on-demand" or name == "protection" or name == "backoff-init" or name == "backoff-max" or name == "infinite" or name == "seconds"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "backoff-init"):
                        self.backoff_init = value
                        self.backoff_init.value_namespace = name_space
                        self.backoff_init.value_namespace_prefix = name_space_prefix
                    if(value_path == "backoff-max"):
                        self.backoff_max = value
                        self.backoff_max.value_namespace = name_space
                        self.backoff_max.value_namespace_prefix = name_space_prefix
                    if(value_path == "infinite"):
                        self.infinite = value
                        self.infinite.value_namespace = name_space
                        self.infinite.value_namespace_prefix = name_space_prefix
                    if(value_path == "seconds"):
                        self.seconds = value
                        self.seconds.value_namespace = name_space
                        self.seconds.value_namespace_prefix = name_space_prefix


            class PerAf(Entity):
                """
                This container holds the global per address family
                configuration.
                
                .. attribute:: af_cfg
                
                	This container holds the global per address family configuration
                	**type**\: list of    :py:class:`AfCfg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GlobalCfg.PerAf.AfCfg>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.GlobalCfg.PerAf, self).__init__()

                    self.yang_name = "per-af"
                    self.yang_parent_name = "global-cfg"

                    self.af_cfg = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.GlobalCfg.PerAf, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.GlobalCfg.PerAf, self).__setattr__(name, value)


                class AfCfg(Entity):
                    """
                    This container holds the global per address family
                    configuration.
                    
                    .. attribute:: vrf_name  <key>
                    
                    	This contains the VRF Name, where 'default' is used for the default vrf
                    	**type**\:  str
                    
                    .. attribute:: af_name  <key>
                    
                    	Address Family name
                    	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                    
                    .. attribute:: default_route
                    
                    	When set true, this enables MPLS forwarding for the ip default route
                    	**type**\:  bool
                    
                    .. attribute:: implicit
                    
                    	Do not advertise an explicit address in LDP discovery hello messages or advertise a default address. Use the default address for LDP transport
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: interface
                    
                    	Advertise this interface's address as the explicit address in LDP discovery hello messages and use it for LDP transport
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                    
                    .. attribute:: ipaddr
                    
                    	Advertise this address as the explicit address in LDP discovery hello messages and use it for LDP transport
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.GlobalCfg.PerAf.AfCfg, self).__init__()

                        self.yang_name = "af-cfg"
                        self.yang_parent_name = "per-af"

                        self.vrf_name = YLeaf(YType.str, "vrf-name")

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.default_route = YLeaf(YType.boolean, "default-route")

                        self.implicit = YLeaf(YType.empty, "implicit")

                        self.interface = YLeaf(YType.str, "interface")

                        self.ipaddr = YLeaf(YType.str, "ipaddr")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("vrf_name",
                                        "af_name",
                                        "default_route",
                                        "implicit",
                                        "interface",
                                        "ipaddr") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.GlobalCfg.PerAf.AfCfg, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.GlobalCfg.PerAf.AfCfg, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.vrf_name.is_set or
                            self.af_name.is_set or
                            self.default_route.is_set or
                            self.implicit.is_set or
                            self.interface.is_set or
                            self.ipaddr.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.vrf_name.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.default_route.yfilter != YFilter.not_set or
                            self.implicit.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.ipaddr.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "af-cfg" + "[vrf-name='" + self.vrf_name.get() + "']" + "[af-name='" + self.af_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/global-cfg/per-af/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.vrf_name.get_name_leafdata())
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.default_route.is_set or self.default_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.default_route.get_name_leafdata())
                        if (self.implicit.is_set or self.implicit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.implicit.get_name_leafdata())
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.ipaddr.is_set or self.ipaddr.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ipaddr.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "vrf-name" or name == "af-name" or name == "default-route" or name == "implicit" or name == "interface" or name == "ipaddr"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "vrf-name"):
                            self.vrf_name = value
                            self.vrf_name.value_namespace = name_space
                            self.vrf_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "default-route"):
                            self.default_route = value
                            self.default_route.value_namespace = name_space
                            self.default_route.value_namespace_prefix = name_space_prefix
                        if(value_path == "implicit"):
                            self.implicit = value
                            self.implicit.value_namespace = name_space
                            self.implicit.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "ipaddr"):
                            self.ipaddr = value
                            self.ipaddr.value_namespace = name_space
                            self.ipaddr.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.af_cfg:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.af_cfg:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "per-af" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/global-cfg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "af-cfg"):
                        for c in self.af_cfg:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpConfig.GlobalCfg.PerAf.AfCfg()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.af_cfg.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "af-cfg"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                for c in self.router_id:
                    if (c.has_data()):
                        return True
                return (
                    self.admin_status.is_set or
                    self.dcsp_val.is_set or
                    self.disable_delay.is_set or
                    self.disable_delay_proc.is_set or
                    self.disable_quick_start.is_set or
                    self.enable_nsr.is_set or
                    self.high_priority.is_set or
                    self.init_sess_thresh.is_set or
                    self.loop_detection.is_set or
                    self.protocol.is_set or
                    self.seconds.is_set or
                    self.seconds_delay_proc.is_set or
                    self.shutdown.is_set or
                    (self.per_af is not None and self.per_af.has_data()) or
                    (self.session is not None and self.session.has_data()))

            def has_operation(self):
                for c in self.router_id:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.admin_status.yfilter != YFilter.not_set or
                    self.dcsp_val.yfilter != YFilter.not_set or
                    self.disable_delay.yfilter != YFilter.not_set or
                    self.disable_delay_proc.yfilter != YFilter.not_set or
                    self.disable_quick_start.yfilter != YFilter.not_set or
                    self.enable_nsr.yfilter != YFilter.not_set or
                    self.high_priority.yfilter != YFilter.not_set or
                    self.init_sess_thresh.yfilter != YFilter.not_set or
                    self.loop_detection.yfilter != YFilter.not_set or
                    self.protocol.yfilter != YFilter.not_set or
                    self.seconds.yfilter != YFilter.not_set or
                    self.seconds_delay_proc.yfilter != YFilter.not_set or
                    self.shutdown.yfilter != YFilter.not_set or
                    (self.per_af is not None and self.per_af.has_operation()) or
                    (self.session is not None and self.session.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "global-cfg" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.admin_status.is_set or self.admin_status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.admin_status.get_name_leafdata())
                if (self.dcsp_val.is_set or self.dcsp_val.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.dcsp_val.get_name_leafdata())
                if (self.disable_delay.is_set or self.disable_delay.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.disable_delay.get_name_leafdata())
                if (self.disable_delay_proc.is_set or self.disable_delay_proc.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.disable_delay_proc.get_name_leafdata())
                if (self.disable_quick_start.is_set or self.disable_quick_start.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.disable_quick_start.get_name_leafdata())
                if (self.enable_nsr.is_set or self.enable_nsr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable_nsr.get_name_leafdata())
                if (self.high_priority.is_set or self.high_priority.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.high_priority.get_name_leafdata())
                if (self.init_sess_thresh.is_set or self.init_sess_thresh.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.init_sess_thresh.get_name_leafdata())
                if (self.loop_detection.is_set or self.loop_detection.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.loop_detection.get_name_leafdata())
                if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.protocol.get_name_leafdata())
                if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.seconds.get_name_leafdata())
                if (self.seconds_delay_proc.is_set or self.seconds_delay_proc.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.seconds_delay_proc.get_name_leafdata())
                if (self.shutdown.is_set or self.shutdown.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.shutdown.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "per-af"):
                    if (self.per_af is None):
                        self.per_af = MplsLdp.MplsLdpConfig.GlobalCfg.PerAf()
                        self.per_af.parent = self
                        self._children_name_map["per_af"] = "per-af"
                    return self.per_af

                if (child_yang_name == "router-id"):
                    for c in self.router_id:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.GlobalCfg.RouterId()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.router_id.append(c)
                    return c

                if (child_yang_name == "session"):
                    if (self.session is None):
                        self.session = MplsLdp.MplsLdpConfig.GlobalCfg.Session()
                        self.session.parent = self
                        self._children_name_map["session"] = "session"
                    return self.session

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "per-af" or name == "router-id" or name == "session" or name == "admin-status" or name == "dcsp-val" or name == "disable-delay" or name == "disable-delay-proc" or name == "disable-quick-start" or name == "enable-nsr" or name == "high-priority" or name == "init-sess-thresh" or name == "loop-detection" or name == "protocol" or name == "seconds" or name == "seconds-delay-proc" or name == "shutdown"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "admin-status"):
                    self.admin_status = value
                    self.admin_status.value_namespace = name_space
                    self.admin_status.value_namespace_prefix = name_space_prefix
                if(value_path == "dcsp-val"):
                    self.dcsp_val = value
                    self.dcsp_val.value_namespace = name_space
                    self.dcsp_val.value_namespace_prefix = name_space_prefix
                if(value_path == "disable-delay"):
                    self.disable_delay = value
                    self.disable_delay.value_namespace = name_space
                    self.disable_delay.value_namespace_prefix = name_space_prefix
                if(value_path == "disable-delay-proc"):
                    self.disable_delay_proc = value
                    self.disable_delay_proc.value_namespace = name_space
                    self.disable_delay_proc.value_namespace_prefix = name_space_prefix
                if(value_path == "disable-quick-start"):
                    self.disable_quick_start = value
                    self.disable_quick_start.value_namespace = name_space
                    self.disable_quick_start.value_namespace_prefix = name_space_prefix
                if(value_path == "enable-nsr"):
                    self.enable_nsr = value
                    self.enable_nsr.value_namespace = name_space
                    self.enable_nsr.value_namespace_prefix = name_space_prefix
                if(value_path == "high-priority"):
                    self.high_priority = value
                    self.high_priority.value_namespace = name_space
                    self.high_priority.value_namespace_prefix = name_space_prefix
                if(value_path == "init-sess-thresh"):
                    self.init_sess_thresh = value
                    self.init_sess_thresh.value_namespace = name_space
                    self.init_sess_thresh.value_namespace_prefix = name_space_prefix
                if(value_path == "loop-detection"):
                    self.loop_detection = value
                    self.loop_detection.value_namespace = name_space
                    self.loop_detection.value_namespace_prefix = name_space_prefix
                if(value_path == "protocol"):
                    self.protocol = value
                    self.protocol.value_namespace = name_space
                    self.protocol.value_namespace_prefix = name_space_prefix
                if(value_path == "seconds"):
                    self.seconds = value
                    self.seconds.value_namespace = name_space
                    self.seconds.value_namespace_prefix = name_space_prefix
                if(value_path == "seconds-delay-proc"):
                    self.seconds_delay_proc = value
                    self.seconds_delay_proc.value_namespace = name_space
                    self.seconds_delay_proc.value_namespace_prefix = name_space_prefix
                if(value_path == "shutdown"):
                    self.shutdown = value
                    self.shutdown.value_namespace = name_space
                    self.shutdown.value_namespace_prefix = name_space_prefix


        class NbrTable(Entity):
            """
            This container holds the list of neighbor configuration
            parameters.
            
            .. attribute:: nbr_cfg
            
            	This entry holds the configuration of a single neighbor identified by the IP address of that neighbor
            	**type**\: list of    :py:class:`NbrCfg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.NbrTable.NbrCfg>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.NbrTable, self).__init__()

                self.yang_name = "nbr-table"
                self.yang_parent_name = "mpls-ldp-config"

                self.nbr_cfg = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.NbrTable, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.NbrTable, self).__setattr__(name, value)


            class NbrCfg(Entity):
                """
                This entry holds the configuration of a single neighbor
                identified by the IP address of that neighbor.
                
                .. attribute:: nbr_vrf  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: nbr_ip  <key>
                
                	The IP address for the LDP neighbor. This may be IPv4 or IPv6
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                .. attribute:: admin_status
                
                	The administrative status of this neighbor. If this object is changed from 'enable' to 'disable' and this entity has already attempted to establish contact with a neighbor, a 'tear\-down' for that session is issued and the session and all information related to that session ceases to exist).  When the admin status is set back to 'enable', then this Entity will attempt to establish a new session with the neighbor
                	**type**\:   :py:class:`AdminStatus <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.NbrTable.NbrCfg.AdminStatus>`
                
                .. attribute:: implicit_withdraw
                
                	Enable LDP implicit withdraw label for this peer
                	**type**\:  bool
                
                .. attribute:: label_binding_filter
                
                	Accept only labels matching this filter. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                .. attribute:: label_protocol
                
                	This leaf defines the protocol to be used. The default is LDP
                	**type**\:   :py:class:`LabelProtocol <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.NbrTable.NbrCfg.LabelProtocol>`
                
                .. attribute:: password
                
                	Enables password authentication and stores the password using a cryptographic hash
                	**type**\:  str
                
                .. attribute:: targeted
                
                	Establish or delete a targeted session
                	**type**\:  bool
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.NbrTable.NbrCfg, self).__init__()

                    self.yang_name = "nbr-cfg"
                    self.yang_parent_name = "nbr-table"

                    self.nbr_vrf = YLeaf(YType.str, "nbr-vrf")

                    self.nbr_ip = YLeaf(YType.str, "nbr-ip")

                    self.admin_status = YLeaf(YType.enumeration, "admin-status")

                    self.implicit_withdraw = YLeaf(YType.boolean, "implicit-withdraw")

                    self.label_binding_filter = YLeaf(YType.str, "label-binding-filter")

                    self.label_protocol = YLeaf(YType.enumeration, "label-protocol")

                    self.password = YLeaf(YType.str, "password")

                    self.targeted = YLeaf(YType.boolean, "targeted")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("nbr_vrf",
                                    "nbr_ip",
                                    "admin_status",
                                    "implicit_withdraw",
                                    "label_binding_filter",
                                    "label_protocol",
                                    "password",
                                    "targeted") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.NbrTable.NbrCfg, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.NbrTable.NbrCfg, self).__setattr__(name, value)

                class AdminStatus(Enum):
                    """
                    AdminStatus

                    The administrative status of this neighbor.

                    If this object is changed from 'enable' to 'disable'

                    and this entity has already attempted to establish

                    contact with a neighbor, a 'tear\-down' for that session

                    is issued and the session and all information related

                    to that session ceases to exist).

                    When the admin status is set back to 'enable', then

                    this Entity will attempt to establish a new session

                    with the neighbor.

                    .. data:: enable = 1

                    	Set the administrative status of this neighbor

                    	to enabled.

                    .. data:: disable = 2

                    	Set the administrative status of this neighbor

                    	to disabled.

                    """

                    enable = Enum.YLeaf(1, "enable")

                    disable = Enum.YLeaf(2, "disable")


                class LabelProtocol(Enum):
                    """
                    LabelProtocol

                    This leaf defines the protocol to be used. The default

                    is LDP.

                    .. data:: ldp = 1

                    	This LSR should use the LDP tagging protocol.

                    .. data:: tdp = 2

                    	This LSR should use the TDP tagging protocol.

                    """

                    ldp = Enum.YLeaf(1, "ldp")

                    tdp = Enum.YLeaf(2, "tdp")


                def has_data(self):
                    return (
                        self.nbr_vrf.is_set or
                        self.nbr_ip.is_set or
                        self.admin_status.is_set or
                        self.implicit_withdraw.is_set or
                        self.label_binding_filter.is_set or
                        self.label_protocol.is_set or
                        self.password.is_set or
                        self.targeted.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.nbr_vrf.yfilter != YFilter.not_set or
                        self.nbr_ip.yfilter != YFilter.not_set or
                        self.admin_status.yfilter != YFilter.not_set or
                        self.implicit_withdraw.yfilter != YFilter.not_set or
                        self.label_binding_filter.yfilter != YFilter.not_set or
                        self.label_protocol.yfilter != YFilter.not_set or
                        self.password.yfilter != YFilter.not_set or
                        self.targeted.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "nbr-cfg" + "[nbr-vrf='" + self.nbr_vrf.get() + "']" + "[nbr-ip='" + self.nbr_ip.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/nbr-table/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.nbr_vrf.is_set or self.nbr_vrf.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nbr_vrf.get_name_leafdata())
                    if (self.nbr_ip.is_set or self.nbr_ip.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nbr_ip.get_name_leafdata())
                    if (self.admin_status.is_set or self.admin_status.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_status.get_name_leafdata())
                    if (self.implicit_withdraw.is_set or self.implicit_withdraw.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.implicit_withdraw.get_name_leafdata())
                    if (self.label_binding_filter.is_set or self.label_binding_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.label_binding_filter.get_name_leafdata())
                    if (self.label_protocol.is_set or self.label_protocol.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.label_protocol.get_name_leafdata())
                    if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.password.get_name_leafdata())
                    if (self.targeted.is_set or self.targeted.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.targeted.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "nbr-vrf" or name == "nbr-ip" or name == "admin-status" or name == "implicit-withdraw" or name == "label-binding-filter" or name == "label-protocol" or name == "password" or name == "targeted"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "nbr-vrf"):
                        self.nbr_vrf = value
                        self.nbr_vrf.value_namespace = name_space
                        self.nbr_vrf.value_namespace_prefix = name_space_prefix
                    if(value_path == "nbr-ip"):
                        self.nbr_ip = value
                        self.nbr_ip.value_namespace = name_space
                        self.nbr_ip.value_namespace_prefix = name_space_prefix
                    if(value_path == "admin-status"):
                        self.admin_status = value
                        self.admin_status.value_namespace = name_space
                        self.admin_status.value_namespace_prefix = name_space_prefix
                    if(value_path == "implicit-withdraw"):
                        self.implicit_withdraw = value
                        self.implicit_withdraw.value_namespace = name_space
                        self.implicit_withdraw.value_namespace_prefix = name_space_prefix
                    if(value_path == "label-binding-filter"):
                        self.label_binding_filter = value
                        self.label_binding_filter.value_namespace = name_space
                        self.label_binding_filter.value_namespace_prefix = name_space_prefix
                    if(value_path == "label-protocol"):
                        self.label_protocol = value
                        self.label_protocol.value_namespace = name_space
                        self.label_protocol.value_namespace_prefix = name_space_prefix
                    if(value_path == "password"):
                        self.password = value
                        self.password.value_namespace = name_space
                        self.password.value_namespace_prefix = name_space_prefix
                    if(value_path == "targeted"):
                        self.targeted = value
                        self.targeted.value_namespace = name_space
                        self.targeted.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.nbr_cfg:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.nbr_cfg:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "nbr-table" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "nbr-cfg"):
                    for c in self.nbr_cfg:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.NbrTable.NbrCfg()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.nbr_cfg.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "nbr-cfg"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Passwords(Entity):
            """
            This holds the MPLS LDP password configuration for use
            with LDP neighbors.
            
            .. attribute:: password
            
            	This holds the MPLS LDP password configuration for use with a single LDP neighbor or group of LDP neighbors
            	**type**\: list of    :py:class:`Password <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Passwords.Password>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.Passwords, self).__init__()

                self.yang_name = "passwords"
                self.yang_parent_name = "mpls-ldp-config"

                self.password = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.Passwords, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.Passwords, self).__setattr__(name, value)


            class Password(Entity):
                """
                This holds the MPLS LDP password configuration for use
                with a single LDP neighbor or group of LDP neighbors.
                
                .. attribute:: nbr_vrf  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: nbr_id  <key>
                
                	This leaf holds the neighbor id for this password. This id may be an lsr\-id, an ip\-address, or a filter describing a group of neighbors
                	**type**\: one of the below types:
                
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                
                ----
                	**type**\:  str
                
                	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                
                
                ----
                
                ----
                	**type**\:  str
                
                
                ----
                .. attribute:: password_num  <key>
                
                	This is a user\-assigned unique number identifying a password for this neighbor or group of neighbors. Multiple passwords may be assigned to a neighbor. If that is the case, each password is tried starting with the lowest number to the highest until a passsword matches or the list is exhausted
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: clear_pass
                
                	This is a clear\-text (non\-encrypted password to be used with the neighbor
                	**type**\:  str
                
                .. attribute:: encrypt_pass
                
                	This is an encrypted password to be used with the neighbor
                	**type**\:  str
                
                .. attribute:: keychain_pass
                
                	This is a keychain identifier, which identifies an separately configured keychain to be used with the neighbor neighbor
                	**type**\:  str
                
                .. attribute:: pass_required
                
                	This leaf is set true if the password is required and false if the password is not required
                	**type**\:  bool
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Passwords.Password, self).__init__()

                    self.yang_name = "password"
                    self.yang_parent_name = "passwords"

                    self.nbr_vrf = YLeaf(YType.str, "nbr-vrf")

                    self.nbr_id = YLeaf(YType.str, "nbr-id")

                    self.password_num = YLeaf(YType.uint32, "password-num")

                    self.clear_pass = YLeaf(YType.str, "clear-pass")

                    self.encrypt_pass = YLeaf(YType.str, "encrypt-pass")

                    self.keychain_pass = YLeaf(YType.str, "keychain-pass")

                    self.pass_required = YLeaf(YType.boolean, "pass-required")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("nbr_vrf",
                                    "nbr_id",
                                    "password_num",
                                    "clear_pass",
                                    "encrypt_pass",
                                    "keychain_pass",
                                    "pass_required") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.Passwords.Password, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.Passwords.Password, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.nbr_vrf.is_set or
                        self.nbr_id.is_set or
                        self.password_num.is_set or
                        self.clear_pass.is_set or
                        self.encrypt_pass.is_set or
                        self.keychain_pass.is_set or
                        self.pass_required.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.nbr_vrf.yfilter != YFilter.not_set or
                        self.nbr_id.yfilter != YFilter.not_set or
                        self.password_num.yfilter != YFilter.not_set or
                        self.clear_pass.yfilter != YFilter.not_set or
                        self.encrypt_pass.yfilter != YFilter.not_set or
                        self.keychain_pass.yfilter != YFilter.not_set or
                        self.pass_required.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "password" + "[nbr-vrf='" + self.nbr_vrf.get() + "']" + "[nbr-id='" + self.nbr_id.get() + "']" + "[password-num='" + self.password_num.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/passwords/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.nbr_vrf.is_set or self.nbr_vrf.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nbr_vrf.get_name_leafdata())
                    if (self.nbr_id.is_set or self.nbr_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.nbr_id.get_name_leafdata())
                    if (self.password_num.is_set or self.password_num.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.password_num.get_name_leafdata())
                    if (self.clear_pass.is_set or self.clear_pass.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.clear_pass.get_name_leafdata())
                    if (self.encrypt_pass.is_set or self.encrypt_pass.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.encrypt_pass.get_name_leafdata())
                    if (self.keychain_pass.is_set or self.keychain_pass.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.keychain_pass.get_name_leafdata())
                    if (self.pass_required.is_set or self.pass_required.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.pass_required.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "nbr-vrf" or name == "nbr-id" or name == "password-num" or name == "clear-pass" or name == "encrypt-pass" or name == "keychain-pass" or name == "pass-required"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "nbr-vrf"):
                        self.nbr_vrf = value
                        self.nbr_vrf.value_namespace = name_space
                        self.nbr_vrf.value_namespace_prefix = name_space_prefix
                    if(value_path == "nbr-id"):
                        self.nbr_id = value
                        self.nbr_id.value_namespace = name_space
                        self.nbr_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "password-num"):
                        self.password_num = value
                        self.password_num.value_namespace = name_space
                        self.password_num.value_namespace_prefix = name_space_prefix
                    if(value_path == "clear-pass"):
                        self.clear_pass = value
                        self.clear_pass.value_namespace = name_space
                        self.clear_pass.value_namespace_prefix = name_space_prefix
                    if(value_path == "encrypt-pass"):
                        self.encrypt_pass = value
                        self.encrypt_pass.value_namespace = name_space
                        self.encrypt_pass.value_namespace_prefix = name_space_prefix
                    if(value_path == "keychain-pass"):
                        self.keychain_pass = value
                        self.keychain_pass.value_namespace = name_space
                        self.keychain_pass.value_namespace_prefix = name_space_prefix
                    if(value_path == "pass-required"):
                        self.pass_required = value
                        self.pass_required.value_namespace = name_space
                        self.pass_required.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.password:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.password:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "passwords" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "password"):
                    for c in self.password:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.Passwords.Password()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.password.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "password"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Session(Entity):
            """
            Configure session parameters
            
            .. attribute:: backoff
            
            	Initial session backoff time (seconds)
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            	**default value**\: 15
            
            .. attribute:: infinite
            
            	Ignore LDP session holdtime
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: seconds
            
            	Session holdtime in seconds
            	**type**\:  int
            
            	**range:** 0..65535
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.Session, self).__init__()

                self.yang_name = "session"
                self.yang_parent_name = "mpls-ldp-config"

                self.backoff = YLeaf(YType.uint32, "backoff")

                self.infinite = YLeaf(YType.empty, "infinite")

                self.seconds = YLeaf(YType.uint16, "seconds")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("backoff",
                                "infinite",
                                "seconds") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.Session, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.Session, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.backoff.is_set or
                    self.infinite.is_set or
                    self.seconds.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.backoff.yfilter != YFilter.not_set or
                    self.infinite.yfilter != YFilter.not_set or
                    self.seconds.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "session" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.backoff.is_set or self.backoff.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.backoff.get_name_leafdata())
                if (self.infinite.is_set or self.infinite.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.infinite.get_name_leafdata())
                if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.seconds.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "backoff" or name == "infinite" or name == "seconds"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "backoff"):
                    self.backoff = value
                    self.backoff.value_namespace = name_space
                    self.backoff.value_namespace_prefix = name_space_prefix
                if(value_path == "infinite"):
                    self.infinite = value
                    self.infinite.value_namespace = name_space
                    self.infinite.value_namespace_prefix = name_space_prefix
                if(value_path == "seconds"):
                    self.seconds = value
                    self.seconds.value_namespace = name_space
                    self.seconds.value_namespace_prefix = name_space_prefix


        class LabelCfg(Entity):
            """
            This container holds the label allocation and
            advertisement configuration for the LDP Label Information
            Base. These control what prefixes may be allocated and
            advertised to peers.
            
            .. attribute:: label_af_cfg
            
            	This is an allocation filter and advertisement filters for LDP labels in this address family
            	**type**\: list of    :py:class:`LabelAfCfg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.LabelCfg, self).__init__()

                self.yang_name = "label-cfg"
                self.yang_parent_name = "mpls-ldp-config"

                self.label_af_cfg = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.LabelCfg, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.LabelCfg, self).__setattr__(name, value)


            class LabelAfCfg(Entity):
                """
                This is an allocation filter and advertisement filters
                for LDP labels in this address family.
                
                .. attribute:: vrf_name  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: af_name  <key>
                
                	Address Family name
                	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                
                .. attribute:: advt_filter
                
                	MPLS LDP Label advertisement filter restrictions
                	**type**\: list of    :py:class:`AdvtFilter <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg.AdvtFilter>`
                
                .. attribute:: host_route_enable
                
                	True if this LSR should allocate host\-routes only
                	**type**\:  bool
                
                .. attribute:: prefix_filter
                
                	This contains the filter name for this label's prefix. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..64
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg, self).__init__()

                    self.yang_name = "label-af-cfg"
                    self.yang_parent_name = "label-cfg"

                    self.vrf_name = YLeaf(YType.str, "vrf-name")

                    self.af_name = YLeaf(YType.enumeration, "af-name")

                    self.host_route_enable = YLeaf(YType.boolean, "host-route-enable")

                    self.prefix_filter = YLeaf(YType.str, "prefix-filter")

                    self.advt_filter = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf_name",
                                    "af_name",
                                    "host_route_enable",
                                    "prefix_filter") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg, self).__setattr__(name, value)


                class AdvtFilter(Entity):
                    """
                    MPLS LDP Label advertisement filter restrictions.
                    
                    .. attribute:: prefix_filter  <key>
                    
                    	This contains the filter name for this label's prefix.  The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: peer_filter  <key>
                    
                    	This contains the filter name for this label's Peer. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                    	**type**\:  str
                    
                    	**length:** 0..64
                    
                    .. attribute:: interface  <key>
                    
                    	This is an optional interface that may be used to restrict the scope of the label advertisement
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                    
                    .. attribute:: adv_label_cfg
                    
                    	This leaf controls what type of label is advertised for matching prefixes to the matching peers
                    	**type**\:   :py:class:`AdvLabelType <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.AdvLabelType>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg.AdvtFilter, self).__init__()

                        self.yang_name = "advt-filter"
                        self.yang_parent_name = "label-af-cfg"

                        self.prefix_filter = YLeaf(YType.str, "prefix-filter")

                        self.peer_filter = YLeaf(YType.str, "peer-filter")

                        self.interface = YLeaf(YType.str, "interface")

                        self.adv_label_cfg = YLeaf(YType.enumeration, "adv-label-cfg")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("prefix_filter",
                                        "peer_filter",
                                        "interface",
                                        "adv_label_cfg") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg.AdvtFilter, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg.AdvtFilter, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.prefix_filter.is_set or
                            self.peer_filter.is_set or
                            self.interface.is_set or
                            self.adv_label_cfg.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.prefix_filter.yfilter != YFilter.not_set or
                            self.peer_filter.yfilter != YFilter.not_set or
                            self.interface.yfilter != YFilter.not_set or
                            self.adv_label_cfg.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "advt-filter" + "[prefix-filter='" + self.prefix_filter.get() + "']" + "[peer-filter='" + self.peer_filter.get() + "']" + "[interface='" + self.interface.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.prefix_filter.is_set or self.prefix_filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.prefix_filter.get_name_leafdata())
                        if (self.peer_filter.is_set or self.peer_filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_filter.get_name_leafdata())
                        if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface.get_name_leafdata())
                        if (self.adv_label_cfg.is_set or self.adv_label_cfg.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.adv_label_cfg.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-filter" or name == "peer-filter" or name == "interface" or name == "adv-label-cfg"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "prefix-filter"):
                            self.prefix_filter = value
                            self.prefix_filter.value_namespace = name_space
                            self.prefix_filter.value_namespace_prefix = name_space_prefix
                        if(value_path == "peer-filter"):
                            self.peer_filter = value
                            self.peer_filter.value_namespace = name_space
                            self.peer_filter.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface"):
                            self.interface = value
                            self.interface.value_namespace = name_space
                            self.interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "adv-label-cfg"):
                            self.adv_label_cfg = value
                            self.adv_label_cfg.value_namespace = name_space
                            self.adv_label_cfg.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.advt_filter:
                        if (c.has_data()):
                            return True
                    return (
                        self.vrf_name.is_set or
                        self.af_name.is_set or
                        self.host_route_enable.is_set or
                        self.prefix_filter.is_set)

                def has_operation(self):
                    for c in self.advt_filter:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf_name.yfilter != YFilter.not_set or
                        self.af_name.yfilter != YFilter.not_set or
                        self.host_route_enable.yfilter != YFilter.not_set or
                        self.prefix_filter.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "label-af-cfg" + "[vrf-name='" + self.vrf_name.get() + "']" + "[af-name='" + self.af_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/label-cfg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf_name.get_name_leafdata())
                    if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.af_name.get_name_leafdata())
                    if (self.host_route_enable.is_set or self.host_route_enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.host_route_enable.get_name_leafdata())
                    if (self.prefix_filter.is_set or self.prefix_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.prefix_filter.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "advt-filter"):
                        for c in self.advt_filter:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg.AdvtFilter()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.advt_filter.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "advt-filter" or name == "vrf-name" or name == "af-name" or name == "host-route-enable" or name == "prefix-filter"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf-name"):
                        self.vrf_name = value
                        self.vrf_name.value_namespace = name_space
                        self.vrf_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "af-name"):
                        self.af_name = value
                        self.af_name.value_namespace = name_space
                        self.af_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "host-route-enable"):
                        self.host_route_enable = value
                        self.host_route_enable.value_namespace = name_space
                        self.host_route_enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "prefix-filter"):
                        self.prefix_filter = value
                        self.prefix_filter.value_namespace = name_space
                        self.prefix_filter.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.label_af_cfg:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.label_af_cfg:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "label-cfg" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "label-af-cfg"):
                    for c in self.label_af_cfg:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.LabelCfg.LabelAfCfg()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.label_af_cfg.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "label-af-cfg"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Discovery(Entity):
            """
            LDP discovery
            
            .. attribute:: instance_tlv
            
            	Set this leaf to true to disable transmit and receive processing for Type\-Length\-Value (TLV) in the discovery messages
            	**type**\:  bool
            
            .. attribute:: int_trans_addrs
            
            	This list contains the per\-interface transport addresses, which overide the global and default values
            	**type**\:   :py:class:`IntTransAddrs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs>`
            
            .. attribute:: link_hello
            
            	This container holds the parameters for the non\-targeted link hello
            	**type**\:   :py:class:`LinkHello <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Discovery.LinkHello>`
            
            .. attribute:: targeted_hello
            
            	This container holds the parameters for the targeted link hello
            	**type**\:   :py:class:`TargetedHello <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Discovery.TargetedHello>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.Discovery, self).__init__()

                self.yang_name = "discovery"
                self.yang_parent_name = "mpls-ldp-config"

                self.instance_tlv = YLeaf(YType.boolean, "instance-tlv")

                self.int_trans_addrs = MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs()
                self.int_trans_addrs.parent = self
                self._children_name_map["int_trans_addrs"] = "int-trans-addrs"
                self._children_yang_names.add("int-trans-addrs")

                self.link_hello = MplsLdp.MplsLdpConfig.Discovery.LinkHello()
                self.link_hello.parent = self
                self._children_name_map["link_hello"] = "link-hello"
                self._children_yang_names.add("link-hello")

                self.targeted_hello = MplsLdp.MplsLdpConfig.Discovery.TargetedHello()
                self.targeted_hello.parent = self
                self._children_name_map["targeted_hello"] = "targeted-hello"
                self._children_yang_names.add("targeted-hello")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("instance_tlv") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.Discovery, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.Discovery, self).__setattr__(name, value)


            class LinkHello(Entity):
                """
                This container holds the parameters for the non\-targeted
                link hello.
                
                .. attribute:: holdtime
                
                	LDP discovery link hello holdtime in seconds
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: interval
                
                	LDP discovery link hello interval in seconds
                	**type**\:  int
                
                	**range:** 0..65535
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Discovery.LinkHello, self).__init__()

                    self.yang_name = "link-hello"
                    self.yang_parent_name = "discovery"

                    self.holdtime = YLeaf(YType.uint16, "holdtime")

                    self.interval = YLeaf(YType.uint16, "interval")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("holdtime",
                                    "interval") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.Discovery.LinkHello, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.Discovery.LinkHello, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.holdtime.is_set or
                        self.interval.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.holdtime.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "link-hello" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.holdtime.is_set or self.holdtime.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.holdtime.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "holdtime" or name == "interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "holdtime"):
                        self.holdtime = value
                        self.holdtime.value_namespace = name_space
                        self.holdtime.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix


            class TargetedHello(Entity):
                """
                This container holds the parameters for the targeted
                link hello.
                
                .. attribute:: accept
                
                	Enables router to respond to requests for targeted hello messages
                	**type**\:   :py:class:`Accept <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Discovery.TargetedHello.Accept>`
                
                .. attribute:: enable
                
                	Set to true if targeted hello messages may be accepted
                	**type**\:  bool
                
                .. attribute:: holdtime
                
                	LDP discovery targeted hello holdtime in seconds
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: interval
                
                	LDP discovery targeted hello interval in seconds
                	**type**\:  int
                
                	**range:** 0..65535
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Discovery.TargetedHello, self).__init__()

                    self.yang_name = "targeted-hello"
                    self.yang_parent_name = "discovery"

                    self.enable = YLeaf(YType.boolean, "enable")

                    self.holdtime = YLeaf(YType.uint16, "holdtime")

                    self.interval = YLeaf(YType.uint16, "interval")

                    self.accept = MplsLdp.MplsLdpConfig.Discovery.TargetedHello.Accept()
                    self.accept.parent = self
                    self._children_name_map["accept"] = "accept"
                    self._children_yang_names.add("accept")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("enable",
                                    "holdtime",
                                    "interval") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.Discovery.TargetedHello, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.Discovery.TargetedHello, self).__setattr__(name, value)


                class Accept(Entity):
                    """
                    Enables router to respond to requests for targeted
                    hello messages
                    
                    .. attribute:: enable
                    
                    	Set to true if targeted hello messages may be accepted
                    	**type**\:  bool
                    
                    .. attribute:: src_filter
                    
                    	Only respond to requests for targeted hello messages from sources matching this filter. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.Discovery.TargetedHello.Accept, self).__init__()

                        self.yang_name = "accept"
                        self.yang_parent_name = "targeted-hello"

                        self.enable = YLeaf(YType.boolean, "enable")

                        self.src_filter = YLeaf(YType.str, "src-filter")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "src_filter") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.Discovery.TargetedHello.Accept, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.Discovery.TargetedHello.Accept, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.src_filter.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.src_filter.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "accept" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/discovery/targeted-hello/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.src_filter.is_set or self.src_filter.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.src_filter.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "src-filter"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "src-filter"):
                            self.src_filter = value
                            self.src_filter.value_namespace = name_space
                            self.src_filter.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.enable.is_set or
                        self.holdtime.is_set or
                        self.interval.is_set or
                        (self.accept is not None and self.accept.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.holdtime.yfilter != YFilter.not_set or
                        self.interval.yfilter != YFilter.not_set or
                        (self.accept is not None and self.accept.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "targeted-hello" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.holdtime.is_set or self.holdtime.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.holdtime.get_name_leafdata())
                    if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "accept"):
                        if (self.accept is None):
                            self.accept = MplsLdp.MplsLdpConfig.Discovery.TargetedHello.Accept()
                            self.accept.parent = self
                            self._children_name_map["accept"] = "accept"
                        return self.accept

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "accept" or name == "enable" or name == "holdtime" or name == "interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "holdtime"):
                        self.holdtime = value
                        self.holdtime.value_namespace = name_space
                        self.holdtime.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval"):
                        self.interval = value
                        self.interval.value_namespace = name_space
                        self.interval.value_namespace_prefix = name_space_prefix


            class IntTransAddrs(Entity):
                """
                This list contains the per\-interface transport
                addresses, which overide the global and default
                values.
                
                .. attribute:: int_trans_addr
                
                	This entry contains the per\-interface transport addresses, which overide the global and default values
                	**type**\: list of    :py:class:`IntTransAddr <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs.IntTransAddr>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs, self).__init__()

                    self.yang_name = "int-trans-addrs"
                    self.yang_parent_name = "discovery"

                    self.int_trans_addr = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs, self).__setattr__(name, value)


                class IntTransAddr(Entity):
                    """
                    This entry contains the per\-interface transport
                    addresses, which overide the global and default
                    values.
                    
                    .. attribute:: af_name  <key>
                    
                    	Address Family name
                    	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                    
                    .. attribute:: int_name  <key>
                    
                    	The Interface Name
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                    
                    .. attribute:: trans_int
                    
                    	Advertise this interface's address as the address in LDP discovery hello messages and use it for LDP transport
                    	**type**\:  str
                    
                    	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                    
                    .. attribute:: trans_ip
                    
                    	Advertise this address as the address in LDP discovery hello messages and use it for LDP transport
                    	**type**\: one of the below types:
                    
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    	**type**\:  str
                    
                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                    
                    
                    ----
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs.IntTransAddr, self).__init__()

                        self.yang_name = "int-trans-addr"
                        self.yang_parent_name = "int-trans-addrs"

                        self.af_name = YLeaf(YType.enumeration, "af-name")

                        self.int_name = YLeaf(YType.str, "int-name")

                        self.trans_int = YLeaf(YType.str, "trans-int")

                        self.trans_ip = YLeaf(YType.str, "trans-ip")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("af_name",
                                        "int_name",
                                        "trans_int",
                                        "trans_ip") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs.IntTransAddr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs.IntTransAddr, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.af_name.is_set or
                            self.int_name.is_set or
                            self.trans_int.is_set or
                            self.trans_ip.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.af_name.yfilter != YFilter.not_set or
                            self.int_name.yfilter != YFilter.not_set or
                            self.trans_int.yfilter != YFilter.not_set or
                            self.trans_ip.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "int-trans-addr" + "[af-name='" + self.af_name.get() + "']" + "[int-name='" + self.int_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/discovery/int-trans-addrs/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.af_name.get_name_leafdata())
                        if (self.int_name.is_set or self.int_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.int_name.get_name_leafdata())
                        if (self.trans_int.is_set or self.trans_int.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.trans_int.get_name_leafdata())
                        if (self.trans_ip.is_set or self.trans_ip.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.trans_ip.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "af-name" or name == "int-name" or name == "trans-int" or name == "trans-ip"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "af-name"):
                            self.af_name = value
                            self.af_name.value_namespace = name_space
                            self.af_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "int-name"):
                            self.int_name = value
                            self.int_name.value_namespace = name_space
                            self.int_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "trans-int"):
                            self.trans_int = value
                            self.trans_int.value_namespace = name_space
                            self.trans_int.value_namespace_prefix = name_space_prefix
                        if(value_path == "trans-ip"):
                            self.trans_ip = value
                            self.trans_ip.value_namespace = name_space
                            self.trans_ip.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.int_trans_addr:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.int_trans_addr:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "int-trans-addrs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/discovery/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "int-trans-addr"):
                        for c in self.int_trans_addr:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs.IntTransAddr()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.int_trans_addr.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "int-trans-addr"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.instance_tlv.is_set or
                    (self.int_trans_addrs is not None and self.int_trans_addrs.has_data()) or
                    (self.link_hello is not None and self.link_hello.has_data()) or
                    (self.targeted_hello is not None and self.targeted_hello.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.instance_tlv.yfilter != YFilter.not_set or
                    (self.int_trans_addrs is not None and self.int_trans_addrs.has_operation()) or
                    (self.link_hello is not None and self.link_hello.has_operation()) or
                    (self.targeted_hello is not None and self.targeted_hello.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "discovery" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.instance_tlv.is_set or self.instance_tlv.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.instance_tlv.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "int-trans-addrs"):
                    if (self.int_trans_addrs is None):
                        self.int_trans_addrs = MplsLdp.MplsLdpConfig.Discovery.IntTransAddrs()
                        self.int_trans_addrs.parent = self
                        self._children_name_map["int_trans_addrs"] = "int-trans-addrs"
                    return self.int_trans_addrs

                if (child_yang_name == "link-hello"):
                    if (self.link_hello is None):
                        self.link_hello = MplsLdp.MplsLdpConfig.Discovery.LinkHello()
                        self.link_hello.parent = self
                        self._children_name_map["link_hello"] = "link-hello"
                    return self.link_hello

                if (child_yang_name == "targeted-hello"):
                    if (self.targeted_hello is None):
                        self.targeted_hello = MplsLdp.MplsLdpConfig.Discovery.TargetedHello()
                        self.targeted_hello.parent = self
                        self._children_name_map["targeted_hello"] = "targeted-hello"
                    return self.targeted_hello

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "int-trans-addrs" or name == "link-hello" or name == "targeted-hello" or name == "instance-tlv"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "instance-tlv"):
                    self.instance_tlv = value
                    self.instance_tlv.value_namespace = name_space
                    self.instance_tlv.value_namespace_prefix = name_space_prefix


        class GracefulRestart(Entity):
            """
            Configure LDP Graceful Restart
            
            .. attribute:: forwarding_holding
            
            	Specifies the amount of time the MPLS LDP forwarding state must be preserved after the control plane restarts
            	**type**\:  int
            
            	**range:** 5..300
            
            	**units**\: seconds
            
            .. attribute:: helper
            
            	This contains the filter name for peers for which this LSR will act as a graceful\-restart helper
            	**type**\: list of    :py:class:`Helper <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.GracefulRestart.Helper>`
            
            .. attribute:: is_graceful_restartable
            
            	Enable graceful restartable
            	**type**\:  bool
            
            .. attribute:: max_recovery
            
            	Amount of time (in seconds) that the router should hold stale label\-FEC bindings after an LDP session has been reestablished
            	**type**\:  int
            
            	**range:** 5..300
            
            	**units**\: seconds
            
            .. attribute:: nbr_liveness
            
            	Amount of time (in seconds) that the router must wait for an LDP session to be reestablished
            	**type**\:  int
            
            	**range:** 5..300
            
            	**units**\: seconds
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.GracefulRestart, self).__init__()

                self.yang_name = "graceful-restart"
                self.yang_parent_name = "mpls-ldp-config"

                self.forwarding_holding = YLeaf(YType.uint32, "forwarding-holding")

                self.is_graceful_restartable = YLeaf(YType.boolean, "is-graceful-restartable")

                self.max_recovery = YLeaf(YType.uint32, "max-recovery")

                self.nbr_liveness = YLeaf(YType.uint32, "nbr-liveness")

                self.helper = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("forwarding_holding",
                                "is_graceful_restartable",
                                "max_recovery",
                                "nbr_liveness") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.GracefulRestart, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.GracefulRestart, self).__setattr__(name, value)


            class Helper(Entity):
                """
                This contains the filter name for peers for which this
                LSR will act as a graceful\-restart helper.
                
                .. attribute:: helper_vrf  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: helper_filter  <key>
                
                	This contains the filter name for peers for which this LSR will act as a graceful\-restart helper. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
                	**type**\:  str
                
                	**length:** 0..64
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.GracefulRestart.Helper, self).__init__()

                    self.yang_name = "helper"
                    self.yang_parent_name = "graceful-restart"

                    self.helper_vrf = YLeaf(YType.str, "helper-vrf")

                    self.helper_filter = YLeaf(YType.str, "helper-filter")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("helper_vrf",
                                    "helper_filter") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.GracefulRestart.Helper, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.GracefulRestart.Helper, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.helper_vrf.is_set or
                        self.helper_filter.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.helper_vrf.yfilter != YFilter.not_set or
                        self.helper_filter.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "helper" + "[helper-vrf='" + self.helper_vrf.get() + "']" + "[helper-filter='" + self.helper_filter.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/graceful-restart/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.helper_vrf.is_set or self.helper_vrf.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.helper_vrf.get_name_leafdata())
                    if (self.helper_filter.is_set or self.helper_filter.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.helper_filter.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "helper-vrf" or name == "helper-filter"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "helper-vrf"):
                        self.helper_vrf = value
                        self.helper_vrf.value_namespace = name_space
                        self.helper_vrf.value_namespace_prefix = name_space_prefix
                    if(value_path == "helper-filter"):
                        self.helper_filter = value
                        self.helper_filter.value_namespace = name_space
                        self.helper_filter.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.helper:
                    if (c.has_data()):
                        return True
                return (
                    self.forwarding_holding.is_set or
                    self.is_graceful_restartable.is_set or
                    self.max_recovery.is_set or
                    self.nbr_liveness.is_set)

            def has_operation(self):
                for c in self.helper:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.forwarding_holding.yfilter != YFilter.not_set or
                    self.is_graceful_restartable.yfilter != YFilter.not_set or
                    self.max_recovery.yfilter != YFilter.not_set or
                    self.nbr_liveness.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "graceful-restart" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.forwarding_holding.is_set or self.forwarding_holding.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.forwarding_holding.get_name_leafdata())
                if (self.is_graceful_restartable.is_set or self.is_graceful_restartable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.is_graceful_restartable.get_name_leafdata())
                if (self.max_recovery.is_set or self.max_recovery.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_recovery.get_name_leafdata())
                if (self.nbr_liveness.is_set or self.nbr_liveness.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nbr_liveness.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "helper"):
                    for c in self.helper:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.GracefulRestart.Helper()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.helper.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "helper" or name == "forwarding-holding" or name == "is-graceful-restartable" or name == "max-recovery" or name == "nbr-liveness"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "forwarding-holding"):
                    self.forwarding_holding = value
                    self.forwarding_holding.value_namespace = name_space
                    self.forwarding_holding.value_namespace_prefix = name_space_prefix
                if(value_path == "is-graceful-restartable"):
                    self.is_graceful_restartable = value
                    self.is_graceful_restartable.value_namespace = name_space
                    self.is_graceful_restartable.value_namespace_prefix = name_space_prefix
                if(value_path == "max-recovery"):
                    self.max_recovery = value
                    self.max_recovery.value_namespace = name_space
                    self.max_recovery.value_namespace_prefix = name_space_prefix
                if(value_path == "nbr-liveness"):
                    self.nbr_liveness = value
                    self.nbr_liveness.value_namespace = name_space
                    self.nbr_liveness.value_namespace_prefix = name_space_prefix


        class Logging(Entity):
            """
            Enable LDP logging
            
            .. attribute:: adjacency
            
            	Enable logging of adjacency messages
            	**type**\:  bool
            
            .. attribute:: graceful_restart
            
            	Enable logging of graceful\-restart messages
            	**type**\:  bool
            
            .. attribute:: neighbor
            
            	Enable logging of neighbor messages
            	**type**\:  bool
            
            .. attribute:: nsr
            
            	Enable logging of nsr messages
            	**type**\:  bool
            
            .. attribute:: password
            
            	Enable logging of password messages
            	**type**\:   :py:class:`Password <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Logging.Password>`
            
            .. attribute:: session_protection
            
            	Enable logging of session\-protection messages
            	**type**\:  bool
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.Logging, self).__init__()

                self.yang_name = "logging"
                self.yang_parent_name = "mpls-ldp-config"

                self.adjacency = YLeaf(YType.boolean, "adjacency")

                self.graceful_restart = YLeaf(YType.boolean, "graceful-restart")

                self.neighbor = YLeaf(YType.boolean, "neighbor")

                self.nsr = YLeaf(YType.boolean, "nsr")

                self.session_protection = YLeaf(YType.boolean, "session-protection")

                self.password = MplsLdp.MplsLdpConfig.Logging.Password()
                self.password.parent = self
                self._children_name_map["password"] = "password"
                self._children_yang_names.add("password")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("adjacency",
                                "graceful_restart",
                                "neighbor",
                                "nsr",
                                "session_protection") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.Logging, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.Logging, self).__setattr__(name, value)


            class Password(Entity):
                """
                Enable logging of password messages.
                
                .. attribute:: config_msg
                
                	Log MPLS LDP password configuration changes
                	**type**\:   :py:class:`ConfigMsg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Logging.Password.ConfigMsg>`
                
                .. attribute:: rollover_msg
                
                	Log MPLS LDP password rollover messages
                	**type**\:   :py:class:`RolloverMsg <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Logging.Password.RolloverMsg>`
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Logging.Password, self).__init__()

                    self.yang_name = "password"
                    self.yang_parent_name = "logging"

                    self.config_msg = MplsLdp.MplsLdpConfig.Logging.Password.ConfigMsg()
                    self.config_msg.parent = self
                    self._children_name_map["config_msg"] = "config-msg"
                    self._children_yang_names.add("config-msg")

                    self.rollover_msg = MplsLdp.MplsLdpConfig.Logging.Password.RolloverMsg()
                    self.rollover_msg.parent = self
                    self._children_name_map["rollover_msg"] = "rollover-msg"
                    self._children_yang_names.add("rollover-msg")


                class ConfigMsg(Entity):
                    """
                    Log MPLS LDP password configuration changes.
                    
                    .. attribute:: enable
                    
                    	Log MPLS LDP password configuration changes
                    	**type**\:  bool
                    
                    .. attribute:: rate_limit
                    
                    	This is the number of messages per minute to limit the logging. A value of 0 indicates no limits on the number of logged messages
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.Logging.Password.ConfigMsg, self).__init__()

                        self.yang_name = "config-msg"
                        self.yang_parent_name = "password"

                        self.enable = YLeaf(YType.boolean, "enable")

                        self.rate_limit = YLeaf(YType.uint32, "rate-limit")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "rate_limit") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.Logging.Password.ConfigMsg, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.Logging.Password.ConfigMsg, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.rate_limit.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.rate_limit.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "config-msg" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/logging/password/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.rate_limit.is_set or self.rate_limit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rate_limit.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "rate-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "rate-limit"):
                            self.rate_limit = value
                            self.rate_limit.value_namespace = name_space
                            self.rate_limit.value_namespace_prefix = name_space_prefix


                class RolloverMsg(Entity):
                    """
                    Log MPLS LDP password rollover messages.
                    
                    .. attribute:: enable
                    
                    	Log MPLS LDP password rollover messages
                    	**type**\:  bool
                    
                    .. attribute:: rate_limit
                    
                    	This is the number of messages per minute to limit the logging. A value of 0 indicates no limits on the number of logged messages
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.Logging.Password.RolloverMsg, self).__init__()

                        self.yang_name = "rollover-msg"
                        self.yang_parent_name = "password"

                        self.enable = YLeaf(YType.boolean, "enable")

                        self.rate_limit = YLeaf(YType.uint32, "rate-limit")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("enable",
                                        "rate_limit") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.Logging.Password.RolloverMsg, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.Logging.Password.RolloverMsg, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.enable.is_set or
                            self.rate_limit.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.rate_limit.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "rollover-msg" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/logging/password/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.rate_limit.is_set or self.rate_limit.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.rate_limit.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "enable" or name == "rate-limit"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "rate-limit"):
                            self.rate_limit = value
                            self.rate_limit.value_namespace = name_space
                            self.rate_limit.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.config_msg is not None and self.config_msg.has_data()) or
                        (self.rollover_msg is not None and self.rollover_msg.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.config_msg is not None and self.config_msg.has_operation()) or
                        (self.rollover_msg is not None and self.rollover_msg.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "password" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/logging/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "config-msg"):
                        if (self.config_msg is None):
                            self.config_msg = MplsLdp.MplsLdpConfig.Logging.Password.ConfigMsg()
                            self.config_msg.parent = self
                            self._children_name_map["config_msg"] = "config-msg"
                        return self.config_msg

                    if (child_yang_name == "rollover-msg"):
                        if (self.rollover_msg is None):
                            self.rollover_msg = MplsLdp.MplsLdpConfig.Logging.Password.RolloverMsg()
                            self.rollover_msg.parent = self
                            self._children_name_map["rollover_msg"] = "rollover-msg"
                        return self.rollover_msg

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "config-msg" or name == "rollover-msg"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.adjacency.is_set or
                    self.graceful_restart.is_set or
                    self.neighbor.is_set or
                    self.nsr.is_set or
                    self.session_protection.is_set or
                    (self.password is not None and self.password.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.adjacency.yfilter != YFilter.not_set or
                    self.graceful_restart.yfilter != YFilter.not_set or
                    self.neighbor.yfilter != YFilter.not_set or
                    self.nsr.yfilter != YFilter.not_set or
                    self.session_protection.yfilter != YFilter.not_set or
                    (self.password is not None and self.password.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "logging" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.adjacency.is_set or self.adjacency.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.adjacency.get_name_leafdata())
                if (self.graceful_restart.is_set or self.graceful_restart.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.graceful_restart.get_name_leafdata())
                if (self.neighbor.is_set or self.neighbor.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.neighbor.get_name_leafdata())
                if (self.nsr.is_set or self.nsr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.nsr.get_name_leafdata())
                if (self.session_protection.is_set or self.session_protection.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.session_protection.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "password"):
                    if (self.password is None):
                        self.password = MplsLdp.MplsLdpConfig.Logging.Password()
                        self.password.parent = self
                        self._children_name_map["password"] = "password"
                    return self.password

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "password" or name == "adjacency" or name == "graceful-restart" or name == "neighbor" or name == "nsr" or name == "session-protection"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "adjacency"):
                    self.adjacency = value
                    self.adjacency.value_namespace = name_space
                    self.adjacency.value_namespace_prefix = name_space_prefix
                if(value_path == "graceful-restart"):
                    self.graceful_restart = value
                    self.graceful_restart.value_namespace = name_space
                    self.graceful_restart.value_namespace_prefix = name_space_prefix
                if(value_path == "neighbor"):
                    self.neighbor = value
                    self.neighbor.value_namespace = name_space
                    self.neighbor.value_namespace_prefix = name_space_prefix
                if(value_path == "nsr"):
                    self.nsr = value
                    self.nsr.value_namespace = name_space
                    self.nsr.value_namespace_prefix = name_space_prefix
                if(value_path == "session-protection"):
                    self.session_protection = value
                    self.session_protection.value_namespace = name_space
                    self.session_protection.value_namespace_prefix = name_space_prefix


        class Interfaces(Entity):
            """
            MPLS LDP Interface configuration commands.
            
            .. attribute:: interface
            
            	MPLS LDP Interface configuration commands. Where a corresponding global configuration command exists, the interface level command will take precedence when configured
            	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Interfaces.Interface>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.Interfaces, self).__init__()

                self.yang_name = "interfaces"
                self.yang_parent_name = "mpls-ldp-config"

                self.interface = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.Interfaces, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.Interfaces, self).__setattr__(name, value)


            class Interface(Entity):
                """
                MPLS LDP Interface configuration commands. Where a
                corresponding global configuration command exists, the
                interface level command will take precedence when
                configured.
                
                .. attribute:: vrf  <key>
                
                	This contains the VRF Name, where 'default' is used for the default vrf
                	**type**\:  str
                
                .. attribute:: interface  <key>
                
                	The Interface Name
                	**type**\:  str
                
                	**refers to**\:  :py:class:`name <ydk.models.ietf.ietf_interfaces.Interfaces.Interface>`
                
                .. attribute:: afs
                
                	Address Family specific operational data
                	**type**\:   :py:class:`Afs <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs>`
                
                .. attribute:: disable_delay
                
                	This choice causes IGP sync up immediately upon session up
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: disable_quick_start_int
                
                	When set to true, disable LDP discovery's quick start mode for this interface
                	**type**\:  bool
                
                .. attribute:: link_hello_hold
                
                	LDP discovery link hello holdtime in seconds for this interface. This value overides the global setting
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                	**default value**\: 15
                
                .. attribute:: link_hello_int
                
                	LDP discovery link hello interval in seconds for this interface. This value overides the global setting
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                	**units**\: second
                
                	**default value**\: 5
                
                .. attribute:: seconds
                
                	Time in seconds to delay IGP sync after session comes up
                	**type**\:  int
                
                	**range:** 5..300
                
                	**units**\: second
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Interfaces.Interface, self).__init__()

                    self.yang_name = "interface"
                    self.yang_parent_name = "interfaces"

                    self.vrf = YLeaf(YType.str, "vrf")

                    self.interface = YLeaf(YType.str, "interface")

                    self.disable_delay = YLeaf(YType.empty, "disable-delay")

                    self.disable_quick_start_int = YLeaf(YType.boolean, "disable-quick-start-int")

                    self.link_hello_hold = YLeaf(YType.uint32, "link-hello-hold")

                    self.link_hello_int = YLeaf(YType.uint32, "link-hello-int")

                    self.seconds = YLeaf(YType.uint32, "seconds")

                    self.afs = MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs()
                    self.afs.parent = self
                    self._children_name_map["afs"] = "afs"
                    self._children_yang_names.add("afs")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("vrf",
                                    "interface",
                                    "disable_delay",
                                    "disable_quick_start_int",
                                    "link_hello_hold",
                                    "link_hello_int",
                                    "seconds") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.Interfaces.Interface, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.Interfaces.Interface, self).__setattr__(name, value)


                class Afs(Entity):
                    """
                    Address Family specific operational data
                    
                    .. attribute:: af
                    
                    	MPLS LDP Operational data for this Address Family
                    	**type**\: list of    :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af>`
                    
                    

                    """

                    _prefix = 'mpls-ldp-ios-xe-oper'
                    _revision = '2017-02-07'

                    def __init__(self):
                        super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs, self).__init__()

                        self.yang_name = "afs"
                        self.yang_parent_name = "interface"

                        self.af = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs, self).__setattr__(name, value)


                    class Af(Entity):
                        """
                        MPLS LDP Operational data for this Address Family.
                        
                        .. attribute:: af_name  <key>
                        
                        	Address Family name
                        	**type**\:   :py:class:`Af <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.Af>`
                        
                        .. attribute:: autoconfig_disable
                        
                        	True if LDP autoconfig is explicitly disabled on this interface
                        	**type**\:  bool
                        
                        .. attribute:: bgp_redist
                        
                        	MPLS LDP configuration for protocol redistribution. By default, redistribution of BGP routes is disabled. It can be enabled for all BGP routes or for a specific AS. Also it can be redistributed to all LDP peers or to a filtered group of peers
                        	**type**\:   :py:class:`BgpRedist <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af.BgpRedist>`
                        
                        .. attribute:: enable
                        
                        	This is set true to enable LDP on this interface
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'mpls-ldp-ios-xe-oper'
                        _revision = '2017-02-07'

                        def __init__(self):
                            super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af, self).__init__()

                            self.yang_name = "af"
                            self.yang_parent_name = "afs"

                            self.af_name = YLeaf(YType.enumeration, "af-name")

                            self.autoconfig_disable = YLeaf(YType.boolean, "autoconfig-disable")

                            self.enable = YLeaf(YType.boolean, "enable")

                            self.bgp_redist = MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af.BgpRedist()
                            self.bgp_redist.parent = self
                            self._children_name_map["bgp_redist"] = "bgp-redist"
                            self._children_yang_names.add("bgp-redist")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("af_name",
                                            "autoconfig_disable",
                                            "enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af, self).__setattr__(name, value)


                        class BgpRedist(Entity):
                            """
                            MPLS LDP configuration for protocol
                            redistribution. By default, redistribution of BGP
                            routes is disabled. It can be enabled for all
                            BGP routes or for a specific AS. Also it can be
                            redistributed to all LDP peers or to a filtered
                            group of peers.
                            
                            .. attribute:: advertise_to
                            
                            	Filter of neighbors to receive BGP route redistributions from LDP. If the list is empty or unset, all LDP neighbors will receive redistributions
                            	**type**\:  str
                            
                            .. attribute:: as_xx
                            
                            	First half of BGP AS number in XX.YY format.  Mandatory Must be a non\-zero value if second half is zero
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: as_yy
                            
                            	Second half of BGP AS number in XX.YY format. Mandatory Must be a non\-zero value if first half is zero
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: enable
                            
                            	This is set true to allow LDP to redistribute BGP routes
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'mpls-ldp-ios-xe-oper'
                            _revision = '2017-02-07'

                            def __init__(self):
                                super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af.BgpRedist, self).__init__()

                                self.yang_name = "bgp-redist"
                                self.yang_parent_name = "af"

                                self.advertise_to = YLeaf(YType.str, "advertise-to")

                                self.as_xx = YLeaf(YType.uint32, "as-xx")

                                self.as_yy = YLeaf(YType.uint32, "as-yy")

                                self.enable = YLeaf(YType.boolean, "enable")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("advertise_to",
                                                "as_xx",
                                                "as_yy",
                                                "enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af.BgpRedist, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af.BgpRedist, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.advertise_to.is_set or
                                    self.as_xx.is_set or
                                    self.as_yy.is_set or
                                    self.enable.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.advertise_to.yfilter != YFilter.not_set or
                                    self.as_xx.yfilter != YFilter.not_set or
                                    self.as_yy.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bgp-redist" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.advertise_to.is_set or self.advertise_to.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.advertise_to.get_name_leafdata())
                                if (self.as_xx.is_set or self.as_xx.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_xx.get_name_leafdata())
                                if (self.as_yy.is_set or self.as_yy.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.as_yy.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "advertise-to" or name == "as-xx" or name == "as-yy" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "advertise-to"):
                                    self.advertise_to = value
                                    self.advertise_to.value_namespace = name_space
                                    self.advertise_to.value_namespace_prefix = name_space_prefix
                                if(value_path == "as-xx"):
                                    self.as_xx = value
                                    self.as_xx.value_namespace = name_space
                                    self.as_xx.value_namespace_prefix = name_space_prefix
                                if(value_path == "as-yy"):
                                    self.as_yy = value
                                    self.as_yy.value_namespace = name_space
                                    self.as_yy.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.af_name.is_set or
                                self.autoconfig_disable.is_set or
                                self.enable.is_set or
                                (self.bgp_redist is not None and self.bgp_redist.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.af_name.yfilter != YFilter.not_set or
                                self.autoconfig_disable.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                (self.bgp_redist is not None and self.bgp_redist.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "af" + "[af-name='" + self.af_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.af_name.is_set or self.af_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.af_name.get_name_leafdata())
                            if (self.autoconfig_disable.is_set or self.autoconfig_disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.autoconfig_disable.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bgp-redist"):
                                if (self.bgp_redist is None):
                                    self.bgp_redist = MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af.BgpRedist()
                                    self.bgp_redist.parent = self
                                    self._children_name_map["bgp_redist"] = "bgp-redist"
                                return self.bgp_redist

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bgp-redist" or name == "af-name" or name == "autoconfig-disable" or name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "af-name"):
                                self.af_name = value
                                self.af_name.value_namespace = name_space
                                self.af_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "autoconfig-disable"):
                                self.autoconfig_disable = value
                                self.autoconfig_disable.value_namespace = name_space
                                self.autoconfig_disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.af:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.af:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "afs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "af"):
                            for c in self.af:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs.Af()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.af.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "af"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.vrf.is_set or
                        self.interface.is_set or
                        self.disable_delay.is_set or
                        self.disable_quick_start_int.is_set or
                        self.link_hello_hold.is_set or
                        self.link_hello_int.is_set or
                        self.seconds.is_set or
                        (self.afs is not None and self.afs.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.vrf.yfilter != YFilter.not_set or
                        self.interface.yfilter != YFilter.not_set or
                        self.disable_delay.yfilter != YFilter.not_set or
                        self.disable_quick_start_int.yfilter != YFilter.not_set or
                        self.link_hello_hold.yfilter != YFilter.not_set or
                        self.link_hello_int.yfilter != YFilter.not_set or
                        self.seconds.yfilter != YFilter.not_set or
                        (self.afs is not None and self.afs.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "interface" + "[vrf='" + self.vrf.get() + "']" + "[interface='" + self.interface.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/interfaces/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.vrf.is_set or self.vrf.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.vrf.get_name_leafdata())
                    if (self.interface.is_set or self.interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface.get_name_leafdata())
                    if (self.disable_delay.is_set or self.disable_delay.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable_delay.get_name_leafdata())
                    if (self.disable_quick_start_int.is_set or self.disable_quick_start_int.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable_quick_start_int.get_name_leafdata())
                    if (self.link_hello_hold.is_set or self.link_hello_hold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.link_hello_hold.get_name_leafdata())
                    if (self.link_hello_int.is_set or self.link_hello_int.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.link_hello_int.get_name_leafdata())
                    if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.seconds.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "afs"):
                        if (self.afs is None):
                            self.afs = MplsLdp.MplsLdpConfig.Interfaces.Interface.Afs()
                            self.afs.parent = self
                            self._children_name_map["afs"] = "afs"
                        return self.afs

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "afs" or name == "vrf" or name == "interface" or name == "disable-delay" or name == "disable-quick-start-int" or name == "link-hello-hold" or name == "link-hello-int" or name == "seconds"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "vrf"):
                        self.vrf = value
                        self.vrf.value_namespace = name_space
                        self.vrf.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface"):
                        self.interface = value
                        self.interface.value_namespace = name_space
                        self.interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "disable-delay"):
                        self.disable_delay = value
                        self.disable_delay.value_namespace = name_space
                        self.disable_delay.value_namespace_prefix = name_space_prefix
                    if(value_path == "disable-quick-start-int"):
                        self.disable_quick_start_int = value
                        self.disable_quick_start_int.value_namespace = name_space
                        self.disable_quick_start_int.value_namespace_prefix = name_space_prefix
                    if(value_path == "link-hello-hold"):
                        self.link_hello_hold = value
                        self.link_hello_hold.value_namespace = name_space
                        self.link_hello_hold.value_namespace_prefix = name_space_prefix
                    if(value_path == "link-hello-int"):
                        self.link_hello_int = value
                        self.link_hello_int.value_namespace = name_space
                        self.link_hello_int.value_namespace_prefix = name_space_prefix
                    if(value_path == "seconds"):
                        self.seconds = value
                        self.seconds.value_namespace = name_space
                        self.seconds.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.interface:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.interface:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interfaces" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "interface"):
                    for c in self.interface:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.Interfaces.Interface()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.interface.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "interface"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Routing(Entity):
            """
            This containter provides the MPLS LDP config for routing
            protocols from which it can obtain addresses to
            associate with labels.
            
            .. attribute:: routing_inst
            
            	This entry provides the MPLS LDP config for this routing instance
            	**type**\: list of    :py:class:`RoutingInst <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Routing.RoutingInst>`
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.Routing, self).__init__()

                self.yang_name = "routing"
                self.yang_parent_name = "mpls-ldp-config"

                self.routing_inst = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.Routing, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.Routing, self).__setattr__(name, value)


            class RoutingInst(Entity):
                """
                This entry provides the MPLS LDP config for this
                routing instance.
                
                .. attribute:: routing_inst_name  <key>
                
                	Name of the routing instance for which this MPLS LDP configuration applies
                	**type**\:  str
                
                .. attribute:: area_id
                
                	This leaf restricts the LDP Autoconfiguration feature to enable LDP on interfaces belonging to an OSPF process for a specific area. If no area is specified, then this applies to all interfaces associated with the. If an area ID is specified, then only interfaces associated with that OSPF area are automatically enabled with LDP. Any interface\-specific ldp configuration will overide this setting for that interface
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: autoconfig_enable
                
                	This leaf enables or disables LDP for all interfaces covered by this routing instance subject to the autoconfig\-scope
                	**type**\:  bool
                
                .. attribute:: level_id
                
                	This leaf restricts the LDP Autoconfiguration feature to enable LDP on interfaces belonging to an ISIS process for a specific level. If no level is specified, then this applies to all interfaces associated with the. If a level is specified, then only interfaces associated with that ISIS level are automatically enabled with LDP. Any interface\-specific ldp configuration will overide this setting for that interface
                	**type**\:   :py:class:`LevelId <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.MplsLdp.MplsLdpConfig.Routing.RoutingInst.LevelId>`
                
                .. attribute:: sync
                
                	When set to true this enables LDP IGP synchronization. Without syncrhonization, packet loss can occur because the actions of the IGP and LDP are not synchronized
                	**type**\:  bool
                
                

                """

                _prefix = 'mpls-ldp-ios-xe-oper'
                _revision = '2017-02-07'

                def __init__(self):
                    super(MplsLdp.MplsLdpConfig.Routing.RoutingInst, self).__init__()

                    self.yang_name = "routing-inst"
                    self.yang_parent_name = "routing"

                    self.routing_inst_name = YLeaf(YType.str, "routing-inst-name")

                    self.area_id = YLeaf(YType.uint32, "area-id")

                    self.autoconfig_enable = YLeaf(YType.boolean, "autoconfig-enable")

                    self.level_id = YLeaf(YType.enumeration, "level-id")

                    self.sync = YLeaf(YType.boolean, "sync")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("routing_inst_name",
                                    "area_id",
                                    "autoconfig_enable",
                                    "level_id",
                                    "sync") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsLdp.MplsLdpConfig.Routing.RoutingInst, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsLdp.MplsLdpConfig.Routing.RoutingInst, self).__setattr__(name, value)

                class LevelId(Enum):
                    """
                    LevelId

                    This leaf restricts the LDP Autoconfiguration

                    feature to enable LDP on interfaces belonging to

                    an ISIS process for a specific level. If no level

                    is specified, then this applies to all interfaces

                    associated with the. If a level is specified,

                    then only interfaces associated with that ISIS

                    level are automatically enabled with LDP.

                    Any interface\-specific ldp configuration will

                    overide this setting for that interface.

                    .. data:: level_1 = 1

                    	This leaf restricts the LDP Autoconfiguration

                    	feature to enable LDP on interfaces belonging

                    	to an IS-IS process level 1.

                    	Any interface-specific ldp configuration will

                    	overide this setting for that interface.

                    .. data:: level_2 = 2

                    	This leaf restricts the LDP Autoconfiguration

                    	feature to enable LDP on interfaces belonging

                    	to an IS-IS process level 1.

                    	Any interface-specific ldp configuration will

                    	overide this setting for that interface.

                    .. data:: level_1_2 = 3

                    	This leaf restricts the LDP Autoconfiguration

                    	feature to enable LDP on interfaces belonging

                    	to an IS-IS process level 2.

                    	Any interface-specific ldp configuration will

                    	overide this setting for that interface.

                    """

                    level_1 = Enum.YLeaf(1, "level-1")

                    level_2 = Enum.YLeaf(2, "level-2")

                    level_1_2 = Enum.YLeaf(3, "level-1-2")


                def has_data(self):
                    return (
                        self.routing_inst_name.is_set or
                        self.area_id.is_set or
                        self.autoconfig_enable.is_set or
                        self.level_id.is_set or
                        self.sync.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.routing_inst_name.yfilter != YFilter.not_set or
                        self.area_id.yfilter != YFilter.not_set or
                        self.autoconfig_enable.yfilter != YFilter.not_set or
                        self.level_id.yfilter != YFilter.not_set or
                        self.sync.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "routing-inst" + "[routing-inst-name='" + self.routing_inst_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/routing/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.routing_inst_name.is_set or self.routing_inst_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.routing_inst_name.get_name_leafdata())
                    if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.area_id.get_name_leafdata())
                    if (self.autoconfig_enable.is_set or self.autoconfig_enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.autoconfig_enable.get_name_leafdata())
                    if (self.level_id.is_set or self.level_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.level_id.get_name_leafdata())
                    if (self.sync.is_set or self.sync.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sync.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "routing-inst-name" or name == "area-id" or name == "autoconfig-enable" or name == "level-id" or name == "sync"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "routing-inst-name"):
                        self.routing_inst_name = value
                        self.routing_inst_name.value_namespace = name_space
                        self.routing_inst_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "area-id"):
                        self.area_id = value
                        self.area_id.value_namespace = name_space
                        self.area_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "autoconfig-enable"):
                        self.autoconfig_enable = value
                        self.autoconfig_enable.value_namespace = name_space
                        self.autoconfig_enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "level-id"):
                        self.level_id = value
                        self.level_id.value_namespace = name_space
                        self.level_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "sync"):
                        self.sync = value
                        self.sync.value_namespace = name_space
                        self.sync.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.routing_inst:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.routing_inst:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "routing" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "routing-inst"):
                    for c in self.routing_inst:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsLdp.MplsLdpConfig.Routing.RoutingInst()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.routing_inst.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "routing-inst"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class DualStack(Entity):
            """
            This container holds the configuration of dual IPv4 and
            IPv6 stack peers.
            
            .. attribute:: max_wait
            
            	Wait time in seconds (0 indicates no preference)
            	**type**\:  int
            
            	**range:** 0..60
            
            .. attribute:: prefer_ipv4_peers
            
            	This contains the filter name for peers where IPv4 connections are preferred over IPv6 connections. The filter type is device specific and could be an ACL, a prefix list, or other mechanism
            	**type**\:  str
            
            

            """

            _prefix = 'mpls-ldp-ios-xe-oper'
            _revision = '2017-02-07'

            def __init__(self):
                super(MplsLdp.MplsLdpConfig.DualStack, self).__init__()

                self.yang_name = "dual-stack"
                self.yang_parent_name = "mpls-ldp-config"

                self.max_wait = YLeaf(YType.uint32, "max-wait")

                self.prefer_ipv4_peers = YLeaf(YType.str, "prefer-ipv4-peers")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("max_wait",
                                "prefer_ipv4_peers") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsLdp.MplsLdpConfig.DualStack, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsLdp.MplsLdpConfig.DualStack, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.max_wait.is_set or
                    self.prefer_ipv4_peers.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.max_wait.yfilter != YFilter.not_set or
                    self.prefer_ipv4_peers.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "dual-stack" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/mpls-ldp-config/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.max_wait.is_set or self.max_wait.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_wait.get_name_leafdata())
                if (self.prefer_ipv4_peers.is_set or self.prefer_ipv4_peers.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.prefer_ipv4_peers.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "max-wait" or name == "prefer-ipv4-peers"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "max-wait"):
                    self.max_wait = value
                    self.max_wait.value_namespace = name_space
                    self.max_wait.value_namespace_prefix = name_space_prefix
                if(value_path == "prefer-ipv4-peers"):
                    self.prefer_ipv4_peers = value
                    self.prefer_ipv4_peers.value_namespace = name_space
                    self.prefer_ipv4_peers.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                (self.discovery is not None and self.discovery.has_data()) or
                (self.dual_stack is not None and self.dual_stack.has_data()) or
                (self.global_cfg is not None and self.global_cfg.has_data()) or
                (self.graceful_restart is not None and self.graceful_restart.has_data()) or
                (self.interfaces is not None and self.interfaces.has_data()) or
                (self.label_cfg is not None and self.label_cfg.has_data()) or
                (self.logging is not None and self.logging.has_data()) or
                (self.nbr_table is not None and self.nbr_table.has_data()) or
                (self.passwords is not None and self.passwords.has_data()) or
                (self.routing is not None and self.routing.has_data()) or
                (self.session is not None and self.session.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.discovery is not None and self.discovery.has_operation()) or
                (self.dual_stack is not None and self.dual_stack.has_operation()) or
                (self.global_cfg is not None and self.global_cfg.has_operation()) or
                (self.graceful_restart is not None and self.graceful_restart.has_operation()) or
                (self.interfaces is not None and self.interfaces.has_operation()) or
                (self.label_cfg is not None and self.label_cfg.has_operation()) or
                (self.logging is not None and self.logging.has_operation()) or
                (self.nbr_table is not None and self.nbr_table.has_operation()) or
                (self.passwords is not None and self.passwords.has_operation()) or
                (self.routing is not None and self.routing.has_operation()) or
                (self.session is not None and self.session.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "mpls-ldp-config" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "discovery"):
                if (self.discovery is None):
                    self.discovery = MplsLdp.MplsLdpConfig.Discovery()
                    self.discovery.parent = self
                    self._children_name_map["discovery"] = "discovery"
                return self.discovery

            if (child_yang_name == "dual-stack"):
                if (self.dual_stack is None):
                    self.dual_stack = MplsLdp.MplsLdpConfig.DualStack()
                    self.dual_stack.parent = self
                    self._children_name_map["dual_stack"] = "dual-stack"
                return self.dual_stack

            if (child_yang_name == "global-cfg"):
                if (self.global_cfg is None):
                    self.global_cfg = MplsLdp.MplsLdpConfig.GlobalCfg()
                    self.global_cfg.parent = self
                    self._children_name_map["global_cfg"] = "global-cfg"
                return self.global_cfg

            if (child_yang_name == "graceful-restart"):
                if (self.graceful_restart is None):
                    self.graceful_restart = MplsLdp.MplsLdpConfig.GracefulRestart()
                    self.graceful_restart.parent = self
                    self._children_name_map["graceful_restart"] = "graceful-restart"
                return self.graceful_restart

            if (child_yang_name == "interfaces"):
                if (self.interfaces is None):
                    self.interfaces = MplsLdp.MplsLdpConfig.Interfaces()
                    self.interfaces.parent = self
                    self._children_name_map["interfaces"] = "interfaces"
                return self.interfaces

            if (child_yang_name == "label-cfg"):
                if (self.label_cfg is None):
                    self.label_cfg = MplsLdp.MplsLdpConfig.LabelCfg()
                    self.label_cfg.parent = self
                    self._children_name_map["label_cfg"] = "label-cfg"
                return self.label_cfg

            if (child_yang_name == "logging"):
                if (self.logging is None):
                    self.logging = MplsLdp.MplsLdpConfig.Logging()
                    self.logging.parent = self
                    self._children_name_map["logging"] = "logging"
                return self.logging

            if (child_yang_name == "nbr-table"):
                if (self.nbr_table is None):
                    self.nbr_table = MplsLdp.MplsLdpConfig.NbrTable()
                    self.nbr_table.parent = self
                    self._children_name_map["nbr_table"] = "nbr-table"
                return self.nbr_table

            if (child_yang_name == "passwords"):
                if (self.passwords is None):
                    self.passwords = MplsLdp.MplsLdpConfig.Passwords()
                    self.passwords.parent = self
                    self._children_name_map["passwords"] = "passwords"
                return self.passwords

            if (child_yang_name == "routing"):
                if (self.routing is None):
                    self.routing = MplsLdp.MplsLdpConfig.Routing()
                    self.routing.parent = self
                    self._children_name_map["routing"] = "routing"
                return self.routing

            if (child_yang_name == "session"):
                if (self.session is None):
                    self.session = MplsLdp.MplsLdpConfig.Session()
                    self.session.parent = self
                    self._children_name_map["session"] = "session"
                return self.session

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "discovery" or name == "dual-stack" or name == "global-cfg" or name == "graceful-restart" or name == "interfaces" or name == "label-cfg" or name == "logging" or name == "nbr-table" or name == "passwords" or name == "routing" or name == "session"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.mpls_ldp_config is not None and self.mpls_ldp_config.has_data()) or
            (self.mpls_ldp_state is not None and self.mpls_ldp_state.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.mpls_ldp_config is not None and self.mpls_ldp_config.has_operation()) or
            (self.mpls_ldp_state is not None and self.mpls_ldp_state.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XE-mpls-ldp:mpls-ldp" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "mpls-ldp-config"):
            if (self.mpls_ldp_config is None):
                self.mpls_ldp_config = MplsLdp.MplsLdpConfig()
                self.mpls_ldp_config.parent = self
                self._children_name_map["mpls_ldp_config"] = "mpls-ldp-config"
            return self.mpls_ldp_config

        if (child_yang_name == "mpls-ldp-state"):
            if (self.mpls_ldp_state is None):
                self.mpls_ldp_state = MplsLdp.MplsLdpState()
                self.mpls_ldp_state.parent = self
                self._children_name_map["mpls_ldp_state"] = "mpls-ldp-state"
            return self.mpls_ldp_state

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "mpls-ldp-config" or name == "mpls-ldp-state"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = MplsLdp()
        return self._top_entity

class ClearMsgCounters(Entity):
    """
    This RPC clears the LDP message counters for either a single
    neighbor or for all neighbors.
    
    .. attribute:: input
    
    	
    	**type**\:   :py:class:`Input <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.ClearMsgCounters.Input>`
    
    .. attribute:: output
    
    	
    	**type**\:   :py:class:`Output <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.ClearMsgCounters.Output>`
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(ClearMsgCounters, self).__init__()
        self._top_entity = None

        self.yang_name = "clear-msg-counters"
        self.yang_parent_name = "Cisco-IOS-XE-mpls-ldp"

        self.input = ClearMsgCounters.Input()
        self.input.parent = self
        self._children_name_map["input"] = "input"
        self._children_yang_names.add("input")

        self.output = ClearMsgCounters.Output()
        self.output.parent = self
        self._children_name_map["output"] = "output"
        self._children_yang_names.add("output")


    class Input(Entity):
        """
        
        
        .. attribute:: all
        
        	Clear information for all neighbors
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: nbr_ip
        
        	LSR ID of the neighbor
        	**type**\: one of the below types:
        
        	**type**\:  str
        
        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
        
        
        ----
        	**type**\:  str
        
        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
        
        
        ----
        .. attribute:: vrf_name
        
        	This contains the VRF Name, where 'default' is used for the default vrf
        	**type**\:  str
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(ClearMsgCounters.Input, self).__init__()

            self.yang_name = "input"
            self.yang_parent_name = "clear-msg-counters"

            self.all = YLeaf(YType.empty, "all")

            self.nbr_ip = YLeaf(YType.str, "nbr-ip")

            self.vrf_name = YLeaf(YType.str, "vrf-name")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("all",
                            "nbr_ip",
                            "vrf_name") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(ClearMsgCounters.Input, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(ClearMsgCounters.Input, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.all.is_set or
                self.nbr_ip.is_set or
                self.vrf_name.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.all.yfilter != YFilter.not_set or
                self.nbr_ip.yfilter != YFilter.not_set or
                self.vrf_name.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "input" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:clear-msg-counters/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                leaf_name_data.append(self.all.get_name_leafdata())
            if (self.nbr_ip.is_set or self.nbr_ip.yfilter != YFilter.not_set):
                leaf_name_data.append(self.nbr_ip.get_name_leafdata())
            if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.vrf_name.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "all" or name == "nbr-ip" or name == "vrf-name"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "all"):
                self.all = value
                self.all.value_namespace = name_space
                self.all.value_namespace_prefix = name_space_prefix
            if(value_path == "nbr-ip"):
                self.nbr_ip = value
                self.nbr_ip.value_namespace = name_space
                self.nbr_ip.value_namespace_prefix = name_space_prefix
            if(value_path == "vrf-name"):
                self.vrf_name = value
                self.vrf_name.value_namespace = name_space
                self.vrf_name.value_namespace_prefix = name_space_prefix


    class Output(Entity):
        """
        
        
        .. attribute:: status
        
        	Return status will be 'OK' on success or an explanation string on failure
        	**type**\:  str
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(ClearMsgCounters.Output, self).__init__()

            self.yang_name = "output"
            self.yang_parent_name = "clear-msg-counters"

            self.status = YLeaf(YType.str, "status")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("status") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(ClearMsgCounters.Output, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(ClearMsgCounters.Output, self).__setattr__(name, value)

        def has_data(self):
            return self.status.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.status.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "output" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:clear-msg-counters/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                leaf_name_data.append(self.status.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "status"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "status"):
                self.status = value
                self.status.value_namespace = name_space
                self.status.value_namespace_prefix = name_space_prefix

    def has_data(self):
        return (
            (self.input is not None and self.input.has_data()) or
            (self.output is not None and self.output.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.input is not None and self.input.has_operation()) or
            (self.output is not None and self.output.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XE-mpls-ldp:clear-msg-counters" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "input"):
            if (self.input is None):
                self.input = ClearMsgCounters.Input()
                self.input.parent = self
                self._children_name_map["input"] = "input"
            return self.input

        if (child_yang_name == "output"):
            if (self.output is None):
                self.output = ClearMsgCounters.Output()
                self.output.parent = self
                self._children_name_map["output"] = "output"
            return self.output

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "input" or name == "output"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = ClearMsgCounters()
        return self._top_entity

class RestartNeighbor(Entity):
    """
    This RPC restarts a single LDP session or all LDP sessions,
    but does not restart the LDP process itself, if the device
    supports that capability.
    
    .. attribute:: input
    
    	
    	**type**\:   :py:class:`Input <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.RestartNeighbor.Input>`
    
    .. attribute:: output
    
    	
    	**type**\:   :py:class:`Output <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.RestartNeighbor.Output>`
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RestartNeighbor, self).__init__()
        self._top_entity = None

        self.yang_name = "restart-neighbor"
        self.yang_parent_name = "Cisco-IOS-XE-mpls-ldp"

        self.input = RestartNeighbor.Input()
        self.input.parent = self
        self._children_name_map["input"] = "input"
        self._children_yang_names.add("input")

        self.output = RestartNeighbor.Output()
        self.output.parent = self
        self._children_name_map["output"] = "output"
        self._children_yang_names.add("output")


    class Input(Entity):
        """
        
        
        .. attribute:: all
        
        	Restart sessions for all neighbors
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: nbr_ip
        
        	LSR ID of the neighbor
        	**type**\: one of the below types:
        
        	**type**\:  str
        
        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
        
        
        ----
        	**type**\:  str
        
        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
        
        
        ----
        .. attribute:: vrf_name
        
        	This contains the VRF Name, where 'default' is used for the default vrf
        	**type**\:  str
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(RestartNeighbor.Input, self).__init__()

            self.yang_name = "input"
            self.yang_parent_name = "restart-neighbor"

            self.all = YLeaf(YType.empty, "all")

            self.nbr_ip = YLeaf(YType.str, "nbr-ip")

            self.vrf_name = YLeaf(YType.str, "vrf-name")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("all",
                            "nbr_ip",
                            "vrf_name") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(RestartNeighbor.Input, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(RestartNeighbor.Input, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.all.is_set or
                self.nbr_ip.is_set or
                self.vrf_name.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.all.yfilter != YFilter.not_set or
                self.nbr_ip.yfilter != YFilter.not_set or
                self.vrf_name.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "input" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:restart-neighbor/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                leaf_name_data.append(self.all.get_name_leafdata())
            if (self.nbr_ip.is_set or self.nbr_ip.yfilter != YFilter.not_set):
                leaf_name_data.append(self.nbr_ip.get_name_leafdata())
            if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.vrf_name.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "all" or name == "nbr-ip" or name == "vrf-name"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "all"):
                self.all = value
                self.all.value_namespace = name_space
                self.all.value_namespace_prefix = name_space_prefix
            if(value_path == "nbr-ip"):
                self.nbr_ip = value
                self.nbr_ip.value_namespace = name_space
                self.nbr_ip.value_namespace_prefix = name_space_prefix
            if(value_path == "vrf-name"):
                self.vrf_name = value
                self.vrf_name.value_namespace = name_space
                self.vrf_name.value_namespace_prefix = name_space_prefix


    class Output(Entity):
        """
        
        
        .. attribute:: status
        
        	Return status will be 'OK' on success or an explanation string on failure
        	**type**\:  str
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(RestartNeighbor.Output, self).__init__()

            self.yang_name = "output"
            self.yang_parent_name = "restart-neighbor"

            self.status = YLeaf(YType.str, "status")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("status") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(RestartNeighbor.Output, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(RestartNeighbor.Output, self).__setattr__(name, value)

        def has_data(self):
            return self.status.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.status.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "output" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:restart-neighbor/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                leaf_name_data.append(self.status.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "status"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "status"):
                self.status = value
                self.status.value_namespace = name_space
                self.status.value_namespace_prefix = name_space_prefix

    def has_data(self):
        return (
            (self.input is not None and self.input.has_data()) or
            (self.output is not None and self.output.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.input is not None and self.input.has_operation()) or
            (self.output is not None and self.output.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XE-mpls-ldp:restart-neighbor" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "input"):
            if (self.input is None):
                self.input = RestartNeighbor.Input()
                self.input.parent = self
                self._children_name_map["input"] = "input"
            return self.input

        if (child_yang_name == "output"):
            if (self.output is None):
                self.output = RestartNeighbor.Output()
                self.output.parent = self
                self._children_name_map["output"] = "output"
            return self.output

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "input" or name == "output"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = RestartNeighbor()
        return self._top_entity

class ClearForwarding(Entity):
    """
    This command resets LDP installed forwarding state for all
    prefixes or a given prefix. It is useful when installed 
    LDP forwarding state needs to be reprogrammed in LSD and
    MPLS forwarding.
    
    .. attribute:: input
    
    	
    	**type**\:   :py:class:`Input <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.ClearForwarding.Input>`
    
    .. attribute:: output
    
    	
    	**type**\:   :py:class:`Output <ydk.models.cisco_ios_xe.Cisco_IOS_XE_mpls_ldp.ClearForwarding.Output>`
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(ClearForwarding, self).__init__()
        self._top_entity = None

        self.yang_name = "clear-forwarding"
        self.yang_parent_name = "Cisco-IOS-XE-mpls-ldp"

        self.input = ClearForwarding.Input()
        self.input.parent = self
        self._children_name_map["input"] = "input"
        self._children_yang_names.add("input")

        self.output = ClearForwarding.Output()
        self.output.parent = self
        self._children_name_map["output"] = "output"
        self._children_yang_names.add("output")


    class Input(Entity):
        """
        
        
        .. attribute:: all
        
        	This case is used to clear the forwarding entries for all prefixes
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: prefix_ip
        
        	This case provides the IP prefix for the forwarding entry whose data should be cleared
        	**type**\: one of the below types:
        
        	**type**\:  str
        
        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
        
        
        ----
        	**type**\:  str
        
        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
        
        
        ----
        .. attribute:: vrf_name
        
        	This contains the VRF Name, where 'default' is used for the default vrf
        	**type**\:  str
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(ClearForwarding.Input, self).__init__()

            self.yang_name = "input"
            self.yang_parent_name = "clear-forwarding"

            self.all = YLeaf(YType.empty, "all")

            self.prefix_ip = YLeaf(YType.str, "prefix-ip")

            self.vrf_name = YLeaf(YType.str, "vrf-name")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("all",
                            "prefix_ip",
                            "vrf_name") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(ClearForwarding.Input, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(ClearForwarding.Input, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.all.is_set or
                self.prefix_ip.is_set or
                self.vrf_name.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.all.yfilter != YFilter.not_set or
                self.prefix_ip.yfilter != YFilter.not_set or
                self.vrf_name.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "input" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:clear-forwarding/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                leaf_name_data.append(self.all.get_name_leafdata())
            if (self.prefix_ip.is_set or self.prefix_ip.yfilter != YFilter.not_set):
                leaf_name_data.append(self.prefix_ip.get_name_leafdata())
            if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                leaf_name_data.append(self.vrf_name.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "all" or name == "prefix-ip" or name == "vrf-name"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "all"):
                self.all = value
                self.all.value_namespace = name_space
                self.all.value_namespace_prefix = name_space_prefix
            if(value_path == "prefix-ip"):
                self.prefix_ip = value
                self.prefix_ip.value_namespace = name_space
                self.prefix_ip.value_namespace_prefix = name_space_prefix
            if(value_path == "vrf-name"):
                self.vrf_name = value
                self.vrf_name.value_namespace = name_space
                self.vrf_name.value_namespace_prefix = name_space_prefix


    class Output(Entity):
        """
        
        
        .. attribute:: status
        
        	Return status will be 'OK' on success or an explanatory string on failure
        	**type**\:  str
        
        

        """

        _prefix = 'mpls-ldp-ios-xe-oper'
        _revision = '2017-02-07'

        def __init__(self):
            super(ClearForwarding.Output, self).__init__()

            self.yang_name = "output"
            self.yang_parent_name = "clear-forwarding"

            self.status = YLeaf(YType.str, "status")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("status") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(ClearForwarding.Output, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(ClearForwarding.Output, self).__setattr__(name, value)

        def has_data(self):
            return self.status.is_set

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.status.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "output" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XE-mpls-ldp:clear-forwarding/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                leaf_name_data.append(self.status.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "status"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "status"):
                self.status = value
                self.status.value_namespace = name_space
                self.status.value_namespace_prefix = name_space_prefix

    def has_data(self):
        return (
            (self.input is not None and self.input.has_data()) or
            (self.output is not None and self.output.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.input is not None and self.input.has_operation()) or
            (self.output is not None and self.output.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XE-mpls-ldp:clear-forwarding" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "input"):
            if (self.input is None):
                self.input = ClearForwarding.Input()
                self.input.parent = self
                self._children_name_map["input"] = "input"
            return self.input

        if (child_yang_name == "output"):
            if (self.output is None):
                self.output = ClearForwarding.Output()
                self.output.parent = self
                self._children_name_map["output"] = "output"
            return self.output

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "input" or name == "output"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = ClearForwarding()
        return self._top_entity

class NsrSyncNackRsnPpExists(Identity):
    """
    NSR failed with because pp already exists.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnPpExists, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-pp-exists")


class RoutePathLblOwnerStatic(Identity):
    """
    Path outgoing label statically configured.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathLblOwnerStatic, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-lbl-owner-static")


class NsrPeerSyncErrLdpPeer(Identity):
    """
    LDP Peer Sync failed, ldp peer
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrLdpPeer, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-ldp-peer")


class NsrSyncNackRsnErrTpCreate(Identity):
    """
    NSR failed creating the tp.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrTpCreate, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-tp-create")


class NsrSyncNackRsnMissingElem(Identity):
    """
    NSR failed due to a Missing Element.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnMissingElem, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-missing-elem")


class LdpNsrPeerSyncStNone(Identity):
    """
    LDP NSR peer synchronization none.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LdpNsrPeerSyncStNone, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:ldp-nsr-peer-sync-st-none")


class NsrSyncNackRsnNoCtx(Identity):
    """
    NSR failed with a no context error.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnNoCtx, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-no-ctx")


class NsrSyncNackRsnErrPpCreate(Identity):
    """
    NSR failed creating the pp.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrPpCreate, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-pp-create")


class DownNbrReasonNbrHold(Identity):
    """
    The neighbor sent error, hold time expired..
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(DownNbrReasonNbrHold, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:down-nbr-reason-nbr-hold")


class NsrStatusNotReady(Identity):
    """
    Device is not NSR Ready.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrStatusNotReady, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-status-not-ready")


class NsrPeerSyncErrNone(Identity):
    """
    No error.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrNone, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-none")


class LdpNsrPeerSyncStOper(Identity):
    """
    LDP NSR peer synchronization is operational.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LdpNsrPeerSyncStOper, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:ldp-nsr-peer-sync-st-oper")


class IcpmTypeIccp(Identity):
    """
    ICCP Interchassis Communication Protocol.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IcpmTypeIccp, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:icpm-type-iccp")


class IgpSyncDownReasonNa(Identity):
    """
    Not Applicable.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReasonNa, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason-na")


class NsrPeerSyncErrTcpPeer(Identity):
    """
    LDP Peer Sync failed, tcp peer
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrTcpPeer, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-tcp-peer")


class NsrSyncNackRsnPEndSockNotSynced(Identity):
    """
    NSR failed because the P end sock was not synced.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnPEndSockNotSynced, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-p-end-sock-not-synced")


class RoutePathIpBackupRemote(Identity):
    """
    A non\-primary remote LFA FRR (pure) backup path
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathIpBackupRemote, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-ip-backup-remote")


class LdpNsrPeerSyncStWait(Identity):
    """
    LDP NSR peer synchronization is wait.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LdpNsrPeerSyncStWait, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:ldp-nsr-peer-sync-st-wait")


class IgpSyncDownReasonNoPeerSess(Identity):
    """
    No peer session.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReasonNoPeerSess, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason-no-peer-sess")


class NsrStatusDisabled(Identity):
    """
    NSR is not enabled.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrStatusDisabled, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-status-disabled")


class NsrPeerSyncErrLdpSyncNack(Identity):
    """
    LDP Peer Sync failed, received sync nack.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrLdpSyncNack, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-ldp-sync-nack")


class LabelTypeUnknown(Identity):
    """
    The label is unknown.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LabelTypeUnknown, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:label-type-unknown")


class NsrSyncNackRsnErrDhcAdd(Identity):
    """
    NSR failed with a error creating the directed hello control
    infrastructure.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrDhcAdd, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-dhc-add")


class IgpSyncDownReasonNoHelloAdj(Identity):
    """
    No hello adjacency.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReasonNoHelloAdj, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason-no-hello-adj")


class RoutePathLblOwnerNone(Identity):
    """
    No label and no owner.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathLblOwnerNone, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-lbl-owner-none")


class NsrSyncNackRsnErrAddrBind(Identity):
    """
    NSR failed to bind address.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrAddrBind, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-addr-bind")


class LabelTypeUnLabeled(Identity):
    """
    This is unlabeled
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LabelTypeUnLabeled, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:label-type-un-labeled")


class NsrSyncNackRsnNoPEndSock(Identity):
    """
    NSR failed because there was no P end socket.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnNoPEndSock, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-no-p-end-sock")


class NsrPeerSyncErrSyncPrep(Identity):
    """
    LDP Peer Sync failed, synch prep.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrSyncPrep, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-sync-prep")


class NsrSyncNackRsnErrAppNotFound(Identity):
    """
    NSR failed due to app not found.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrAppNotFound, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-app-not-found")


class RoutePathIpProtected(Identity):
    """
    A primary path with LFA FRR protection
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathIpProtected, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-ip-protected")


class NsrSyncNackRsnErrAppInvalid(Identity):
    """
    NSR failed due to an app invalid error.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrAppInvalid, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-app-invalid")


class RoutePathIpNoFlag(Identity):
    """
    A primary path with no special flag/attribute
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathIpNoFlag, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-ip-no-flag")


class IgpSyncDownReasonInternal(Identity):
    """
    Internal reason.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReasonInternal, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason-internal")


class NsrSyncNackRsnErrRxBadPie(Identity):
    """
    NSR failed, received a bad PIE.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrRxBadPie, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-rx-bad-pie")


class NsrSyncNackRsnNone(Identity):
    """
    None
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnNone, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-none")


class LdpNsrPeerSyncStReady(Identity):
    """
    LDP NSR peer synchronization is ready.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LdpNsrPeerSyncStReady, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:ldp-nsr-peer-sync-st-ready")


class NsrPeerSyncErrTcpGbl(Identity):
    """
    LDP Peer Sync failed, tcp gbl
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrTcpGbl, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-tcp-gbl")


class IccpTypeMlacp(Identity):
    """
    MLACP Multi\-chassic Link Aggregation Control Protocol.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IccpTypeMlacp, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:iccp-type-mlacp")


class NsrSyncNackRsnErrRxNotif(Identity):
    """
    NSR failed with a received notification error.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrRxNotif, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-rx-notif")


class IgpSyncDownReasonPeerUpdateNotReceived(Identity):
    """
    Initial update from peer not received yet.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReasonPeerUpdateNotReceived, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason-peer-update-not-received")


class NsrSyncNackRsnErrUnexpPeerDown(Identity):
    """
    NSR failed due to unexpected peer down.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrUnexpPeerDown, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-unexp-peer-down")


class NsrSyncNackRsnTblIdMismatch(Identity):
    """
    NSR failed with a table ID mismatch.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnTblIdMismatch, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-tbl-id-mismatch")


class NsrSyncNackRsnEnomem(Identity):
    """
    NSR failed due to an out of memory error.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnEnomem, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-enomem")


class RoutePathLblOwnerLdp(Identity):
    """
    Path outgoing label owned by LDP.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathLblOwnerLdp, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-lbl-owner-ldp")


class LabelTypeMpls(Identity):
    """
    The is an MPLS Label.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LabelTypeMpls, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:label-type-mpls")


class LdpNsrPeerSyncStPrep(Identity):
    """
    LDP NSR peer synchronization is prep.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LdpNsrPeerSyncStPrep, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:ldp-nsr-peer-sync-st-prep")


class NsrStatusReady(Identity):
    """
    Device is NSR Ready.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrStatusReady, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-status-ready")


class NsrSyncNackRsnErrAdjAdd(Identity):
    """
    NSR failed due to an error adding the adjacency.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrAdjAdd, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-adj-add")


class NsrSyncNackRsnErrRxUnexpOpen(Identity):
    """
    NSR failed due to an unexpected open.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrSyncNackRsnErrRxUnexpOpen, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-sync-nack-rsn-err-rx-unexp-open")


class DownNbrReasonNa(Identity):
    """
    Not applicable, the neighbor is up..
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(DownNbrReasonNa, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:down-nbr-reason-na")


class LdpNsrPeerSyncStAppWait(Identity):
    """
    LDP NSR peer synchronization is app wait.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(LdpNsrPeerSyncStAppWait, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:ldp-nsr-peer-sync-st-app-wait")


class NsrPeerSyncErrAppFail(Identity):
    """
    LDP Peer Sync failed, app fail
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrAppFail, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-app-fail")


class DownNbrReasonDiscHello(Identity):
    """
    The local discovery hello timer expired..
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(DownNbrReasonDiscHello, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:down-nbr-reason-disc-hello")


class RoutePathIpBgpBackup(Identity):
    """
    A non\-primary BGP backup path
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathIpBgpBackup, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-ip-bgp-backup")


class RoutePathLblOwnerBgp(Identity):
    """
    Path outgoing label owned by BGP.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathLblOwnerBgp, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-lbl-owner-bgp")


class IgpSyncDownReasonPeerUpdateNotDone(Identity):
    """
    Initial update to peer not done yet.
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(IgpSyncDownReasonPeerUpdateNotDone, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:igp-sync-down-reason-peer-update-not-done")


class NsrPeerSyncErrLdpGbl(Identity):
    """
    LDP Peer Sync failed, ldp gbl
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(NsrPeerSyncErrLdpGbl, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:nsr-peer-sync-err-ldp-gbl")


class RoutePathIpBackup(Identity):
    """
    A non\-primary local LFA FRR (pure) backup path
    
    

    """

    _prefix = 'mpls-ldp-ios-xe-oper'
    _revision = '2017-02-07'

    def __init__(self):
        super(RoutePathIpBackup, self).__init__("http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp", "Cisco-IOS-XE-mpls-ldp:route-path-ip-backup")


